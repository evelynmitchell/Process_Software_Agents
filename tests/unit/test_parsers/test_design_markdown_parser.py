"""
Unit tests for Design Markdown Parser.

Tests the DesignMarkdownParser class which converts markdown-formatted
Design Agent output into structured dictionaries for Pydantic validation.

Author: ASP Development Team
Date: November 21, 2025
"""

import pytest

from asp.models.design import DesignSpecification
from asp.parsers.design_markdown_parser import DesignMarkdownParser


class TestDesignMarkdownParserBasic:
    """Test basic parsing functionality."""

    @pytest.fixture
    def parser(self):
        """Create parser instance."""
        return DesignMarkdownParser()

    def test_parser_initialization(self, parser):
        """Test parser initializes correctly."""
        assert parser is not None
        assert isinstance(parser, DesignMarkdownParser)

    def test_parse_minimal_markdown(self, parser):
        """Test parsing minimal valid markdown."""
        markdown = """# Design Specification: TEST-001

**Task ID:** TEST-001
**Timestamp:** 2025-11-21T10:00:00Z

## Architecture Overview

Simple test architecture with at least 50 characters to meet minimum requirement for validation.

## Technology Stack

- **Language:** Python 3.12
- **Framework:** FastAPI 0.104

## Assumptions

- Test assumption 1
- Test assumption 2

## API Contracts

### GET /test

**Description:** Test endpoint description

**Authentication Required:** No

**Response (Success):**
```json
{
  "status": "string (ok)"
}
```

**Error Responses:**
- **500 INTERNAL_ERROR**: Server error

---

## Component Logic

### Component: TestComponent

**Semantic Unit:** SU-001

**Responsibility:** Test component responsibility description with sufficient detail.

**Dependencies:**
- None

**Interfaces:**

#### `test_method() -> str`

Test method description.

**Returns:** Test return value

---

**Implementation Notes:**

Test implementation notes with sufficient detail to guide implementation.

**Estimated Complexity:** 10

---

## Design Review Checklist

### Security: Test security check

**Validation Criteria:** Test validation criteria with specific details.

**Severity:** Critical

---

### Performance: Test performance check

**Validation Criteria:** Test performance validation criteria.

**Severity:** High

---

### Architecture: Test architecture check

**Validation Criteria:** Test architecture validation criteria.

**Severity:** Medium

---

### Data Integrity: Test data check

**Validation Criteria:** Test data integrity validation.

**Severity:** Medium

---

### Error Handling: Test error handling

**Validation Criteria:** Test error handling validation.

**Severity:** Low

---

*Generated by Design Agent v2.0 (Markdown) on 2025-11-21T10:00:00Z*
"""
        result = parser.parse(markdown)

        # Verify structure
        assert isinstance(result, dict)
        assert result["task_id"] == "TEST-001"
        assert len(result["architecture_overview"]) >= 50
        assert len(result["technology_stack"]) >= 2
        assert len(result["assumptions"]) == 2
        assert len(result["api_contracts"]) == 1
        assert len(result["component_logic"]) == 1
        assert len(result["design_review_checklist"]) >= 5

        # Verify Pydantic validation works
        design_spec = DesignSpecification(**result)
        assert design_spec.task_id == "TEST-001"

    def test_extract_task_id_from_title(self, parser):
        """Test extracting task ID from document title."""
        markdown = "# Design Specification: TASK-123\n\n**Task ID:** TASK-123"
        task_id = parser._extract_task_id(markdown)
        assert task_id == "TASK-123"

    def test_extract_task_id_from_metadata(self, parser):
        """Test extracting task ID from metadata."""
        markdown = "**Task ID:** TASK-456"
        task_id = parser._extract_task_id(markdown)
        assert task_id == "TASK-456"

    def test_extract_task_id_missing_raises_error(self, parser):
        """Test missing task ID raises ValueError."""
        markdown = "# Some Document\n\nNo task ID here"
        with pytest.raises(ValueError, match="Task ID not found"):
            parser._extract_task_id(markdown)

    def test_extract_timestamp(self, parser):
        """Test extracting timestamp from metadata."""
        markdown = "**Timestamp:** 2025-11-21T15:30:00Z"
        timestamp = parser._extract_timestamp(markdown)
        assert timestamp is not None
        assert timestamp.year == 2025
        assert timestamp.month == 11
        assert timestamp.day == 21

    def test_extract_timestamp_missing_returns_none(self, parser):
        """Test missing timestamp returns None."""
        markdown = "**Task ID:** TEST-001"
        timestamp = parser._extract_timestamp(markdown)
        assert timestamp is None


class TestArchitectureOverviewParsing:
    """Test architecture overview section parsing."""

    @pytest.fixture
    def parser(self):
        return DesignMarkdownParser()

    def test_parse_architecture_overview(self, parser):
        """Test parsing architecture overview."""
        content = "This is a comprehensive architecture overview with multiple sentences describing the system design, components, and data flow patterns."
        result = parser._parse_architecture_overview(content)
        assert result == content.strip()

    def test_architecture_too_short_raises_error(self, parser):
        """Test architecture overview must be at least 50 chars."""
        content = "Too short"
        with pytest.raises(ValueError, match="at least 50 characters"):
            parser._parse_architecture_overview(content)


class TestTechnologyStackParsing:
    """Test technology stack section parsing."""

    @pytest.fixture
    def parser(self):
        return DesignMarkdownParser()

    def test_parse_technology_stack(self, parser):
        """Test parsing technology stack."""
        content = """- **Language:** Python 3.12
- **Framework:** FastAPI 0.104.1
- **Database:** PostgreSQL 15
- **Cache:** Redis 7"""
        result = parser._parse_technology_stack(content)

        assert result["language"] == "Python 3.12"
        assert result["framework"] == "FastAPI 0.104.1"
        assert result["database"] == "PostgreSQL 15"
        assert result["cache"] == "Redis 7"

    def test_empty_technology_stack_raises_error(self, parser):
        """Test empty technology stack raises error."""
        content = ""
        with pytest.raises(ValueError, match="at least one technology"):
            parser._parse_technology_stack(content)


class TestAssumptionsParsing:
    """Test assumptions section parsing."""

    @pytest.fixture
    def parser(self):
        return DesignMarkdownParser()

    def test_parse_assumptions(self, parser):
        """Test parsing assumptions list."""
        content = """- Assumption one
- Assumption two
- Assumption three"""
        result = parser._parse_assumptions(content)

        assert len(result) == 3
        assert result[0] == "Assumption one"
        assert result[1] == "Assumption two"
        assert result[2] == "Assumption three"

    def test_parse_empty_assumptions(self, parser):
        """Test parsing empty assumptions returns empty list."""
        content = ""
        result = parser._parse_assumptions(content)
        assert result == []


class TestAPIContractsParsing:
    """Test API contracts section parsing."""

    @pytest.fixture
    def parser(self):
        return DesignMarkdownParser()

    def test_parse_single_api_contract(self, parser):
        """Test parsing single API endpoint."""
        content = """### GET /api/users

**Description:** Get all users

**Authentication Required:** Yes

**Request Parameters:**
- `limit`: integer (max 100, default 10)
- `offset`: integer (default 0)

**Response (Success):**
```json
{
  "users": "array of user objects",
  "total": "integer"
}
```

**Error Responses:**
- **401 UNAUTHORIZED**: Authentication required
- **500 INTERNAL_ERROR**: Server error

---"""
        result = parser._parse_api_contracts(content)

        assert len(result) == 1
        contract = result[0]
        assert contract["method"] == "GET"
        assert contract["endpoint"] == "/api/users"
        assert contract["description"] == "Get all users"
        assert contract["authentication_required"] is True
        assert contract["request_params"]["limit"] == "integer (max 100, default 10)"
        assert contract["response_schema"]["users"] == "array of user objects"
        assert len(contract["error_responses"]) == 2
        assert contract["error_responses"][0]["status"] == 401
        assert contract["error_responses"][0]["code"] == "UNAUTHORIZED"

    def test_parse_post_request_with_body(self, parser):
        """Test parsing POST endpoint with request body."""
        content = """### POST /api/users

**Description:** Create new user

**Authentication Required:** No

**Request Body:**
```json
{
  "email": "string (required)",
  "password": "string (min 8 chars)"
}
```

**Response (Success):**
```json
{
  "user_id": "string (UUID)"
}
```

**Error Responses:**
- **400 INVALID_INPUT**: Invalid email or password

---"""
        result = parser._parse_api_contracts(content)

        assert len(result) == 1
        contract = result[0]
        assert contract["method"] == "POST"
        assert contract["endpoint"] == "/api/users"
        assert contract["request_schema"] is not None
        assert contract["request_schema"]["email"] == "string (required)"
        assert contract["authentication_required"] is False

    def test_parse_multiple_api_contracts(self, parser):
        """Test parsing multiple API endpoints."""
        content = """### GET /api/users

**Description:** Get users

**Authentication Required:** No

**Response (Success):**
```json
{"users": "array"}
```

**Error Responses:**
- **500 ERROR**: Server error

---

### POST /api/users

**Description:** Create user

**Authentication Required:** Yes

**Response (Success):**
```json
{"user_id": "string"}
```

**Error Responses:**
- **400 BAD_REQUEST**: Invalid data

---"""
        result = parser._parse_api_contracts(content)

        assert len(result) == 2
        assert result[0]["method"] == "GET"
        assert result[1]["method"] == "POST"


class TestDataSchemasParsing:
    """Test data schemas section parsing."""

    @pytest.fixture
    def parser(self):
        return DesignMarkdownParser()

    def test_parse_single_table(self, parser):
        """Test parsing single database table."""
        content = """### Table: users

**Description:** User account information

**Columns:**
| Column | Type | Constraints |
|--------|------|-------------|
| user_id | UUID | PRIMARY KEY |
| email | VARCHAR(255) | NOT NULL UNIQUE |
| created_at | TIMESTAMP | DEFAULT NOW() |

**Indexes:**
```sql
CREATE INDEX idx_users_email ON users(email);
```

**Relationships:**
```sql
ALTER TABLE posts ADD FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE;
```

**Constraints:**
```sql
CHECK (LENGTH(email) >= 5);
```

---"""
        result = parser._parse_data_schemas(content)

        assert len(result) == 1
        schema = result[0]
        assert schema["table_name"] == "users"
        assert schema["description"] == "User account information"
        assert len(schema["columns"]) == 3
        assert schema["columns"][0]["name"] == "user_id"
        assert schema["columns"][0]["type"] == "UUID"
        assert schema["columns"][0]["constraints"] == "PRIMARY KEY"
        assert len(schema["indexes"]) == 1
        assert "idx_users_email" in schema["indexes"][0]
        assert len(schema["relationships"]) == 1
        assert len(schema["constraints"]) == 1

    def test_parse_empty_data_schemas(self, parser):
        """Test parsing empty data schemas section."""
        content = ""
        result = parser._parse_data_schemas(content)
        assert result == []


class TestComponentLogicParsing:
    """Test component logic section parsing."""

    @pytest.fixture
    def parser(self):
        return DesignMarkdownParser()

    def test_parse_single_component(self, parser):
        """Test parsing single component."""
        content = """### Component: UserService

**Semantic Unit:** SU-001

**Responsibility:** Manages user accounts and authentication

**Dependencies:**
- DatabaseService
- PasswordHasher

**Interfaces:**

#### `create_user(email: str, password: str) -> User`

Create a new user account.

**Parameters:**
- `email`: User email address
- `password`: User password (plaintext)

**Returns:** Created User object

---

#### `authenticate(email: str, password: str) -> Optional[str]`

Authenticate user and return token.

**Parameters:**
- `email`: User email
- `password`: User password

**Returns:** JWT token if successful, None otherwise

---

**Implementation Notes:**

Use bcrypt for password hashing with cost factor 12. Validate email format using regex. Store hashed passwords only. Generate JWT tokens with 1-hour expiration.

**Estimated Complexity:** 45

---"""
        result = parser._parse_component_logic(content)

        assert len(result) == 1
        component = result[0]
        assert component["component_name"] == "UserService"
        assert component["semantic_unit_id"] == "SU-001"
        assert component["responsibility"] == "Manages user accounts and authentication"
        assert len(component["dependencies"]) == 2
        assert "DatabaseService" in component["dependencies"]
        assert len(component["interfaces"]) == 2
        assert component["interfaces"][0]["method"] == "create_user"
        assert component["interfaces"][0]["parameters"]["email"] == "str"
        assert component["interfaces"][0]["returns"] == "User"
        assert component["complexity"] == 45
        assert "bcrypt" in component["implementation_notes"]

    def test_parse_component_no_dependencies(self, parser):
        """Test parsing component with no dependencies."""
        content = """### Component: UtilityHelper

**Semantic Unit:** SU-005

**Responsibility:** Provides utility functions

**Dependencies:**
- None

**Interfaces:**

#### `format_date(date: datetime) -> str`

Format date to ISO 8601.

**Returns:** Formatted string

---

**Implementation Notes:**

Use datetime.isoformat() method.

**Estimated Complexity:** 5

---"""
        result = parser._parse_component_logic(content)

        assert len(result) == 1
        component = result[0]
        assert len(component["dependencies"]) == 0


class TestDesignReviewChecklistParsing:
    """Test design review checklist parsing."""

    @pytest.fixture
    def parser(self):
        return DesignMarkdownParser()

    def test_parse_checklist_items(self, parser):
        """Test parsing checklist items."""
        content = """### Security: Password storage

**Validation Criteria:** Passwords must be hashed with bcrypt cost factor >= 12

**Severity:** Critical

---

### Performance: Database indexing

**Validation Criteria:** All foreign keys must have corresponding indexes

**Severity:** High

---

### Architecture: Component separation

**Validation Criteria:** Each component has single responsibility

**Severity:** Medium

---"""
        result = parser._parse_design_review_checklist(content)

        assert len(result) == 3
        assert result[0]["category"] == "Security"
        assert result[0]["description"] == "Password storage"
        assert result[0]["severity"] == "Critical"
        assert "bcrypt" in result[0]["validation_criteria"]
        assert result[1]["category"] == "Performance"
        assert result[1]["severity"] == "High"
        assert result[2]["severity"] == "Medium"


class TestHelperMethods:
    """Test helper parsing methods."""

    @pytest.fixture
    def parser(self):
        return DesignMarkdownParser()

    def test_extract_field(self, parser):
        """Test extracting field values."""
        content = "**Description:** Test description value"
        result = parser._extract_field(content, "Description")
        assert result == "Test description value"

    def test_extract_field_missing(self, parser):
        """Test extracting missing field returns empty string."""
        content = "**Other Field:** Value"
        result = parser._extract_field(content, "Description")
        assert result == ""

    def test_parse_json_block(self, parser):
        """Test parsing JSON code block."""
        content = """**Response (Success):**
```json
{
  "user_id": "string",
  "email": "string"
}
```"""
        result = parser._parse_json_block(content, "Response (Success):")
        assert result is not None
        assert result["user_id"] == "string"
        assert result["email"] == "string"

    def test_parse_json_block_invalid(self, parser):
        """Test parsing invalid JSON returns None."""
        content = """**Response:**
```json
{invalid json}
```"""
        result = parser._parse_json_block(content, "Response:")
        assert result is None

    def test_parse_error_responses(self, parser):
        """Test parsing error responses."""
        content = """**Error Responses:**
- **400 INVALID_INPUT**: Input validation failed
- **401 UNAUTHORIZED**: Authentication required
- **500 SERVER_ERROR**: Internal server error"""

        result = parser._parse_error_responses(content)

        assert len(result) == 3
        assert result[0]["status"] == 400
        assert result[0]["code"] == "INVALID_INPUT"
        assert result[0]["message"] == "Input validation failed"


class TestEdgeCases:
    """Test edge cases and error handling."""

    @pytest.fixture
    def parser(self):
        return DesignMarkdownParser()

    def test_parse_with_extra_whitespace(self, parser):
        """Test parser handles extra whitespace gracefully."""
        markdown = """# Design Specification: TEST-001

**Task ID:** TEST-001

## Architecture Overview


This architecture has extra whitespace everywhere.


## Technology Stack

- **Language:** Python 3.12


## Assumptions

- Assumption with trailing space

## API Contracts

### GET /test

**Description:** Test

**Authentication Required:** No

**Response (Success):**
```json
{"status": "ok"}
```

**Error Responses:**
- **500 ERROR**: Error

---

## Component Logic

### Component: Test

**Semantic Unit:** SU-001

**Responsibility:** Test responsibility with minimum length for validation.

**Dependencies:**
- None

**Interfaces:**

#### `test() -> str`

Test

**Returns:** String

---

**Implementation Notes:**

Test notes with sufficient detail.

**Estimated Complexity:** 1

---

## Design Review Checklist

### Test: Check

**Validation Criteria:** Test criteria

**Severity:** Critical

---

### Test2: Check2

**Validation Criteria:** Test criteria 2

**Severity:** High

---

### Test3: Check3

**Validation Criteria:** Test criteria 3

**Severity:** Medium

---

### Test4: Check4

**Validation Criteria:** Test criteria 4

**Severity:** Medium

---

### Test5: Check5

**Validation Criteria:** Test criteria 5

**Severity:** Low

---
"""
        # Should not raise errors
        result = parser.parse(markdown)
        assert result["task_id"] == "TEST-001"

    def test_parse_with_missing_optional_sections(self, parser):
        """Test parser handles missing optional sections."""
        markdown = """# Design Specification: TEST-001

**Task ID:** TEST-001

## Architecture Overview

Architecture overview with at least 50 characters to meet minimum requirement.

## Technology Stack

- **Language:** Python 3.12

## Assumptions

- Test assumption

## API Contracts

### GET /test

**Description:** Test

**Authentication Required:** No

**Response (Success):**
```json
{"status": "ok"}
```

**Error Responses:**
- **500 ERROR**: Error

---

## Component Logic

### Component: Test

**Semantic Unit:** SU-001

**Responsibility:** Test responsibility description with sufficient length.

**Dependencies:**
- None

**Interfaces:**

#### `test() -> str`

Test

**Returns:** String

---

**Implementation Notes:**

Test implementation notes.

**Estimated Complexity:** 1

---

## Design Review Checklist

### Test: Check1

**Validation Criteria:** Criteria 1

**Severity:** Critical

---

### Test: Check2

**Validation Criteria:** Criteria 2

**Severity:** High

---

### Test: Check3

**Validation Criteria:** Criteria 3

**Severity:** Medium

---

### Test: Check4

**Validation Criteria:** Criteria 4

**Severity:** Medium

---

### Test: Check5

**Validation Criteria:** Criteria 5

**Severity:** Low

---
"""
        result = parser.parse(markdown)

        # Data schemas should be empty (omitted section)
        assert result["data_schemas"] == []


class TestIntegrationWithPydantic:
    """Test integration with Pydantic DesignSpecification model."""

    @pytest.fixture
    def parser(self):
        return DesignMarkdownParser()

    def test_full_integration_validation(self, parser):
        """Test full markdown parsing and Pydantic validation."""
        # Use complete example from format spec
        markdown = """# Design Specification: INTEGRATION-001

**Task ID:** INTEGRATION-001
**Timestamp:** 2025-11-21T10:00:00Z

## Architecture Overview

Three-tier web application architecture with React frontend, FastAPI backend, and PostgreSQL database. Frontend communicates with backend via REST API. Backend handles business logic and data persistence. Redis cache layer for session management and frequently accessed data.

## Technology Stack

- **Language:** Python 3.12
- **Framework:** FastAPI 0.104
- **Database:** PostgreSQL 15
- **Cache:** Redis 7
- **Frontend:** React 18

## Assumptions

- PostgreSQL configured with connection pooling
- Redis available for caching
- JWT tokens expire after 1 hour
- System scales to 1000 concurrent users

## API Contracts

### POST /api/auth/login

**Description:** Authenticate user and return JWT access token

**Authentication Required:** No

**Request Body:**
```json
{
  "email": "string (required)",
  "password": "string (required)"
}
```

**Response (Success):**
```json
{
  "access_token": "string (JWT token)",
  "token_type": "string (bearer)",
  "expires_in": "integer (3600)"
}
```

**Error Responses:**
- **400 INVALID_CREDENTIALS**: Email or password is incorrect
- **500 INTERNAL_ERROR**: Server error

---

## Data Schemas

### Table: users

**Description:** User account information

**Columns:**
| Column | Type | Constraints |
|--------|------|-------------|
| user_id | UUID | PRIMARY KEY |
| email | VARCHAR(255) | NOT NULL UNIQUE |
| password_hash | VARCHAR(255) | NOT NULL |
| created_at | TIMESTAMP | DEFAULT NOW() |

**Indexes:**
```sql
CREATE INDEX idx_users_email ON users(email);
```

---

## Component Logic

### Component: AuthenticationService

**Semantic Unit:** SU-001

**Responsibility:** Handles user authentication and JWT token generation

**Dependencies:**
- DatabaseService
- PasswordHasher
- TokenGenerator

**Interfaces:**

#### `authenticate(email: str, password: str) -> str`

Authenticate user and return JWT token.

**Parameters:**
- `email`: User email address
- `password`: User password (plaintext)

**Returns:** JWT access token

---

**Implementation Notes:**

Use bcrypt for password hashing with cost factor 12. Validate email format. Query database for user by email. Verify password hash matches. Generate JWT token with 1-hour expiration. Include user_id in token payload. Use HS256 algorithm for JWT signing.

**Estimated Complexity:** 45

---

## Design Review Checklist

### Security: Password hashing

**Validation Criteria:** Passwords must be hashed with bcrypt cost factor >= 12. Never store plaintext passwords.

**Severity:** Critical

---

### Security: JWT token security

**Validation Criteria:** JWT tokens use HS256 algorithm with strong secret. Tokens include expiration claim.

**Severity:** Critical

---

### Architecture: Component separation

**Validation Criteria:** Each component has single responsibility. No circular dependencies.

**Severity:** High

---

### Performance: Database indexing

**Validation Criteria:** Email column has index for fast lookups.

**Severity:** Medium

---

### Data Integrity: Email uniqueness

**Validation Criteria:** Email column has UNIQUE constraint to prevent duplicates.

**Severity:** High

---

*Generated by Design Agent v2.0 (Markdown) on 2025-11-21T10:00:00Z*
"""

        # Parse markdown
        result = parser.parse(markdown)

        # Validate with Pydantic
        design_spec = DesignSpecification(**result)

        # Verify key fields
        assert design_spec.task_id == "INTEGRATION-001"
        assert len(design_spec.api_contracts) == 1
        assert len(design_spec.data_schemas) == 1
        assert len(design_spec.component_logic) == 1
        assert len(design_spec.design_review_checklist) >= 5

        # Verify API contract
        api = design_spec.api_contracts[0]
        assert api.method == "POST"
        assert api.endpoint == "/api/auth/login"
        assert api.authentication_required is False

        # Verify data schema
        table = design_spec.data_schemas[0]
        assert table.table_name == "users"
        assert len(table.columns) == 4

        # Verify component
        component = design_spec.component_logic[0]
        assert component.component_name == "AuthenticationService"
        assert component.semantic_unit_id == "SU-001"
        assert len(component.dependencies) == 3

        # Verify checklist has high-priority items
        high_priority = [
            item
            for item in design_spec.design_review_checklist
            if item.severity in ("Critical", "High")
        ]
        assert len(high_priority) >= 1
