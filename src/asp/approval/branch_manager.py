"""
Branch management for local PR-style HITL workflow.
"""

import subprocess
from pathlib import Path
from typing import Dict, Any, Optional, List
import json


class BranchManager:
    """Manages git branch operations for local PR workflow."""

    def __init__(self, repo_path: str):
        """
        Initialize BranchManager.

        Args:
            repo_path: Path to git repository
        """
        self.repo_path = Path(repo_path)

    def create_branch(self, branch_name: str, base_branch: str) -> None:
        """
        Create new branch from base branch.

        Args:
            branch_name: Name for the new branch
            base_branch: Base branch to create from
        """
        subprocess.run(
            ["git", "checkout", base_branch],
            cwd=self.repo_path,
            check=True,
            capture_output=True,
        )
        subprocess.run(
            ["git", "checkout", "-b", branch_name],
            cwd=self.repo_path,
            check=True,
            capture_output=True,
        )

    def commit_output(
        self, branch_name: str, output: Dict[str, Any], task_id: str, gate_type: str
    ) -> str:
        """
        Commit agent output to branch.

        Args:
            branch_name: Branch to commit to
            output: Agent output data
            task_id: Task identifier
            gate_type: Quality gate type

        Returns:
            Commit SHA
        """
        # Switch to branch
        subprocess.run(
            ["git", "checkout", branch_name],
            cwd=self.repo_path,
            check=True,
            capture_output=True,
        )

        # Write output files
        self._write_output_files(output)

        # Stage changes
        subprocess.run(
            ["git", "add", "."], cwd=self.repo_path, check=True, capture_output=True
        )

        # Check if there are changes to commit
        status_result = subprocess.run(
            ["git", "status", "--porcelain"],
            cwd=self.repo_path,
            capture_output=True,
            text=True,
            check=True,
        )

        if not status_result.stdout.strip():
            # No changes to commit, return current HEAD
            result = subprocess.run(
                ["git", "rev-parse", "HEAD"],
                cwd=self.repo_path,
                capture_output=True,
                text=True,
                check=True,
            )
            return result.stdout.strip()

        # Commit
        agent_name = output.get("agent", "Unknown Agent")
        commit_msg = f"""Agent output for {task_id}

Task: {task_id}
Quality Gate: {gate_type}
Generated by: {agent_name}
Requires HITL approval"""

        subprocess.run(
            ["git", "commit", "-m", commit_msg],
            cwd=self.repo_path,
            check=True,
            capture_output=True,
        )

        # Get commit SHA
        result = subprocess.run(
            ["git", "rev-parse", "HEAD"],
            cwd=self.repo_path,
            capture_output=True,
            text=True,
            check=True,
        )
        return result.stdout.strip()

    def generate_diff(self, base_branch: str, feature_branch: str) -> str:
        """
        Generate diff between branches.

        Args:
            base_branch: Base branch name
            feature_branch: Feature branch name

        Returns:
            Diff output as string
        """
        result = subprocess.run(
            ["git", "diff", f"{base_branch}...{feature_branch}"],
            cwd=self.repo_path,
            capture_output=True,
            text=True,
            check=True,
        )
        return result.stdout

    def get_diff_stats(self, base_branch: str, feature_branch: str) -> Dict[str, Any]:
        """
        Get diff statistics between branches.

        Args:
            base_branch: Base branch name
            feature_branch: Feature branch name

        Returns:
            Dictionary with files_changed, insertions, deletions
        """
        result = subprocess.run(
            ["git", "diff", "--stat", f"{base_branch}...{feature_branch}"],
            cwd=self.repo_path,
            capture_output=True,
            text=True,
            check=True,
        )

        # Parse the summary line (e.g., "3 files changed, 45 insertions(+), 12 deletions(-)")
        lines = result.stdout.strip().split("\n")
        if not lines:
            return {"files_changed": 0, "insertions": 0, "deletions": 0}

        summary = lines[-1]
        stats = {"files_changed": 0, "insertions": 0, "deletions": 0}

        if "file" in summary:
            parts = summary.split(",")
            for part in parts:
                part = part.strip()
                if "file" in part:
                    stats["files_changed"] = int(part.split()[0])
                elif "insertion" in part:
                    stats["insertions"] = int(part.split()[0])
                elif "deletion" in part:
                    stats["deletions"] = int(part.split()[0])

        return stats

    def add_note(
        self, commit_sha: str, note_content: str, notes_ref: str = "reviews"
    ) -> None:
        """
        Add git note to commit.

        Args:
            commit_sha: Commit SHA to annotate
            note_content: Note content
            notes_ref: Git notes ref name
        """
        subprocess.run(
            ["git", "notes", "--ref", notes_ref, "add", commit_sha, "-m", note_content],
            cwd=self.repo_path,
            check=True,
            capture_output=True,
        )

    def delete_branch(
        self, branch_name: str, force: bool = False, switch_to: str = "main"
    ) -> None:
        """
        Delete branch.

        Args:
            branch_name: Branch to delete
            force: Force delete (use -D instead of -d)
            switch_to: Branch to switch to before deleting (default: "main")
        """
        # Get current branch
        current_branch = self.get_current_branch()

        # Switch away from branch if we're currently on it
        if current_branch == branch_name:
            subprocess.run(
                ["git", "checkout", switch_to],
                cwd=self.repo_path,
                check=True,
                capture_output=True,
            )

        flag = "-D" if force else "-d"
        subprocess.run(
            ["git", "branch", flag, branch_name],
            cwd=self.repo_path,
            check=True,
            capture_output=True,
        )

    def get_current_branch(self) -> str:
        """
        Get current branch name.

        Returns:
            Current branch name
        """
        result = subprocess.run(
            ["git", "rev-parse", "--abbrev-ref", "HEAD"],
            cwd=self.repo_path,
            capture_output=True,
            text=True,
            check=True,
        )
        return result.stdout.strip()

    def branch_exists(self, branch_name: str) -> bool:
        """
        Check if branch exists.

        Args:
            branch_name: Branch name to check

        Returns:
            True if branch exists
        """
        result = subprocess.run(
            ["git", "rev-parse", "--verify", branch_name],
            cwd=self.repo_path,
            capture_output=True,
        )
        return result.returncode == 0

    def list_branches(self, pattern: Optional[str] = None) -> List[str]:
        """
        List branches matching pattern.

        Args:
            pattern: Optional glob pattern (e.g., "review/*")

        Returns:
            List of branch names
        """
        cmd = ["git", "branch", "--list"]
        if pattern:
            cmd.append(pattern)

        result = subprocess.run(
            cmd, cwd=self.repo_path, capture_output=True, text=True, check=True
        )

        # Parse branch names (remove leading spaces and asterisk)
        branches = []
        for line in result.stdout.strip().split("\n"):
            if line:
                branch = line.strip().lstrip("* ")
                branches.append(branch)

        return branches

    def _write_output_files(self, output: Dict[str, Any]) -> None:
        """
        Write agent output to files.

        Args:
            output: Agent output dictionary
        """
        # If output contains 'artifacts' key with file paths
        if "artifacts" in output:
            artifacts = output["artifacts"]
            if isinstance(artifacts, dict):
                for file_path, content in artifacts.items():
                    full_path = self.repo_path / file_path
                    full_path.parent.mkdir(parents=True, exist_ok=True)
                    full_path.write_text(content)

        # If output contains 'output_file' key
        if "output_file" in output and "content" in output:
            output_file = self.repo_path / output["output_file"]
            output_file.parent.mkdir(parents=True, exist_ok=True)
            output_file.write_text(output["content"])

        # Write metadata file
        metadata_file = self.repo_path / ".review_metadata.json"
        metadata = {
            "task_id": output.get("task_id"),
            "agent": output.get("agent"),
            "timestamp": output.get("timestamp"),
            "gate_type": output.get("gate_type"),
        }
        metadata_file.write_text(json.dumps(metadata, indent=2))
