"""
PIP (Process Improvement Proposal) Review Service

This module provides a terminal-based interface for reviewing and approving
Process Improvement Proposals generated by the Postmortem Agent.

PIPs contain specific changes to process artifacts (prompts, checklists) that
are designed to prevent defects identified in postmortem analysis.

The PIP Review workflow:
1. Display PIP details (analysis, proposed changes, expected impact)
2. Collect human decision (approve/reject/needs_revision)
3. Update PIP status in artifact
4. On approval: Trigger prompt versioning to apply changes

Author: ASP Development Team
Date: November 25, 2025
"""

import json
import logging
from datetime import datetime
from pathlib import Path
from typing import Optional

from rich.console import Console
from rich.markdown import Markdown
from rich.panel import Panel
from rich.table import Table

from asp.models.postmortem import ProcessImprovementProposal
from asp.utils.artifact_io import read_artifact_json, write_artifact_json


logger = logging.getLogger(__name__)


class PIPReviewCollector:
    """
    Collects PIP review decisions from user via terminal.

    Displays PIP details in a structured, human-readable format and
    collects approval decisions with justification.

    Example:
        >>> from asp.approval.pip_review_service import PIPReviewCollector
        >>> from asp.utils.artifact_io import read_artifact_json
        >>>
        >>> # Load PIP from artifact
        >>> pip_data = read_artifact_json("POSTMORTEM-001", "pip")
        >>> pip = ProcessImprovementProposal(**pip_data)
        >>>
        >>> # Review PIP
        >>> collector = PIPReviewCollector()
        >>> updated_pip = collector.review_pip(pip)
        >>> print(f"Decision: {updated_pip.hitl_status}")
    """

    def __init__(self, base_path: Optional[str] = None):
        """Initialize PIPReviewCollector with rich console."""
        self.console = Console()
        self.base_path = base_path

    def review_pip(
        self,
        pip: ProcessImprovementProposal,
        reviewer: Optional[str] = None,
    ) -> ProcessImprovementProposal:
        """
        Present PIP for review and collect decision.

        Args:
            pip: ProcessImprovementProposal to review
            reviewer: Optional reviewer identifier (auto-detected if not provided)

        Returns:
            Updated ProcessImprovementProposal with HITL fields populated
        """
        logger.info(f"Presenting PIP {pip.proposal_id} for review")

        # Display PIP details
        self._display_pip_header(pip)
        self._display_pip_analysis(pip)
        self._display_proposed_changes(pip)
        self._display_expected_impact(pip)

        # Collect decision
        decision = self._prompt_decision()

        # Collect justification/feedback
        feedback = self._prompt_feedback(decision)

        # Get reviewer identifier
        if reviewer is None:
            reviewer = self._get_reviewer()

        # Update PIP with HITL fields
        pip.hitl_status = decision
        pip.hitl_reviewer = reviewer
        pip.hitl_reviewed_at = datetime.now()
        pip.hitl_feedback = feedback

        # Display confirmation
        self._display_decision_summary(pip)

        # Write updated PIP back to artifact
        try:
            write_artifact_json(
                task_id=pip.task_id,
                artifact_type="pip",
                data=pip,
                base_path=self.base_path,
            )
            logger.info(f"Updated PIP artifact: {pip.proposal_id} -> {pip.hitl_status}")
        except Exception as e:
            logger.error(f"Failed to write updated PIP: {e}", exc_info=True)
            self.console.print(f"[red]Warning: Failed to save decision: {e}[/red]")

        return pip

    def _display_pip_header(self, pip: ProcessImprovementProposal) -> None:
        """Display PIP header with metadata."""
        self.console.rule(
            f"[bold cyan]Process Improvement Proposal: {pip.proposal_id}[/bold cyan]",
            style="cyan",
        )
        self.console.print()

        # Metadata table
        table = Table(show_header=False, box=None, padding=(0, 2))
        table.add_column("Field", style="bold")
        table.add_column("Value")

        table.add_row("PIP ID:", pip.proposal_id)
        table.add_row("Task ID:", pip.task_id)
        table.add_row("Created:", pip.created_at.strftime("%Y-%m-%d %H:%M:%S UTC"))
        table.add_row("Status:", f"[yellow]{pip.hitl_status}[/yellow]")

        self.console.print(table)
        self.console.print()

    def _display_pip_analysis(self, pip: ProcessImprovementProposal) -> None:
        """Display problem analysis."""
        panel = Panel(
            pip.analysis,
            title="[bold]Problem Analysis[/bold]",
            border_style="blue",
            padding=(1, 2),
        )
        self.console.print(panel)
        self.console.print()

    def _display_proposed_changes(self, pip: ProcessImprovementProposal) -> None:
        """Display proposed changes in detail."""
        self.console.print("[bold]Proposed Changes:[/bold]")
        self.console.print()

        for i, change in enumerate(pip.proposed_changes, 1):
            # Change header
            self.console.print(
                f"  [bold cyan]Change {i}:[/bold cyan] "
                f"[yellow]{change.change_type.upper()}[/yellow] to "
                f"[green]{change.target_artifact}[/green]"
            )

            # Current content (for modify/remove)
            if change.current_content:
                self.console.print("  [dim]Current content:[/dim]")
                self.console.print(f"    {change.current_content}")

            # Proposed content
            if change.change_type != "remove":
                self.console.print("  [bold]Proposed content:[/bold]")
                self.console.print(f"    {change.proposed_content}")

            # Rationale
            self.console.print("  [bold]Rationale:[/bold]")
            self.console.print(f"    [italic]{change.rationale}[/italic]")

            self.console.print()

    def _display_expected_impact(self, pip: ProcessImprovementProposal) -> None:
        """Display expected impact."""
        panel = Panel(
            pip.expected_impact,
            title="[bold]Expected Impact[/bold]",
            border_style="green",
            padding=(1, 2),
        )
        self.console.print(panel)
        self.console.print()

    def _prompt_decision(self) -> str:
        """
        Prompt user for PIP decision.

        Returns:
            Decision string ("approved", "rejected", or "needs_revision")
        """
        self.console.rule("[bold cyan]REVIEW DECISION", style="cyan")
        self.console.print()
        self.console.print("[bold]Options:[/bold]")
        self.console.print(
            "  [green]1. APPROVE[/green]          - Accept and apply changes"
        )
        self.console.print(
            "  [red]2. REJECT[/red]           - Reject proposal entirely"
        )
        self.console.print(
            "  [yellow]3. NEEDS REVISION[/yellow]  - Request modifications"
        )
        self.console.print()

        decision_map = {
            "1": "approved",
            "2": "rejected",
            "3": "needs_revision",
        }

        while True:
            choice = self.console.input("[bold]Your decision [1/2/3]:[/bold] ")
            if choice in decision_map:
                return decision_map[choice]
            self.console.print("[red]Invalid choice. Please enter 1, 2, or 3.[/red]")

    def _prompt_feedback(self, decision: str) -> str:
        """
        Prompt user for feedback/justification.

        Args:
            decision: The decision that was made

        Returns:
            Feedback text
        """
        self.console.print()

        if decision == "approved":
            self.console.print(
                "[bold green]Approval justification (required):[/bold green]"
            )
        elif decision == "rejected":
            self.console.print("[bold red]Rejection reason (required):[/bold red]")
        else:
            self.console.print(
                "[bold yellow]Revision requests (required):[/bold yellow]"
            )

        while True:
            feedback = self.console.input("> ")
            if feedback.strip():
                return feedback.strip()
            self.console.print(
                "[red]Feedback is required. Please provide a reason.[/red]"
            )

    def _get_reviewer(self) -> str:
        """
        Get reviewer identifier from git config or system.

        Returns:
            Reviewer email or username
        """
        import subprocess
        import getpass

        # Try to get from git config
        try:
            result = subprocess.run(
                ["git", "config", "user.email"],
                capture_output=True,
                text=True,
                check=True,
            )
            email = result.stdout.strip()
            if email:
                return email
        except subprocess.CalledProcessError:
            pass

        # Fallback to system username
        username = getpass.getuser()
        return f"{username}@local"

    def _display_decision_summary(self, pip: ProcessImprovementProposal) -> None:
        """Display decision summary."""
        self.console.print()
        self.console.rule("[bold]Decision Summary[/bold]")
        self.console.print()

        # Color based on decision
        color_map = {
            "approved": "green",
            "rejected": "red",
            "needs_revision": "yellow",
        }
        color = color_map.get(pip.hitl_status, "white")

        self.console.print(
            f"[bold]Decision:[/bold] [{color}]{pip.hitl_status.upper()}[/{color}]"
        )
        self.console.print(f"[bold]Reviewer:[/bold] {pip.hitl_reviewer}")
        self.console.print(f"[bold]Timestamp:[/bold] {pip.hitl_reviewed_at}")
        self.console.print(f"[bold]Feedback:[/bold] {pip.hitl_feedback}")
        self.console.print()

        if pip.hitl_status == "approved":
            self.console.print(
                "[bold green]✓ PIP approved! Changes will be applied to prompts.[/bold green]"
            )
        elif pip.hitl_status == "rejected":
            self.console.print(
                "[bold red]✗ PIP rejected. No changes will be applied.[/bold red]"
            )
        else:
            self.console.print(
                "[bold yellow]⚠ PIP needs revision. Postmortem Agent will regenerate.[/bold yellow]"
            )

        self.console.print()


class PIPReviewService:
    """
    Service for managing PIP review workflow.

    Orchestrates the complete PIP review process:
    1. Load PIPs from artifacts
    2. Present for human review
    3. Update PIP status
    4. Trigger prompt versioning (if approved)

    Example:
        >>> from asp.approval.pip_review_service import PIPReviewService
        >>>
        >>> service = PIPReviewService()
        >>> pip = service.review_pip_by_id("POSTMORTEM-001")
        >>>
        >>> if pip.hitl_status == "approved":
        >>>     print("PIP approved! Applying changes...")
    """

    def __init__(self, base_path: Optional[str] = None):
        """Initialize PIPReviewService."""
        self.collector = PIPReviewCollector(base_path=base_path)
        self.base_path = base_path

    def review_pip_by_id(
        self,
        task_id: str,
        reviewer: Optional[str] = None,
    ) -> ProcessImprovementProposal:
        """
        Load and review PIP by task ID.

        Args:
            task_id: Task ID associated with the PIP
            reviewer: Optional reviewer identifier

        Returns:
            Updated ProcessImprovementProposal with review decision

        Raises:
            FileNotFoundError: If PIP artifact not found
            ValueError: If PIP data is invalid
        """
        logger.info(f"Loading PIP for task_id={task_id}")

        # Load PIP from artifact
        pip_data = read_artifact_json(task_id, "pip", base_path=self.base_path)
        pip = ProcessImprovementProposal(**pip_data)

        # Review PIP
        return self.collector.review_pip(pip, reviewer=reviewer)

    def review_pip(
        self,
        pip: ProcessImprovementProposal,
        reviewer: Optional[str] = None,
    ) -> ProcessImprovementProposal:
        """
        Review an existing PIP object.

        Args:
            pip: ProcessImprovementProposal to review
            reviewer: Optional reviewer identifier

        Returns:
            Updated ProcessImprovementProposal with review decision
        """
        return self.collector.review_pip(pip, reviewer=reviewer)

    def list_pending_pips(self, artifacts_dir: Optional[Path] = None) -> list[str]:
        """
        List all pending PIPs (status = "pending").

        Returns:
            List of task IDs with pending PIPs
        """
        pending_pips = []
        if artifacts_dir is None:
            artifacts_dir = Path(self.base_path or "artifacts")

        if not artifacts_dir.exists():
            return pending_pips

        for task_dir in artifacts_dir.iterdir():
            if not task_dir.is_dir():
                continue

            pip_file = task_dir / "pip.json"
            if not pip_file.exists():
                continue

            try:
                pip_data = read_artifact_json(
                    task_dir.name, "pip", base_path=self.base_path
                )
                pip = ProcessImprovementProposal(**pip_data)

                if pip.hitl_status == "pending":
                    pending_pips.append(task_dir.name)
            except Exception as e:
                logger.warning(f"Failed to load PIP from {pip_file}: {e}")

        return pending_pips
