# Design Agent Markdown Format Specification

**Version:** 2.0
**Date:** 2025-11-21
**Status:** Draft - Phase 1 Implementation
**Related:** `docs/agent_output_format_decision.md` (ADR)

---

## Overview

This document defines the Markdown format for Design Agent output (DesignSpecification). This format replaces the current JSON-first approach to improve LLM reliability, especially with cost-effective models like Haiku 4.5.

**Goals:**
- Natural format for LLMs to generate reliably
- Human-readable by default (no rendering needed)
- Parseable to Pydantic model for validation
- Reduce JSON escaping issues (Design Agent's Haiku compatibility problems)

---

## Format Structure

### Document Layout

```markdown
# Design Specification: {task_id}

**Task ID:** {task_id}
**Timestamp:** {ISO 8601 timestamp}

## Architecture Overview

{High-level architecture description - minimum 50 characters}

## Technology Stack

- **Language:** {language and version}
- **Framework:** {web framework and version}
- **Database:** {database and version} (if applicable)
- **Cache:** {caching technology} (if applicable)
- **Authentication:** {auth method} (if applicable)
- **{Other}:** {technology}

## Assumptions

- {Assumption 1}
- {Assumption 2}
- {Assumption N}

## API Contracts

### {METHOD} {endpoint}

**Description:** {What this endpoint does}

**Authentication Required:** {Yes/No}

**Rate Limit:** {rate limit specification} (optional)

**Request Parameters:** (if applicable)
- `{param_name}`: {type and description}
- `{param_name}`: {type and description}

**Request Body:** (if applicable - POST/PUT/PATCH)
```json
{
  "field1": "type (constraints, description)",
  "field2": "type (constraints, description)"
}
```

**Response (Success):**
```json
{
  "field1": "type (description)",
  "field2": "type (description)"
}
```

**Error Responses:**
- **{status_code} {ERROR_CODE}**: {message/description}
- **{status_code} {ERROR_CODE}**: {message/description}

---

### {Next API endpoint...}

## Data Schemas

(Optional section - omit if no database)

### Table: {table_name}

**Description:** {Purpose of this table}

**Columns:**
| Column | Type | Constraints |
|--------|------|-------------|
| {column_name} | {SQL type} | {PRIMARY KEY, NOT NULL, etc.} |
| {column_name} | {SQL type} | {constraints} |

**Indexes:**
```sql
CREATE INDEX {index_name} ON {table_name}({columns});
```

**Relationships:**
```sql
ALTER TABLE {table} ADD FOREIGN KEY ({column}) REFERENCES {ref_table}({ref_column}) ON DELETE {CASCADE/SET NULL};
```

**Constraints:**
```sql
CHECK ({constraint_expression});
```

---

### Table: {Next table...}

## Component Logic

### Component: {component_name}

**Semantic Unit:** {SU-XXX}

**Responsibility:** {Single responsibility description}

**Dependencies:**
- {Component/Service 1}
- {Component/Service 2}

**Interfaces:**

#### `{method_name}({param1}: {type}, {param2}: {type}) -> {return_type}`

{Method description}

**Parameters:**
- `{param}`: {description}

**Returns:** {return value description}

---

#### `{next_method}(...) -> {return_type}`

{Method description}

---

**Implementation Notes:**

{Detailed implementation guidance - algorithms, validation rules, error handling, performance considerations}

**Estimated Complexity:** {number} (from Planning Agent)

---

### Component: {Next component...}

## Design Review Checklist

### {Category}: {Check description}

**Validation Criteria:** {How to validate this check}

**Severity:** {Critical|High|Medium|Low}

---

### {Next checklist item...}

---

*Generated by Design Agent v2.0 (Markdown) on {timestamp}*
```

---

## Example 1: Hello World API

```markdown
# Design Specification: HW-001

**Task ID:** HW-001
**Timestamp:** 2025-11-21T20:53:05Z

## Architecture Overview

Simple single-tier REST API architecture using FastAPI framework. Application consists of four main components: (1) FastAPIApplicationFactory initializes the FastAPI application with middleware and exception handlers, (2) HelloEndpointHandler processes GET /hello requests with optional name parameter validation and personalized greeting generation, (3) HealthEndpointHandler processes GET /health requests and returns service status with current timestamp, (4) GlobalExceptionHandler provides centralized error handling for all exceptions with appropriate HTTP status codes and JSON error responses. No database layer required. All components are stateless and can handle concurrent requests.

## Technology Stack

- **Language:** Python 3.12
- **Framework:** FastAPI 0.104.1
- **ASGI Server:** uvicorn 0.24.0
- **Validation:** FastAPI Pydantic v2 (built-in)
- **Datetime:** Python datetime module (stdlib)

## Assumptions

- FastAPI is installed with all required dependencies (uvicorn, pydantic, starlette)
- Application runs on localhost:8000 by default (standard uvicorn configuration)
- HTTPS/TLS is handled at infrastructure level (reverse proxy or load balancer)
- Server timezone is UTC or properly configured for UTC timestamp generation
- Name parameter validation uses simple alphanumeric + spaces pattern
- No authentication or authorization required for either endpoint
- No rate limiting required at application level

## API Contracts

### GET /hello

**Description:** Returns a personalized greeting message. If a name query parameter is provided, includes it in the response; otherwise returns a generic greeting.

**Authentication Required:** No

**Request Parameters:**
- `name`: string (optional, max 255 characters, alphanumeric and spaces only)

**Response (Success):**
```json
{
  "message": "string (format: 'Hello, {name}!' or 'Hello, World!')"
}
```

**Error Responses:**
- **400 INVALID_NAME_PARAMETER**: Name parameter contains invalid characters. Only alphanumeric characters and spaces are allowed.
- **400 NAME_TOO_LONG**: Name parameter exceeds maximum length of 255 characters.
- **500 INTERNAL_SERVER_ERROR**: An unexpected error occurred while processing the request.

---

### GET /health

**Description:** Returns the health status of the API service along with the current server timestamp in ISO 8601 format.

**Authentication Required:** No

**Response (Success):**
```json
{
  "status": "string (value: 'ok')",
  "timestamp": "string (ISO 8601 format, example: '2024-01-15T10:30:45.123456Z')"
}
```

**Error Responses:**
- **500 INTERNAL_SERVER_ERROR**: An unexpected error occurred while processing the request.

---

## Component Logic

### Component: FastAPIApplicationFactory

**Semantic Unit:** SU-001

**Responsibility:** Initializes and configures the FastAPI application with middleware, exception handlers, and application settings.

**Dependencies:** None

**Interfaces:**

#### `create_app() -> FastAPI`

Create and configure FastAPI application instance with all middleware and exception handlers.

**Returns:** Configured FastAPI application instance

---

#### `setup_exception_handlers(app: FastAPI) -> None`

Register global exception handlers for the application.

**Parameters:**
- `app`: FastAPI application instance to configure

**Returns:** None (modifies app in-place)

---

**Implementation Notes:**

Use FastAPI 0.104+ with default settings. Set title='Hello World API', version='1.0.0', description='Minimal REST API with hello and health endpoints'. Configure CORS if needed (allow all origins for development). Add exception handlers in setup_exception_handlers method. Use uvicorn as ASGI server with default configuration.

**Estimated Complexity:** 11

---

### Component: HelloEndpointHandler

**Semantic Unit:** SU-002

**Responsibility:** Handles GET /hello requests with optional name parameter and returns personalized greeting message.

**Dependencies:** None

**Interfaces:**

#### `get_hello(name: Optional[str] = None) -> dict[str, str]`

Process hello request with optional name and return greeting message.

**Parameters:**
- `name`: Optional string containing user's name (validated)

**Returns:** Dictionary with 'message' key containing greeting

---

#### `validate_name(name: str) -> bool`

Validate name parameter against allowed character pattern.

**Parameters:**
- `name`: String to validate

**Returns:** True if valid, raises HTTPException if invalid

---

#### `format_greeting(name: Optional[str]) -> str`

Format greeting message based on name parameter.

**Parameters:**
- `name`: Optional name to include in greeting

**Returns:** Formatted greeting string

---

**Implementation Notes:**

Use FastAPI @app.get('/hello') decorator. Accept name as Query parameter with default None. Validate name using regex pattern '^[a-zA-Z0-9 ]*$' if provided. Raise HTTPException(status_code=400, detail='INVALID_NAME_PARAMETER') for invalid characters. Raise HTTPException(status_code=400, detail='NAME_TOO_LONG') if length > 255. Return dict with 'message' key. If name is None or empty string, return 'Hello, World!'. Otherwise return 'Hello, {name}!' with name stripped of leading/trailing whitespace.

**Estimated Complexity:** 24

---

### Component: HealthEndpointHandler

**Semantic Unit:** SU-003

**Responsibility:** Handles GET /health requests and returns service status with current server timestamp.

**Dependencies:** None

**Interfaces:**

#### `get_health() -> dict[str, str]`

Process health check request and return status with timestamp.

**Returns:** Dictionary with 'status' and 'timestamp' keys

---

#### `get_current_timestamp() -> str`

Get current server time in ISO 8601 format.

**Returns:** ISO 8601 formatted timestamp string

---

**Implementation Notes:**

Use FastAPI @app.get('/health') decorator. Use datetime.datetime.utcnow() or datetime.datetime.now(datetime.timezone.utc) to get current time. Format timestamp as ISO 8601 string using .isoformat() method. Return dict with 'status' key set to 'ok' and 'timestamp' key with ISO 8601 formatted timestamp. Example: {'status': 'ok', 'timestamp': '2024-01-15T10:30:45.123456+00:00'}.

**Estimated Complexity:** 21

---

### Component: GlobalExceptionHandler

**Semantic Unit:** SU-004

**Responsibility:** Handles all exceptions globally and returns appropriate HTTP status codes with formatted error responses.

**Dependencies:** None

**Interfaces:**

#### `handle_http_exception(request: Request, exc: HTTPException) -> JSONResponse`

Handle FastAPI HTTPException and return formatted error response.

**Parameters:**
- `request`: FastAPI Request object
- `exc`: HTTPException to handle

**Returns:** JSONResponse with error details

---

#### `handle_validation_exception(request: Request, exc: RequestValidationError) -> JSONResponse`

Handle Pydantic validation errors and return formatted error response.

**Parameters:**
- `request`: FastAPI Request object
- `exc`: RequestValidationError to handle

**Returns:** JSONResponse with validation error details

---

#### `handle_generic_exception(request: Request, exc: Exception) -> JSONResponse`

Handle unexpected exceptions and return safe error response.

**Parameters:**
- `request`: FastAPI Request object
- `exc`: Generic exception to handle

**Returns:** JSONResponse with safe generic error message

---

**Implementation Notes:**

Register exception handlers using @app.exception_handler(ExceptionType) decorator. For HTTPException: pass through status_code and detail as-is. For RequestValidationError: return status 400 with error code 'VALIDATION_ERROR' and message describing validation failure. For generic Exception: log exception with logging.error(), return status 500 with error code 'INTERNAL_SERVER_ERROR' and generic message 'An unexpected error occurred'. All error responses must be JSON with structure: {'error_code': str, 'message': str}. Never expose stack traces in error responses.

**Estimated Complexity:** 27

---

## Design Review Checklist

### Security: Password and sensitive data handling

**Validation Criteria:** Verify no passwords or sensitive data are logged or exposed in error responses. Exception handlers should sanitize error messages.

**Severity:** Critical

---

### Architecture: Component separation and single responsibility

**Validation Criteria:** Each component handles one specific responsibility. No component has multiple unrelated concerns.

**Severity:** High

---

### API Design: Error response consistency

**Validation Criteria:** All API endpoints return consistent error response format with error_code and message fields. Status codes follow HTTP standards.

**Severity:** High

---

### Performance: Efficient validation logic

**Validation Criteria:** Name validation uses compiled regex pattern (not recompiled on each request). Timestamp generation is fast (no external API calls).

**Severity:** Medium

---

### Maintainability: Clear interface definitions

**Validation Criteria:** All component interfaces are well-defined with clear parameters and return types. Implementation notes provide sufficient guidance for coding agent.

**Severity:** Medium

---

*Generated by Design Agent v2.0 (Markdown) on 2025-11-21T20:53:05Z*
```

---

## Example 2: JWT Authentication System (Partial)

```markdown
# Design Specification: JWT-AUTH-001

**Task ID:** JWT-AUTH-001
**Timestamp:** 2025-11-21T10:00:00Z

## Architecture Overview

3-tier architecture with FastAPI REST API layer, business logic service layer, and PostgreSQL data layer. JWT tokens provide stateless authentication. Redis caches active sessions and implements rate limiting. Password hashing uses bcrypt with cost factor 12. User registration validates email uniqueness and password complexity. Login endpoint authenticates credentials and returns JWT token with 1-hour expiration. Logout endpoint invalidates tokens by adding to Redis blacklist.

## Technology Stack

- **Language:** Python 3.12
- **Framework:** FastAPI 0.104.1
- **Database:** PostgreSQL 15.0
- **Cache:** Redis 7.2
- **Authentication:** JWT (PyJWT 2.8.0)
- **Password Hashing:** bcrypt (via passlib)
- **Validation:** Pydantic v2
- **ORM:** SQLAlchemy 2.0

## Assumptions

- Email addresses are unique user identifiers
- Password complexity enforced: min 8 chars, 1 uppercase, 1 lowercase, 1 digit
- JWT tokens expire after 1 hour (configurable via environment variable)
- System scales to 10,000 concurrent users
- Redis available for caching and rate limiting
- PostgreSQL configured with connection pooling (min 5, max 20 connections)

## API Contracts

### POST /api/v1/auth/register

**Description:** Register a new user account with email and password. Validates email format, password complexity, and email uniqueness. Hashes password with bcrypt before storage.

**Authentication Required:** No

**Rate Limit:** 5 requests per minute per IP address

**Request Body:**
```json
{
  "email": "string (email format, required, max 255 chars)",
  "password": "string (min 8 chars, required, must contain uppercase, lowercase, and digit)",
  "username": "string (optional, min 3 chars, max 50 chars, alphanumeric)"
}
```

**Response (Success):**
```json
{
  "user_id": "string (UUID v4)",
  "email": "string",
  "username": "string (or null)",
  "created_at": "string (ISO 8601 timestamp)"
}
```

**Error Responses:**
- **400 INVALID_EMAIL**: Email format is invalid or missing.
- **400 WEAK_PASSWORD**: Password does not meet complexity requirements (min 8 chars, 1 uppercase, 1 lowercase, 1 digit).
- **409 USER_EXISTS**: A user with this email already exists.
- **429 RATE_LIMIT_EXCEEDED**: Too many registration attempts. Try again later.
- **500 INTERNAL_SERVER_ERROR**: An unexpected error occurred.

---

### POST /api/v1/auth/login

**Description:** Authenticate user with email and password. Returns JWT access token on success. Rate limited to prevent brute force attacks.

**Authentication Required:** No

**Rate Limit:** 5 requests per minute per IP address

**Request Body:**
```json
{
  "email": "string (email format, required)",
  "password": "string (required)"
}
```

**Response (Success):**
```json
{
  "access_token": "string (JWT token)",
  "token_type": "string (value: 'bearer')",
  "expires_in": "integer (seconds, typically 3600)",
  "user_id": "string (UUID v4)"
}
```

**Error Responses:**
- **400 MISSING_CREDENTIALS**: Email or password is missing.
- **401 INVALID_CREDENTIALS**: Email or password is incorrect.
- **429 RATE_LIMIT_EXCEEDED**: Too many login attempts. Account temporarily locked.
- **500 INTERNAL_SERVER_ERROR**: An unexpected error occurred.

---

## Data Schemas

### Table: users

**Description:** Stores user account information including credentials and metadata.

**Columns:**
| Column | Type | Constraints |
|--------|------|-------------|
| user_id | UUID | PRIMARY KEY |
| email | VARCHAR(255) | NOT NULL UNIQUE |
| password_hash | VARCHAR(255) | NOT NULL |
| username | VARCHAR(50) | NULL |
| created_at | TIMESTAMP | NOT NULL DEFAULT NOW() |
| updated_at | TIMESTAMP | NOT NULL DEFAULT NOW() |
| is_active | BOOLEAN | NOT NULL DEFAULT TRUE |
| last_login | TIMESTAMP | NULL |

**Indexes:**
```sql
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_created_at ON users(created_at);
CREATE INDEX idx_users_is_active ON users(is_active);
```

**Constraints:**
```sql
CHECK (LENGTH(email) >= 5);
CHECK (LENGTH(password_hash) >= 50);
CHECK (created_at <= NOW());
```

---

### Table: authentication_tokens

**Description:** Stores issued JWT tokens for tracking and invalidation (blacklist).

**Columns:**
| Column | Type | Constraints |
|--------|------|-------------|
| token_id | UUID | PRIMARY KEY |
| user_id | UUID | NOT NULL |
| token_hash | VARCHAR(64) | NOT NULL UNIQUE |
| issued_at | TIMESTAMP | NOT NULL DEFAULT NOW() |
| expires_at | TIMESTAMP | NOT NULL |
| is_revoked | BOOLEAN | NOT NULL DEFAULT FALSE |
| revoked_at | TIMESTAMP | NULL |

**Indexes:**
```sql
CREATE INDEX idx_tokens_user_id ON authentication_tokens(user_id);
CREATE INDEX idx_tokens_expires_at ON authentication_tokens(expires_at);
CREATE INDEX idx_tokens_token_hash ON authentication_tokens(token_hash);
CREATE INDEX idx_tokens_is_revoked ON authentication_tokens(is_revoked);
```

**Relationships:**
```sql
ALTER TABLE authentication_tokens ADD FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE;
```

**Constraints:**
```sql
CHECK (expires_at > issued_at);
CHECK (revoked_at IS NULL OR revoked_at >= issued_at);
```

---

## Component Logic

### Component: UserAuthenticationService

**Semantic Unit:** SU-002

**Responsibility:** Handles user authentication including registration, login, logout, and token validation.

**Dependencies:**
- DatabaseService
- PasswordHasher
- TokenGenerator
- RateLimiter

**Interfaces:**

#### `register_user(email: str, password: str, username: Optional[str] = None) -> User`

Register a new user account with email and password.

**Parameters:**
- `email`: User's email address (validated format)
- `password`: User's password (validated complexity)
- `username`: Optional username (alphanumeric)

**Returns:** Created User object with user_id and metadata

**Raises:**
- `UserExistsError`: If email already registered
- `ValidationError`: If email/password invalid

---

#### `authenticate(email: str, password: str) -> str`

Authenticate user and return JWT access token.

**Parameters:**
- `email`: User's email address
- `password`: User's password (plaintext)

**Returns:** JWT access token string

**Raises:**
- `InvalidCredentialsError`: If email/password incorrect
- `RateLimitError`: If too many attempts

---

#### `validate_token(token: str) -> User`

Validate JWT token and return associated user.

**Parameters:**
- `token`: JWT access token string

**Returns:** User object if token valid

**Raises:**
- `InvalidTokenError`: If token invalid/expired
- `RevokedTokenError`: If token blacklisted

---

**Implementation Notes:**

Use bcrypt for password hashing with cost factor 12 (configurable via PASSWORD_HASH_ROUNDS env var). Validate email format using RFC 5322 pattern. Enforce password complexity: min 8 chars, 1 uppercase, 1 lowercase, 1 digit. Generate JWT tokens with 1-hour expiration (configurable via TOKEN_EXPIRATION_SECONDS). Store token hash in database for revocation tracking. Use Redis for rate limiting (5 requests per minute per IP). Cache user lookups in Redis with 5-minute TTL. Log all authentication attempts (success/failure) for security auditing. Never log passwords or tokens.

**Estimated Complexity:** 85

---

## Design Review Checklist

### Security: Password storage and hashing

**Validation Criteria:** Passwords must be hashed with bcrypt cost factor >= 12. Password field in database is named 'password_hash', never 'password'. No passwords logged or exposed in API responses.

**Severity:** Critical

---

### Security: JWT token security

**Validation Criteria:** JWT tokens use HS256 algorithm with strong secret key (min 32 bytes). Tokens include expiration claim (exp). Token validation checks signature, expiration, and blacklist status.

**Severity:** Critical

---

### Security: Rate limiting implementation

**Validation Criteria:** Rate limiting enforced on /register and /login endpoints. Limits are per-IP address. Failed attempts increment counter. Counter resets after time window expires.

**Severity:** High

---

### Data Integrity: Email uniqueness constraint

**Validation Criteria:** Users table has UNIQUE constraint on email column. Registration endpoint catches IntegrityError and returns USER_EXISTS error code.

**Severity:** High

---

### API Design: Consistent error responses

**Validation Criteria:** All error responses follow format: {"error_code": str, "message": str, "details": Optional[dict]}. HTTP status codes match error semantics (400 for validation, 401 for auth, 409 for conflict).

**Severity:** High

---

### Performance: Database connection pooling

**Validation Criteria:** SQLAlchemy configured with connection pool (min 5, max 20). No connection leaks (all connections properly closed). Connection timeout configured (30 seconds).

**Severity:** Medium

---

### Performance: Redis caching strategy

**Validation Criteria:** User lookups cached in Redis with 5-minute TTL. Cache invalidated on user update. Rate limit counters use Redis INCR with EXPIRE. Token blacklist uses Redis SET with TTL matching token expiration.

**Severity:** Medium

---

*Generated by Design Agent v2.0 (Markdown) on 2025-11-21T10:00:00Z*
```

---

## Parsing Strategy

### Phase 1: Section Extraction

Use regex patterns to extract major sections:
- Metadata (task_id, timestamp)
- Architecture Overview
- Technology Stack
- Assumptions
- API Contracts (split by `###` headers)
- Data Schemas (split by `###` headers)
- Component Logic (split by `###` headers)
- Design Review Checklist (split by `###` headers)

### Phase 2: Section Parsing

**API Contracts:**
- Extract endpoint + method from header (`### GET /hello`)
- Parse fields after bold labels (`**Description:**`, `**Authentication Required:**`)
- Extract JSON schemas from code blocks
- Parse error responses from bullet lists

**Data Schemas:**
- Extract table name from header (`### Table: users`)
- Parse markdown table for columns
- Extract SQL from code blocks (indexes, relationships, constraints)

**Component Logic:**
- Extract component name from header (`### Component: ComponentName`)
- Parse metadata fields (Semantic Unit, Responsibility, Dependencies)
- Extract method signatures from headers (`#### \`method_name(...) -> Type\``)
- Parse implementation notes from dedicated section

**Design Review Checklist:**
- Extract category + description from header (`### Category: Description`)
- Parse validation criteria and severity from bold labels

### Phase 3: Pydantic Validation

Convert parsed dict to Pydantic models:
```python
design_data = parse_design_markdown(markdown_content)
design_spec = DesignSpecification.model_validate(design_data)
```

---

## LLM Generation Guidelines

**Prompt Instructions for LLM:**

1. Generate complete markdown following this exact structure
2. Use consistent header levels (# for title, ## for major sections, ### for items)
3. Use bold labels for field names (`**Field:**`)
4. Use JSON code blocks for schemas (```json...```)
5. Use SQL code blocks for database statements (```sql...```)
6. Use markdown tables for column definitions
7. Use bullet lists for lists (assumptions, dependencies, error responses)
8. Include all required sections (even if empty, mark as "N/A" or omit)
9. Format method signatures consistently: `` `method_name(param: type) -> return_type` ``
10. End with generation timestamp

**Quality Checklist:**
- [ ] All headers use correct levels
- [ ] All required sections present
- [ ] JSON schemas are valid JSON
- [ ] SQL statements are valid syntax
- [ ] Method signatures follow Python typing syntax
- [ ] Severity values are one of: Critical, High, Medium, Low
- [ ] Task ID appears in title and metadata
- [ ] Timestamp in ISO 8601 format

---

## Parser Implementation Notes

**Libraries:**
- `python-markdown` or `mistune` for parsing markdown AST
- `re` (regex) for pattern matching
- `json` for parsing code blocks
- `pydantic` for validation

**Error Handling:**
- Missing sections → Use default values or raise ValidationError
- Malformed JSON → Try to repair or raise clear error
- Invalid SQL → Log warning but don't fail (SQL not validated)
- Missing required fields → Raise ValidationError with field name

**Testing:**
- Unit tests for each section parser (20+ tests)
- Integration tests with complete examples (5+ examples)
- Edge case handling (missing fields, malformed content)
- Performance benchmarks (target: <100ms parsing time)

---

## Migration Path

**Phase 1: Design & Validate (Week 1)**
- Create this specification document ✅
- Get team review and approval
- Finalize format with examples

**Phase 2: Implementation (Week 2)**
- Implement markdown parser
- Create new prompt template
- Add feature flag to Design Agent
- Write comprehensive tests

**Phase 3: Testing (Week 3)**
- Run E2E tests 50+ times
- Compare success rates (Sonnet vs Haiku)
- Validate output quality
- Measure token usage and costs

**Phase 4: Rollout (Week 4+)**
- Canary release (10% of tasks)
- Gradual increase (50%, 100%)
- Remove feature flag after 2 weeks
- Update documentation

---

## Success Criteria

**Must Have:**
- Parsing success rate ≥ 99% (100+ test runs)
- All Pydantic validations pass after parsing
- No regressions vs JSON baseline quality
- Haiku compatibility >= Sonnet baseline

**Should Have:**
- Token usage reduction ≥ 5%
- Parsing latency ≤ 100ms
- Clear error messages for parsing failures

**Nice to Have:**
- Human readability improvement (developer feedback)
- Reduced prompt engineering iterations for Haiku
- Architectural consistency with Code Agent approach

---

**Status:** Draft - Awaiting Phase 2 implementation
**Next:** Implement markdown parser and updated prompt template
**Review Date:** 2025-11-28 (after Phase 3 testing)
