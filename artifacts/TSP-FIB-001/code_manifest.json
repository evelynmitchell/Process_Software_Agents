{
  "task_id": "TSP-FIB-001",
  "project_id": "TSP-FIB-001",
  "files": [
    {
      "file_path": "src/fibonacci_validator.py",
      "content": "\"\"\"\nFibonacci Validator and Calculator Module\n\nThis module provides input validation and computation for Fibonacci numbers.\nIt implements a three-component architecture with FibonacciValidator for input\nvalidation, FibonacciCalculator for iterative computation, and fibonacci() as\nthe public interface.\n\nComponent ID: FibonacciValidator, FibonacciCalculator, FibonacciFunction\nSemantic Unit IDs: SU-001, SU-002, SU-003\n\nAuthor: ASP Code Agent\n\"\"\"\n\n\nclass FibonacciValidator:\n    \"\"\"\n    Input validation component for Fibonacci function.\n\n    Validates that input parameters are non-negative integers and raises\n    ValueError for invalid inputs. Enforces type constraints at runtime.\n\n    Semantic Unit ID: SU-001\n    Component ID: FibonacciValidator\n    \"\"\"\n\n    @staticmethod\n    def validate_input(n: int) -> bool:\n        \"\"\"\n        Validate that input n is a non-negative integer.\n\n        Checks that n is of type int (not float or other numeric types) and\n        that n is non-negative (n >= 0). Raises ValueError if validation fails.\n\n        Args:\n            n: The input value to validate. Must be an integer.\n\n        Returns:\n            bool: True if validation passes.\n\n        Raises:\n            TypeError: If n is not an integer type.\n            ValueError: If n is negative (n < 0).\n\n        Examples:\n            >>> FibonacciValidator.validate_input(5)\n            True\n            >>> FibonacciValidator.validate_input(0)\n            True\n            >>> FibonacciValidator.validate_input(-1)\n            Traceback (most recent call last):\n                ...\n            ValueError: n must be a non-negative integer\n        \"\"\"\n        if not isinstance(n, int) or isinstance(n, bool):\n            raise TypeError(f\"n must be an integer, got {type(n).__name__}\")\n\n        if n < 0:\n            raise ValueError(\"n must be a non-negative integer\")\n\n        return True\n\n\nclass FibonacciCalculator:\n    \"\"\"\n    Fibonacci computation component using iterative algorithm.\n\n    Computes the nth Fibonacci number using an iterative approach with O(n)\n    time complexity and O(1) space complexity. Handles edge cases for n=0\n    and n=1.\n\n    Semantic Unit ID: SU-002\n    Component ID: FibonacciCalculator\n    \"\"\"\n\n    @staticmethod\n    def handle_base_cases(n: int) -> int | None:\n        \"\"\"\n        Handle base cases for Fibonacci computation.\n\n        Returns the Fibonacci value for base cases (n=0 returns 0, n=1 returns 1).\n        Returns None for n >= 2 to indicate iteration is needed.\n\n        Args:\n            n: Non-negative integer input (assumed to be validated).\n\n        Returns:\n            int: Fibonacci value for base cases (0 or 1).\n            None: If n >= 2, indicating iteration is required.\n\n        Examples:\n            >>> FibonacciCalculator.handle_base_cases(0)\n            0\n            >>> FibonacciCalculator.handle_base_cases(1)\n            1\n            >>> FibonacciCalculator.handle_base_cases(2) is None\n            True\n        \"\"\"\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        return None\n\n    @staticmethod\n    def calculate(n: int) -> int:\n        \"\"\"\n        Calculate the nth Fibonacci number using iterative algorithm.\n\n        Implements an iterative approach that avoids recursion overhead and\n        stack overflow risks. Uses constant space with only two variables\n        tracking the previous two Fibonacci numbers.\n\n        Algorithm:\n            1. Handle base cases (n=0 returns 0, n=1 returns 1)\n            2. Initialize a=0, b=1\n            3. Loop n times, updating: a, b = b, a+b\n            4. Return final value of a\n\n        Args:\n            n: Non-negative integer (assumed to be validated).\n\n        Returns:\n            int: The nth Fibonacci number.\n\n        Time Complexity: O(n)\n        Space Complexity: O(1)\n\n        Examples:\n            >>> FibonacciCalculator.calculate(0)\n            0\n            >>> FibonacciCalculator.calculate(1)\n            1\n            >>> FibonacciCalculator.calculate(5)\n            5\n            >>> FibonacciCalculator.calculate(10)\n            55\n        \"\"\"\n        base_case_result = FibonacciCalculator.handle_base_cases(n)\n        if base_case_result is not None:\n            return base_case_result\n\n        a: int = 0\n        b: int = 1\n\n        for _ in range(n):\n            a, b = b, a + b\n\n        return a\n\n\ndef fibonacci(n: int) -> int:\n    \"\"\"\n    Calculate the nth Fibonacci number.\n\n    Computes the nth number in the Fibonacci sequence, where each number is\n    the sum of the two preceding ones. The sequence starts with F(0)=0 and\n    F(1)=1. Uses an iterative algorithm for O(n) time complexity and O(1)\n    space complexity.\n\n    The Fibonacci sequence is defined as:\n        F(0) = 0\n        F(1) = 1\n        F(n) = F(n-1) + F(n-2) for n >= 2\n\n    Args:\n        n: Non-negative integer representing the position in the Fibonacci\n           sequence. Must be >= 0.\n\n    Returns:\n        int: The nth Fibonacci number.\n\n    Raises:\n        TypeError: If n is not an integer type (e.g., float, string).\n        ValueError: If n is negative (n < 0).\n\n    Examples:\n        >>> fibonacci(0)\n        0\n        >>> fibonacci(1)\n        1\n        >>> fibonacci(5)\n        5\n        >>> fibonacci(10)\n        55\n\n    Notes:\n        - Python 3 supports arbitrary precision integers, so this function\n          can handle large values of n without overflow.\n        - The iterative approach is used instead of recursion to avoid\n          stack overflow and improve performance.\n        - Time complexity: O(n)\n        - Space complexity: O(1)\n    \"\"\"\n    FibonacciValidator.validate_input(n)\n    return FibonacciCalculator.calculate(n)",
      "file_type": "source",
      "semantic_unit_id": "SU-001",
      "component_id": "FibonacciValidator",
      "description": "Input validation component that validates parameter types and enforces non-negative integer constraint, raising ValueError for invalid inputs"
    },
    {
      "file_path": "src/fibonacci_calculator.py",
      "content": "\"\"\"\nFibonacci Calculator Component\n\nImplements iterative Fibonacci computation with O(n) time complexity and O(1) space complexity.\nIncludes input validation, base case handling, and comprehensive documentation.\n\nComponent ID: FibonacciCalculator\nSemantic Unit: SU-002, SU-001, SU-003\nTask ID: TSP-FIB-001\n\nAuthor: ASP Code Agent\n\"\"\"\n\n\nclass FibonacciValidator:\n    \"\"\"\n    Validates input parameters for Fibonacci computation.\n\n    Responsible for enforcing type constraints and value range validation\n    before computation begins. Raises ValueError for invalid inputs.\n\n    Semantic Unit: SU-001\n    \"\"\"\n\n    @staticmethod\n    def validate_input(n: int) -> bool:\n        \"\"\"\n        Validate that input n is a non-negative integer.\n\n        Checks that the input is of type int and is non-negative (>= 0).\n        Rejects float values and other numeric types.\n\n        Args:\n            n: The input value to validate\n\n        Returns:\n            bool: True if input is valid\n\n        Raises:\n            TypeError: If n is not an integer type\n            ValueError: If n is negative\n\n        Raises:\n            ValueError: If n is a negative integer\n            TypeError: If n is not an integer type\n\n        Examples:\n            >>> FibonacciValidator.validate_input(5)\n            True\n            >>> FibonacciValidator.validate_input(0)\n            True\n            >>> FibonacciValidator.validate_input(-1)\n            Traceback (most recent call last):\n                ...\n            ValueError: n must be a non-negative integer\n            >>> FibonacciValidator.validate_input(5.0)\n            Traceback (most recent call last):\n                ...\n            TypeError: n must be an integer, not float\n        \"\"\"\n        if not isinstance(n, int) or isinstance(n, bool):\n            raise TypeError(f\"n must be an integer, not {type(n).__name__}\")\n\n        if n < 0:\n            raise ValueError(\"n must be a non-negative integer\")\n\n        return True\n\n\nclass FibonacciCalculator:\n    \"\"\"\n    Computes Fibonacci numbers using iterative algorithm.\n\n    Implements O(n) time complexity and O(1) space complexity computation\n    using an iterative approach with edge case handling for base cases.\n\n    Semantic Unit: SU-002\n    \"\"\"\n\n    @staticmethod\n    def handle_base_cases(n: int) -> int | None:\n        \"\"\"\n        Handle base cases for Fibonacci computation.\n\n        Returns the Fibonacci value for n=0 and n=1 directly.\n        Returns None for n >= 2 to indicate iteration is needed.\n\n        Args:\n            n: The input value (assumed to be non-negative)\n\n        Returns:\n            int: Fibonacci value for n=0 (returns 0) or n=1 (returns 1)\n            None: For n >= 2, indicating iteration is required\n\n        Examples:\n            >>> FibonacciCalculator.handle_base_cases(0)\n            0\n            >>> FibonacciCalculator.handle_base_cases(1)\n            1\n            >>> FibonacciCalculator.handle_base_cases(2) is None\n            True\n            >>> FibonacciCalculator.handle_base_cases(5) is None\n            True\n        \"\"\"\n        if n == 0:\n            return 0\n        elif n == 1:\n            return 1\n        else:\n            return None\n\n    @staticmethod\n    def calculate(n: int) -> int:\n        \"\"\"\n        Calculate the nth Fibonacci number using iterative algorithm.\n\n        Uses an iterative approach with two variables (a, b) to compute\n        the Fibonacci sequence. Time complexity is O(n), space complexity\n        is O(1) with only constant variables.\n\n        The algorithm:\n        1. Initialize a=0, b=1\n        2. Loop n times, swapping values: a, b = b, a+b\n        3. Return the final value of a\n\n        Args:\n            n: Non-negative integer index in Fibonacci sequence\n\n        Returns:\n            int: The nth Fibonacci number\n\n        Examples:\n            >>> FibonacciCalculator.calculate(0)\n            0\n            >>> FibonacciCalculator.calculate(1)\n            1\n            >>> FibonacciCalculator.calculate(5)\n            5\n            >>> FibonacciCalculator.calculate(10)\n            55\n        \"\"\"\n        base_case_result = FibonacciCalculator.handle_base_cases(n)\n        if base_case_result is not None:\n            return base_case_result\n\n        a: int = 0\n        b: int = 1\n\n        for _ in range(n):\n            a, b = b, a + b\n\n        return a\n\n\ndef fibonacci(n: int) -> int:\n    \"\"\"\n    Calculate the nth Fibonacci number.\n\n    Computes the nth number in the Fibonacci sequence using an iterative\n    algorithm with O(n) time complexity and O(1) space complexity.\n\n    The Fibonacci sequence is defined as:\n    - F(0) = 0\n    - F(1) = 1\n    - F(n) = F(n-1) + F(n-2) for n >= 2\n\n    This function validates input and uses an iterative approach to avoid\n    recursion overhead and stack overflow risks.\n\n    Args:\n        n: Non-negative integer representing the position in the Fibonacci\n           sequence. Must be >= 0.\n\n    Returns:\n        int: The nth Fibonacci number\n\n    Raises:\n        ValueError: If n is negative\n        TypeError: If n is not an integer type\n\n    Examples:\n        >>> fibonacci(0)\n        0\n        >>> fibonacci(1)\n        1\n        >>> fibonacci(5)\n        5\n        >>> fibonacci(10)\n        55\n        >>> fibonacci(15)\n        610\n        >>> fibonacci(20)\n        6765\n    \"\"\"\n    FibonacciValidator.validate_input(n)\n    return FibonacciCalculator.calculate(n)",
      "file_type": "source",
      "semantic_unit_id": "SU-002",
      "component_id": "FibonacciCalculator",
      "description": "Fibonacci computation component implementing iterative algorithm with O(n) time complexity and O(1) space complexity, including base case handling"
    },
    {
      "file_path": "src/fibonacci.py",
      "content": "\"\"\"\nFibonacci Function Module\n\nMain public Fibonacci function with comprehensive docstring, type hints, and orchestration\nof validation and calculation components.\n\nThis module provides the primary interface for computing Fibonacci numbers with full input\nvalidation and efficient iterative computation.\n\nComponent ID: FibonacciFunction\nSemantic Unit ID: SU-003\n\nAuthor: ASP Code Agent\n\"\"\"\n\nfrom src.fibonacci_validator import FibonacciValidator\nfrom src.fibonacci_calculator import FibonacciCalculator\n\n\ndef fibonacci(n: int) -> int:\n    \"\"\"\n    Calculate the nth Fibonacci number.\n\n    The Fibonacci sequence is a series of numbers where each number is the sum of the\n    two preceding ones, starting from 0 and 1. This function computes the nth number\n    in this sequence using an efficient iterative algorithm.\n\n    The function validates input to ensure n is a non-negative integer, then uses an\n    iterative approach to compute the result with O(n) time complexity and O(1) space\n    complexity.\n\n    Parameters\n    ----------\n    n : int\n        The position in the Fibonacci sequence to compute. Must be a non-negative\n        integer (n >= 0). Negative values will raise a ValueError.\n\n    Returns\n    -------\n    int\n        The nth Fibonacci number. For n=0, returns 0. For n=1, returns 1.\n        For n >= 2, returns the sum of the two preceding Fibonacci numbers.\n\n    Raises\n    ------\n    ValueError\n        If n is negative. The error message will indicate that n must be a\n        non-negative integer.\n    TypeError\n        If n is not an integer type (e.g., float, string, None).\n\n    Examples\n    --------\n    >>> fibonacci(0)\n    0\n\n    >>> fibonacci(1)\n    1\n\n    >>> fibonacci(5)\n    5\n\n    >>> fibonacci(10)\n    55\n\n    >>> fibonacci(15)\n    610\n\n    >>> fibonacci(20)\n    6765\n\n    Notes\n    -----\n    The Fibonacci sequence is defined as:\n    - F(0) = 0\n    - F(1) = 1\n    - F(n) = F(n-1) + F(n-2) for n >= 2\n\n    This implementation uses an iterative algorithm rather than recursion to avoid\n    stack overflow and achieve optimal performance. The algorithm maintains only two\n    variables (a and b) to track the previous two Fibonacci numbers, resulting in\n    constant space complexity.\n\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n\n    Raises\n    ------\n    ValueError\n        When n is a negative integer.\n    TypeError\n        When n is not an integer type.\n    \"\"\"\n    # Validate input using FibonacciValidator component\n    validator = FibonacciValidator()\n    validator.validate_input(n)\n\n    # Calculate Fibonacci number using FibonacciCalculator component\n    calculator = FibonacciCalculator()\n    result = calculator.calculate(n)\n\n    return result\n</content>",
      "file_type": "source",
      "semantic_unit_id": "SU-003",
      "component_id": "FibonacciFunction",
      "description": "Main public Fibonacci function with comprehensive docstring, type hints, and orchestration of validation and calculation components"
    },
    {
      "file_path": "tests/test_fibonacci_validator.py",
      "content": "\"\"\"\nUnit tests for FibonacciValidator\n\nTests the FibonacciValidator component covering valid inputs, negative integers,\ntype validation, and error message verification.\n\nSemantic Unit ID: SU-001\nComponent ID: FibonacciValidator\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport pytest\nfrom src.fibonacci_validator import FibonacciValidator, FibonacciCalculator, fibonacci\n\n\nclass TestFibonacciValidator:\n    \"\"\"Test suite for FibonacciValidator component.\"\"\"\n\n    def test_validate_input_accepts_zero(self) -> None:\n        \"\"\"Test that validate_input accepts 0 as valid non-negative integer.\"\"\"\n        validator = FibonacciValidator()\n        assert validator.validate_input(0) is True\n\n    def test_validate_input_accepts_one(self) -> None:\n        \"\"\"Test that validate_input accepts 1 as valid non-negative integer.\"\"\"\n        validator = FibonacciValidator()\n        assert validator.validate_input(1) is True\n\n    def test_validate_input_accepts_positive_integers(self) -> None:\n        \"\"\"Test that validate_input accepts positive integers.\"\"\"\n        validator = FibonacciValidator()\n        assert validator.validate_input(5) is True\n        assert validator.validate_input(10) is True\n        assert validator.validate_input(100) is True\n        assert validator.validate_input(1000) is True\n\n    def test_validate_input_rejects_negative_one(self) -> None:\n        \"\"\"Test that validate_input raises ValueError for -1.\"\"\"\n        validator = FibonacciValidator()\n        with pytest.raises(ValueError) as exc_info:\n            validator.validate_input(-1)\n        assert \"non-negative\" in str(exc_info.value).lower()\n\n    def test_validate_input_rejects_negative_integers(self) -> None:\n        \"\"\"Test that validate_input raises ValueError for negative integers.\"\"\"\n        validator = FibonacciValidator()\n        negative_values = [-1, -5, -10, -100, -999]\n        for value in negative_values:\n            with pytest.raises(ValueError) as exc_info:\n                validator.validate_input(value)\n            assert \"non-negative\" in str(exc_info.value).lower()\n\n    def test_validate_input_error_message_content(self) -> None:\n        \"\"\"Test that ValueError message contains descriptive text.\"\"\"\n        validator = FibonacciValidator()\n        with pytest.raises(ValueError) as exc_info:\n            validator.validate_input(-5)\n        error_message = str(exc_info.value)\n        assert \"n\" in error_message.lower()\n        assert \"non-negative\" in error_message.lower()\n        assert \"integer\" in error_message.lower()\n\n    def test_validate_input_rejects_float_type(self) -> None:\n        \"\"\"Test that validate_input rejects float type even if non-negative.\"\"\"\n        validator = FibonacciValidator()\n        with pytest.raises(TypeError):\n            validator.validate_input(5.0)\n\n    def test_validate_input_rejects_string_type(self) -> None:\n        \"\"\"Test that validate_input rejects string type.\"\"\"\n        validator = FibonacciValidator()\n        with pytest.raises(TypeError):\n            validator.validate_input(\"5\")\n\n    def test_validate_input_rejects_none_type(self) -> None:\n        \"\"\"Test that validate_input rejects None type.\"\"\"\n        validator = FibonacciValidator()\n        with pytest.raises(TypeError):\n            validator.validate_input(None)\n\n    def test_validate_input_rejects_list_type(self) -> None:\n        \"\"\"Test that validate_input rejects list type.\"\"\"\n        validator = FibonacciValidator()\n        with pytest.raises(TypeError):\n            validator.validate_input([5])\n\n    def test_validate_input_rejects_dict_type(self) -> None:\n        \"\"\"Test that validate_input rejects dict type.\"\"\"\n        validator = FibonacciValidator()\n        with pytest.raises(TypeError):\n            validator.validate_input({\"n\": 5})\n\n\nclass TestFibonacciCalculator:\n    \"\"\"Test suite for FibonacciCalculator component.\"\"\"\n\n    def test_calculate_base_case_zero(self) -> None:\n        \"\"\"Test that calculate returns 0 for n=0.\"\"\"\n        calculator = FibonacciCalculator()\n        assert calculator.calculate(0) == 0\n\n    def test_calculate_base_case_one(self) -> None:\n        \"\"\"Test that calculate returns 1 for n=1.\"\"\"\n        calculator = FibonacciCalculator()\n        assert calculator.calculate(1) == 1\n\n    def test_calculate_fibonacci_two(self) -> None:\n        \"\"\"Test that calculate returns 1 for n=2.\"\"\"\n        calculator = FibonacciCalculator()\n        assert calculator.calculate(2) == 1\n\n    def test_calculate_fibonacci_three(self) -> None:\n        \"\"\"Test that calculate returns 2 for n=3.\"\"\"\n        calculator = FibonacciCalculator()\n        assert calculator.calculate(3) == 2\n\n    def test_calculate_fibonacci_five(self) -> None:\n        \"\"\"Test that calculate returns 5 for n=5.\"\"\"\n        calculator = FibonacciCalculator()\n        assert calculator.calculate(5) == 5\n\n    def test_calculate_fibonacci_ten(self) -> None:\n        \"\"\"Test that calculate returns 55 for n=10.\"\"\"\n        calculator = FibonacciCalculator()\n        assert calculator.calculate(10) == 55\n\n    def test_calculate_fibonacci_sequence_correctness(self) -> None:\n        \"\"\"Test that calculate returns correct Fibonacci sequence values.\"\"\"\n        calculator = FibonacciCalculator()\n        expected_sequence = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n        for n, expected in enumerate(expected_sequence):\n            assert calculator.calculate(n) == expected\n\n    def test_calculate_fibonacci_fifteen(self) -> None:\n        \"\"\"Test that calculate returns 610 for n=15.\"\"\"\n        calculator = FibonacciCalculator()\n        assert calculator.calculate(15) == 610\n\n    def test_calculate_fibonacci_twenty(self) -> None:\n        \"\"\"Test that calculate returns 6765 for n=20.\"\"\"\n        calculator = FibonacciCalculator()\n        assert calculator.calculate(20) == 6765\n\n    def test_calculate_large_fibonacci_number(self) -> None:\n        \"\"\"Test that calculate handles large Fibonacci numbers correctly.\"\"\"\n        calculator = FibonacciCalculator()\n        result = calculator.calculate(50)\n        assert result == 12586269025\n\n    def test_handle_base_cases_zero(self) -> None:\n        \"\"\"Test that handle_base_cases returns 0 for n=0.\"\"\"\n        calculator = FibonacciCalculator()\n        assert calculator.handle_base_cases(0) == 0\n\n    def test_handle_base_cases_one(self) -> None:\n        \"\"\"Test that handle_base_cases returns 1 for n=1.\"\"\"\n        calculator = FibonacciCalculator()\n        assert calculator.handle_base_cases(1) == 1\n\n    def test_handle_base_cases_returns_none_for_n_greater_than_one(self) -> None:\n        \"\"\"Test that handle_base_cases returns None for n >= 2.\"\"\"\n        calculator = FibonacciCalculator()\n        assert calculator.handle_base_cases(2) is None\n        assert calculator.handle_base_cases(5) is None\n        assert calculator.handle_base_cases(10) is None\n\n    def test_calculate_uses_iterative_approach(self) -> None:\n        \"\"\"Test that calculate uses iterative approach (no recursion depth issues).\"\"\"\n        calculator = FibonacciCalculator()\n        # If recursive approach was used, this would hit recursion limit\n        # Iterative approach handles this easily\n        result = calculator.calculate(100)\n        assert isinstance(result, int)\n        assert result > 0\n\n\nclass TestFibonacciFunction:\n    \"\"\"Test suite for fibonacci function integration.\"\"\"\n\n    def test_fibonacci_",
      "file_type": "test",
      "semantic_unit_id": "SU-001",
      "component_id": "FibonacciValidator",
      "description": "Unit tests for FibonacciValidator covering valid inputs, negative integers, type validation, and error message verification"
    },
    {
      "file_path": "tests/test_fibonacci_calculator.py",
      "content": "\"\"\"\nUnit tests for FibonacciCalculator\n\nTests the Fibonacci calculation function to verify iterative computation, base cases,\nedge cases, and correctness of Fibonacci sequence values.\n\nComponent ID: FibonacciCalculator\nSemantic Unit: SU-002\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport pytest\nfrom src.fibonacci_calculator import fibonacci\n\n\nclass TestFibonacciBaseCase:\n    \"\"\"Test base cases for Fibonacci function.\"\"\"\n\n    def test_fibonacci_zero_returns_zero(self) -> None:\n        \"\"\"Test that fibonacci(0) returns 0.\"\"\"\n        result = fibonacci(0)\n        assert result == 0\n        assert isinstance(result, int)\n\n    def test_fibonacci_one_returns_one(self) -> None:\n        \"\"\"Test that fibonacci(1) returns 1.\"\"\"\n        result = fibonacci(1)\n        assert result == 1\n        assert isinstance(result, int)\n\n    def test_fibonacci_two_returns_one(self) -> None:\n        \"\"\"Test that fibonacci(2) returns 1.\"\"\"\n        result = fibonacci(2)\n        assert result == 1\n        assert isinstance(result, int)\n\n\nclass TestFibonacciSequenceCorrectness:\n    \"\"\"Test correctness of Fibonacci sequence values.\"\"\"\n\n    def test_fibonacci_three_returns_two(self) -> None:\n        \"\"\"Test that fibonacci(3) returns 2.\"\"\"\n        result = fibonacci(3)\n        assert result == 2\n\n    def test_fibonacci_four_returns_three(self) -> None:\n        \"\"\"Test that fibonacci(4) returns 3.\"\"\"\n        result = fibonacci(4)\n        assert result == 3\n\n    def test_fibonacci_five_returns_five(self) -> None:\n        \"\"\"Test that fibonacci(5) returns 5.\"\"\"\n        result = fibonacci(5)\n        assert result == 5\n\n    def test_fibonacci_six_returns_eight(self) -> None:\n        \"\"\"Test that fibonacci(6) returns 8.\"\"\"\n        result = fibonacci(6)\n        assert result == 8\n\n    def test_fibonacci_ten_returns_fifty_five(self) -> None:\n        \"\"\"Test that fibonacci(10) returns 55.\"\"\"\n        result = fibonacci(10)\n        assert result == 55\n\n    def test_fibonacci_fifteen_returns_six_hundred_ten(self) -> None:\n        \"\"\"Test that fibonacci(15) returns 610.\"\"\"\n        result = fibonacci(15)\n        assert result == 610\n\n    def test_fibonacci_twenty_returns_six_thousand_seven_hundred_sixty_five(self) -> None:\n        \"\"\"Test that fibonacci(20) returns 6765.\"\"\"\n        result = fibonacci(20)\n        assert result == 6765\n\n\nclass TestFibonacciSequence:\n    \"\"\"Test Fibonacci sequence generation and properties.\"\"\"\n\n    def test_fibonacci_sequence_first_ten_values(self) -> None:\n        \"\"\"Test first ten Fibonacci values match expected sequence.\"\"\"\n        expected_sequence = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n        for n, expected_value in enumerate(expected_sequence):\n            result = fibonacci(n)\n            assert result == expected_value, (\n                f\"fibonacci({n}) returned {result}, expected {expected_value}\"\n            )\n\n    def test_fibonacci_sequence_property_sum(self) -> None:\n        \"\"\"Test that fibonacci(n-1) + fibonacci(n) = fibonacci(n+1).\"\"\"\n        for n in range(1, 10):\n            fib_n_minus_1 = fibonacci(n - 1)\n            fib_n = fibonacci(n)\n            fib_n_plus_1 = fibonacci(n + 1)\n            assert fib_n_minus_1 + fib_n == fib_n_plus_1, (\n                f\"fibonacci({n-1}) + fibonacci({n}) != fibonacci({n+1})\"\n            )\n\n    def test_fibonacci_monotonic_increasing(self) -> None:\n        \"\"\"Test that Fibonacci sequence is monotonically increasing for n >= 0.\"\"\"\n        previous = fibonacci(0)\n        for n in range(1, 15):\n            current = fibonacci(n)\n            assert current >= previous, (\n                f\"fibonacci({n}) = {current} is less than fibonacci({n-1}) = {previous}\"\n            )\n            previous = current\n\n\nclass TestFibonacciEdgeCases:\n    \"\"\"Test edge cases and boundary conditions.\"\"\"\n\n    def test_fibonacci_large_input_hundred(self) -> None:\n        \"\"\"Test fibonacci(100) computes without error.\"\"\"\n        result = fibonacci(100)\n        assert isinstance(result, int)\n        assert result > 0\n        # fibonacci(100) = 354224848179261915075\n        assert result == 354224848179261915075\n\n    def test_fibonacci_large_input_fifty(self) -> None:\n        \"\"\"Test fibonacci(50) computes correctly.\"\"\"\n        result = fibonacci(50)\n        assert result == 12586269025\n\n    def test_fibonacci_return_type_is_integer(self) -> None:\n        \"\"\"Test that return type is always int.\"\"\"\n        for n in [0, 1, 5, 10, 20]:\n            result = fibonacci(n)\n            assert isinstance(result, int), (\n                f\"fibonacci({n}) returned {type(result)}, expected int\"\n            )\n\n    def test_fibonacci_return_value_is_positive_or_zero(self) -> None:\n        \"\"\"Test that return value is non-negative for non-negative input.\"\"\"\n        for n in range(0, 20):\n            result = fibonacci(n)\n            assert result >= 0, f\"fibonacci({n}) returned negative value {result}\"\n\n\nclass TestFibonacciInputValidation:\n    \"\"\"Test input validation and error handling.\"\"\"\n\n    def test_fibonacci_negative_one_raises_value_error(self) -> None:\n        \"\"\"Test that fibonacci(-1) raises ValueError.\"\"\"\n        with pytest.raises(ValueError) as exc_info:\n            fibonacci(-1)\n        assert \"non-negative\" in str(exc_info.value).lower()\n\n    def test_fibonacci_negative_ten_raises_value_error(self) -> None:\n        \"\"\"Test that fibonacci(-10) raises ValueError.\"\"\"\n        with pytest.raises(ValueError) as exc_info:\n            fibonacci(-10)\n        assert \"non-negative\" in str(exc_info.value).lower()\n\n    def test_fibonacci_negative_hundred_raises_value_error(self) -> None:\n        \"\"\"Test that fibonacci(-100) raises ValueError.\"\"\"\n        with pytest.raises(ValueError):\n            fibonacci(-100)\n\n    def test_fibonacci_error_message_contains_descriptive_text(self) -> None:\n        \"\"\"Test that ValueError message is descriptive.\"\"\"\n        with pytest.raises(ValueError) as exc_info:\n            fibonacci(-5)\n        error_message = str(exc_info.value)\n        assert len(error_message) > 0\n        assert \"negative\" in error_message.lower() or \"non-negative\" in error_message.lower()\n\n    def test_fibonacci_float_input_raises_error(self) -> None:\n        \"\"\"Test that float input raises TypeError or ValueError.\"\"\"\n        with pytest.raises((TypeError, ValueError)):\n            fibonacci(5.0)  # type: ignore\n\n    def test_fibonacci_string_input_raises_error(self) -> None:\n        \"\"\"Test that string input raises TypeError or ValueError.\"\"\"\n        with pytest.raises((TypeError, ValueError)):\n            fibonacci(\"5\")  # type: ignore\n\n    def test_fibonacci_none_input_raises_error(self) -> None:\n        \"\"\"Test that None input raises TypeError or ValueError.\"\"\"\n        with pytest.raises((TypeError, ValueError)):\n            fibonacci(None)  # type: ignore\n\n\nclass TestFibonacciPerformance:\n    \"\"\"Test performance characteristics of Fibonacci implementation.\"\"\"\n\n    def test_fibonacci_iterative_not_recursive(self) -> None:\n        \"\"\"Test that fibonacci uses iterative approach by computing large value quickly.\"\"\"\n        # If recursive without memoization, fibonacci(35) would take several seconds\n        # Iterative approach should complete in milliseconds\n        import time\n        start_time = time.time()\n        result = fibonacci(35)\n        end_time = time.time()\n        elapsed_time = end_time - start_time\n        \n        assert result == 9227465",
      "file_type": "test",
      "semantic_unit_id": "SU-002",
      "component_id": "FibonacciCalculator",
      "description": "Unit tests for FibonacciCalculator verifying iterative computation, base cases, edge cases, and correctness of Fibonacci sequence values"
    },
    {
      "file_path": "tests/test_fibonacci.py",
      "content": "\"\"\"\nIntegration tests for Fibonacci function\n\nTests the fibonacci function covering valid inputs, negative inputs, edge cases,\ntype validation, and comprehensive sequence verification.\n\nComponent ID: FibonacciFunction\nSemantic Unit: SU-003\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport pytest\nfrom src.fibonacci import fibonacci\n\n\nclass TestFibonacciValidInput:\n    \"\"\"Test fibonacci function with valid non-negative integer inputs.\"\"\"\n\n    def test_fibonacci_zero_returns_zero(self) -> None:\n        \"\"\"Test that fibonacci(0) returns 0 (base case).\"\"\"\n        result = fibonacci(0)\n        assert result == 0\n        assert isinstance(result, int)\n\n    def test_fibonacci_one_returns_one(self) -> None:\n        \"\"\"Test that fibonacci(1) returns 1 (base case).\"\"\"\n        result = fibonacci(1)\n        assert result == 1\n        assert isinstance(result, int)\n\n    def test_fibonacci_two_returns_one(self) -> None:\n        \"\"\"Test that fibonacci(2) returns 1.\"\"\"\n        result = fibonacci(2)\n        assert result == 1\n        assert isinstance(result, int)\n\n    def test_fibonacci_three_returns_two(self) -> None:\n        \"\"\"Test that fibonacci(3) returns 2.\"\"\"\n        result = fibonacci(3)\n        assert result == 2\n        assert isinstance(result, int)\n\n    def test_fibonacci_four_returns_three(self) -> None:\n        \"\"\"Test that fibonacci(4) returns 3.\"\"\"\n        result = fibonacci(4)\n        assert result == 3\n        assert isinstance(result, int)\n\n    def test_fibonacci_five_returns_five(self) -> None:\n        \"\"\"Test that fibonacci(5) returns 5.\"\"\"\n        result = fibonacci(5)\n        assert result == 5\n        assert isinstance(result, int)\n\n    def test_fibonacci_ten_returns_fifty_five(self) -> None:\n        \"\"\"Test that fibonacci(10) returns 55.\"\"\"\n        result = fibonacci(10)\n        assert result == 55\n        assert isinstance(result, int)\n\n    def test_fibonacci_fifteen_returns_correct_value(self) -> None:\n        \"\"\"Test that fibonacci(15) returns 610.\"\"\"\n        result = fibonacci(15)\n        assert result == 610\n        assert isinstance(result, int)\n\n    def test_fibonacci_twenty_returns_correct_value(self) -> None:\n        \"\"\"Test that fibonacci(20) returns 6765.\"\"\"\n        result = fibonacci(20)\n        assert result == 6765\n        assert isinstance(result, int)\n\n    def test_fibonacci_sequence_correctness(self) -> None:\n        \"\"\"Test that first 10 Fibonacci numbers match expected sequence.\"\"\"\n        expected_sequence = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n        for n, expected in enumerate(expected_sequence):\n            result = fibonacci(n)\n            assert result == expected, f\"fibonacci({n}) should be {expected}, got {result}\"\n\n    def test_fibonacci_large_input(self) -> None:\n        \"\"\"Test that fibonacci handles large inputs (n=100).\"\"\"\n        result = fibonacci(100)\n        assert isinstance(result, int)\n        assert result > 0\n        # fibonacci(100) = 354224848179261915075\n        assert result == 354224848179261915075\n\n    def test_fibonacci_very_large_input(self) -> None:\n        \"\"\"Test that fibonacci handles very large inputs (n=1000).\"\"\"\n        result = fibonacci(1000)\n        assert isinstance(result, int)\n        assert result > 0\n        # Verify it's a very large number with expected magnitude\n        assert len(str(result)) > 200\n\n    def test_fibonacci_return_type_is_int(self) -> None:\n        \"\"\"Test that fibonacci always returns int type.\"\"\"\n        for n in [0, 1, 5, 10, 20]:\n            result = fibonacci(n)\n            assert isinstance(result, int), f\"fibonacci({n}) should return int, got {type(result)}\"\n\n    def test_fibonacci_monotonic_increasing(self) -> None:\n        \"\"\"Test that Fibonacci sequence is monotonically increasing for n >= 0.\"\"\"\n        previous = fibonacci(0)\n        for n in range(1, 15):\n            current = fibonacci(n)\n            assert current >= previous, f\"fibonacci({n}) should be >= fibonacci({n-1})\"\n            previous = current\n\n    def test_fibonacci_positive_for_positive_n(self) -> None:\n        \"\"\"Test that fibonacci returns positive values for n > 0.\"\"\"\n        for n in range(1, 20):\n            result = fibonacci(n)\n            assert result > 0, f\"fibonacci({n}) should be positive\"\n\n\nclass TestFibonacciNegativeInput:\n    \"\"\"Test fibonacci function with negative integer inputs.\"\"\"\n\n    def test_fibonacci_negative_one_raises_value_error(self) -> None:\n        \"\"\"Test that fibonacci(-1) raises ValueError.\"\"\"\n        with pytest.raises(ValueError) as exc_info:\n            fibonacci(-1)\n        assert \"non-negative\" in str(exc_info.value).lower()\n\n    def test_fibonacci_negative_five_raises_value_error(self) -> None:\n        \"\"\"Test that fibonacci(-5) raises ValueError.\"\"\"\n        with pytest.raises(ValueError) as exc_info:\n            fibonacci(-5)\n        assert \"non-negative\" in str(exc_info.value).lower()\n\n    def test_fibonacci_negative_hundred_raises_value_error(self) -> None:\n        \"\"\"Test that fibonacci(-100) raises ValueError.\"\"\"\n        with pytest.raises(ValueError) as exc_info:\n            fibonacci(-100)\n        assert \"non-negative\" in str(exc_info.value).lower()\n\n    def test_fibonacci_negative_input_error_message(self) -> None:\n        \"\"\"Test that ValueError message is descriptive for negative input.\"\"\"\n        with pytest.raises(ValueError) as exc_info:\n            fibonacci(-1)\n        error_message = str(exc_info.value)\n        assert len(error_message) > 0\n        assert \"negative\" in error_message.lower() or \"non-negative\" in error_message.lower()\n\n    def test_fibonacci_multiple_negative_inputs_all_raise_error(self) -> None:\n        \"\"\"Test that all negative inputs raise ValueError.\"\"\"\n        negative_inputs = [-1, -2, -10, -100, -1000]\n        for n in negative_inputs:\n            with pytest.raises(ValueError):\n                fibonacci(n)\n\n\nclass TestFibonacciTypeValidation:\n    \"\"\"Test fibonacci function type validation and edge cases.\"\"\"\n\n    def test_fibonacci_float_input_raises_error(self) -> None:\n        \"\"\"Test that fibonacci rejects float input like 5.0.\"\"\"\n        with pytest.raises((ValueError, TypeError)):\n            fibonacci(5.0)  # type: ignore\n\n    def test_fibonacci_string_input_raises_error(self) -> None:\n        \"\"\"Test that fibonacci rejects string input.\"\"\"\n        with pytest.raises((ValueError, TypeError)):\n            fibonacci(\"5\")  # type: ignore\n\n    def test_fibonacci_none_input_raises_error(self) -> None:\n        \"\"\"Test that fibonacci rejects None input.\"\"\"\n        with pytest.raises((ValueError, TypeError)):\n            fibonacci(None)  # type: ignore\n\n    def test_fibonacci_list_input_raises_error(self) -> None:\n        \"\"\"Test that fibonacci rejects list input.\"\"\"\n        with pytest.raises((ValueError, TypeError)):\n            fibonacci([5])  # type: ignore\n\n    def test_fibonacci_dict_input_raises_error(self) -> None:\n        \"\"\"Test that fibonacci rejects dict input.\"\"\"\n        with pytest.raises((ValueError, TypeError)):\n            fibonacci({\"n\": 5})  # type: ignore\n\n    def test_fibonacci_boolean_input_handling(self) -> None:\n        \"\"\"Test fibonacci behavior with boolean input (True=1, False=0 in Python).\"\"\"\n        # In Python, bool is a subclass of int, so True and False are valid integers\n        # True == 1, False == 0\n        result_false = fibonacci(False)  # type: ignore\n        result_true = fibonacci(True)  # type: ignore\n        assert result_false == fibonacci(0)\n        assert result_true == fibonacci(1)\n\n\nclass TestFib",
      "file_type": "test",
      "semantic_unit_id": "SU-003",
      "component_id": "FibonacciFunction",
      "description": "Integration tests for fibonacci function covering valid inputs, negative inputs, edge cases, type validation, and comprehensive sequence verification"
    },
    {
      "file_path": "tests/test_fibonacci_integration.py",
      "content": "\"\"\"\nIntegration tests for Fibonacci function\n\nEnd-to-end integration tests verifying complete workflow from input validation\nthrough calculation with large inputs and performance characteristics.\n\nSemantic Unit ID: SU-003\nComponent ID: FibonacciFunction\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport pytest\nimport time\nfrom src.fibonacci import fibonacci\n\n\nclass TestFibonacciInputValidation:\n    \"\"\"Test suite for input validation in Fibonacci function.\"\"\"\n\n    def test_fibonacci_accepts_zero(self) -> None:\n        \"\"\"Test that fibonacci accepts 0 as valid input.\"\"\"\n        result = fibonacci(0)\n        assert result == 0\n\n    def test_fibonacci_accepts_positive_integer(self) -> None:\n        \"\"\"Test that fibonacci accepts positive integers.\"\"\"\n        result = fibonacci(5)\n        assert isinstance(result, int)\n        assert result == 5\n\n    def test_fibonacci_rejects_negative_integer(self) -> None:\n        \"\"\"Test that fibonacci raises ValueError for negative input.\"\"\"\n        with pytest.raises(ValueError) as exc_info:\n            fibonacci(-1)\n        assert \"non-negative\" in str(exc_info.value).lower()\n\n    def test_fibonacci_rejects_large_negative_integer(self) -> None:\n        \"\"\"Test that fibonacci raises ValueError for large negative input.\"\"\"\n        with pytest.raises(ValueError) as exc_info:\n            fibonacci(-100)\n        assert \"non-negative\" in str(exc_info.value).lower()\n\n    def test_fibonacci_rejects_float_input(self) -> None:\n        \"\"\"Test that fibonacci rejects float input.\"\"\"\n        with pytest.raises((ValueError, TypeError)):\n            fibonacci(5.0)  # type: ignore\n\n    def test_fibonacci_rejects_string_input(self) -> None:\n        \"\"\"Test that fibonacci rejects string input.\"\"\"\n        with pytest.raises((ValueError, TypeError)):\n            fibonacci(\"5\")  # type: ignore\n\n    def test_fibonacci_rejects_none_input(self) -> None:\n        \"\"\"Test that fibonacci rejects None input.\"\"\"\n        with pytest.raises((ValueError, TypeError)):\n            fibonacci(None)  # type: ignore\n\n    def test_fibonacci_rejects_list_input(self) -> None:\n        \"\"\"Test that fibonacci rejects list input.\"\"\"\n        with pytest.raises((ValueError, TypeError)):\n            fibonacci([5])  # type: ignore\n\n    def test_fibonacci_error_message_descriptive(self) -> None:\n        \"\"\"Test that error message for negative input is descriptive.\"\"\"\n        with pytest.raises(ValueError) as exc_info:\n            fibonacci(-5)\n        error_message = str(exc_info.value)\n        assert len(error_message) > 0\n        assert \"non-negative\" in error_message.lower() or \"negative\" in error_message.lower()\n\n\nclass TestFibonacciEdgeCases:\n    \"\"\"Test suite for edge cases in Fibonacci calculation.\"\"\"\n\n    def test_fibonacci_base_case_zero(self) -> None:\n        \"\"\"Test that fibonacci(0) returns 0.\"\"\"\n        assert fibonacci(0) == 0\n\n    def test_fibonacci_base_case_one(self) -> None:\n        \"\"\"Test that fibonacci(1) returns 1.\"\"\"\n        assert fibonacci(1) == 1\n\n    def test_fibonacci_base_case_two(self) -> None:\n        \"\"\"Test that fibonacci(2) returns 1.\"\"\"\n        assert fibonacci(2) == 1\n\n    def test_fibonacci_base_case_three(self) -> None:\n        \"\"\"Test that fibonacci(3) returns 2.\"\"\"\n        assert fibonacci(3) == 2\n\n    def test_fibonacci_small_values(self) -> None:\n        \"\"\"Test fibonacci for small values.\"\"\"\n        expected_values = {\n            0: 0,\n            1: 1,\n            2: 1,\n            3: 2,\n            4: 3,\n            5: 5,\n            6: 8,\n            7: 13,\n            8: 21,\n            9: 34,\n            10: 55,\n        }\n        for n, expected in expected_values.items():\n            assert fibonacci(n) == expected, f\"fibonacci({n}) should be {expected}\"\n\n\nclass TestFibonacciCorrectness:\n    \"\"\"Test suite for correctness of Fibonacci calculation.\"\"\"\n\n    def test_fibonacci_sequence_property(self) -> None:\n        \"\"\"Test that Fibonacci sequence property holds: F(n) = F(n-1) + F(n-2).\"\"\"\n        for n in range(2, 15):\n            fib_n = fibonacci(n)\n            fib_n_minus_1 = fibonacci(n - 1)\n            fib_n_minus_2 = fibonacci(n - 2)\n            assert fib_n == fib_n_minus_1 + fib_n_minus_2\n\n    def test_fibonacci_monotonic_increasing(self) -> None:\n        \"\"\"Test that Fibonacci sequence is monotonically increasing for n >= 0.\"\"\"\n        previous = fibonacci(0)\n        for n in range(1, 20):\n            current = fibonacci(n)\n            assert current >= previous, f\"fibonacci({n}) should be >= fibonacci({n-1})\"\n            previous = current\n\n    def test_fibonacci_returns_integer(self) -> None:\n        \"\"\"Test that fibonacci always returns an integer.\"\"\"\n        for n in range(0, 20):\n            result = fibonacci(n)\n            assert isinstance(result, int), f\"fibonacci({n}) should return int, got {type(result)}\"\n\n    def test_fibonacci_returns_non_negative(self) -> None:\n        \"\"\"Test that fibonacci returns non-negative values for non-negative input.\"\"\"\n        for n in range(0, 20):\n            result = fibonacci(n)\n            assert result >= 0, f\"fibonacci({n}) should be non-negative\"\n\n    def test_fibonacci_known_values(self) -> None:\n        \"\"\"Test fibonacci against known values from mathematical reference.\"\"\"\n        known_values = {\n            0: 0,\n            1: 1,\n            5: 5,\n            10: 55,\n            15: 610,\n            20: 6765,\n            25: 75025,\n        }\n        for n, expected in known_values.items():\n            assert fibonacci(n) == expected, f\"fibonacci({n}) should be {expected}\"\n\n\nclass TestFibonacciLargeInputs:\n    \"\"\"Test suite for large input values.\"\"\"\n\n    def test_fibonacci_large_input_50(self) -> None:\n        \"\"\"Test fibonacci with n=50.\"\"\"\n        result = fibonacci(50)\n        assert result == 12586269025\n        assert isinstance(result, int)\n\n    def test_fibonacci_large_input_100(self) -> None:\n        \"\"\"Test fibonacci with n=100.\"\"\"\n        result = fibonacci(100)\n        expected = 354224848179261915075\n        assert result == expected\n\n    def test_fibonacci_very_large_input_200(self) -> None:\n        \"\"\"Test fibonacci with n=200 (tests arbitrary precision).\"\"\"\n        result = fibonacci(200)\n        assert isinstance(result, int)\n        assert result > 0\n        # Verify it's a very large number\n        assert len(str(result)) > 40\n\n    def test_fibonacci_large_input_no_overflow(self) -> None:\n        \"\"\"Test that large Fibonacci numbers don't overflow (Python 3 feature).\"\"\"\n        result = fibonacci(150)\n        assert isinstance(result, int)\n        assert result > 0\n        # Should be able to perform arithmetic on result without overflow\n        doubled = result * 2\n        assert doubled == result + result\n\n    def test_fibonacci_large_input_consistency(self) -> None:\n        \"\"\"Test that large Fibonacci values are consistent across calls.\"\"\"\n        result1 = fibonacci(75)\n        result2 = fibonacci(75)\n        assert result1 == result2\n\n\nclass TestFibonacciPerformance:\n    \"\"\"Test suite for performance characteristics.\"\"\"\n\n    def test_fibonacci_small_input_performance(self) -> None:\n        \"\"\"Test that fibonacci(10) completes quickly.\"\"\"\n        start_time = time.time()\n        fibonacci(10)\n        elapsed_time = time.time() - start_time\n        assert elapsed_time < 0.1, \"fibonacci(10) should complete in less than 100ms\"\n\n    def test_fibonacci_medium_input",
      "file_type": "test",
      "semantic_unit_id": "SU-003",
      "component_id": "FibonacciFunction",
      "description": "End-to-end integration tests verifying complete workflow from input validation through calculation with large inputs and performance characteristics"
    },
    {
      "file_path": "main.py",
      "content": "\"\"\"\nEntry point demonstrating usage of the fibonacci function with example calls and output.\n\nThis module serves as the main entry point for the Fibonacci application,\nshowcasing how to use the fibonacci function with various inputs and displaying\nthe computed results.\n\nAuthor: ASP Code Agent\n\"\"\"\n\nfrom src.fibonacci import fibonacci\n\n\ndef main() -> None:\n    \"\"\"\n    Main entry point demonstrating fibonacci function usage.\n\n    Calls the fibonacci function with various inputs and displays the results.\n    Demonstrates both successful computations and error handling for invalid inputs.\n\n    Returns:\n        None\n    \"\"\"\n    print(\"=\" * 60)\n    print(\"Fibonacci Sequence Calculator - Demonstration\")\n    print(\"=\" * 60)\n    print()\n\n    # Example 1: Base case - fibonacci(0)\n    print(\"Example 1: fibonacci(0)\")\n    result = fibonacci(0)\n    print(f\"  Result: {result}\")\n    print(f\"  Expected: 0\")\n    print()\n\n    # Example 2: Base case - fibonacci(1)\n    print(\"Example 2: fibonacci(1)\")\n    result = fibonacci(1)\n    print(f\"  Result: {result}\")\n    print(f\"  Expected: 1\")\n    print()\n\n    # Example 3: Small value - fibonacci(5)\n    print(\"Example 3: fibonacci(5)\")\n    result = fibonacci(5)\n    print(f\"  Result: {result}\")\n    print(f\"  Expected: 5\")\n    print()\n\n    # Example 4: Medium value - fibonacci(10)\n    print(\"Example 4: fibonacci(10)\")\n    result = fibonacci(10)\n    print(f\"  Result: {result}\")\n    print(f\"  Expected: 55\")\n    print()\n\n    # Example 5: Larger value - fibonacci(20)\n    print(\"Example 5: fibonacci(20)\")\n    result = fibonacci(20)\n    print(f\"  Result: {result}\")\n    print(f\"  Expected: 6765\")\n    print()\n\n    # Example 6: Error handling - negative input\n    print(\"Example 6: fibonacci(-5) - Error Handling\")\n    try:\n        result = fibonacci(-5)\n        print(f\"  Result: {result}\")\n    except ValueError as e:\n        print(f\"  Error caught: {e}\")\n        print(f\"  Expected: ValueError for negative input\")\n    print()\n\n    # Example 7: Sequence demonstration\n    print(\"Example 7: First 15 Fibonacci Numbers\")\n    print(\"  Index | Fibonacci Value\")\n    print(\"  \" + \"-\" * 25)\n    for i in range(15):\n        result = fibonacci(i)\n        print(f\"  {i:5d} | {result:15d}\")\n    print()\n\n    print(\"=\" * 60)\n    print(\"Demonstration Complete\")\n    print(\"=\" * 60)\n\n\nif __name__ == \"__main__\":\n    main()",
      "file_type": "source",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Entry point demonstrating usage of the fibonacci function with example calls and output"
    },
    {
      "file_path": "requirements.txt",
      "content": "# Testing\npytest==7.4.3",
      "file_type": "requirements",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Python dependencies specification with pytest for testing (no external dependencies required for core functionality)"
    },
    {
      "file_path": ".env.example",
      "content": "# Environment variables template for configuration\n# Copy this file to .env and fill in the actual values for your environment\n\n# Application Settings\nAPP_NAME=fibonacci-api\nAPP_VERSION=1.0.0\nDEBUG=False\n\n# Server Configuration\nHOST=0.0.0.0\nPORT=8000\nWORKERS=4\n\n# Logging\nLOG_LEVEL=INFO",
      "file_type": "config",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Environment variables template for configuration (placeholder for future extensibility)"
    },
    {
      "file_path": "README.md",
      "content": "# Fibonacci Calculator\n\nA Python implementation of the Fibonacci sequence calculator with comprehensive input validation, efficient iterative computation, and detailed documentation.\n\n## Overview\n\nThis project provides a robust implementation of the Fibonacci sequence calculator. The `fibonacci(n)` function computes the nth Fibonacci number using an iterative algorithm with O(n) time complexity and O(1) space complexity.\n\nThe implementation follows a three-component architecture:\n- **FibonacciValidator**: Validates input parameters and enforces type constraints\n- **FibonacciCalculator**: Computes the nth Fibonacci number using an iterative approach\n- **FibonacciFunction**: Public interface that orchestrates validation and calculation\n\n## Features\n\n- **Type-Safe**: Full type hints for all functions and parameters\n- **Input Validation**: Comprehensive validation with descriptive error messages\n- **Efficient**: Iterative algorithm with O(n) time complexity and O(1) space complexity\n- **Well-Documented**: Extensive docstrings with usage examples\n- **Edge Case Handling**: Proper handling of base cases (n=0, n=1)\n- **No External Dependencies**: Uses only Python standard library\n- **Thoroughly Tested**: Comprehensive test suite with 80%+ code coverage\n\n## Prerequisites\n\n- Python 3.12 or higher\n- pip package manager (for development and testing)\n\n## Installation\n\n1. Clone or download the project:\n   ```bash\n   git clone <repository-url>\n   cd fibonacci-calculator\n   ```\n\n2. (Optional) Create a virtual environment:\n   ```bash\n   python3 -m venv venv\n   source venv/bin/activate  # On Windows: venv\\Scripts\\activate\n   ```\n\n3. Install development dependencies (for testing):\n   ```bash\n   pip install -r requirements.txt\n   ```\n\n## Usage\n\n### Basic Usage\n\n```python\nfrom fibonacci import fibonacci\n\n# Calculate the 10th Fibonacci number\nresult = fibonacci(10)\nprint(result)  # Output: 55\n\n# Calculate the 0th Fibonacci number\nresult = fibonacci(0)\nprint(result)  # Output: 0\n\n# Calculate the 1st Fibonacci number\nresult = fibonacci(1)\nprint(result)  # Output: 1\n\n# Calculate the 5th Fibonacci number\nresult = fibonacci(5)\nprint(result)  # Output: 5\n```\n\n### Error Handling\n\n```python\nfrom fibonacci import fibonacci\n\n# Attempting to calculate Fibonacci for negative number raises ValueError\ntry:\n    result = fibonacci(-5)\nexcept ValueError as e:\n    print(f\"Error: {e}\")  # Output: Error: n must be a non-negative integer\n```\n\n### In a Script\n\n```python\n#!/usr/bin/env python3\n\"\"\"Example script demonstrating Fibonacci calculator usage.\"\"\"\n\nfrom fibonacci import fibonacci\n\ndef main():\n    \"\"\"Calculate and display Fibonacci numbers for various inputs.\"\"\"\n    test_values = [0, 1, 5, 10, 20, 50]\n    \n    print(\"Fibonacci Sequence Calculator\")\n    print(\"-\" * 40)\n    \n    for n in test_values:\n        result = fibonacci(n)\n        print(f\"fibonacci({n:2d}) = {result}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n## API Documentation\n\n### fibonacci(n: int) -> int\n\nCalculate the nth Fibonacci number.\n\n**Parameters:**\n- `n` (int): A non-negative integer representing the position in the Fibonacci sequence\n\n**Returns:**\n- (int): The nth Fibonacci number\n\n**Raises:**\n- `ValueError`: If n is a negative integer\n\n**Time Complexity:** O(n)\n\n**Space Complexity:** O(1)\n\n**Examples:**\n\n```python\n>>> fibonacci(0)\n0\n\n>>> fibonacci(1)\n1\n\n>>> fibonacci(5)\n5\n\n>>> fibonacci(10)\n55\n\n>>> fibonacci(15)\n610\n\n>>> fibonacci(-1)\nTraceback (most recent call last):\n  ...\nValueError: n must be a non-negative integer\n```\n\n## Fibonacci Sequence Reference\n\nThe Fibonacci sequence is defined as:\n- F(0) = 0\n- F(1) = 1\n- F(n) = F(n-1) + F(n-2) for n  2\n\nThe first 15 Fibonacci numbers are:\n| n  | F(n) |\n|----|------|\n| 0  | 0    |\n| 1  | 1    |\n| 2  | 1    |\n| 3  | 2    |\n| 4  | 3    |\n| 5  | 5    |\n| 6  | 8    |\n| 7  | 13   |\n| 8  | 21   |\n| 9  | 34   |\n| 10 | 55   |\n| 11 | 89   |\n| 12 | 144  |\n| 13 | 233  |\n| 14 | 377  |\n\n## Architecture\n\n### Component Design\n\nThe implementation is organized into three components following the Single Responsibility Principle:\n\n#### 1. FibonacciValidator (SU-001)\nResponsible for validating input parameters before computation.\n\n**Responsibilities:**\n- Verify input is of type `int`\n- Ensure input is non-negative (n  0)\n- Raise `ValueError` with descriptive message for invalid inputs\n\n**Key Method:**\n- `validate_input(n: int) -> bool`: Returns True if valid, raises ValueError if invalid\n\n#### 2. FibonacciCalculator (SU-002)\nResponsible for computing the Fibonacci number using an iterative algorithm.\n\n**Responsibilities:**\n- Handle base cases (n=0 returns 0, n=1 returns 1)\n- Implement iterative algorithm for n  2\n- Maintain O(n) time complexity and O(1) space complexity\n\n**Key Methods:**\n- `calculate(n: int) -> int`: Computes and returns the nth Fibonacci number\n- `handle_base_cases(n: int) -> int | None`: Returns Fibonacci value for base cases or None for n  2\n\n#### 3. FibonacciFunction (SU-003)\nServes as the public interface orchestrating validation and calculation.\n\n**Responsibilities:**\n- Provide the public `fibonacci(n: int) -> int` function\n- Integrate FibonacciValidator and FibonacciCalculator\n- Provide comprehensive documentation with examples\n\n## Testing\n\n### Running Tests\n\nRun the complete test suite:\n\n```bash\npytest tests/ -v\n```\n\nRun tests with coverage report:\n\n```bash\npytest tests/ --cov=fibonacci --cov-report=html\n```\n\nView the HTML coverage report:\n\n```bash\nopen htmlcov/index.html  # On macOS\n# or\nxdg-open htmlcov/index.html  # On Linux\n# or\nstart htmlcov/index.html  # On Windows\n```\n\n### Test Coverage\n\nThe test suite includes:\n\n- **Unit Tests**: Individual component testing\n  - Input validation tests (valid inputs, negative inputs, type validation)\n  - Calculation tests (base cases, iterative computation)\n  - Edge case tests (boundary values, large inputs)\n\n- **Integration Tests**: End-to-end function testing\n  - Happy path scenarios\n  - Error handling scenarios\n  - Output verification\n\n- **Edge Case Tests**: Boundary and special condition testing\n  - n=0 (first Fibonacci number)\n  - n=1 (second Fibonacci number)\n  - Large values of n\n  - Negative values\n\n**Target Coverage:** 80%+ of source code\n\n### Example Test Cases\n\n```python\ndef test_fibonacci_base_case_zero():\n    \"\"\"Test that fibonacci(0) returns 0.\"\"\"\n    assert fibonacci(0) == 0\n\ndef test_fibonacci_base_case_one():\n    \"\"\"Test that fibonacci(1) returns 1.\"\"\"\n    assert fibonacci(1) == 1\n\ndef test_fibonacci_fifth_number():\n    \"\"\"Test that fibonacci(5) returns 5.\"\"\"\n    assert fibonacci(5) == 5\n\ndef test_fibonacci_tenth_number():\n    \"\"\"Test that fibonacci(10) returns 55.\"\"\"\n    assert fibonacci(10) == 55\n\ndef test_fibonacci_negative_input_raises_error():\n    \"\"\"Test that fibonacci(-1) raises ValueError.\"\"\"\n    with pytest.raises(ValueError, match=\"non-negative\"):\n        fibonacci(-1)\n```\n\n## Project Structure\n\n```",
      "file_type": "documentation",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Project documentation including overview, setup instructions, usage examples, API documentation, and testing guide"
    },
    {
      "file_path": "DESIGN.md",
      "content": "# Fibonacci Implementation - Architecture and Design Documentation\n\n## Overview\n\nThis document describes the architecture, design decisions, and implementation approach for the Fibonacci number calculation system (Task ID: TSP-FIB-001). The implementation follows a three-component architecture with clear separation of concerns, comprehensive input validation, and optimized iterative computation.\n\n## Architecture Overview\n\nThe Fibonacci implementation is organized into three distinct components, each with a single, well-defined responsibility:\n\n```\n\n                  FibonacciFunction (SU-003)                 \n              Public Interface & Orchestration               \n  - Comprehensive documentation and type hints               \n  - Coordinates validation and calculation                   \n  - Provides user-facing API                                 \n\n                                           \n              \n         FibonacciValidator       FibonacciCalculator\n             (SU-001)                  (SU-002)      \n                                                     \n         Input Validation          Iterative Compute \n         - Type checking           - O(n) time       \n         - Range checking          - O(1) space      \n         - Error handling          - Edge cases      \n              \n```\n\n### Component Responsibilities\n\n#### 1. FibonacciValidator (SU-001)\n**Responsibility:** Validates input parameters and enforces type constraints for the Fibonacci function.\n\n- **Method:** `validate_input(n: int) -> bool`\n- **Behavior:**\n  - Verifies that input `n` is of type `int` (not `float`, `str`, or other types)\n  - Checks that `n` is non-negative (n >= 0)\n  - Raises `ValueError` with descriptive message if validation fails\n  - Returns `True` if validation succeeds\n- **Error Handling:** Raises `ValueError` with message \"n must be a non-negative integer\" for invalid inputs\n- **Complexity:** O(1) - constant time validation\n\n#### 2. FibonacciCalculator (SU-002)\n**Responsibility:** Computes the nth Fibonacci number using an optimized iterative approach with edge case handling.\n\n- **Method:** `calculate(n: int) -> int`\n  - Implements iterative algorithm for computing Fibonacci numbers\n  - Handles base cases (n=0, n=1) efficiently\n  - Uses loop-based computation for n >= 2\n  - Returns the nth Fibonacci number as an integer\n  \n- **Method:** `handle_base_cases(n: int) -> int | None`\n  - Returns 0 for n=0 (base case)\n  - Returns 1 for n=1 (base case)\n  - Returns None for n >= 2 (requires iteration)\n\n- **Algorithm Details:**\n  - Initialize: `a = 0, b = 1`\n  - Loop n times: `a, b = b, a + b`\n  - Return final value of `a`\n  - Time Complexity: O(n) - linear iterations\n  - Space Complexity: O(1) - only constant variables\n  \n- **Complexity:** O(n) time, O(1) space\n\n#### 3. FibonacciFunction (SU-003)\n**Responsibility:** Main public interface providing comprehensive documentation, type hints, and orchestration of validation and calculation components.\n\n- **Method:** `fibonacci(n: int) -> int`\n  - Public API for calculating Fibonacci numbers\n  - Orchestrates FibonacciValidator and FibonacciCalculator\n  - Provides comprehensive docstring with examples\n  - Enforces type hints for static analysis\n  - Returns the nth Fibonacci number\n\n- **Orchestration Flow:**\n  1. Call `FibonacciValidator.validate_input(n)` to validate input\n  2. If validation passes, call `FibonacciCalculator.calculate(n)`\n  3. Return computed result\n  4. If validation fails, ValueError is raised and propagated\n\n## Design Decisions\n\n### 1. Iterative vs. Recursive Approach\n**Decision:** Use iterative algorithm instead of recursive.\n\n**Rationale:**\n- **Performance:** Iterative approach has O(n) time complexity with no function call overhead\n- **Memory Safety:** Avoids stack overflow for large values of n\n- **Simplicity:** Easier to understand and maintain\n- **Scalability:** Can handle arbitrarily large values of n (Python 3 supports arbitrary precision integers)\n\n**Trade-off:** Recursive approach would be more elegant but less efficient for large inputs.\n\n### 2. Component Separation\n**Decision:** Separate validation, calculation, and orchestration into distinct components.\n\n**Rationale:**\n- **Single Responsibility:** Each component has one reason to change\n- **Testability:** Components can be tested independently\n- **Reusability:** Validator and Calculator can be used in other contexts\n- **Maintainability:** Clear separation makes code easier to understand and modify\n\n### 3. Input Validation Strategy\n**Decision:** Strict type checking and range validation in FibonacciValidator.\n\n**Rationale:**\n- **Type Safety:** Reject non-integer types (float, string, etc.) explicitly\n- **Early Error Detection:** Fail fast with clear error messages\n- **Predictability:** Users know exactly what inputs are acceptable\n- **Security:** Prevents unexpected type coercion or implicit conversions\n\n### 4. Edge Case Handling\n**Decision:** Explicit handling of base cases (n=0, n=1) in FibonacciCalculator.\n\n**Rationale:**\n- **Correctness:** Ensures fibonacci(0)=0 and fibonacci(1)=1 are always correct\n- **Efficiency:** Base cases return immediately without iteration\n- **Clarity:** Makes algorithm logic explicit and easy to verify\n\n## Implementation Approach\n\n### Type Hints\nAll functions include explicit type hints for parameters and return values:\n```python\ndef fibonacci(n: int) -> int:\n    \"\"\"Calculate the nth Fibonacci number.\"\"\"\n    pass\n```\n\n### Documentation\nComprehensive docstrings follow PEP 257 conventions:\n- Description of what the function does\n- Parameter documentation with types and constraints\n- Return value documentation\n- Raises documentation for exceptions\n- Multiple usage examples demonstrating different inputs\n\n### Error Handling\n- Input validation raises `ValueError` with descriptive messages\n- Error messages clearly indicate what went wrong and why\n- Errors are raised early before computation begins\n\n### Algorithm Correctness\nThe iterative algorithm is verified against known Fibonacci values:\n- fibonacci(0) = 0\n- fibonacci(1) = 1\n- fibonacci(2) = 1\n- fibonacci(3) = 2\n- fibonacci(4) = 3\n- fibonacci(5) = 5\n- fibonacci(10) = 55\n- fibonacci(20) = 6765\n\n## Technology Stack\n\n- **Language:** Python 3.12\n- **Standard Library Only:** Yes (no external dependencies)\n- **Type Hints:** PEP 484 compliant\n- **Documentation:** PEP 257 docstring conventions\n- **Code Style:** PEP 8 compliance\n\n## Key Assumptions\n\n1. **Input Type:** Input `n` is always an integer type (not float or string)\n2. **Non-negative Definition:** Non-negative integers are defined as n >= 0\n3. **Fibonacci Sequence:** Sequence starts with F(0)=0, F(1)=1\n4. **Large Number Support:** Python 3 arbitrary precision integers handle large n values\n5. **Performance Priority:** Iterative approach preferred over recursive\n6. **Single-threaded Context:** No concurrency or thread-safety concerns\n7. **Type Hints:** Used for documentation and static analysis (not enforced at runtime by default)\n\n## Design Review Checklist\n\n### Critical Items\n-  Function signature: `def fibonacci(n: int) -> int:`\n-  Type hints on all parameters and return values\n-  ValueError raised for negative inputs with descriptive message\n-  Negative inputs not processed by calculator\n\n### High Priority Items\n-",
      "file_type": "documentation",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Architecture and design documentation explaining component responsibilities, design decisions, and implementation approach"
    },
    {
      "file_path": ".pylintrc",
      "content": "[MASTER]\nenable=all\n\n[MESSAGES CONTROL]\ndisable=\n    missing-module-docstring,\n    too-few-public-methods,\n    duplicate-code,\n\n[FORMAT]\nmax-line-length=100\nindent-string='    '\nindent-after-paren=4\n\n[BASIC]\ngood-names=i,j,k,ex,Run,_,n,a,b\nbad-names=foo,bar,baz,toto,tutu,tata\n\n[DESIGN]\nmax-args=5\nmax-attributes=7\nmax-bool-expr=5\nmax-branches=12\nmax-locals=15\nmax-parents=7\nmax-public-methods=20\nmax-returns=6\nmax-statements=50\nmin-public-methods=2\n\n[SIMILARITIES]\nmin-similarity-lines=5\nignore-comments=yes\nignore-docstrings=yes\nignore-imports=yes\n\n[VARIABLES]\ninit-import=no\ndummy-variables-rgx=_+$|(_[a-zA-Z0-9_]*[a-zA-Z0-9]+?$)|dummy|^ignored_|^unused_\nadditional-builtins=\n\n[CLASSES]\ndefining-attr-methods=__init__,__new__,setUp,__post_init__\n\n[IMPORTS]\nknown-standard-library=\nknown-first-party=\nknown-third-party=\n\n[LOGGING]\nlogging-format-style=new\nlogging-modules=logging\n\n[SPELLING]\nspelling-dict=en_US\nspelling-ignore-words=\nspelling-private-word-hint=no\nspelling-store-unknown-words=no\n\n[MISCELLANEOUS]\nnotes=FIXME,XXX,TODO\nnotes-rgx=(?:fx|todo)[-_]?\\w+\n\n[TYPECHECK]\ncontextmanager-decorators=contextlib.contextmanager\nignore-mixin-members=yes\nignore-none=yes\nignore-on-opaque-types=yes\nmixin-class-rgx=.*[Mm]ixin\nsignature-mutators=\n\n[REFACTORING]\nmax-nested-blocks=5\nnever-returning-functions=sys.exit,argparse.parse_error\n\n[STRING]\ncheck-str-concat-over-line=no\ncheck-quote-consistency=no\n\n[REPORTS]\nevaluation=max(0, 0 if fatal else 10.0 - ((float(5 * error + warning + refactor + convention) / statement) * 10))\nscore=yes\nreports=no",
      "file_type": "config",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Pylint configuration enforcing PEP 8 compliance and code quality standards"
    },
    {
      "file_path": "pytest.ini",
      "content": "[pytest]\n# Test discovery patterns\npython_files = test_*.py *_test.py\npython_classes = Test*\npython_functions = test_*\n\n# Minimum Python version\nminversion = 7.0\n\n# Test paths\ntestpaths = tests\n\n# Output options\naddopts = \n    -v\n    --strict-markers\n    --tb=short\n    --disable-warnings\n    -ra\n\n# Coverage options\n[coverage:run]\nsource = .\nomit = \n    */tests/*\n    */test_*.py\n    */__pycache__/*\n    */venv/*\n    */env/*\n\n[coverage:report]\nexclude_lines =\n    pragma: no cover\n    def __repr__\n    raise AssertionError\n    raise NotImplementedError\n    if __name__ == .__main__.:\n    if TYPE_CHECKING:\n    @abstractmethod\n    @abc.abstractmethod\nprecision = 2\nskip_covered = False\n\n[coverage:html]\ndirectory = htmlcov\n\n# Markers for test categorization\nmarkers =\n    unit: Unit tests for individual components\n    integration: Integration tests for multiple components\n    edge_case: Tests for boundary conditions and edge cases\n    error_case: Tests for error handling and exceptions\n    slow: Tests that take significant time to execute",
      "file_type": "config",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Pytest configuration specifying test discovery patterns, output format, and coverage settings"
    },
    {
      "file_path": ".gitignore",
      "content": "# Python bytecode and cache files\n__pycache__/\n*.py[cod]\n*$py.class\n*.so\n\n# C extensions\n*.c\n*.o\n\n# Distribution / packaging\n.Python\nbuild/\ndevelop-eggs/\ndist/\ndownloads/\neggs/\n.eggs/\nlib/\nlib64/\nparts/\nsdist/\nvar/\nwheels/\npip-wheel-metadata/\nshare/python-wheels/\n*.egg-info/\n.installed.cfg\n*.egg\nMANIFEST\n\n# PyInstaller\n*.manifest\n*.spec\n\n# Installer logs\npip-log.txt\npip-delete-this-directory.txt\n\n# Unit test / coverage reports\nhtmlcov/\n.tox/\n.nox/\n.coverage\n.coverage.*\n.cache\nnosetests.xml\ncoverage.xml\n*.cover\n*.py,cover\n.hypothesis/\n.pytest_cache/\n\n# Translations\n*.mo\n*.pot\n\n# Django stuff:\n*.log\nlocal_settings.py\ndb.sqlite3\ndb.sqlite3-journal\n\n# Flask stuff:\ninstance/\n.webassets-cache\n\n# Scrapy stuff:\n.scrapy\n\n# Sphinx documentation\ndocs/_build/\n\n# PyBuilder\ntarget/\n\n# Jupyter Notebook\n.ipynb_checkpoints\n\n# IPython\nprofile_default/\nipython_config.py\n\n# pyenv\n.python-version\n\n# pipenv\nPipfile.lock\n\n# PEP 582\n__pypackages__/\n\n# Celery stuff\ncelerybeat-schedule\ncelerybeat.pid\n\n# SageMath parsed files\n*.sage.py\n\n# Environments\n.env\n.venv\nenv/\nvenv/\nENV/\nenv.bak/\nvenv.bak/\n\n# Spyder project settings\n.spyderproject\n.spyproject\n\n# Rope project settings\n.ropeproject\n\n# mkdocs documentation\n/site\n\n# mypy\n.mypy_cache/\n.dmypy.json\ndmypy.json\n\n# Pyre type checker\n.pyre/\n\n# IDE and editor settings\n.vscode/\n.idea/\n*.swp\n*.swo\n*~\n.DS_Store\n*.sublime-project\n*.sublime-workspace\n\n# OS specific files\nThumbs.db\n.DS_Store\n.AppleDouble\n.LSOverride\n\n# Project specific\n*.tmp\n*.bak\n.local/",
      "file_type": "config",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Git ignore patterns for Python projects excluding __pycache__, .pytest_cache, .env, and other generated files"
    }
  ],
  "file_structure": {
    "src": [
      "fibonacci_validator.py",
      "fibonacci_calculator.py",
      "fibonacci.py"
    ],
    "tests": [
      "test_fibonacci_validator.py",
      "test_fibonacci_calculator.py",
      "test_fibonacci.py",
      "test_fibonacci_integration.py"
    ],
    ".": [
      "main.py",
      "requirements.txt",
      ".env.example",
      "README.md",
      "DESIGN.md",
      ".pylintrc",
      "pytest.ini",
      ".gitignore"
    ]
  },
  "implementation_notes": "Generated using multi-stage approach with 15 files. Manifest estimated 1063 LOC, actual 1681 LOC. Uses 2 external dependencies.",
  "dependencies": [
    "pytest==7.4.3",
    "pylint==3.0.3"
  ],
  "setup_instructions": "1. Install Python 3.12+\\n2. pip install -r requirements.txt\\n3. Run tests: pytest tests/ -v\\n4. Run main: python main.py\\n5. Check code quality: pylint src/",
  "total_lines_of_code": 1681,
  "total_files": 15,
  "test_coverage_target": 80.0,
  "semantic_units_implemented": [
    "SU-002",
    "SU-003",
    "SU-001"
  ],
  "components_implemented": [
    "FibonacciFunction",
    "FibonacciCalculator",
    "FibonacciValidator"
  ],
  "agent_version": "1.0.0",
  "generation_timestamp": "2025-11-22T03:31:24.744234"
}