{
  "task_id": "TSP-FIB-001",
  "project_id": "TSP-FIB-001",
  "files": [
    {
      "file_path": "src/fibonacci.py",
      "content": "\"\"\"\nFibonacci module providing iterative computation of Fibonacci numbers.\n\nThis module implements the Fibonacci sequence calculation with input validation\nand comprehensive documentation. It provides a public fibonacci() function that\norchestrates validation and calculation.\n\nComponent IDs: FibonacciValidator, FibonacciCalculator, FibonacciFunction\nSemantic Units: SU-001, SU-002, SU-003\nTask ID: TSP-FIB-001\n\nAuthor: ASP Code Agent\n\"\"\"\n\n\nclass FibonacciValidator:\n    \"\"\"\n    Validates input parameters for Fibonacci computation.\n\n    This class handles input validation and enforces type constraints for the\n    Fibonacci function. It ensures that only non-negative integers are accepted.\n\n    Component ID: FibonacciValidator\n    Semantic Unit ID: SU-001\n    \"\"\"\n\n    @staticmethod\n    def validate_input(n: int) -> bool:\n        \"\"\"\n        Validate that input n is a non-negative integer.\n\n        This method checks if the input is an integer type (excluding booleans)\n        and is non-negative. It raises ValueError if validation fails.\n\n        Args:\n            n: The input value to validate.\n\n        Returns:\n            bool: True if validation passes.\n\n        Raises:\n            ValueError: If n is not an integer or is negative, with message\n                'n must be a non-negative integer'.\n\n        Examples:\n            >>> FibonacciValidator.validate_input(0)\n            True\n            >>> FibonacciValidator.validate_input(5)\n            True\n            >>> FibonacciValidator.validate_input(-1)\n            Traceback (most recent call last):\n                ...\n            ValueError: n must be a non-negative integer\n            >>> FibonacciValidator.validate_input(3.5)\n            Traceback (most recent call last):\n                ...\n            ValueError: n must be a non-negative integer\n            >>> FibonacciValidator.validate_input(True)\n            Traceback (most recent call last):\n                ...\n            ValueError: n must be a non-negative integer\n        \"\"\"\n        # Exclude booleans explicitly since bool is a subclass of int in Python\n        if isinstance(n, bool) or not isinstance(n, int):\n            raise ValueError(\"n must be a non-negative integer\")\n\n        if n < 0:\n            raise ValueError(\"n must be a non-negative integer\")\n\n        return True\n\n\nclass FibonacciCalculator:\n    \"\"\"\n    Computes Fibonacci numbers using an iterative approach.\n\n    This class implements the iterative Fibonacci algorithm with O(n) time\n    complexity and O(1) space complexity. It handles edge cases for n=0 and n=1,\n    and uses integer arithmetic for all computations.\n\n    Component ID: FibonacciCalculator\n    Semantic Unit ID: SU-002\n    \"\"\"\n\n    @staticmethod\n    def calculate(n: int) -> int:\n        \"\"\"\n        Calculate the nth Fibonacci number using iterative algorithm.\n\n        This method computes the nth Fibonacci number where the sequence is\n        defined as: F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) for n>=2.\n\n        The iterative approach maintains two variables (prev and curr) that\n        represent consecutive Fibonacci numbers, updating them in each iteration\n        until the nth number is computed.\n\n        Args:\n            n: The position in the Fibonacci sequence (must be non-negative).\n\n        Returns:\n            int: The nth Fibonacci number.\n\n        Time Complexity:\n            O(n) - Single pass through n iterations.\n\n        Space Complexity:\n            O(1) - Only two variables used regardless of input size.\n\n        Examples:\n            >>> FibonacciCalculator.calculate(0)\n            0\n            >>> FibonacciCalculator.calculate(1)\n            1\n            >>> FibonacciCalculator.calculate(2)\n            1\n            >>> FibonacciCalculator.calculate(5)\n            5\n            >>> FibonacciCalculator.calculate(10)\n            55\n        \"\"\"\n        # Handle base cases\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n\n        # Iterative computation for n >= 2\n        prev = 0\n        curr = 1\n\n        for _ in range(2, n + 1):\n            next_val = prev + curr\n            prev = curr\n            curr = next_val\n\n        return curr\n\n\ndef fibonacci(n: int) -> int:\n    \"\"\"\n    Calculate the nth Fibonacci number using iterative approach.\n\n    This function computes the nth number in the Fibonacci sequence, which is\n    a series of integers where each number is the sum of the two preceding ones.\n    The sequence starts with 0 and 1: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, ...\n\n    The function validates the input to ensure it is a non-negative integer,\n    then uses an iterative algorithm to compute the result efficiently with\n    O(n) time complexity and O(1) space complexity.\n\n    Args:\n        n: The position in the Fibonacci sequence. Must be a non-negative integer\n            (n >= 0). Represents which Fibonacci number to compute, where F(0)=0,\n            F(1)=1, F(2)=1, F(3)=2, etc.\n\n    Returns:\n        int: The nth Fibonacci number. For n=0 returns 0, for n=1 returns 1,\n            and for n>=2 returns the sum of the two preceding Fibonacci numbers.\n\n    Raises:\n        ValueError: If n is negative or not an integer type. The error message\n            will be 'n must be a non-negative integer'. Note that boolean values\n            (True, False) are rejected even though bool is a subclass of int.\n\n    Examples:\n        >>> fibonacci(0)\n        0\n        >>> fibonacci(1)\n        1\n        >>> fibonacci(2)\n        1\n        >>> fibonacci(5)\n        5\n        >>> fibonacci(10)\n        55\n\n    Component ID: FibonacciFunction\n    Semantic Unit ID: SU-003\n    Task ID: TSP-FIB-001\n    \"\"\"\n    # Validate input using FibonacciValidator\n    FibonacciValidator.validate_input(n)\n\n    # Calculate Fibonacci number using FibonacciCalculator\n    result = FibonacciCalculator.calculate(n)\n\n    return result",
      "file_type": "source",
      "semantic_unit_id": "SU-001,SU-002,SU-003",
      "component_id": "FibonacciValidator,FibonacciCalculator,FibonacciFunction",
      "description": "Main Fibonacci module containing FibonacciValidator for input validation, FibonacciCalculator for iterative computation, and public fibonacci() function that orchestrates validation and calculation with comprehensive Google-style docstring."
    },
    {
      "file_path": "tests/test_fibonacci.py",
      "content": "import pytest\nfrom src.fibonacci import fibonacci\n\n\nclass TestFibonacciCorrectness:\n    \"\"\"Test suite for Fibonacci sequence correctness.\n    \n    Validates that the fibonacci function returns correct values for the\n    Fibonacci sequence. Tests cover base cases, standard cases, and larger values.\n    \n    Component ID: FibonacciCalculator\n    Semantic Unit: SU-002\n    \"\"\"\n\n    def test_fibonacci_n_zero_returns_zero(self) -> None:\n        \"\"\"Test that fibonacci(0) returns 0 (base case).\"\"\"\n        result = fibonacci(0)\n        assert result == 0\n        assert isinstance(result, int)\n\n    def test_fibonacci_n_one_returns_one(self) -> None:\n        \"\"\"Test that fibonacci(1) returns 1 (base case).\"\"\"\n        result = fibonacci(1)\n        assert result == 1\n        assert isinstance(result, int)\n\n    def test_fibonacci_n_two_returns_one(self) -> None:\n        \"\"\"Test that fibonacci(2) returns 1.\"\"\"\n        result = fibonacci(2)\n        assert result == 1\n        assert isinstance(result, int)\n\n    def test_fibonacci_n_three_returns_two(self) -> None:\n        \"\"\"Test that fibonacci(3) returns 2.\"\"\"\n        result = fibonacci(3)\n        assert result == 2\n        assert isinstance(result, int)\n\n    def test_fibonacci_n_four_returns_three(self) -> None:\n        \"\"\"Test that fibonacci(4) returns 3.\"\"\"\n        result = fibonacci(4)\n        assert result == 3\n        assert isinstance(result, int)\n\n    def test_fibonacci_n_five_returns_five(self) -> None:\n        \"\"\"Test that fibonacci(5) returns 5.\"\"\"\n        result = fibonacci(5)\n        assert result == 5\n        assert isinstance(result, int)\n\n    def test_fibonacci_n_six_returns_eight(self) -> None:\n        \"\"\"Test that fibonacci(6) returns 8.\"\"\"\n        result = fibonacci(6)\n        assert result == 8\n        assert isinstance(result, int)\n\n    def test_fibonacci_n_ten_returns_fifty_five(self) -> None:\n        \"\"\"Test that fibonacci(10) returns 55.\"\"\"\n        result = fibonacci(10)\n        assert result == 55\n        assert isinstance(result, int)\n\n    def test_fibonacci_n_fifteen_returns_six_hundred_ten(self) -> None:\n        \"\"\"Test that fibonacci(15) returns 610.\"\"\"\n        result = fibonacci(15)\n        assert result == 610\n        assert isinstance(result, int)\n\n    def test_fibonacci_sequence_correctness(self) -> None:\n        \"\"\"Test that fibonacci produces correct sequence for multiple values.\"\"\"\n        expected_sequence = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]\n        for n, expected_value in enumerate(expected_sequence):\n            result = fibonacci(n)\n            assert result == expected_value, (\n                f\"fibonacci({n}) returned {result}, expected {expected_value}\"\n            )\n\n    def test_fibonacci_n_twenty_returns_correct_value(self) -> None:\n        \"\"\"Test that fibonacci(20) returns 6765.\"\"\"\n        result = fibonacci(20)\n        assert result == 6765\n\n    def test_fibonacci_n_twenty_five_returns_correct_value(self) -> None:\n        \"\"\"Test that fibonacci(25) returns 75025.\"\"\"\n        result = fibonacci(25)\n        assert result == 75025\n\n    def test_fibonacci_large_value_n_fifty(self) -> None:\n        \"\"\"Test that fibonacci(50) computes correctly for large values.\"\"\"\n        result = fibonacci(50)\n        assert result == 12586269025\n        assert isinstance(result, int)\n\n    def test_fibonacci_large_value_n_one_hundred(self) -> None:\n        \"\"\"Test that fibonacci(100) handles very large values without overflow.\"\"\"\n        result = fibonacci(100)\n        expected = 354224848179261915075\n        assert result == expected\n        assert isinstance(result, int)\n\n    def test_fibonacci_return_type_is_always_int(self) -> None:\n        \"\"\"Test that fibonacci always returns int type, never float or other.\"\"\"\n        for n in [0, 1, 5, 10, 20]:\n            result = fibonacci(n)\n            assert isinstance(result, int)\n            assert not isinstance(result, bool)\n            assert not isinstance(result, float)\n\n\nclass TestFibonacciErrorHandling:\n    \"\"\"Test suite for error handling and input validation.\n    \n    Validates that the fibonacci function properly rejects invalid inputs\n    and raises appropriate exceptions with descriptive messages.\n    \n    Component ID: FibonacciValidator\n    Semantic Unit: SU-001\n    \"\"\"\n\n    def test_fibonacci_negative_one_raises_value_error(self) -> None:\n        \"\"\"Test that fibonacci(-1) raises ValueError.\"\"\"\n        with pytest.raises(ValueError) as exc_info:\n            fibonacci(-1)\n        assert \"non-negative\" in str(exc_info.value).lower()\n\n    def test_fibonacci_negative_ten_raises_value_error(self) -> None:\n        \"\"\"Test that fibonacci(-10) raises ValueError.\"\"\"\n        with pytest.raises(ValueError) as exc_info:\n            fibonacci(-10)\n        assert \"non-negative\" in str(exc_info.value).lower()\n\n    def test_fibonacci_negative_one_hundred_raises_value_error(self) -> None:\n        \"\"\"Test that fibonacci(-100) raises ValueError.\"\"\"\n        with pytest.raises(ValueError) as exc_info:\n            fibonacci(-100)\n        assert \"non-negative\" in str(exc_info.value).lower()\n\n    def test_fibonacci_error_message_contains_non_negative(self) -> None:\n        \"\"\"Test that error message explicitly mentions 'non-negative'.\"\"\"\n        with pytest.raises(ValueError) as exc_info:\n            fibonacci(-5)\n        error_message = str(exc_info.value)\n        assert \"non-negative\" in error_message.lower()\n\n    def test_fibonacci_error_message_contains_integer(self) -> None:\n        \"\"\"Test that error message mentions 'integer' requirement.\"\"\"\n        with pytest.raises(ValueError) as exc_info:\n            fibonacci(-1)\n        error_message = str(exc_info.value)\n        assert \"integer\" in error_message.lower()\n\n    def test_fibonacci_float_input_raises_value_error(self) -> None:\n        \"\"\"Test that fibonacci with float input raises ValueError.\"\"\"\n        with pytest.raises(ValueError):\n            fibonacci(5.5)  # type: ignore\n\n    def test_fibonacci_string_input_raises_type_error_or_value_error(self) -> None:\n        \"\"\"Test that fibonacci with string input raises appropriate error.\"\"\"\n        with pytest.raises((ValueError, TypeError)):\n            fibonacci(\"5\")  # type: ignore\n\n    def test_fibonacci_none_input_raises_type_error_or_value_error(self) -> None:\n        \"\"\"Test that fibonacci with None input raises appropriate error.\"\"\"\n        with pytest.raises((ValueError, TypeError)):\n            fibonacci(None)  # type: ignore\n\n    def test_fibonacci_list_input_raises_type_error_or_value_error(self) -> None:\n        \"\"\"Test that fibonacci with list input raises appropriate error.\"\"\"\n        with pytest.raises((ValueError, TypeError)):\n            fibonacci([5])  # type: ignore\n\n    def test_fibonacci_boolean_true_raises_value_error(self) -> None:\n        \"\"\"Test that fibonacci(True) raises ValueError (bool excluded from int).\"\"\"\n        with pytest.raises(ValueError):\n            fibonacci(True)  # type: ignore\n\n    def test_fibonacci_boolean_false_raises_value_error(self) -> None:\n        \"\"\"Test that fibonacci(False) raises ValueError (bool excluded from int).\"\"\"\n        with pytest.raises(ValueError):\n            fibonacci(False)  # type: ignore\n\n    def test_fibonacci_no_exception_for_valid_non_negative_integers(self) -> None:\n        \"\"\"Test that no exceptions are raised for valid non-negative integers.\"\"\"\n        valid_inputs = [0, 1, 2, 5, 10, 20, 50, 100]\n        for n in valid_inputs:",
      "file_type": "test",
      "semantic_unit_id": "SU-001,SU-002,SU-003",
      "component_id": "FibonacciValidator,FibonacciCalculator,FibonacciFunction",
      "description": "Comprehensive unit tests covering correctness of Fibonacci sequence values, error handling for negative inputs, type safety validation, edge cases (n=0, n=1, large values), and validation of docstring examples."
    },
    {
      "file_path": "tests/test_validator.py",
      "content": "\"\"\"\nUnit tests for FibonacciValidator.validate_input() method\n\nTests the FibonacciValidator component to verify input validation for the Fibonacci function.\nCovers valid non-negative integers, negative integers, boolean rejection, and error messages.\n\nComponent ID: FibonacciValidator\nSemantic Unit ID: SU-001\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport pytest\n\nfrom src.fibonacci import FibonacciValidator\n\n\nclass TestFibonacciValidatorValidateInput:\n    \"\"\"Test suite for FibonacciValidator.validate_input() method.\"\"\"\n\n    def test_validate_input_zero_returns_true(self) -> None:\n        \"\"\"Test that validate_input returns True for n=0.\"\"\"\n        validator = FibonacciValidator()\n        result = validator.validate_input(0)\n        assert result is True\n\n    def test_validate_input_one_returns_true(self) -> None:\n        \"\"\"Test that validate_input returns True for n=1.\"\"\"\n        validator = FibonacciValidator()\n        result = validator.validate_input(1)\n        assert result is True\n\n    def test_validate_input_positive_integer_returns_true(self) -> None:\n        \"\"\"Test that validate_input returns True for positive integers.\"\"\"\n        validator = FibonacciValidator()\n        test_values = [2, 5, 10, 100, 1000]\n        for n in test_values:\n            result = validator.validate_input(n)\n            assert result is True, f\"validate_input({n}) should return True\"\n\n    def test_validate_input_large_positive_integer_returns_true(self) -> None:\n        \"\"\"Test that validate_input returns True for large positive integers.\"\"\"\n        validator = FibonacciValidator()\n        result = validator.validate_input(1000000)\n        assert result is True\n\n    def test_validate_input_negative_one_raises_value_error(self) -> None:\n        \"\"\"Test that validate_input raises ValueError for n=-1.\"\"\"\n        validator = FibonacciValidator()\n        with pytest.raises(ValueError):\n            validator.validate_input(-1)\n\n    def test_validate_input_negative_integer_raises_value_error(self) -> None:\n        \"\"\"Test that validate_input raises ValueError for negative integers.\"\"\"\n        validator = FibonacciValidator()\n        test_values = [-1, -5, -10, -100, -1000]\n        for n in test_values:\n            with pytest.raises(ValueError):\n                validator.validate_input(n)\n\n    def test_validate_input_negative_integer_error_message(self) -> None:\n        \"\"\"Test that ValueError message contains 'non-negative' for negative input.\"\"\"\n        validator = FibonacciValidator()\n        with pytest.raises(ValueError) as exc_info:\n            validator.validate_input(-5)\n        error_message = str(exc_info.value)\n        assert \"non-negative\" in error_message.lower()\n\n    def test_validate_input_negative_integer_error_message_exact(self) -> None:\n        \"\"\"Test that ValueError message matches expected format for negative input.\"\"\"\n        validator = FibonacciValidator()\n        with pytest.raises(ValueError) as exc_info:\n            validator.validate_input(-1)\n        error_message = str(exc_info.value)\n        assert error_message == \"n must be a non-negative integer\"\n\n    def test_validate_input_boolean_true_raises_value_error(self) -> None:\n        \"\"\"Test that validate_input raises ValueError for boolean True.\"\"\"\n        validator = FibonacciValidator()\n        with pytest.raises(ValueError):\n            validator.validate_input(True)\n\n    def test_validate_input_boolean_false_raises_value_error(self) -> None:\n        \"\"\"Test that validate_input raises ValueError for boolean False.\"\"\"\n        validator = FibonacciValidator()\n        with pytest.raises(ValueError):\n            validator.validate_input(False)\n\n    def test_validate_input_boolean_error_message(self) -> None:\n        \"\"\"Test that ValueError message is appropriate for boolean input.\"\"\"\n        validator = FibonacciValidator()\n        with pytest.raises(ValueError) as exc_info:\n            validator.validate_input(True)\n        error_message = str(exc_info.value)\n        assert \"non-negative\" in error_message.lower() or \"integer\" in error_message.lower()\n\n    def test_validate_input_float_raises_value_error(self) -> None:\n        \"\"\"Test that validate_input raises ValueError for float input.\"\"\"\n        validator = FibonacciValidator()\n        with pytest.raises(ValueError):\n            validator.validate_input(5.5)\n\n    def test_validate_input_string_raises_value_error(self) -> None:\n        \"\"\"Test that validate_input raises ValueError for string input.\"\"\"\n        validator = FibonacciValidator()\n        with pytest.raises(ValueError):\n            validator.validate_input(\"5\")\n\n    def test_validate_input_none_raises_value_error(self) -> None:\n        \"\"\"Test that validate_input raises ValueError for None input.\"\"\"\n        validator = FibonacciValidator()\n        with pytest.raises(ValueError):\n            validator.validate_input(None)\n\n    def test_validate_input_list_raises_value_error(self) -> None:\n        \"\"\"Test that validate_input raises ValueError for list input.\"\"\"\n        validator = FibonacciValidator()\n        with pytest.raises(ValueError):\n            validator.validate_input([1, 2, 3])\n\n    def test_validate_input_dict_raises_value_error(self) -> None:\n        \"\"\"Test that validate_input raises ValueError for dict input.\"\"\"\n        validator = FibonacciValidator()\n        with pytest.raises(ValueError):\n            validator.validate_input({\"n\": 5})\n\n    def test_validate_input_multiple_calls_zero(self) -> None:\n        \"\"\"Test that validate_input can be called multiple times with n=0.\"\"\"\n        validator = FibonacciValidator()\n        for _ in range(5):\n            result = validator.validate_input(0)\n            assert result is True\n\n    def test_validate_input_multiple_calls_positive(self) -> None:\n        \"\"\"Test that validate_input can be called multiple times with positive integers.\"\"\"\n        validator = FibonacciValidator()\n        for n in [1, 2, 3, 4, 5]:\n            result = validator.validate_input(n)\n            assert result is True\n\n    def test_validate_input_multiple_calls_negative(self) -> None:\n        \"\"\"Test that validate_input consistently raises ValueError for negative integers.\"\"\"\n        validator = FibonacciValidator()\n        for n in [-1, -2, -3, -4, -5]:\n            with pytest.raises(ValueError):\n                validator.validate_input(n)\n\n    def test_validate_input_boundary_zero_and_one(self) -> None:\n        \"\"\"Test that validate_input correctly handles boundary values 0 and 1.\"\"\"\n        validator = FibonacciValidator()\n        assert validator.validate_input(0) is True\n        assert validator.validate_input(1) is True\n\n    def test_validate_input_boundary_negative_and_zero(self) -> None:\n        \"\"\"Test that validate_input correctly handles boundary between negative and zero.\"\"\"\n        validator = FibonacciValidator()\n        with pytest.raises(ValueError):\n            validator.validate_input(-1)\n        assert validator.validate_input(0) is True\n\n    def test_validate_input_return_type_is_bool(self) -> None:\n        \"\"\"Test that validate_input returns a boolean type.\"\"\"\n        validator = FibonacciValidator()\n        result = validator.validate_input(5)\n        assert isinstance(result, bool)\n        assert result is True\n\n    def test_validate_input_return_type_true_not_truthy(self) -> None:\n        \"\"\"Test that validate_input returns True (not just truthy value).\"\"\"\n        validator = FibonacciValidator()\n        result = validator.validate_input(10)\n        assert result is True\n        assert result == True\n\n    def test_validate_input_exception_type_is_value_error(self) -> None:\n        \"\"\"Test that validate_input raises ValueError (not other exception types).\"\"\"",
      "file_type": "test",
      "semantic_unit_id": "SU-001",
      "component_id": "FibonacciValidator",
      "description": "Unit tests specifically for FibonacciValidator.validate_input() method, testing valid non-negative integers, negative integers, boolean rejection, and error message validation."
    },
    {
      "file_path": "tests/test_calculator.py",
      "content": "\"\"\"\nUnit tests for FibonacciCalculator.calculate() method\n\nTests the Fibonacci sequence computation for edge cases and various input values,\nverifying correct calculation of the nth Fibonacci number using the iterative approach.\n\nComponent ID: FibonacciCalculator\nSemantic Unit ID: SU-002\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport pytest\nfrom src.fibonacci import fibonacci, FibonacciCalculator, FibonacciValidator\n\n\nclass TestFibonacciValidator:\n    \"\"\"Test suite for FibonacciValidator.validate_input() method.\"\"\"\n\n    def test_validate_input_zero_is_valid(self) -> None:\n        \"\"\"Test that validate_input accepts zero as valid input.\"\"\"\n        validator = FibonacciValidator()\n        assert validator.validate_input(0) is True\n\n    def test_validate_input_one_is_valid(self) -> None:\n        \"\"\"Test that validate_input accepts one as valid input.\"\"\"\n        validator = FibonacciValidator()\n        assert validator.validate_input(1) is True\n\n    def test_validate_input_positive_integer_is_valid(self) -> None:\n        \"\"\"Test that validate_input accepts positive integers as valid input.\"\"\"\n        validator = FibonacciValidator()\n        assert validator.validate_input(5) is True\n        assert validator.validate_input(100) is True\n        assert validator.validate_input(1000) is True\n\n    def test_validate_input_negative_integer_raises_error(self) -> None:\n        \"\"\"Test that validate_input raises ValueError for negative integers.\"\"\"\n        validator = FibonacciValidator()\n        with pytest.raises(ValueError, match=\"non-negative\"):\n            validator.validate_input(-1)\n\n    def test_validate_input_large_negative_integer_raises_error(self) -> None:\n        \"\"\"Test that validate_input raises ValueError for large negative integers.\"\"\"\n        validator = FibonacciValidator()\n        with pytest.raises(ValueError, match=\"non-negative\"):\n            validator.validate_input(-100)\n\n    def test_validate_input_error_message_content(self) -> None:\n        \"\"\"Test that ValueError message contains 'non-negative' for invalid input.\"\"\"\n        validator = FibonacciValidator()\n        with pytest.raises(ValueError) as exc_info:\n            validator.validate_input(-5)\n        assert \"non-negative\" in str(exc_info.value).lower()\n\n    def test_validate_input_boolean_true_raises_error(self) -> None:\n        \"\"\"Test that validate_input rejects boolean True (even though bool is subclass of int).\"\"\"\n        validator = FibonacciValidator()\n        with pytest.raises(ValueError):\n            validator.validate_input(True)\n\n    def test_validate_input_boolean_false_raises_error(self) -> None:\n        \"\"\"Test that validate_input rejects boolean False (even though bool is subclass of int).\"\"\"\n        validator = FibonacciValidator()\n        with pytest.raises(ValueError):\n            validator.validate_input(False)\n\n\nclass TestFibonacciCalculator:\n    \"\"\"Test suite for FibonacciCalculator.calculate() method.\"\"\"\n\n    def test_calculate_zero_returns_zero(self) -> None:\n        \"\"\"Test that calculate(0) returns 0 (first Fibonacci number).\"\"\"\n        calculator = FibonacciCalculator()\n        assert calculator.calculate(0) == 0\n\n    def test_calculate_one_returns_one(self) -> None:\n        \"\"\"Test that calculate(1) returns 1 (second Fibonacci number).\"\"\"\n        calculator = FibonacciCalculator()\n        assert calculator.calculate(1) == 1\n\n    def test_calculate_two_returns_one(self) -> None:\n        \"\"\"Test that calculate(2) returns 1 (third Fibonacci number).\"\"\"\n        calculator = FibonacciCalculator()\n        assert calculator.calculate(2) == 1\n\n    def test_calculate_three_returns_two(self) -> None:\n        \"\"\"Test that calculate(3) returns 2 (fourth Fibonacci number).\"\"\"\n        calculator = FibonacciCalculator()\n        assert calculator.calculate(3) == 2\n\n    def test_calculate_four_returns_three(self) -> None:\n        \"\"\"Test that calculate(4) returns 3 (fifth Fibonacci number).\"\"\"\n        calculator = FibonacciCalculator()\n        assert calculator.calculate(4) == 3\n\n    def test_calculate_five_returns_five(self) -> None:\n        \"\"\"Test that calculate(5) returns 5 (sixth Fibonacci number).\"\"\"\n        calculator = FibonacciCalculator()\n        assert calculator.calculate(5) == 5\n\n    def test_calculate_six_returns_eight(self) -> None:\n        \"\"\"Test that calculate(6) returns 8 (seventh Fibonacci number).\"\"\"\n        calculator = FibonacciCalculator()\n        assert calculator.calculate(6) == 8\n\n    def test_calculate_ten_returns_fifty_five(self) -> None:\n        \"\"\"Test that calculate(10) returns 55 (eleventh Fibonacci number).\"\"\"\n        calculator = FibonacciCalculator()\n        assert calculator.calculate(10) == 55\n\n    def test_calculate_fifteen_returns_six_hundred_ten(self) -> None:\n        \"\"\"Test that calculate(15) returns 610 (sixteenth Fibonacci number).\"\"\"\n        calculator = FibonacciCalculator()\n        assert calculator.calculate(15) == 610\n\n    def test_calculate_twenty_returns_correct_value(self) -> None:\n        \"\"\"Test that calculate(20) returns 6765 (twenty-first Fibonacci number).\"\"\"\n        calculator = FibonacciCalculator()\n        assert calculator.calculate(20) == 6765\n\n    def test_calculate_large_input_hundred(self) -> None:\n        \"\"\"Test that calculate(100) returns correct large Fibonacci number.\"\"\"\n        calculator = FibonacciCalculator()\n        result = calculator.calculate(100)\n        assert result == 354224848179261915075\n\n    def test_calculate_returns_integer_type(self) -> None:\n        \"\"\"Test that calculate() returns an integer type.\"\"\"\n        calculator = FibonacciCalculator()\n        result = calculator.calculate(5)\n        assert isinstance(result, int)\n\n    def test_calculate_sequence_correctness(self) -> None:\n        \"\"\"Test that calculate() produces correct Fibonacci sequence for multiple values.\"\"\"\n        calculator = FibonacciCalculator()\n        expected_sequence = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n        for n, expected in enumerate(expected_sequence):\n            assert calculator.calculate(n) == expected\n\n    def test_calculate_consecutive_values_relationship(self) -> None:\n        \"\"\"Test that consecutive Fibonacci numbers follow the recurrence relation.\"\"\"\n        calculator = FibonacciCalculator()\n        for n in range(2, 20):\n            fib_n_minus_2 = calculator.calculate(n - 2)\n            fib_n_minus_1 = calculator.calculate(n - 1)\n            fib_n = calculator.calculate(n)\n            assert fib_n == fib_n_minus_2 + fib_n_minus_1\n\n    def test_calculate_monotonic_increasing(self) -> None:\n        \"\"\"Test that Fibonacci sequence is monotonically increasing for n >= 0.\"\"\"\n        calculator = FibonacciCalculator()\n        previous = calculator.calculate(0)\n        for n in range(1, 30):\n            current = calculator.calculate(n)\n            assert current >= previous\n            previous = current\n\n\nclass TestFibonacciFunction:\n    \"\"\"Test suite for fibonacci() public API function.\"\"\"\n\n    def test_fibonacci_zero_returns_zero(self) -> None:\n        \"\"\"Test that fibonacci(0) returns 0.\"\"\"\n        assert fibonacci(0) == 0\n\n    def test_fibonacci_one_returns_one(self) -> None:\n        \"\"\"Test that fibonacci(1) returns 1.\"\"\"\n        assert fibonacci(1) == 1\n\n    def test_fibonacci_two_returns_one(self) -> None:\n        \"\"\"Test that fibonacci(2) returns 1.\"\"\"\n        assert fibonacci(2) == 1",
      "file_type": "test",
      "semantic_unit_id": "SU-002",
      "component_id": "FibonacciCalculator",
      "description": "Unit tests for FibonacciCalculator.calculate() method, verifying correct Fibonacci sequence computation for edge cases and various input values."
    },
    {
      "file_path": "requirements.txt",
      "content": "# Testing framework\npytest==7.4.3\n\n# Code quality and linting\npylint==3.0.3\nblack==23.12.1\nflake8==6.1.0\n\n# Type checking\nmypy==1.7.1",
      "file_type": "requirements",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Python dependencies file specifying pytest for testing and any development tools; no external runtime dependencies required as implementation uses only Python standard library."
    },
    {
      "file_path": "README.md",
      "content": "# Fibonacci Implementation\n\nA pure Python implementation of the Fibonacci sequence calculator using an efficient iterative algorithm.\n\n## Overview\n\nThis project provides a robust implementation of the Fibonacci sequence calculator that computes the nth Fibonacci number. The implementation uses an iterative approach with O(n) time complexity and O(1) space complexity, making it efficient for computing Fibonacci numbers without the overhead of recursion or memoization.\n\nThe Fibonacci sequence is defined as:\n- F(0) = 0\n- F(1) = 1\n- F(n) = F(n-1) + F(n-2) for n ≥ 2\n\nThis results in the sequence: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ...\n\n## Features\n\n- **Efficient Iterative Algorithm**: O(n) time complexity with O(1) space complexity\n- **Comprehensive Input Validation**: Rejects negative integers and non-integer types\n- **Type Safety**: Full type hints for all parameters and return values\n- **Detailed Documentation**: Google-style docstrings with usage examples\n- **Edge Case Handling**: Correctly handles base cases (n=0, n=1) and large values\n- **Pure Python**: No external dependencies, uses only Python standard library\n\n## Prerequisites\n\n- Python 3.12 or higher\n- pip package manager (for development and testing)\n\n## Installation\n\n1. Clone or download the project:\n   ```bash\n   git clone <repository-url>\n   cd fibonacci\n   ```\n\n2. (Optional) Create a virtual environment:\n   ```bash\n   python3 -m venv venv\n   source venv/bin/activate  # On Windows: venv\\Scripts\\activate\n   ```\n\n3. Install development dependencies (for testing):\n   ```bash\n   pip install -r requirements.txt\n   ```\n\n## Usage\n\n### Basic Usage\n\n```python\nfrom fibonacci import fibonacci\n\n# Calculate the 10th Fibonacci number\nresult = fibonacci(10)\nprint(result)  # Output: 55\n\n# Calculate other Fibonacci numbers\nprint(fibonacci(0))   # Output: 0\nprint(fibonacci(1))   # Output: 1\nprint(fibonacci(5))   # Output: 5\nprint(fibonacci(15))  # Output: 610\n```\n\n### In Your Code\n\nSimply import the `fibonacci` function and call it with a non-negative integer:\n\n```python\nfrom fibonacci import fibonacci\n\ndef process_sequence():\n    \"\"\"Process Fibonacci numbers up to the 20th term.\"\"\"\n    for n in range(21):\n        fib_n = fibonacci(n)\n        print(f\"F({n}) = {fib_n}\")\n```\n\n### Error Handling\n\nThe function validates input and raises `ValueError` for invalid inputs:\n\n```python\nfrom fibonacci import fibonacci\n\ntry:\n    result = fibonacci(-5)\nexcept ValueError as e:\n    print(f\"Error: {e}\")  # Output: Error: n must be a non-negative integer\n\ntry:\n    result = fibonacci(3.5)\nexcept ValueError as e:\n    print(f\"Error: {e}\")  # Output: Error: n must be a non-negative integer\n\ntry:\n    result = fibonacci(True)  # Boolean is rejected even though it's technically an int\nexcept ValueError as e:\n    print(f\"Error: {e}\")  # Output: Error: n must be a non-negative integer\n```\n\n## API Reference\n\n### `fibonacci(n: int) -> int`\n\nCalculate the nth Fibonacci number using an iterative approach.\n\n**Parameters:**\n- `n` (int): The position in the Fibonacci sequence (must be non-negative)\n\n**Returns:**\n- (int): The nth Fibonacci number\n\n**Raises:**\n- `ValueError`: If n is negative or not an integer type\n\n**Examples:**\n```python\nfibonacci(0)   # Returns 0\nfibonacci(1)   # Returns 1\nfibonacci(2)   # Returns 1\nfibonacci(5)   # Returns 5\nfibonacci(10)  # Returns 55\nfibonacci(15)  # Returns 610\nfibonacci(100) # Returns 354224848179261915075\n```\n\n## Running Tests\n\n### Run All Tests\n\n```bash\npytest tests/ -v\n```\n\n### Run Tests with Coverage Report\n\n```bash\npytest tests/ --cov=. --cov-report=html\n```\n\nThis generates an HTML coverage report in the `htmlcov/` directory.\n\n### Run Specific Test File\n\n```bash\npytest tests/test_fibonacci.py -v\n```\n\n### Run Tests with Detailed Output\n\n```bash\npytest tests/ -vv --tb=short\n```\n\n## Design Rationale\n\n### Why Iterative Over Recursive?\n\nThe implementation uses an iterative approach rather than recursion for several important reasons:\n\n1. **Performance**: The iterative approach has O(n) time complexity with O(1) space complexity. A naive recursive implementation would have O(2^n) time complexity due to redundant calculations.\n\n2. **Stack Safety**: Iterative approach avoids stack overflow errors that can occur with deep recursion. Python has a default recursion limit (~1000), which would prevent computing Fibonacci numbers beyond approximately F(1000).\n\n3. **Memory Efficiency**: The iterative approach uses constant space regardless of n, while recursive approaches (even with memoization) require O(n) space for the call stack or memoization cache.\n\n4. **Simplicity**: The iterative algorithm is straightforward and easy to understand, with clear variable names and minimal complexity.\n\n### Algorithm Explanation\n\nThe iterative algorithm works as follows:\n\n1. **Base Cases**: Handle n=0 and n=1 directly as they are the foundation of the sequence.\n\n2. **Iteration**: For n ≥ 2, maintain two variables:\n   - `prev`: The (i-1)th Fibonacci number\n   - `curr`: The ith Fibonacci number\n\n3. **Loop**: Iterate from 2 to n, computing the next Fibonacci number as the sum of the previous two, then shifting the window forward.\n\n4. **Return**: After the loop completes, `curr` contains F(n).\n\n**Time Complexity**: O(n) - single pass through n iterations\n**Space Complexity**: O(1) - only two variables regardless of input size\n\n### Input Validation Strategy\n\nThe implementation validates inputs to ensure:\n\n1. **Type Checking**: Input must be an integer type (not float, string, etc.)\n2. **Boolean Exclusion**: Booleans are explicitly rejected even though `isinstance(True, int)` returns True in Python\n3. **Non-Negative Constraint**: Input must be >= 0 (negative integers are rejected)\n4. **Clear Error Messages**: ValueError includes descriptive message for debugging\n\n## Examples\n\n### Computing Fibonacci Sequence\n\n```python\nfrom fibonacci import fibonacci\n\n# Print first 20 Fibonacci numbers\nfor i in range(20):\n    print(f\"F({i:2d}) = {fibonacci(i):6d}\")\n```\n\nOutput:\n```\nF( 0) =      0\nF( 1) =      1\nF( 2) =      1\nF( 3) =      2\nF( 4) =      3\nF( 5) =      5\nF( 6) =      8\nF( 7) =     13\nF( 8) =     21\nF( 9) =     34\nF(10) =     55\nF(11) =     89\nF(12) =    144\nF(13) =    233\nF(14) =    377\nF(15) =    610\nF(16) =    987\nF(17) =   1597\nF(18) =   2584\nF(19) =   4181\n```\n\n### Finding Fibonacci Numbers in a Range\n\n```python\nfrom fibonacci import fibonacci\n\ndef fibonacci_in_range(start: int, end: int) -> list[int]:\n    \"\"\"Find all Fibonacci numbers between start and end (inclusive).\"\"\"\n    result = []\n    n = 0\n    while True:\n        fib_n = fibonacci(n)\n        if fib_n > end:\n            break\n        if fib_n >= start:\n            result.append(fib_n)\n        n += 1\n    return result\n\n# Find Fibonacci numbers between 10 and 1000\nfibs = fibonacci_in_range(10, 1000)\nprint(fibs)  # Output: [13, 21, 34, 55, 89, 144, 233, 377, 610,",
      "file_type": "documentation",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Project documentation including overview of Fibonacci implementation, setup instructions, usage examples, running tests, and design rationale for iterative O(n) algorithm."
    },
    {
      "file_path": ".pylintrc",
      "content": "[MASTER]\ndisable=\n    missing-module-docstring,\n    missing-class-docstring,\n    missing-function-docstring,\n\n[MESSAGES CONTROL]\ndisable=\n    C0111,\n    C0103,\n    W0212,\n\n[FORMAT]\nmax-line-length=100\nindent-string='    '\nindent-after-paren=4\n\n[BASIC]\ngood-names=i,j,k,ex,Run,_,n,x,y,f,df\n\n[DESIGN]\nmax-args=5\nmax-attributes=7\nmax-bool-expr=5\nmax-branches=12\nmax-locals=15\nmax-parents=7\nmax-public-methods=20\nmax-returns=6\nmax-statements=50\nmin-public-methods=1\n\n[SIMILARITIES]\nignore-comments=yes\nignore-docstrings=yes\nignore-imports=yes\nmin-similarity-lines=4\n\n[VARIABLES]\ninit-import=no\ndummy-variables-rgx=_+$|(_[a-zA-Z0-9_]*[a-zA-Z0-9]+?$)|dummy|^ignored_|^unused_\nadditional-builtins=\n\n[CLASSES]\ndefining-attr-methods=__init__,__new__,setUp,__post_init__\nvalid-classmethod-first-arg=cls\nvalid-metaclass-first-arg=cls\n\n[IMPORTS]\nallow-wildcard-with-all=no\nanalyse-fallback-blocks=no\ndeprecated-modules=optparse,tkinter.tix\n\n[LOGGING]\nlogging-format-style=new\nlogging-modules=logging\n\n[MISCELLANEOUS]\nnotes=FIXME,XXX,TODO\n\n[SPELLING]\nmax-spelling-suggestions=4\nspelling-store-unknown-words=no\n\n[TYPECHECK]\ncontextmanager-decorators=contextlib.contextmanager\ngenerated-members=\nignore-mixin-members=yes\nignore-none-returning-init-method=yes\nignored-classes=optparse.Values,thread._local,_thread._local\nsignature-mutators=\n\n[REPORTS]\nevaluation=10.0 - ((float(5 * error + warning + refactor + convention) / statement) * 10)\noutput-format=text\nreports=no\nscore=yes\n\n[REFACTORING]\nmax-nested-blocks=5\nnever-returning-functions=sys.exit,argparse.parse_error\n\n[STRING]\ncheck-quote-consistency=no\ncheck-str-concat-over-line-join=no\n\n[TOOL:PYLINT]\nload-plugins=",
      "file_type": "config",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Pylint configuration file enforcing PEP 8 compliance and code quality standards for the project."
    },
    {
      "file_path": "pytest.ini",
      "content": "[tool:pytest]\n# Test discovery patterns\npython_files = test_*.py *_test.py\npython_classes = Test*\npython_functions = test_*\n\n# Test output and reporting\naddopts = \n    -v\n    --strict-markers\n    --tb=short\n    --disable-warnings\n    -ra\n\n# Coverage options\n# Uncomment to enable coverage reporting\n# addopts = --cov=. --cov-report=html --cov-report=term-missing\n\n# Test paths\ntestpaths = tests\n\n# Markers for organizing tests\nmarkers =\n    unit: Unit tests for individual components\n    integration: Integration tests for multiple components\n    edge_case: Tests for edge cases and boundary conditions\n    error_case: Tests for error handling and exception cases\n    slow: Tests that take significant time to execute\n\n# Minimum Python version\nminversion = 7.0\n\n# Timeout for tests (in seconds)\ntimeout = 300\n\n# Console output options\nconsole_output_style = progress\n\n# Logging\nlog_cli = false\nlog_cli_level = INFO\nlog_level = DEBUG",
      "file_type": "config",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Pytest configuration file specifying test discovery patterns, output format, and test execution settings."
    },
    {
      "file_path": "DESIGN.md",
      "content": "# Fibonacci Function Design Documentation\n\n## Overview\n\nThis document provides detailed design documentation for the Fibonacci function implementation (Task ID: TSP-FIB-001). The design follows a three-component architecture with clear separation of concerns, comprehensive validation, and optimized algorithmic complexity.\n\n## Architecture Overview\n\nThe Fibonacci implementation uses a modular three-component architecture:\n\n1. **FibonacciValidator (SU-001)**: Handles input validation and type constraints\n2. **FibonacciCalculator (SU-002)**: Implements the iterative Fibonacci algorithm\n3. **FibonacciFunction (SU-003)**: Public API that orchestrates validation and calculation\n\nThis architecture ensures:\n- **Separation of Concerns**: Each component has a single, well-defined responsibility\n- **Testability**: Components can be tested independently\n- **Maintainability**: Clear boundaries make the code easy to understand and modify\n- **Reusability**: Components can be used independently if needed\n\n## Technology Stack\n\n- **Language**: Python 3.12\n- **Type Hints**: Python typing module (built-in)\n- **Docstring Format**: Google-style docstring\n- **Dependencies**: None (pure Python standard library only)\n\n## Component Design\n\n### Component 1: FibonacciValidator (SU-001)\n\n**Responsibility**: Validates input parameters and enforces type constraints for the Fibonacci function.\n\n**Semantic Unit ID**: SU-001\n\n**Component ID**: FibonacciValidator\n\n**Complexity**: O(1) - constant time validation\n\n#### Interface\n\n```python\ndef validate_input(n: int) -> bool\n```\n\n**Parameters**:\n- `n` (int): The input value to validate\n\n**Returns**:\n- `bool`: True if validation passes\n\n**Raises**:\n- `ValueError`: If n is not a non-negative integer\n\n#### Implementation Details\n\nThe validator performs the following checks:\n\n1. **Type Check**: Verify that `n` is an integer type using `isinstance(n, int)`\n2. **Boolean Exclusion**: Exclude boolean values using `not isinstance(n, bool)` (since bool is a subclass of int in Python)\n3. **Non-Negative Check**: Verify that `n >= 0`\n\nIf any check fails, the validator raises a `ValueError` with the message: `\"n must be a non-negative integer\"`\n\n#### Validation Logic\n\n```\nInput: n\n├─ Is n an integer type? (isinstance(n, int) and not isinstance(n, bool))\n│  └─ No → Raise ValueError\n├─ Is n >= 0?\n│  └─ No → Raise ValueError\n└─ Yes → Return True\n```\n\n#### Design Decisions\n\n- **Boolean Exclusion**: Although `bool` is a subclass of `int` in Python, we explicitly exclude it because `True` and `False` are not meaningful Fibonacci indices\n- **Early Validation**: Validation occurs before any computation, preventing invalid states\n- **Clear Error Messages**: The error message explicitly states the constraint (\"non-negative integer\")\n\n### Component 2: FibonacciCalculator (SU-002)\n\n**Responsibility**: Computes the nth Fibonacci number using an iterative approach with edge case handling.\n\n**Semantic Unit ID**: SU-002\n\n**Component ID**: FibonacciCalculator\n\n**Complexity**: O(n) time, O(1) space\n\n#### Interface\n\n```python\ndef calculate(n: int) -> int\n```\n\n**Parameters**:\n- `n` (int): A non-negative integer (assumed to be pre-validated)\n\n**Returns**:\n- `int`: The nth Fibonacci number\n\n#### Algorithm\n\nThe iterative Fibonacci algorithm handles three logical branches:\n\n**Branch 1: Base Case n = 0**\n```\nReturn 0\n```\n\n**Branch 2: Base Case n = 1**\n```\nReturn 1\n```\n\n**Branch 3: Recursive Case n >= 2**\n```\nInitialize: prev = 0, curr = 1\nLoop from i = 2 to n (inclusive):\n    next = prev + curr\n    prev = curr\n    curr = next\nReturn curr\n```\n\n#### Complexity Analysis\n\n**Time Complexity**: O(n)\n- The algorithm performs exactly n-1 iterations for input n >= 2\n- Each iteration performs constant-time operations (addition, assignment)\n- Total operations: O(n)\n\n**Space Complexity**: O(1)\n- Only three variables are used: `prev`, `curr`, `next`\n- No data structures that grow with input size\n- Constant memory regardless of n\n\n#### Example Execution\n\nFor `n = 5`:\n\n```\nInitial: prev = 0, curr = 1\n\nIteration 1 (i=2): next = 0+1 = 1, prev = 1, curr = 1\nIteration 2 (i=3): next = 1+1 = 2, prev = 1, curr = 2\nIteration 3 (i=4): next = 1+2 = 3, prev = 2, curr = 3\nIteration 4 (i=5): next = 2+3 = 5, prev = 3, curr = 5\n\nReturn: 5\n```\n\n#### Design Decisions\n\n- **Iterative Approach**: Chosen over recursive to avoid stack overflow for large n and to achieve O(1) space complexity\n- **Integer Arithmetic Only**: Uses only integer operations, no floating-point arithmetic\n- **Edge Case Handling**: Explicitly handles n=0 and n=1 cases for clarity and efficiency\n- **No Memoization**: Single function calls don't benefit from caching; memoization would add complexity without benefit\n\n### Component 3: FibonacciFunction (SU-003)\n\n**Responsibility**: Public API function that orchestrates validation and calculation with comprehensive documentation.\n\n**Semantic Unit ID**: SU-003\n\n**Component ID**: FibonacciFunction\n\n**Complexity**: O(n) - dominated by calculation component\n\n#### Interface\n\n```python\ndef fibonacci(n: int) -> int\n```\n\n**Parameters**:\n- `n` (int): The index of the Fibonacci number to calculate (must be non-negative)\n\n**Returns**:\n- `int`: The nth Fibonacci number\n\n**Raises**:\n- `ValueError`: If n is negative or not an integer\n\n#### Orchestration Flow\n\n```\nInput: n\n├─ Call FibonacciValidator.validate_input(n)\n│  └─ Raises ValueError if invalid\n├─ Call FibonacciCalculator.calculate(n)\n│  └─ Returns the nth Fibonacci number\n└─ Return result\n```\n\n#### Documentation\n\nThe function includes comprehensive Google-style docstring with:\n\n1. **One-line Summary**: Brief description of functionality\n2. **Extended Description**: Explanation of the Fibonacci sequence and algorithm approach\n3. **Args Section**: Parameter documentation with type and constraints\n4. **Returns Section**: Return type and value description\n5. **Raises Section**: Exception documentation for ValueError\n6. **Examples Section**: At least 5 usage examples demonstrating various inputs\n\n#### Design Decisions\n\n- **Separation of Concerns**: Delegates validation to FibonacciValidator and calculation to FibonacciCalculator\n- **Comprehensive Documentation**: Extensive docstring ensures users understand constraints and usage\n- **Type Hints**: Full type hints for IDE support and static type checking\n- **Error Propagation**: Allows ValueError from validator to propagate to caller\n\n## Algorithm Complexity Analysis\n\n### Time Complexity: O(n)\n\nThe iterative algorithm performs exactly n-1 iterations for input n >= 2:\n\n```\nT(n) = {\n    O(1)  if n = 0 or n = 1\n    O(n)  if n >= 2\n}\n```\n\nOverall: **O(n)** - linear time complexity\n\n### Space Complexity: O(1)\n\nThe algorithm uses only three variables regardless of input size:\n\n```\nS(n) = O(1)\n```\n\nVariables: `prev`, `curr`, `next` - constant space\n\n### Comparison with Alternatives\n\n| Approach | Time | Space | Notes |\n|----------|------|-------|-------|\n| Recursive | O(2^n) | O(n) | Exponential time, stack overflow risk |\n| Recursive + Memoization | O(n) | O(n) | Linear time but uses O(n) space |\n| Iterative (Our Choice) | O(n) | O(1) | Optimal time and space |\n| Matrix",
      "file_type": "documentation",
      "semantic_unit_id": "SU-001,SU-002,SU-003",
      "component_id": "FibonacciValidator,FibonacciCalculator,FibonacciFunction",
      "description": "Detailed design documentation explaining the three-component architecture, algorithm complexity analysis (O(n) time, O(1) space), design decisions, and validation criteria from design review checklist."
    }
  ],
  "file_structure": {
    "src": [
      "fibonacci.py"
    ],
    "tests": [
      "test_fibonacci.py",
      "test_validator.py",
      "test_calculator.py"
    ],
    ".": [
      "requirements.txt",
      "README.md",
      ".pylintrc",
      "pytest.ini",
      "DESIGN.md"
    ]
  },
  "implementation_notes": "Generated using multi-stage approach with 9 files. Manifest estimated 920 LOC, actual 1044 LOC. Uses 1 external dependencies.",
  "dependencies": [
    "pytest==7.4.3"
  ],
  "setup_instructions": "1. Install Python 3.12 or later\\n2. pip install -r requirements.txt\\n3. Run tests: pytest tests/ -v\\n4. Run linter: pylint src/fibonacci.py\\n5. Import and use: from src.fibonacci import fibonacci; result = fibonacci(10)",
  "total_lines_of_code": 1044,
  "total_files": 9,
  "test_coverage_target": 80.0,
  "semantic_units_implemented": [
    "SU-002",
    "SU-001,SU-002,SU-003",
    "SU-001"
  ],
  "components_implemented": [
    "FibonacciValidator,FibonacciCalculator,FibonacciFunction",
    "FibonacciValidator",
    "FibonacciCalculator"
  ],
  "agent_version": "1.0.0",
  "generation_timestamp": "2025-11-22T03:12:49.948809"
}