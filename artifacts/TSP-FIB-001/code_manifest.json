{
  "task_id": "TSP-FIB-001",
  "project_id": "TSP-FIB-001",
  "files": [
    {
      "file_path": "src/fibonacci_validator.py",
      "content": "\"\"\"\nFibonacci Validator and Calculator Module\n\nInput validation component that enforces type checking and validates non-negative\ninteger constraints for Fibonacci function parameters. Implements iterative Fibonacci\ncalculation with proper handling of edge cases.\n\nComponent ID: FibonacciValidator\nSemantic Unit ID: SU-001, SU-002, SU-003\n\nAuthor: ASP Code Agent\n\"\"\"\n\n\nclass FibonacciValidator:\n    \"\"\"\n    Validates input parameters and enforces type hints for the Fibonacci function.\n\n    This class provides input validation to ensure that parameters meet the\n    requirements for Fibonacci calculation: must be an integer type and must be\n    non-negative.\n\n    Semantic Unit ID: SU-001\n    \"\"\"\n\n    @staticmethod\n    def validate_input(n: int) -> bool:\n        \"\"\"\n        Validate that input n is a non-negative integer.\n\n        Performs type checking to ensure n is an integer (not float, string, or\n        other numeric type) and range checking to ensure n is non-negative.\n\n        Args:\n            n: The input value to validate. Must be of type int.\n\n        Returns:\n            bool: True if validation passes.\n\n        Raises:\n            TypeError: If n is not an integer type.\n            ValueError: If n is a negative integer.\n\n        Examples:\n            >>> FibonacciValidator.validate_input(0)\n            True\n            >>> FibonacciValidator.validate_input(5)\n            True\n            >>> FibonacciValidator.validate_input(-1)\n            Traceback (most recent call last):\n                ...\n            ValueError: n must be a non-negative integer\n            >>> FibonacciValidator.validate_input(5.5)\n            Traceback (most recent call last):\n                ...\n            TypeError: n must be an integer, not float\n        \"\"\"\n        if not isinstance(n, int) or isinstance(n, bool):\n            raise TypeError(f\"n must be an integer, not {type(n).__name__}\")\n\n        if n < 0:\n            raise ValueError(\"n must be a non-negative integer\")\n\n        return True\n\n\nclass FibonacciCalculator:\n    \"\"\"\n    Implements iterative Fibonacci calculation with proper handling of edge cases.\n\n    This class provides the core Fibonacci computation using an iterative approach\n    to avoid stack overflow and ensure O(1) space complexity.\n\n    Semantic Unit ID: SU-002\n    \"\"\"\n\n    @staticmethod\n    def handle_base_cases(n: int) -> int:\n        \"\"\"\n        Return Fibonacci value for base cases n=0 and n=1.\n\n        Args:\n            n: The input value (must be 0 or 1).\n\n        Returns:\n            int: The Fibonacci value for the base case (0 or 1).\n\n        Examples:\n            >>> FibonacciCalculator.handle_base_cases(0)\n            0\n            >>> FibonacciCalculator.handle_base_cases(1)\n            1\n        \"\"\"\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n\n    @staticmethod\n    def calculate(n: int) -> int:\n        \"\"\"\n        Calculate the nth Fibonacci number using iterative approach.\n\n        Uses an iterative algorithm with two variables (prev, curr) to compute\n        the Fibonacci number at position n. This approach has O(n) time complexity\n        and O(1) space complexity, avoiding recursion and stack overflow issues.\n\n        Args:\n            n: The position in the Fibonacci sequence (must be non-negative).\n\n        Returns:\n            int: The nth Fibonacci number.\n\n        Examples:\n            >>> FibonacciCalculator.calculate(0)\n            0\n            >>> FibonacciCalculator.calculate(1)\n            1\n            >>> FibonacciCalculator.calculate(2)\n            1\n            >>> FibonacciCalculator.calculate(5)\n            5\n            >>> FibonacciCalculator.calculate(10)\n            55\n        \"\"\"\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n\n        prev: int = 0\n        curr: int = 1\n\n        for _ in range(2, n + 1):\n            temp: int = curr\n            curr = prev + curr\n            prev = temp\n\n        return curr\n\n\ndef fibonacci(n: int) -> int:\n    \"\"\"\n    Calculate and return the nth Fibonacci number.\n\n    The Fibonacci sequence is a series of numbers where each number is the sum\n    of the two preceding ones, typically starting with 0 and 1. This function\n    computes the nth number in this sequence using an efficient iterative approach.\n\n    The function validates input to ensure n is a non-negative integer, then\n    calculates the corresponding Fibonacci number. Base cases (n=0 and n=1) are\n    handled explicitly for clarity and efficiency.\n\n    Args:\n        n: The position in the Fibonacci sequence. Must be a non-negative integer.\n           Type must be int (not float or string representation).\n\n    Returns:\n        int: The nth Fibonacci number in the sequence.\n\n    Raises:\n        TypeError: If n is not an integer type (e.g., float, string, None).\n        ValueError: If n is a negative integer.\n\n    Examples:\n        >>> fibonacci(0)\n        0\n        >>> fibonacci(1)\n        1\n        >>> fibonacci(2)\n        1\n        >>> fibonacci(5)\n        5\n        >>> fibonacci(10)\n        55\n\n    Semantic Unit ID: SU-003\n    \"\"\"\n    FibonacciValidator.validate_input(n)\n    return FibonacciCalculator.calculate(n)",
      "file_type": "source",
      "semantic_unit_id": "SU-001",
      "component_id": "FibonacciValidator",
      "description": "Input validation component that enforces type checking and validates non-negative integer constraints for Fibonacci function parameters"
    },
    {
      "file_path": "src/fibonacci_calculator.py",
      "content": "\"\"\"\nFibonacci Calculator Module\n\nCore Fibonacci calculation engine implementing iterative algorithm with explicit base case\nhandling and O(n) time complexity. This module provides a pure Python implementation of the\nFibonacci sequence calculation without external dependencies.\n\nComponent ID: FibonacciCalculator\nSemantic Unit: SU-002, SU-001, SU-003\nTask ID: TSP-FIB-001\n\nAuthor: ASP Code Agent\n\"\"\"\n\n\nclass FibonacciValidator:\n    \"\"\"\n    Validates input parameters for Fibonacci calculation.\n\n    This class is responsible for validating that input parameters meet the requirements\n    for Fibonacci calculation, including type checking and range validation.\n\n    Semantic Unit: SU-001\n    \"\"\"\n\n    @staticmethod\n    def validate_input(n: int) -> bool:\n        \"\"\"\n        Validate that input n is a non-negative integer.\n\n        Performs type checking to ensure n is an integer (not float, string, or other type)\n        and range checking to ensure n is non-negative. Raises ValueError immediately on\n        invalid input to fail fast before any calculation occurs.\n\n        Args:\n            n: The input value to validate. Must be an integer type.\n\n        Returns:\n            bool: True if input is valid (non-negative integer).\n\n        Raises:\n            TypeError: If n is not an integer type (e.g., float, string, None).\n            ValueError: If n is a negative integer.\n\n        Examples:\n            >>> FibonacciValidator.validate_input(0)\n            True\n            >>> FibonacciValidator.validate_input(5)\n            True\n            >>> FibonacciValidator.validate_input(-1)\n            Traceback (most recent call last):\n                ...\n            ValueError: n must be a non-negative integer\n            >>> FibonacciValidator.validate_input(5.5)\n            Traceback (most recent call last):\n                ...\n            TypeError: n must be an integer, not float\n        \"\"\"\n        # Type check: ensure n is an integer, not float or other type\n        if not isinstance(n, int) or isinstance(n, bool):\n            raise TypeError(f\"n must be an integer, not {type(n).__name__}\")\n\n        # Range check: ensure n is non-negative\n        if n < 0:\n            raise ValueError(\"n must be a non-negative integer\")\n\n        return True\n\n\nclass FibonacciCalculator:\n    \"\"\"\n    Implements iterative Fibonacci calculation with proper edge case handling.\n\n    This class provides the core computational logic for calculating Fibonacci numbers\n    using an iterative approach with O(n) time complexity and O(1) space complexity.\n    The iterative approach avoids stack overflow issues that would occur with recursion\n    on large values of n.\n\n    Semantic Unit: SU-002\n    \"\"\"\n\n    @staticmethod\n    def handle_base_cases(n: int) -> int:\n        \"\"\"\n        Return Fibonacci value for base cases n=0 and n=1.\n\n        Handles the explicit base cases of the Fibonacci sequence where:\n        - F(0) = 0\n        - F(1) = 1\n\n        Args:\n            n: The input value. Must be 0 or 1 for this method to apply.\n\n        Returns:\n            int: The Fibonacci value for n (0 or 1).\n\n        Examples:\n            >>> FibonacciCalculator.handle_base_cases(0)\n            0\n            >>> FibonacciCalculator.handle_base_cases(1)\n            1\n        \"\"\"\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n\n    @staticmethod\n    def calculate(n: int) -> int:\n        \"\"\"\n        Calculate the nth Fibonacci number using iterative approach.\n\n        Implements an efficient iterative algorithm that computes the nth Fibonacci number\n        in O(n) time with O(1) space complexity. The algorithm uses two variables (prev, curr)\n        to track consecutive Fibonacci values and iteratively computes the sequence up to n.\n\n        For n >= 2, the algorithm:\n        1. Initializes prev=0 (F(0)) and curr=1 (F(1))\n        2. Iterates from 2 to n (inclusive)\n        3. In each iteration: temp=curr, curr=prev+curr, prev=temp\n        4. Returns curr after loop completes\n\n        Args:\n            n: The position in the Fibonacci sequence to calculate. Must be non-negative.\n\n        Returns:\n            int: The nth Fibonacci number.\n\n        Examples:\n            >>> FibonacciCalculator.calculate(0)\n            0\n            >>> FibonacciCalculator.calculate(1)\n            1\n            >>> FibonacciCalculator.calculate(2)\n            1\n            >>> FibonacciCalculator.calculate(5)\n            5\n            >>> FibonacciCalculator.calculate(10)\n            55\n        \"\"\"\n        # Handle base cases explicitly\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n\n        # Iterative approach for n >= 2\n        # Initialize with F(0)=0 and F(1)=1\n        prev = 0\n        curr = 1\n\n        # Iterate from 2 to n (inclusive)\n        for _ in range(2, n + 1):\n            # Compute next Fibonacci number: F(i) = F(i-1) + F(i-2)\n            temp = curr\n            curr = prev + curr\n            prev = temp\n\n        return curr\n\n\ndef fibonacci(n: int) -> int:\n    \"\"\"\n    Calculate and return the nth Fibonacci number.\n\n    Computes the nth number in the Fibonacci sequence, where each number is the sum of\n    the two preceding ones. The sequence starts with F(0)=0 and F(1)=1, and continues\n    as: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, ...\n\n    This function uses an iterative algorithm with O(n) time complexity and O(1) space\n    complexity, making it efficient for large values of n without risk of stack overflow.\n\n    Args:\n        n: The position in the Fibonacci sequence to calculate. Must be a non-negative\n           integer. Negative values will raise ValueError.\n\n    Returns:\n        int: The nth Fibonacci number. For n=0, returns 0. For n=1, returns 1.\n             For n>=2, returns the sum of the two preceding Fibonacci numbers.\n\n    Raises:\n        TypeError: If n is not an integer type (e.g., float, string, None, bool).\n        ValueError: If n is a negative integer.\n\n    Examples:\n        >>> fibonacci(0)\n        0\n        >>> fibonacci(1)\n        1\n        >>> fibonacci(2)\n        1\n        >>> fibonacci(5)\n        5\n        >>> fibonacci(10)\n        55\n\n    Semantic Unit: SU-003\n    \"\"\"\n    # Validate input: type check and range check\n    FibonacciValidator.validate_input(n)\n\n    # Calculate and return the Fibonacci number\n    return FibonacciCalculator.calculate(n)",
      "file_type": "source",
      "semantic_unit_id": "SU-002",
      "component_id": "FibonacciCalculator",
      "description": "Core Fibonacci calculation engine implementing iterative algorithm with explicit base case handling and O(n) time complexity"
    },
    {
      "file_path": "src/fibonacci.py",
      "content": "\"\"\"\nFibonacci calculation module with validation and computation orchestration.\n\nThis module provides a public API function for calculating Fibonacci numbers with\ncomprehensive input validation and error handling. The implementation uses an\niterative approach for optimal performance.\n\nComponent ID: FibonacciFunction\nSemantic Unit ID: SU-003\n\nAuthor: ASP Code Agent\n\"\"\"\n\nfrom src.fibonacci_validator import FibonacciValidator\nfrom src.fibonacci_calculator import FibonacciCalculator\n\n\ndef fibonacci(n: int) -> int:\n    \"\"\"\n    Calculate and return the nth Fibonacci number.\n\n    The Fibonacci sequence is a series of numbers where each number is the sum\n    of the two preceding ones, typically starting with 0 and 1. This function\n    computes the nth number in this sequence using an efficient iterative\n    approach with O(n) time complexity and O(1) space complexity.\n\n    Args:\n        n (int): The position in the Fibonacci sequence to calculate. Must be\n            a non-negative integer (0 or greater). The function will raise a\n            ValueError if a negative integer is provided.\n\n    Returns:\n        int: The nth Fibonacci number. For n=0, returns 0. For n=1, returns 1.\n            For n>=2, returns the sum of the two preceding Fibonacci numbers.\n\n    Raises:\n        ValueError: If n is negative. The error message will indicate that\n            n must be a non-negative integer.\n        TypeError: If n is not an integer type (e.g., float, string, or other\n            non-integer numeric types).\n\n    Examples:\n        >>> fibonacci(0)\n        0\n\n        >>> fibonacci(1)\n        1\n\n        >>> fibonacci(2)\n        1\n\n        >>> fibonacci(5)\n        5\n\n        >>> fibonacci(10)\n        55\n\n        >>> fibonacci(15)\n        610\n\n        Attempting to calculate with a negative number raises ValueError:\n\n        >>> fibonacci(-1)\n        Traceback (most recent call last):\n            ...\n        ValueError: n must be a non-negative integer\n\n        Attempting to calculate with a non-integer type raises ValueError:\n\n        >>> fibonacci(5.5)\n        Traceback (most recent call last):\n            ...\n        ValueError: n must be a non-negative integer\n\n    Note:\n        The function uses an iterative algorithm rather than recursion to\n        avoid stack overflow issues with large values of n. The implementation\n        maintains constant space complexity regardless of input size.\n    \"\"\"\n    # Validate input parameter\n    validator = FibonacciValidator()\n    validator.validate_input(n)\n\n    # Calculate Fibonacci number\n    calculator = FibonacciCalculator()\n    result = calculator.calculate(n)\n\n    return result\n</code>",
      "file_type": "source",
      "semantic_unit_id": "SU-003",
      "component_id": "FibonacciFunction",
      "description": "Public API function orchestrating validation and calculation with comprehensive Google-style docstring including examples and error documentation"
    },
    {
      "file_path": "tests/test_fibonacci_validator.py",
      "content": "\"\"\"\nUnit tests for Fibonacci validator and calculator.\n\nTests input validation including negative integers, non-integer types (float, string),\nand valid non-negative integers. Also tests the Fibonacci calculation for correctness\nand edge cases.\n\nSemantic Unit ID: SU-001\nComponent ID: FibonacciValidator\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport pytest\nfrom src.fibonacci_validator import fibonacci\n\n\nclass TestFibonacciValidatorNegativeIntegers:\n    \"\"\"Test suite for negative integer validation.\"\"\"\n\n    def test_fibonacci_negative_one_raises_value_error(self) -> None:\n        \"\"\"Test that fibonacci(-1) raises ValueError.\"\"\"\n        with pytest.raises(ValueError, match=\"non-negative\"):\n            fibonacci(-1)\n\n    def test_fibonacci_negative_ten_raises_value_error(self) -> None:\n        \"\"\"Test that fibonacci(-10) raises ValueError.\"\"\"\n        with pytest.raises(ValueError, match=\"non-negative\"):\n            fibonacci(-10)\n\n    def test_fibonacci_negative_large_number_raises_value_error(self) -> None:\n        \"\"\"Test that fibonacci with large negative number raises ValueError.\"\"\"\n        with pytest.raises(ValueError, match=\"non-negative\"):\n            fibonacci(-1000)\n\n    def test_fibonacci_negative_zero_point_one_raises_value_error(self) -> None:\n        \"\"\"Test that fibonacci(-0.1) raises ValueError for negative float.\"\"\"\n        with pytest.raises((ValueError, TypeError)):\n            fibonacci(-0.1)  # type: ignore\n\n\nclass TestFibonacciValidatorNonIntegerTypes:\n    \"\"\"Test suite for non-integer type validation.\"\"\"\n\n    def test_fibonacci_float_five_point_five_raises_error(self) -> None:\n        \"\"\"Test that fibonacci(5.5) raises error for float input.\"\"\"\n        with pytest.raises((ValueError, TypeError)):\n            fibonacci(5.5)  # type: ignore\n\n    def test_fibonacci_float_zero_raises_error(self) -> None:\n        \"\"\"Test that fibonacci(0.0) raises error for float input.\"\"\"\n        with pytest.raises((ValueError, TypeError)):\n            fibonacci(0.0)  # type: ignore\n\n    def test_fibonacci_float_one_raises_error(self) -> None:\n        \"\"\"Test that fibonacci(1.0) raises error for float input.\"\"\"\n        with pytest.raises((ValueError, TypeError)):\n            fibonacci(1.0)  # type: ignore\n\n    def test_fibonacci_string_five_raises_error(self) -> None:\n        \"\"\"Test that fibonacci('5') raises error for string input.\"\"\"\n        with pytest.raises((ValueError, TypeError)):\n            fibonacci('5')  # type: ignore\n\n    def test_fibonacci_string_zero_raises_error(self) -> None:\n        \"\"\"Test that fibonacci('0') raises error for string input.\"\"\"\n        with pytest.raises((ValueError, TypeError)):\n            fibonacci('0')  # type: ignore\n\n    def test_fibonacci_string_negative_raises_error(self) -> None:\n        \"\"\"Test that fibonacci('-5') raises error for string input.\"\"\"\n        with pytest.raises((ValueError, TypeError)):\n            fibonacci('-5')  # type: ignore\n\n    def test_fibonacci_none_raises_error(self) -> None:\n        \"\"\"Test that fibonacci(None) raises error for None input.\"\"\"\n        with pytest.raises((ValueError, TypeError)):\n            fibonacci(None)  # type: ignore\n\n    def test_fibonacci_list_raises_error(self) -> None:\n        \"\"\"Test that fibonacci([5]) raises error for list input.\"\"\"\n        with pytest.raises((ValueError, TypeError)):\n            fibonacci([5])  # type: ignore\n\n    def test_fibonacci_dict_raises_error(self) -> None:\n        \"\"\"Test that fibonacci({'n': 5}) raises error for dict input.\"\"\"\n        with pytest.raises((ValueError, TypeError)):\n            fibonacci({'n': 5})  # type: ignore\n\n    def test_fibonacci_boolean_true_raises_error(self) -> None:\n        \"\"\"Test that fibonacci(True) raises error for boolean input.\"\"\"\n        with pytest.raises((ValueError, TypeError)):\n            fibonacci(True)  # type: ignore\n\n    def test_fibonacci_boolean_false_raises_error(self) -> None:\n        \"\"\"Test that fibonacci(False) raises error for boolean input.\"\"\"\n        with pytest.raises((ValueError, TypeError)):\n            fibonacci(False)  # type: ignore\n\n\nclass TestFibonacciValidatorValidNonNegativeIntegers:\n    \"\"\"Test suite for valid non-negative integer inputs.\"\"\"\n\n    def test_fibonacci_zero_returns_zero(self) -> None:\n        \"\"\"Test that fibonacci(0) returns 0.\"\"\"\n        result = fibonacci(0)\n        assert result == 0\n        assert isinstance(result, int)\n\n    def test_fibonacci_one_returns_one(self) -> None:\n        \"\"\"Test that fibonacci(1) returns 1.\"\"\"\n        result = fibonacci(1)\n        assert result == 1\n        assert isinstance(result, int)\n\n    def test_fibonacci_two_returns_one(self) -> None:\n        \"\"\"Test that fibonacci(2) returns 1.\"\"\"\n        result = fibonacci(2)\n        assert result == 1\n        assert isinstance(result, int)\n\n    def test_fibonacci_three_returns_two(self) -> None:\n        \"\"\"Test that fibonacci(3) returns 2.\"\"\"\n        result = fibonacci(3)\n        assert result == 2\n        assert isinstance(result, int)\n\n    def test_fibonacci_four_returns_three(self) -> None:\n        \"\"\"Test that fibonacci(4) returns 3.\"\"\"\n        result = fibonacci(4)\n        assert result == 3\n        assert isinstance(result, int)\n\n    def test_fibonacci_five_returns_five(self) -> None:\n        \"\"\"Test that fibonacci(5) returns 5.\"\"\"\n        result = fibonacci(5)\n        assert result == 5\n        assert isinstance(result, int)\n\n    def test_fibonacci_ten_returns_fifty_five(self) -> None:\n        \"\"\"Test that fibonacci(10) returns 55.\"\"\"\n        result = fibonacci(10)\n        assert result == 55\n        assert isinstance(result, int)\n\n    def test_fibonacci_fifteen_returns_correct_value(self) -> None:\n        \"\"\"Test that fibonacci(15) returns 610.\"\"\"\n        result = fibonacci(15)\n        assert result == 610\n        assert isinstance(result, int)\n\n    def test_fibonacci_twenty_returns_correct_value(self) -> None:\n        \"\"\"Test that fibonacci(20) returns 6765.\"\"\"\n        result = fibonacci(20)\n        assert result == 6765\n        assert isinstance(result, int)\n\n\nclass TestFibonacciCalculatorSequence:\n    \"\"\"Test suite for Fibonacci sequence correctness.\"\"\"\n\n    def test_fibonacci_sequence_first_ten_values(self) -> None:\n        \"\"\"Test that first 10 Fibonacci numbers are correct.\"\"\"\n        expected_sequence = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n        for n, expected in enumerate(expected_sequence):\n            result = fibonacci(n)\n            assert result == expected, f\"fibonacci({n}) should be {expected}, got {result}\"\n\n    def test_fibonacci_sequence_property_sum(self) -> None:\n        \"\"\"Test Fibonacci property: F(n) = F(n-1) + F(n-2).\"\"\"\n        for n in range(2, 15):\n            f_n = fibonacci(n)\n            f_n_minus_1 = fibonacci(n - 1)\n            f_n_minus_2 = fibonacci(n - 2)\n            assert f_n == f_n_minus_1 + f_n_minus_2, \\\n                f\"fibonacci({n}) should equal fibonacci({n-1}) + fibonacci({n-2})\"\n\n    def test_fibonacci_monotonically_increasing(self) -> None:\n        \"\"\"Test that Fibonacci sequence is monotonically increasing for n >= 0.\"\"\"\n        previous = fibonacci(0)\n        for n in range(1, 20):\n            current = fibonacci(n)\n            assert current >= previous, \\\n                f\"fibonacci({n}) should be >= fibonacci({n-1})\"\n            previous = current\n\n    def test_fibonacci_large_value(self) -> None:\n        \"\"\"Test Fibonacci calculation for larger value.\"\"\"\n        result = fibonacci(30)\n        assert result == 832040\n        assert isinstance(result, int)",
      "file_type": "test",
      "semantic_unit_id": "SU-001",
      "component_id": "FibonacciValidator",
      "description": "Unit tests for input validation including negative integers, non-integer types (float, string), and valid non-negative integers"
    },
    {
      "file_path": "tests/test_fibonacci_calculator.py",
      "content": "\"\"\"\nUnit tests for Fibonacci Calculator\n\nTests the fibonacci function to verify correct calculation of Fibonacci numbers,\nproper handling of edge cases (n=0, n=1), validation of inputs, and correctness\nof the iterative algorithm for various input values.\n\nComponent ID: FibonacciCalculator\nSemantic Unit: SU-002\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport pytest\nfrom src.fibonacci_calculator import fibonacci\n\n\nclass TestFibonacciBaseCase:\n    \"\"\"Test suite for Fibonacci base cases.\"\"\"\n\n    def test_fibonacci_n_zero_returns_zero(self) -> None:\n        \"\"\"Test that fibonacci(0) returns 0.\"\"\"\n        result = fibonacci(0)\n        assert result == 0\n        assert isinstance(result, int)\n\n    def test_fibonacci_n_one_returns_one(self) -> None:\n        \"\"\"Test that fibonacci(1) returns 1.\"\"\"\n        result = fibonacci(1)\n        assert result == 1\n        assert isinstance(result, int)\n\n    def test_fibonacci_n_two_returns_one(self) -> None:\n        \"\"\"Test that fibonacci(2) returns 1.\"\"\"\n        result = fibonacci(2)\n        assert result == 1\n        assert isinstance(result, int)\n\n\nclass TestFibonacciSmallValues:\n    \"\"\"Test suite for Fibonacci calculation with small values.\"\"\"\n\n    def test_fibonacci_n_three_returns_two(self) -> None:\n        \"\"\"Test that fibonacci(3) returns 2.\"\"\"\n        result = fibonacci(3)\n        assert result == 2\n\n    def test_fibonacci_n_four_returns_three(self) -> None:\n        \"\"\"Test that fibonacci(4) returns 3.\"\"\"\n        result = fibonacci(4)\n        assert result == 3\n\n    def test_fibonacci_n_five_returns_five(self) -> None:\n        \"\"\"Test that fibonacci(5) returns 5.\"\"\"\n        result = fibonacci(5)\n        assert result == 5\n\n    def test_fibonacci_n_six_returns_eight(self) -> None:\n        \"\"\"Test that fibonacci(6) returns 8.\"\"\"\n        result = fibonacci(6)\n        assert result == 8\n\n    def test_fibonacci_n_seven_returns_thirteen(self) -> None:\n        \"\"\"Test that fibonacci(7) returns 13.\"\"\"\n        result = fibonacci(7)\n        assert result == 13\n\n    def test_fibonacci_n_eight_returns_twentyone(self) -> None:\n        \"\"\"Test that fibonacci(8) returns 21.\"\"\"\n        result = fibonacci(8)\n        assert result == 21\n\n    def test_fibonacci_n_nine_returns_thirtyfour(self) -> None:\n        \"\"\"Test that fibonacci(9) returns 34.\"\"\"\n        result = fibonacci(9)\n        assert result == 34\n\n    def test_fibonacci_n_ten_returns_fiftyfive(self) -> None:\n        \"\"\"Test that fibonacci(10) returns 55.\"\"\"\n        result = fibonacci(10)\n        assert result == 55\n\n\nclass TestFibonacciLargerValues:\n    \"\"\"Test suite for Fibonacci calculation with larger values.\"\"\"\n\n    def test_fibonacci_n_fifteen_returns_correct_value(self) -> None:\n        \"\"\"Test that fibonacci(15) returns 610.\"\"\"\n        result = fibonacci(15)\n        assert result == 610\n\n    def test_fibonacci_n_twenty_returns_correct_value(self) -> None:\n        \"\"\"Test that fibonacci(20) returns 6765.\"\"\"\n        result = fibonacci(20)\n        assert result == 6765\n\n    def test_fibonacci_n_twentyfive_returns_correct_value(self) -> None:\n        \"\"\"Test that fibonacci(25) returns 75025.\"\"\"\n        result = fibonacci(25)\n        assert result == 75025\n\n    def test_fibonacci_n_thirty_returns_correct_value(self) -> None:\n        \"\"\"Test that fibonacci(30) returns 832040.\"\"\"\n        result = fibonacci(30)\n        assert result == 832040\n\n    def test_fibonacci_n_fifty_returns_correct_value(self) -> None:\n        \"\"\"Test that fibonacci(50) returns 12586269025.\"\"\"\n        result = fibonacci(50)\n        assert result == 12586269025\n\n    def test_fibonacci_n_hundred_returns_correct_value(self) -> None:\n        \"\"\"Test that fibonacci(100) returns correct large Fibonacci number.\"\"\"\n        result = fibonacci(100)\n        assert result == 354224848179261915075\n\n\nclass TestFibonacciInputValidation:\n    \"\"\"Test suite for input validation and error handling.\"\"\"\n\n    def test_fibonacci_negative_one_raises_value_error(self) -> None:\n        \"\"\"Test that fibonacci(-1) raises ValueError.\"\"\"\n        with pytest.raises(ValueError) as exc_info:\n            fibonacci(-1)\n        assert \"non-negative\" in str(exc_info.value).lower()\n\n    def test_fibonacci_negative_ten_raises_value_error(self) -> None:\n        \"\"\"Test that fibonacci(-10) raises ValueError.\"\"\"\n        with pytest.raises(ValueError) as exc_info:\n            fibonacci(-10)\n        assert \"non-negative\" in str(exc_info.value).lower()\n\n    def test_fibonacci_negative_hundred_raises_value_error(self) -> None:\n        \"\"\"Test that fibonacci(-100) raises ValueError.\"\"\"\n        with pytest.raises(ValueError) as exc_info:\n            fibonacci(-100)\n        assert \"non-negative\" in str(exc_info.value).lower()\n\n    def test_fibonacci_float_input_raises_error(self) -> None:\n        \"\"\"Test that fibonacci(5.5) raises ValueError or TypeError.\"\"\"\n        with pytest.raises((ValueError, TypeError)):\n            fibonacci(5.5)  # type: ignore\n\n    def test_fibonacci_string_input_raises_error(self) -> None:\n        \"\"\"Test that fibonacci('5') raises ValueError or TypeError.\"\"\"\n        with pytest.raises((ValueError, TypeError)):\n            fibonacci('5')  # type: ignore\n\n    def test_fibonacci_none_input_raises_error(self) -> None:\n        \"\"\"Test that fibonacci(None) raises ValueError or TypeError.\"\"\"\n        with pytest.raises((ValueError, TypeError)):\n            fibonacci(None)  # type: ignore\n\n    def test_fibonacci_list_input_raises_error(self) -> None:\n        \"\"\"Test that fibonacci([5]) raises ValueError or TypeError.\"\"\"\n        with pytest.raises((ValueError, TypeError)):\n            fibonacci([5])  # type: ignore\n\n    def test_fibonacci_dict_input_raises_error(self) -> None:\n        \"\"\"Test that fibonacci({'n': 5}) raises ValueError or TypeError.\"\"\"\n        with pytest.raises((ValueError, TypeError)):\n            fibonacci({'n': 5})  # type: ignore\n\n\nclass TestFibonacciReturnType:\n    \"\"\"Test suite for return type validation.\"\"\"\n\n    def test_fibonacci_returns_integer_type(self) -> None:\n        \"\"\"Test that fibonacci always returns int type.\"\"\"\n        result = fibonacci(5)\n        assert isinstance(result, int)\n        assert not isinstance(result, bool)\n\n    def test_fibonacci_returns_integer_for_zero(self) -> None:\n        \"\"\"Test that fibonacci(0) returns int type.\"\"\"\n        result = fibonacci(0)\n        assert isinstance(result, int)\n\n    def test_fibonacci_returns_integer_for_large_value(self) -> None:\n        \"\"\"Test that fibonacci(100) returns int type.\"\"\"\n        result = fibonacci(100)\n        assert isinstance(result, int)\n\n    def test_fibonacci_returns_positive_integer(self) -> None:\n        \"\"\"Test that fibonacci returns non-negative integer for valid input.\"\"\"\n        for n in range(0, 20):\n            result = fibonacci(n)\n            assert isinstance(result, int)\n            assert result >= 0\n\n\nclass TestFibonacciSequenceProperties:\n    \"\"\"Test suite for mathematical properties of Fibonacci sequence.\"\"\"\n\n    def test_fibonacci_sequence_is_monotonically_increasing(self) -> None:\n        \"\"\"Test that Fibonacci sequence is monotonically increasing.\"\"\"\n        previous = fibonacci(0)\n        for n in range(1, 15):\n            current = fibonacci(n)\n            assert current >= previous\n            previous = current\n\n    def test_fibonacci_sum_property(self) -> None:\n        \"\"\"Test that fibonacci(n) = fibonacci(n-1) + fibonacci(n-2) for n >= 2.\"\"\"\n        for n in range(2, 20):\n            fib_n =",
      "file_type": "test",
      "semantic_unit_id": "SU-002",
      "component_id": "FibonacciCalculator",
      "description": "Unit tests for Fibonacci calculation covering base cases (n=0, n=1), small values, and larger values to verify iterative algorithm correctness"
    },
    {
      "file_path": "tests/test_fibonacci.py",
      "content": "\"\"\"\nIntegration tests for Fibonacci function\n\nTests the public fibonacci function to verify end-to-end behavior including error handling,\nedge cases, and documented examples.\n\nComponent ID: FibonacciFunction\nSemantic Unit: SU-003\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport pytest\nfrom src.fibonacci import fibonacci\n\n\nclass TestFibonacciBaseCase:\n    \"\"\"Test Fibonacci function base cases (n=0 and n=1).\"\"\"\n\n    def test_fibonacci_zero_returns_zero(self) -> None:\n        \"\"\"Test that fibonacci(0) returns 0.\"\"\"\n        result = fibonacci(0)\n        assert result == 0\n        assert isinstance(result, int)\n\n    def test_fibonacci_one_returns_one(self) -> None:\n        \"\"\"Test that fibonacci(1) returns 1.\"\"\"\n        result = fibonacci(1)\n        assert result == 1\n        assert isinstance(result, int)\n\n    def test_fibonacci_two_returns_one(self) -> None:\n        \"\"\"Test that fibonacci(2) returns 1.\"\"\"\n        result = fibonacci(2)\n        assert result == 1\n        assert isinstance(result, int)\n\n\nclass TestFibonacciSequence:\n    \"\"\"Test Fibonacci function for correct sequence values.\"\"\"\n\n    def test_fibonacci_three_returns_two(self) -> None:\n        \"\"\"Test that fibonacci(3) returns 2.\"\"\"\n        result = fibonacci(3)\n        assert result == 2\n\n    def test_fibonacci_four_returns_three(self) -> None:\n        \"\"\"Test that fibonacci(4) returns 3.\"\"\"\n        result = fibonacci(4)\n        assert result == 3\n\n    def test_fibonacci_five_returns_five(self) -> None:\n        \"\"\"Test that fibonacci(5) returns 5.\"\"\"\n        result = fibonacci(5)\n        assert result == 5\n\n    def test_fibonacci_six_returns_eight(self) -> None:\n        \"\"\"Test that fibonacci(6) returns 8.\"\"\"\n        result = fibonacci(6)\n        assert result == 8\n\n    def test_fibonacci_ten_returns_fifty_five(self) -> None:\n        \"\"\"Test that fibonacci(10) returns 55.\"\"\"\n        result = fibonacci(10)\n        assert result == 55\n\n    def test_fibonacci_fifteen_returns_correct_value(self) -> None:\n        \"\"\"Test that fibonacci(15) returns 610.\"\"\"\n        result = fibonacci(15)\n        assert result == 610\n\n    def test_fibonacci_twenty_returns_correct_value(self) -> None:\n        \"\"\"Test that fibonacci(20) returns 6765.\"\"\"\n        result = fibonacci(20)\n        assert result == 6765\n\n    def test_fibonacci_sequence_is_monotonic_increasing(self) -> None:\n        \"\"\"Test that Fibonacci sequence is monotonically increasing for n >= 0.\"\"\"\n        previous = fibonacci(0)\n        for n in range(1, 15):\n            current = fibonacci(n)\n            assert current >= previous\n            previous = current\n\n    def test_fibonacci_sequence_satisfies_recurrence_relation(self) -> None:\n        \"\"\"Test that fibonacci(n) = fibonacci(n-1) + fibonacci(n-2) for n >= 2.\"\"\"\n        for n in range(2, 20):\n            fib_n = fibonacci(n)\n            fib_n_minus_1 = fibonacci(n - 1)\n            fib_n_minus_2 = fibonacci(n - 2)\n            assert fib_n == fib_n_minus_1 + fib_n_minus_2\n\n\nclass TestFibonacciNegativeInput:\n    \"\"\"Test Fibonacci function error handling for negative inputs.\"\"\"\n\n    def test_fibonacci_negative_one_raises_value_error(self) -> None:\n        \"\"\"Test that fibonacci(-1) raises ValueError.\"\"\"\n        with pytest.raises(ValueError) as exc_info:\n            fibonacci(-1)\n        assert \"non-negative\" in str(exc_info.value).lower()\n\n    def test_fibonacci_negative_five_raises_value_error(self) -> None:\n        \"\"\"Test that fibonacci(-5) raises ValueError.\"\"\"\n        with pytest.raises(ValueError) as exc_info:\n            fibonacci(-5)\n        assert \"non-negative\" in str(exc_info.value).lower()\n\n    def test_fibonacci_negative_hundred_raises_value_error(self) -> None:\n        \"\"\"Test that fibonacci(-100) raises ValueError.\"\"\"\n        with pytest.raises(ValueError) as exc_info:\n            fibonacci(-100)\n        assert \"non-negative\" in str(exc_info.value).lower()\n\n    def test_fibonacci_error_message_contains_constraint_info(self) -> None:\n        \"\"\"Test that ValueError message contains information about constraint.\"\"\"\n        with pytest.raises(ValueError) as exc_info:\n            fibonacci(-1)\n        error_message = str(exc_info.value).lower()\n        assert \"non-negative\" in error_message or \"negative\" in error_message\n\n\nclass TestFibonacciTypeValidation:\n    \"\"\"Test Fibonacci function type validation and rejection of invalid types.\"\"\"\n\n    def test_fibonacci_float_input_raises_error(self) -> None:\n        \"\"\"Test that fibonacci(5.5) raises ValueError or TypeError.\"\"\"\n        with pytest.raises((ValueError, TypeError)):\n            fibonacci(5.5)  # type: ignore\n\n    def test_fibonacci_string_input_raises_error(self) -> None:\n        \"\"\"Test that fibonacci('5') raises ValueError or TypeError.\"\"\"\n        with pytest.raises((ValueError, TypeError)):\n            fibonacci('5')  # type: ignore\n\n    def test_fibonacci_none_input_raises_error(self) -> None:\n        \"\"\"Test that fibonacci(None) raises ValueError or TypeError.\"\"\"\n        with pytest.raises((ValueError, TypeError)):\n            fibonacci(None)  # type: ignore\n\n    def test_fibonacci_list_input_raises_error(self) -> None:\n        \"\"\"Test that fibonacci([5]) raises ValueError or TypeError.\"\"\"\n        with pytest.raises((ValueError, TypeError)):\n            fibonacci([5])  # type: ignore\n\n    def test_fibonacci_dict_input_raises_error(self) -> None:\n        \"\"\"Test that fibonacci({'n': 5}) raises ValueError or TypeError.\"\"\"\n        with pytest.raises((ValueError, TypeError)):\n            fibonacci({'n': 5})  # type: ignore\n\n    def test_fibonacci_float_zero_raises_error(self) -> None:\n        \"\"\"Test that fibonacci(0.0) raises ValueError or TypeError.\"\"\"\n        with pytest.raises((ValueError, TypeError)):\n            fibonacci(0.0)  # type: ignore\n\n    def test_fibonacci_float_one_raises_error(self) -> None:\n        \"\"\"Test that fibonacci(1.0) raises ValueError or TypeError.\"\"\"\n        with pytest.raises((ValueError, TypeError)):\n            fibonacci(1.0)  # type: ignore\n\n\nclass TestFibonacciReturnType:\n    \"\"\"Test Fibonacci function return type consistency.\"\"\"\n\n    def test_fibonacci_returns_integer_type(self) -> None:\n        \"\"\"Test that fibonacci returns int type for valid input.\"\"\"\n        result = fibonacci(5)\n        assert isinstance(result, int)\n        assert not isinstance(result, bool)\n\n    def test_fibonacci_returns_integer_for_zero(self) -> None:\n        \"\"\"Test that fibonacci(0) returns int type.\"\"\"\n        result = fibonacci(0)\n        assert isinstance(result, int)\n\n    def test_fibonacci_returns_integer_for_large_n(self) -> None:\n        \"\"\"Test that fibonacci returns int type for larger values.\"\"\"\n        result = fibonacci(30)\n        assert isinstance(result, int)\n\n    def test_fibonacci_returns_non_negative_integer(self) -> None:\n        \"\"\"Test that fibonacci returns non-negative integer for valid input.\"\"\"\n        for n in range(0, 20):\n            result = fibonacci(n)\n            assert isinstance(result, int)\n            assert result >= 0\n\n\nclass TestFibonacciLargeValues:\n    \"\"\"Test Fibonacci function with larger input values.\"\"\"\n\n    def test_fibonacci_twenty_five(self) -> None:\n        \"\"\"Test that fibonacci(25) returns correct value.\"\"\"\n        result = fibonacci(25)\n        assert result == 75025\n\n    def test_fibonacci_thirty(self) -> None:\n        \"\"\"Test that fibonacci(30) returns correct value.\"\"\"\n        result = fibonacci(30)\n        assert result == 832040\n\n    def test_fibonacci_thirty_five(self) -> None:\n        \"\"\"Test that fibonacci(",
      "file_type": "test",
      "semantic_unit_id": "SU-003",
      "component_id": "FibonacciFunction",
      "description": "Integration tests for public fibonacci function verifying end-to-end behavior including error handling, edge cases, and documented examples"
    },
    {
      "file_path": "tests/test_design_review.py",
      "content": "\"\"\"\nDesign review validation tests for Fibonacci implementation.\n\nTests ensure all critical and high-severity requirements are met including:\n- Type hints on function signature\n- Error handling for negative inputs\n- Edge case handling (n=0, n=1)\n- Iterative implementation (not recursive)\n- Comprehensive documentation with examples\n- Input type validation\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport pytest\nfrom src.fibonacci import fibonacci\nfrom src.fibonacci_validator import FibonacciValidator\nfrom src.fibonacci_calculator import FibonacciCalculator\n\n\nclass TestArchitectureRequirements:\n    \"\"\"Tests for architecture and design requirements.\"\"\"\n\n    def test_fibonacci_function_exists(self) -> None:\n        \"\"\"Test that fibonacci function is defined and callable.\"\"\"\n        assert callable(fibonacci)\n\n    def test_fibonacci_function_signature_has_type_hints(self) -> None:\n        \"\"\"Test that fibonacci function has proper type hints in signature.\"\"\"\n        annotations = fibonacci.__annotations__\n        assert \"n\" in annotations, \"Parameter 'n' must have type hint\"\n        assert annotations[\"n\"] == int, \"Parameter 'n' must be typed as int\"\n        assert \"return\" in annotations, \"Return type must be specified\"\n        assert annotations[\"return\"] == int, \"Return type must be int\"\n\n    def test_fibonacci_function_name_correct(self) -> None:\n        \"\"\"Test that function is named 'fibonacci'.\"\"\"\n        assert fibonacci.__name__ == \"fibonacci\"\n\n    def test_fibonacci_function_has_docstring(self) -> None:\n        \"\"\"Test that fibonacci function has a docstring.\"\"\"\n        assert fibonacci.__doc__ is not None\n        assert len(fibonacci.__doc__.strip()) > 0\n\n    def test_fibonacci_docstring_contains_summary(self) -> None:\n        \"\"\"Test that docstring contains a summary line.\"\"\"\n        docstring = fibonacci.__doc__\n        lines = docstring.strip().split(\"\\n\")\n        assert len(lines) > 0\n        assert len(lines[0].strip()) > 0\n\n    def test_fibonacci_docstring_contains_args_section(self) -> None:\n        \"\"\"Test that docstring contains Args section.\"\"\"\n        docstring = fibonacci.__doc__\n        assert \"Args:\" in docstring or \"Arguments:\" in docstring or \"Parameters:\" in docstring\n\n    def test_fibonacci_docstring_contains_returns_section(self) -> None:\n        \"\"\"Test that docstring contains Returns section.\"\"\"\n        docstring = fibonacci.__doc__\n        assert \"Returns:\" in docstring or \"Return:\" in docstring\n\n    def test_fibonacci_docstring_contains_raises_section(self) -> None:\n        \"\"\"Test that docstring contains Raises section.\"\"\"\n        docstring = fibonacci.__doc__\n        assert \"Raises:\" in docstring or \"Raise:\" in docstring\n\n    def test_fibonacci_docstring_contains_examples_section(self) -> None:\n        \"\"\"Test that docstring contains Examples section.\"\"\"\n        docstring = fibonacci.__doc__\n        assert \"Examples:\" in docstring or \"Example:\" in docstring\n\n    def test_fibonacci_docstring_has_multiple_examples(self) -> None:\n        \"\"\"Test that docstring contains at least 5 examples.\"\"\"\n        docstring = fibonacci.__doc__\n        examples_section = docstring.split(\"Examples:\")[1] if \"Examples:\" in docstring else docstring.split(\"Example:\")[1]\n        example_count = examples_section.count(\"fibonacci(\")\n        assert example_count >= 5, f\"Expected at least 5 examples, found {example_count}\"\n\n\nclass TestErrorHandlingRequirements:\n    \"\"\"Tests for error handling and validation requirements.\"\"\"\n\n    def test_negative_input_raises_value_error(self) -> None:\n        \"\"\"Test that negative input raises ValueError.\"\"\"\n        with pytest.raises(ValueError):\n            fibonacci(-1)\n\n    def test_negative_input_error_message_contains_non_negative(self) -> None:\n        \"\"\"Test that ValueError message mentions non-negative constraint.\"\"\"\n        with pytest.raises(ValueError) as exc_info:\n            fibonacci(-1)\n        error_message = str(exc_info.value).lower()\n        assert \"non-negative\" in error_message or \"negative\" in error_message\n\n    def test_large_negative_input_raises_value_error(self) -> None:\n        \"\"\"Test that large negative input raises ValueError.\"\"\"\n        with pytest.raises(ValueError):\n            fibonacci(-100)\n\n    def test_float_input_raises_error(self) -> None:\n        \"\"\"Test that float input raises TypeError or ValueError.\"\"\"\n        with pytest.raises((TypeError, ValueError)):\n            fibonacci(5.5)\n\n    def test_string_input_raises_error(self) -> None:\n        \"\"\"Test that string input raises TypeError or ValueError.\"\"\"\n        with pytest.raises((TypeError, ValueError)):\n            fibonacci(\"5\")\n\n    def test_none_input_raises_error(self) -> None:\n        \"\"\"Test that None input raises TypeError or ValueError.\"\"\"\n        with pytest.raises((TypeError, ValueError)):\n            fibonacci(None)\n\n    def test_list_input_raises_error(self) -> None:\n        \"\"\"Test that list input raises TypeError or ValueError.\"\"\"\n        with pytest.raises((TypeError, ValueError)):\n            fibonacci([5])\n\n    def test_dict_input_raises_error(self) -> None:\n        \"\"\"Test that dict input raises TypeError or ValueError.\"\"\"\n        with pytest.raises((TypeError, ValueError)):\n            fibonacci({\"n\": 5})\n\n\nclass TestDataIntegrityRequirements:\n    \"\"\"Tests for edge cases and data integrity.\"\"\"\n\n    def test_fibonacci_zero_returns_zero(self) -> None:\n        \"\"\"Test that fibonacci(0) returns 0.\"\"\"\n        result = fibonacci(0)\n        assert result == 0\n        assert isinstance(result, int)\n\n    def test_fibonacci_one_returns_one(self) -> None:\n        \"\"\"Test that fibonacci(1) returns 1.\"\"\"\n        result = fibonacci(1)\n        assert result == 1\n        assert isinstance(result, int)\n\n    def test_fibonacci_two_returns_one(self) -> None:\n        \"\"\"Test that fibonacci(2) returns 1.\"\"\"\n        result = fibonacci(2)\n        assert result == 1\n        assert isinstance(result, int)\n\n    def test_fibonacci_three_returns_two(self) -> None:\n        \"\"\"Test that fibonacci(3) returns 2.\"\"\"\n        result = fibonacci(3)\n        assert result == 2\n        assert isinstance(result, int)\n\n    def test_fibonacci_five_returns_five(self) -> None:\n        \"\"\"Test that fibonacci(5) returns 5.\"\"\"\n        result = fibonacci(5)\n        assert result == 5\n        assert isinstance(result, int)\n\n    def test_fibonacci_ten_returns_fifty_five(self) -> None:\n        \"\"\"Test that fibonacci(10) returns 55.\"\"\"\n        result = fibonacci(10)\n        assert result == 55\n        assert isinstance(result, int)\n\n    def test_fibonacci_sequence_correctness(self) -> None:\n        \"\"\"Test that first 15 Fibonacci numbers are correct.\"\"\"\n        expected = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377]\n        for n, expected_value in enumerate(expected):\n            result = fibonacci(n)\n            assert result == expected_value, f\"fibonacci({n}) should be {expected_value}, got {result}\"\n\n    def test_fibonacci_returns_integer_type(self) -> None:\n        \"\"\"Test that fibonacci always returns int type.\"\"\"\n        for n in [0, 1, 2, 5, 10, 20]:\n            result = fibonacci(n)\n            assert isinstance(result, int), f\"fibonacci({n}) should return int, got {type(result)}\"\n\n    def test_fibonacci_returns_non_negative(self) -> None:\n        \"\"\"Test that fibonacci returns non-negative values for valid inputs.\"\"\"\n        for n in range(0, 20):\n            result = fibonacci(n)\n            assert result >= 0, f\"fibonacci({n}) should be non-negative, got {result}\"\n\n\nclass TestPerformanceRequirements:\n    \"\"\"Tests for performance characteristics and implementation approach.\"\"\"\n\n    def test_fibonacci_completes_for_large_n(self) -> None:\n        \"\"\"Test that fibonacci completes in reasonable time for n=1000.\"\"\"\n        result = fibonacci(1000)\n        assert isinstance(result, int)",
      "file_type": "test",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Design review validation tests ensuring all critical and high-severity requirements are met including type hints, error messages, performance characteristics, and documentation"
    },
    {
      "file_path": "requirements.txt",
      "content": "# Testing\npytest==7.4.3",
      "file_type": "requirements",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Python dependencies file specifying pytest for testing (no external runtime dependencies required)"
    },
    {
      "file_path": ".env.example",
      "content": "# Environment configuration template\n# This is a minimal template for a pure Python project with no external dependencies\n# Copy this file to .env and set values as needed for your environment\n\n# Python environment\nPYTHONUNBUFFERED=1\nPYTHONDONTWRITEBYTECODE=1",
      "file_type": "config",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Environment configuration template (minimal for this pure Python project, included for completeness)"
    },
    {
      "file_path": "pytest.ini",
      "content": "[tool:pytest]\n# Test discovery patterns\npython_files = test_*.py *_test.py\npython_classes = Test*\npython_functions = test_*\n\n# Output formatting\naddopts = \n    -v\n    --strict-markers\n    --tb=short\n    --disable-warnings\n\n# Test paths\ntestpaths = tests\n\n# Markers for organizing tests\nmarkers =\n    unit: Unit tests for individual functions and components\n    integration: Integration tests for multiple components working together\n    edge_case: Tests for boundary conditions and edge cases\n    error_case: Tests for error handling and exception cases\n\n# Coverage options\n[coverage:run]\nsource = .\nomit = \n    */tests/*\n    */test_*.py\n    */__pycache__/*\n    */venv/*\n    */env/*\n\n[coverage:report]\nexclude_lines =\n    pragma: no cover\n    def __repr__\n    raise AssertionError\n    raise NotImplementedError\n    if __name__ == .__main__.:\n    if TYPE_CHECKING:\n    @abstractmethod\n    @abc.abstractmethod\n\n# Minimum coverage threshold\nfail_under = 80",
      "file_type": "config",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Pytest configuration file specifying test discovery patterns and output formatting"
    },
    {
      "file_path": ".pylintrc",
      "content": "[tool:pylint]\n\n# Pylint configuration file enforcing PEP 8 compliance and code quality standards\n# This configuration ensures consistent code style across the project\n\n[MASTER]\n\n# Add files or directories to the blacklist. They should be base names, not\n# paths.\nignore=CVS\n\n# Add files or directories matching the regex patterns to the blacklist. The\n# regex matches against base names, not paths.\nignore-patterns=test_.*?\\.py\n\n# Python code to execute, usually for sys.path manipulation such as\n# pygtk.require().\n#init-hook=\n\n# Use multiple processes to speed up Pylint. Specifying 0 will auto-detect the\n# number of processors available to use.\njobs=1\n\n# Control the amount of potential inferred values when inferring a single\n# object. This can help the performance when dealing with large functions or\n# complex, nested conditions.\nlimit-inference-results=100\n\n# List of plugins (as comma separated). Plugins are modules names not files\n# names.\nload-plugins=\n\n# Pickle collected data for later comparisons.\npersistent=yes\n\n# Specify a configuration file.\n#rcfile=\n\n# When enabled, pylint would attempt to guess common misconfiguration and emit\n# user-friendly hints instead of false-positive error messages.\nsuggestion-mode=yes\n\n# Allow optimization of some checking when you estimate you benefit from it.\nunsafe-load-any-extension=no\n\n[MESSAGES CONTROL]\n\n# Only show warnings with the listed confidence levels. Leave empty to show\n# all. Valid levels: HIGH, INFERENCE, INFERENCE_FAILURE, UNDEFINED.\nconfidence=\n\n# Disable the message, report, category or checker with the given id(s). You\n# can either give multiple identifiers separated by comma (,) or put this\n# option multiple times (only on the command line, not in the configuration\n# file where it should appear only once). You can also use \"--disable=all\" to\n# disable everything first and then reenable specific checks. For example, if\n# you want to run only the similarities checker, you can use \"--disable=all\n# --enable=similarities\". If you want to run only the classes checker, but have\n# no Warning level messages displayed, use \"--disable=all --enable=classes\n# --disable=W\".\ndisable=\n    raw-checker-failed,\n    bad-inline-option-value,\n    locally-disabled,\n    file-ignored,\n    suppressed-message,\n    useless-suppression,\n    deprecated-pragma,\n    use-symbolic-message,\n    missing-module-docstring,\n\n[REPORTS]\n\n# Python expression which should return a note less than 10 (10 is the highest\n# note). You have access to the variables errors warning, statement which\n# respectively contain the number of errors / warnings messages and the total\n# number of statements analyzed. This is used by the global evaluation report\n# (RP0004).\nevaluation=max(0, 0 if fatal else 10.0 - ((float(5 * error + warning + refactor + convention) / statement) * 10))\n\n# Template used to display messages. This is a python new style format string\n# used to format the message information. See doc for all details.\n#msg-template=\n\n# Set the output format. Available formats are text, parseable, colorized, json\n# and msvg (multiple scatterplot values for gp). You can also give a reporter\n# class e.g. mypackage.mymodule.MyReporterClass -:text\noutput-format=text\n\n# Tells whether to display a full report or only the messages.\nreports=no\n\n# Activate the evaluation score.\nscore=yes\n\n[REFACTOR]\n\n# Maximum number of nested blocks for function / method body\nmax-nested-blocks=5\n\n# Complete name of functions that never returns. When checking for\n# inconsistent-return-statements if a never returning function is called then\n# it will be considered as an explicit return statement and no message will be\n# printed.\nnever-returning-functions=sys.exit,argparse.parse_error\n\n[LOGGING]\n\n# The type of string formatting that logging methods do. `old` for %\n# formatting, `new` for {} formatting and `fstring` for f-strings.\nlogging-format-style=old\n\n# Format template used to check logging format string.\nlogging-modules=logging\n\n[SPELLING]\n\n# Limits count of emitted suggestions for spelling mistakes.\nmax-spelling-suggestions=4\n\n# Tells whether to store unknown words to indicated private dictionary in\n# --spelling-private-dict-file option instead of raising a message.\nspelling-store-unknown-words=no\n\n[MISCELLANEOUS]\n\n# List of note tags to take in consideration, separated by a comma.\nnotes=FIXME,XXX,TODO\n\n# Regular expression of note tags to take in consideration.\n#notes-rgx=\n\n[TYPECHECK]\n\n# List of decorators that produce context managers, such as\n# contextlib.contextmanager. Add to this list to register other decorators that\n# produce valid context managers.\ncontextmanager-decorators=contextlib.contextmanager\n\n# List of members which are set dynamically and missed by pylint inference\n# system, and so shouldn't trigger false positives when accessed as undefined\n# members in Python < 3.7.\ngenerated-members=\n\n# Tells whether missing members accessed in mixin class should be ignored. A\n# mixin class is considered a class which inherits from object and does not\n# define its own base classes.\nignore-mixin-members=yes\n\n# Tells whether to warn about missing members when the owner of the attribute\n# is inferred to be None.\nignore-none=yes\n\n# This flag controls whether pylint should warn about no-member-access for\n# owner which are a pass statement. The pass statement is used as a placeholder\n# in empty class body.\nignore-on-opaque-object=yes\n\n# A list of class names for which member attributes should not be checked\n# (useful for classes with dynamically set attributes). This supports the use\n# of the star-import when a __all__ is defined in the module.\nignored-classes=optparse.Values,thread._local,_thread._local\n\n# List of module names for which member attributes should not be checked\n# (useful for modules/projects where namespaces are manipulated during runtime\n# and thus existing member attributes cannot be deduced by static analysis). It\n# supports qualified module names, as well as Unix pattern matching.\nignored-modules=\n\n# Show a hint with possible names when a member name was not found. The aspect\n# of finding the hint is based on edit distance.\nmissing-member-hint=yes\n\n# The minimum edit distance a name should have in order to consider it a\n# similar match for a missing member name.\nmissing-member-hint-distance=1\n\n# The total number of similar lines required to trigger the similar-lines\n# message.\nmin-similarity-lines=4\n\n[VARIABLES]\n\n# List of additional names supposed to be defined in builtins. Remember that\n# you should avoid to define new builtins when possible.\nadditional-builtins=\n\n# Tells whether unused global variables should be treated as a violation.\nallow-global-unused-variables=yes\n\n# List of names allowed to shadow builtins\nallowed-redefined-builtins=\n\n# List of strings which can identify a callback function by name. A callback\n# name must start or end with one of those strings.\ncallbacks=cb_,_cb\n\n# A regular expression matching the name of dummy variables (i.e. expected to\n# not be used).\ndummy-variables-rgx=_+$|(_[a-zA-Z0-9_]*[a-zA-Z0-9]+?$)|^ignored_|^unused_\n\n# Argument names that match this expression will be ignored. Default to name\n# with leading underscore.\nignored-argument-names=_.*|^ignored_|^unused_\n\n# Tells whether we should check for unused import in __init__ files.\ninit-import=no\n\n# List of qualified module names which can have objects that can change during\n# runtime and trigger false positives when accessed as undefined members.\nredefining-builtins-modules=six.moves,past.builtins,future.builtins,builtins,io\n\n[FORMAT]\n\n# Expected format of line ending, especially useful when checking scripts as\n# they are prone to have the wrong line ending convention. This represents the\n# line ending type to be considered as expected.\nexpected-line-ending-format=\n\n# Regexp for a line that is allowed to be longer than the limit.",
      "file_type": "config",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Pylint configuration enforcing PEP 8 compliance and code quality standards"
    },
    {
      "file_path": "README.md",
      "content": "# Fibonacci Calculator\n\nA simple, efficient Python implementation of the Fibonacci sequence calculator with comprehensive input validation and documentation.\n\n## Overview\n\nThis project provides a pure Python implementation of the Fibonacci sequence calculator. The implementation uses an iterative approach to compute the nth Fibonacci number efficiently, with proper input validation and comprehensive error handling.\n\n### Features\n\n- **Efficient Iterative Algorithm**: O(n) time complexity, O(1) space complexity\n- **Input Validation**: Type checking and range validation with clear error messages\n- **Comprehensive Documentation**: Google-style docstrings with multiple examples\n- **Type Hints**: Full type annotations for better code clarity and IDE support\n- **Error Handling**: Explicit validation of negative inputs with descriptive error messages\n- **Edge Case Handling**: Proper handling of base cases (n=0, n=1)\n\n## Prerequisites\n\n- Python 3.12 or higher\n- pip package manager (for running tests)\n\n## Installation\n\n1. Clone or download the project:\n   ```bash\n   git clone <repository-url>\n   cd fibonacci-calculator\n   ```\n\n2. (Optional) Create a virtual environment:\n   ```bash\n   python3 -m venv venv\n   source venv/bin/activate  # On Windows: venv\\Scripts\\activate\n   ```\n\n3. Install development dependencies (for testing):\n   ```bash\n   pip install -r requirements.txt\n   ```\n\n## Usage\n\n### Basic Usage\n\n```python\nfrom fibonacci import fibonacci\n\n# Calculate the 10th Fibonacci number\nresult = fibonacci(10)\nprint(result)  # Output: 55\n\n# Calculate the 0th Fibonacci number\nresult = fibonacci(0)\nprint(result)  # Output: 0\n\n# Calculate the 1st Fibonacci number\nresult = fibonacci(1)\nprint(result)  # Output: 1\n```\n\n### Error Handling\n\n```python\nfrom fibonacci import fibonacci\n\n# Attempting to calculate Fibonacci for negative number raises ValueError\ntry:\n    result = fibonacci(-5)\nexcept ValueError as e:\n    print(f\"Error: {e}\")  # Output: Error: n must be a non-negative integer\n\n# Attempting to pass non-integer type raises ValueError\ntry:\n    result = fibonacci(5.5)\nexcept ValueError as e:\n    print(f\"Error: {e}\")  # Output: Error: n must be a non-negative integer\n\ntry:\n    result = fibonacci(\"5\")\nexcept ValueError as e:\n    print(f\"Error: {e}\")  # Output: Error: n must be a non-negative integer\n```\n\n### Examples\n\n```python\nfrom fibonacci import fibonacci\n\n# Sequence of Fibonacci numbers\nfor i in range(11):\n    print(f\"fibonacci({i}) = {fibonacci(i)}\")\n\n# Output:\n# fibonacci(0) = 0\n# fibonacci(1) = 1\n# fibonacci(2) = 1\n# fibonacci(3) = 2\n# fibonacci(4) = 3\n# fibonacci(5) = 5\n# fibonacci(6) = 8\n# fibonacci(7) = 13\n# fibonacci(8) = 21\n# fibonacci(9) = 34\n# fibonacci(10) = 55\n```\n\n## Architecture\n\nThe implementation is organized into three logical components:\n\n### 1. FibonacciValidator (SU-001)\n\n**Responsibility**: Validates input parameters and enforces type constraints.\n\n**Key Features**:\n- Type checking: Ensures input is an integer, not float or string\n- Range validation: Ensures input is non-negative\n- Fast-fail approach: Validation occurs before any calculation\n\n**Method**: `validate_input(n: int) -> bool`\n- Raises `ValueError` if n is negative\n- Raises `ValueError` if n is not an integer type\n- Returns `True` if validation passes\n\n### 2. FibonacciCalculator (SU-002)\n\n**Responsibility**: Implements the core iterative Fibonacci calculation algorithm.\n\n**Key Features**:\n- Iterative approach: Uses two variables (prev, curr) to track state\n- Base case handling: Explicit handling of n=0 and n=1\n- Efficient computation: O(n) time complexity, O(1) space complexity\n- No recursion: Avoids stack overflow on large values\n\n**Methods**:\n- `calculate(n: int) -> int`: Computes the nth Fibonacci number\n- `handle_base_cases(n: int) -> int`: Returns Fibonacci value for n=0 or n=1\n\n**Algorithm**:\n```\nFor n = 0: return 0\nFor n = 1: return 1\nFor n >= 2:\n  prev = 0, curr = 1\n  Loop from 2 to n:\n    temp = curr\n    curr = prev + curr\n    prev = temp\n  Return curr\n```\n\n### 3. FibonacciFunction (SU-003)\n\n**Responsibility**: Public API function that orchestrates validation and calculation.\n\n**Key Features**:\n- Input validation: Calls FibonacciValidator before calculation\n- Calculation orchestration: Delegates to FibonacciCalculator\n- Comprehensive documentation: Google-style docstring with examples\n- Type hints: Full type annotations on function signature\n\n**Method**: `fibonacci(n: int) -> int`\n- Validates input using FibonacciValidator\n- Calculates result using FibonacciCalculator\n- Returns the nth Fibonacci number\n\n## Running Tests\n\n### Run All Tests\n\n```bash\npytest tests/ -v\n```\n\n### Run Tests with Coverage Report\n\n```bash\npytest tests/ --cov=. --cov-report=html\n```\n\nThis generates an HTML coverage report in the `htmlcov/` directory.\n\n### Run Specific Test File\n\n```bash\npytest tests/test_fibonacci.py -v\n```\n\n### Run Tests Matching Pattern\n\n```bash\npytest tests/ -k \"test_fibonacci_base_cases\" -v\n```\n\n## Test Coverage\n\nThe test suite includes comprehensive coverage of:\n\n- **Happy Path Tests**: Valid inputs returning correct Fibonacci values\n- **Base Case Tests**: n=0 and n=1 returning 0 and 1 respectively\n- **Edge Case Tests**: Large values, boundary conditions\n- **Error Case Tests**: Negative inputs, non-integer types, invalid inputs\n- **Type Validation Tests**: Rejection of float and string inputs\n- **Error Message Tests**: Verification of descriptive error messages\n\nTarget coverage: 80%+ of source code\n\n## Design Decisions\n\n### Iterative vs. Recursive\n\nThe implementation uses an **iterative approach** instead of recursion for the following reasons:\n\n1. **Performance**: O(n) time complexity vs. O(2^n) for naive recursion\n2. **Memory Safety**: O(1) space complexity vs. O(n) stack depth for recursion\n3. **Scalability**: Can handle large n values without stack overflow\n4. **Simplicity**: Easier to understand and maintain\n\n### Input Validation Strategy\n\nInput validation is performed **before** any calculation to implement a \"fail-fast\" approach:\n\n1. **Type Checking**: Ensures input is exactly `int` type, not `float` or `str`\n2. **Range Checking**: Ensures input is non-negative (>= 0)\n3. **Clear Error Messages**: Provides descriptive error messages for debugging\n\n### Base Case Handling\n\nBase cases (n=0, n=1) are handled **explicitly** in the algorithm:\n\n1. **Correctness**: Ensures correct values without relying on loop logic\n2. **Clarity**: Makes the algorithm's behavior obvious\n3. **Efficiency**: Avoids unnecessary computation for small inputs\n\n## Complexity Analysis\n\n### Time Complexity: O(n)\n\nThe iterative algorithm performs exactly n-1 iterations for n >= 2, resulting in linear time complexity.\n\n### Space Complexity: O(1)\n\nOnly two variables (prev, curr) are used regardless of input size, resulting in constant space complexity.\n\n## Troubleshooting\n\n### ValueError: n must be a non-negative integer\n\n**Cause**: Input is either negative or not an integer type.\n\n**Solution**: Ensure input is a non-negative integer:\n```python\n# Incorrect\nfibonacci(-5)      # Negative\nfibonacci(5.5)      # Float\nfibonacci(\"5\")      # String\n\n# Correct\nfibonacci(5)        # Positive integer\nfibonacci(0)        # Zero is valid\n```\n\n### Import Error: No module named 'fibonacci'\n\n**Cause**: The fibonacci module is not in the Python path.\n\n**Solution**: Ensure you're running from the project root directory:\n```bash\ncd /path/to",
      "file_type": "documentation",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Project documentation including overview, setup instructions, usage examples, running tests, and design architecture explanation"
    },
    {
      "file_path": "DESIGN.md",
      "content": "# Fibonacci Implementation - Design Documentation\n\n## Overview\n\nThis document provides detailed design documentation for the Fibonacci number calculation implementation (Task ID: TSP-FIB-001). It outlines the component architecture, algorithm complexity analysis, and design decisions that guide the implementation.\n\n## Architecture Overview\n\nThe implementation follows a modular, single-responsibility design pattern with three logical components:\n\n1. **FibonacciValidator** - Input validation and type checking\n2. **FibonacciCalculator** - Core iterative Fibonacci algorithm\n3. **FibonacciFunction** - Public API orchestration\n\nThis architecture ensures separation of concerns, testability, and maintainability while keeping the implementation simple and efficient.\n\n### Design Principles\n\n- **Fail Fast**: Input validation occurs before any computation\n- **Single Responsibility**: Each component has one clear purpose\n- **Type Safety**: Strict type checking prevents invalid inputs\n- **Efficiency**: Iterative approach ensures O(n) time and O(1) space complexity\n- **Clarity**: Comprehensive documentation and examples guide usage\n\n## Component Architecture\n\n### Component 1: FibonacciValidator (SU-001)\n\n**Responsibility**: Validates input parameters and enforces type hints for the Fibonacci function\n\n**Interface**:\n```\nvalidate_input(n: int) -> bool\n```\n\n**Validation Rules**:\n- Input must be of type `int` (not `float`, `str`, or other numeric types)\n- Input must be non-negative (n >= 0)\n- Raises `ValueError` with message \"n must be a non-negative integer\" if validation fails\n\n**Implementation Strategy**:\n- Use `isinstance(n, int)` to verify exact type (excludes `bool` in Python 3.x)\n- Check `n < 0` condition to enforce non-negative constraint\n- Raise `ValueError` immediately on validation failure (fail-fast principle)\n- Return `True` only if all validations pass\n\n**Complexity**: O(1) - constant time validation\n\n### Component 2: FibonacciCalculator (SU-002)\n\n**Responsibility**: Implements iterative Fibonacci calculation with proper handling of edge cases\n\n**Interfaces**:\n```\ncalculate(n: int) -> int\nhandle_base_cases(n: int) -> int\n```\n\n**Algorithm Details**:\n\n**Base Cases**:\n- `n = 0`: Return 0 immediately\n- `n = 1`: Return 1 immediately\n\n**Iterative Computation** (for n >= 2):\n1. Initialize two variables: `prev = 0`, `curr = 1`\n2. Loop from 2 to n (inclusive)\n3. In each iteration:\n   - `temp = curr`\n   - `curr = prev + curr`\n   - `prev = temp`\n4. Return `curr` after loop completes\n\n**Why Iterative Over Recursive**:\n- Recursive approach has O(2^n) exponential time complexity\n- Recursive approach causes stack overflow for large n values\n- Iterative approach achieves O(n) time with O(1) space\n- Iterative approach is production-ready for any reasonable n value\n\n**Complexity Analysis**:\n- Time Complexity: O(n) - single loop from 2 to n\n- Space Complexity: O(1) - only two variables regardless of n\n\n### Component 3: FibonacciFunction (SU-003)\n\n**Responsibility**: Public API function that orchestrates validation and calculation\n\n**Interface**:\n```python\ndef fibonacci(n: int) -> int\n```\n\n**Orchestration Flow**:\n1. Call `FibonacciValidator.validate_input(n)` to validate input\n2. Call `FibonacciCalculator.calculate(n)` to compute result\n3. Return the computed Fibonacci number\n\n**Documentation Requirements**:\n- One-line summary of function purpose\n- Extended description explaining the Fibonacci sequence\n- Args section documenting the `n` parameter with type and constraints\n- Returns section documenting return type and value\n- Raises section documenting `ValueError` for negative inputs\n- Examples section with at least 5 test cases demonstrating correct usage\n\n**Docstring Format**: Google-style docstring\n\n**Example Cases**:\n- `fibonacci(0)`  0\n- `fibonacci(1)`  1\n- `fibonacci(2)`  1\n- `fibonacci(5)`  5\n- `fibonacci(10)`  55\n\n**Complexity**: O(n) - dominated by calculation component\n\n## Algorithm Complexity Analysis\n\n### Time Complexity: O(n)\n\nThe iterative approach requires exactly n-1 iterations for any input n >= 2:\n- Base cases (n=0, n=1): O(1) constant time\n- Iterative loop: n-2 iterations, each performing constant-time operations\n- Total: O(1) + O(n-2) = O(n)\n\n**Comparison with Alternatives**:\n- Recursive (naive): O(2^n) - exponential, impractical for n > 40\n- Recursive with memoization: O(n) time, O(n) space - uses extra memory\n- Matrix exponentiation: O(log n) time - more complex, not required\n\n### Space Complexity: O(1)\n\nThe iterative approach uses only two variables (`prev`, `curr`) regardless of input size:\n- No recursion stack: O(1) stack space\n- No data structures: O(1) heap space\n- Total: O(1) constant space\n\n**Comparison with Alternatives**:\n- Recursive (naive): O(n) stack space - risk of stack overflow\n- Recursive with memoization: O(n) space - stores all computed values\n- Matrix exponentiation: O(1) space - but more complex\n\n## Design Decisions\n\n### Decision 1: Iterative Over Recursive Implementation\n\n**Rationale**:\n- Production systems require handling large inputs without stack overflow\n- O(n) time complexity is acceptable for most use cases\n- O(1) space complexity is superior to memoization approaches\n- Code is simpler and more maintainable than matrix exponentiation\n\n**Trade-offs**:\n- Cannot achieve O(log n) time complexity (not required)\n- Slightly more verbose than naive recursion (acceptable for production)\n\n### Decision 2: Strict Type Checking (int only)\n\n**Rationale**:\n- Prevents silent errors from float inputs (e.g., 5.0 treated as 5)\n- Prevents string inputs that could be parsed as integers\n- Enforces explicit type conversion by caller\n- Aligns with Python's type hint philosophy\n\n**Trade-offs**:\n- Slightly less flexible than accepting numeric types\n- Caller must explicitly convert float to int if needed\n\n### Decision 3: Fail-Fast Validation\n\n**Rationale**:\n- Detects invalid inputs immediately before computation\n- Provides clear error messages for debugging\n- Prevents wasted computation on invalid inputs\n- Follows defensive programming principles\n\n**Trade-offs**:\n- Adds validation overhead (negligible at O(1))\n- Requires exception handling in calling code\n\n### Decision 4: Explicit Base Case Handling\n\n**Rationale**:\n- Makes algorithm behavior transparent and testable\n- Prevents off-by-one errors in loop logic\n- Improves code readability and maintainability\n- Enables independent testing of base cases\n\n**Trade-offs**:\n- Slightly more code than deriving from general algorithm\n- Minimal performance impact (negligible)\n\n## Design Review Checklist\n\n### Critical Requirements\n\n1. **Function Signature** \n   - Name: `fibonacci`\n   - Parameter: `n` of type `int`\n   - Return type: `int`\n   - Type hints present: `def fibonacci(n: int) -> int:`\n\n2. **Error Handling** \n   - Negative inputs raise `ValueError`\n   - Error message contains \"non-negative\"\n   - No silent failures or special return values\n\n### High Priority Requirements\n\n3. **Edge Cases** \n   - `fibonacci(0)` returns 0\n   - `fibonacci(1)` returns 1\n   - `fibonacci(2)` returns 1\n   - Handled explicitly, not derived from general algorithm\n\n4. **Performance** \n   - Iterative approach used (not recursive)\n   - Two variables (prev, curr) for state\n   - No recursive calls within implementation\n   - Time complexity: O(n)\n   - Space complexity: O(1)\n\n5. **Documentation** \n   - Comprehensive docstring present\n   - Summary",
      "file_type": "documentation",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Detailed design documentation explaining component architecture, algorithm complexity analysis, and design decisions"
    },
    {
      "file_path": "main.py",
      "content": "\"\"\"\nEntry point demonstrating fibonacci function usage with example calls and output.\n\nThis module serves as the main entry point for the Fibonacci application,\nshowcasing the fibonacci function with various example inputs and displaying\nthe calculated results.\n\nComponent ID: None\nSemantic Unit: None\n\"\"\"\n\nfrom src.fibonacci import fibonacci\n\n\ndef main() -> None:\n    \"\"\"\n    Main entry point demonstrating fibonacci function usage.\n\n    Calls the fibonacci function with various example inputs and prints\n    the results to demonstrate correct functionality across different cases\n    including edge cases (0, 1) and larger values.\n\n    Returns:\n        None\n    \"\"\"\n    print(\"Fibonacci Function Demonstration\")\n    print(\"=\" * 50)\n    print()\n\n    # Test cases demonstrating the fibonacci function\n    test_cases: list[int] = [0, 1, 2, 5, 10, 15, 20]\n\n    print(\"Computing Fibonacci numbers:\")\n    print(\"-\" * 50)\n\n    for n in test_cases:\n        result: int = fibonacci(n)\n        print(f\"fibonacci({n:2d}) = {result}\")\n\n    print()\n    print(\"=\" * 50)\n    print(\"Demonstration complete!\")\n    print()\n\n    # Additional demonstration: showing the sequence\n    print(\"Fibonacci Sequence (first 15 numbers):\")\n    print(\"-\" * 50)\n    sequence: list[int] = [fibonacci(i) for i in range(15)]\n    print(\", \".join(str(num) for num in sequence))\n    print()\n\n    # Error handling demonstration\n    print(\"Error Handling Demonstration:\")\n    print(\"-\" * 50)\n    try:\n        print(\"Attempting to calculate fibonacci(-5)...\")\n        result = fibonacci(-5)\n        print(f\"Result: {result}\")\n    except ValueError as e:\n        print(f\"Caught expected error: {e}\")\n    print()\n\n    print(\"All demonstrations completed successfully!\")\n\n\nif __name__ == \"__main__\":\n    main()",
      "file_type": "source",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Entry point demonstrating fibonacci function usage with example calls and output"
    }
  ],
  "file_structure": {
    "src": [
      "fibonacci_validator.py",
      "fibonacci_calculator.py",
      "fibonacci.py"
    ],
    "tests": [
      "test_fibonacci_validator.py",
      "test_fibonacci_calculator.py",
      "test_fibonacci.py",
      "test_design_review.py"
    ],
    ".": [
      "requirements.txt",
      ".env.example",
      "pytest.ini",
      ".pylintrc",
      "README.md",
      "DESIGN.md",
      "main.py"
    ]
  },
  "implementation_notes": "Generated using multi-stage approach with 14 files. Manifest estimated 1053 LOC, actual 1606 LOC. Uses 1 external dependencies.",
  "dependencies": [
    "pytest==7.4.3"
  ],
  "setup_instructions": "1. Install Python 3.12+\\n2. pip install -r requirements.txt\\n3. Run tests: pytest tests/ -v\\n4. Run example: python main.py\\n5. Lint code: pylint src/ tests/",
  "total_lines_of_code": 1606,
  "total_files": 14,
  "test_coverage_target": 80.0,
  "semantic_units_implemented": [
    "SU-003",
    "SU-001",
    "SU-002"
  ],
  "components_implemented": [
    "FibonacciCalculator",
    "FibonacciFunction",
    "FibonacciValidator"
  ],
  "agent_version": "1.0.0",
  "generation_timestamp": "2025-11-22T03:27:39.865599"
}