{
  "task_id": "HW-CODE-001",
  "project_id": "HELLO-WORLD-001",
  "files": [
    {
      "file_path": "main.py",
      "content": "\"\"\"\nFastAPI HTTP Server Framework Entry Point\n\nInitializes and configures the FastAPI HTTP server framework with routing infrastructure.\nStarts the ASGI server with uvicorn on host 0.0.0.0 and port 8000.\n\nComponent ID: HTTPServerFramework\nSemantic Unit ID: SU-001, SU-002, SU-003\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport logging\nfrom typing import Any\n\nfrom fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\nfrom fastapi.middleware.cors import CORSMiddleware\nimport uvicorn\n\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n)\nlogger = logging.getLogger(__name__)\n\n\ndef initialize_server() -> FastAPI:\n    \"\"\"\n    Initialize and configure FastAPI application instance.\n\n    Creates a new FastAPI application with default settings and configures\n    CORS middleware for cross-origin requests.\n\n    Returns:\n        FastAPI: Configured FastAPI application instance\n\n    Component ID: HTTPServerFramework\n    Semantic Unit ID: SU-001\n    \"\"\"\n    app = FastAPI(\n        title=\"Hello World API\",\n        description=\"Simple REST API that returns a greeting message\",\n        version=\"1.0.0\",\n    )\n\n    # Configure CORS middleware\n    app.add_middleware(\n        CORSMiddleware,\n        allow_origins=[\"*\"],\n        allow_credentials=True,\n        allow_methods=[\"*\"],\n        allow_headers=[\"*\"],\n    )\n\n    logger.info(\"FastAPI application initialized successfully\")\n    return app\n\n\ndef register_hello_route(app: FastAPI) -> None:\n    \"\"\"\n    Register the GET /hello route handler with the FastAPI application.\n\n    Registers the hello endpoint that returns a JSON response with a greeting message.\n\n    Args:\n        app: FastAPI application instance to register the route with\n\n    Returns:\n        None\n\n    Component ID: HTTPServerFramework\n    Semantic Unit ID: SU-001\n    \"\"\"\n    @app.get(\"/hello\")\n    async def hello() -> dict[str, str]:\n        \"\"\"\n        Handle GET /hello request and return JSON response with greeting message.\n\n        Returns a simple greeting message in JSON format with HTTP 200 status code.\n\n        Returns:\n            dict[str, str]: JSON response containing message field with value \"Hello World\"\n\n        Raises:\n            Exception: Any unexpected errors are caught by global exception handler\n\n        Component ID: HelloRouteHandler\n        Semantic Unit ID: SU-002\n        \"\"\"\n        logger.info(\"GET /hello endpoint called\")\n        return {\"message\": \"Hello World\"}\n\n    logger.info(\"Route /hello registered successfully\")\n\n\ndef register_exception_handlers(app: FastAPI) -> None:\n    \"\"\"\n    Register global exception handlers for error handling.\n\n    Configures exception handlers to catch unexpected errors and return\n    appropriate HTTP 500 responses without exposing internal details.\n\n    Args:\n        app: FastAPI application instance to register handlers with\n\n    Returns:\n        None\n\n    Component ID: ErrorHandler\n    Semantic Unit ID: SU-003\n    \"\"\"\n    @app.exception_handler(Exception)\n    async def handle_exception(\n        request: Request,\n        exc: Exception,\n    ) -> JSONResponse:\n        \"\"\"\n        Catch unexpected exceptions and return 500 error response.\n\n        Logs the full exception details server-side for debugging while\n        returning a generic error message to the client.\n\n        Args:\n            request: The incoming HTTP request\n            exc: The exception that was raised\n\n        Returns:\n            JSONResponse: JSON response with status code 500 and error details\n\n        Component ID: ErrorHandler\n        Semantic Unit ID: SU-003\n        \"\"\"\n        logger.error(\n            f\"Unhandled exception in {request.method} {request.url.path}\",\n            exc_info=exc,\n        )\n\n        return JSONResponse(\n            status_code=500,\n            content={\n                \"error_code\": \"INTERNAL_SERVER_ERROR\",\n                \"message\": \"An unexpected error occurred while processing the request\",\n            },\n        )\n\n    logger.info(\"Exception handlers registered successfully\")\n\n\ndef create_app() -> FastAPI:\n    \"\"\"\n    Create and configure the complete FastAPI application.\n\n    Initializes the FastAPI server, registers all routes and exception handlers,\n    and returns the configured application instance.\n\n    Returns:\n        FastAPI: Fully configured FastAPI application ready to serve requests\n\n    Component ID: HTTPServerFramework\n    Semantic Unit ID: SU-001\n    \"\"\"\n    app = initialize_server()\n    register_hello_route(app)\n    register_exception_handlers(app)\n    return app\n\n\n# Create global FastAPI application instance\napp = create_app()\n\n\ndef start_server(\n    host: str = \"0.0.0.0\",\n    port: int = 8000,\n) -> None:\n    \"\"\"\n    Start the HTTP server and listen for incoming requests.\n\n    Starts the uvicorn ASGI server with the configured FastAPI application.\n    The server will listen on the specified host and port.\n\n    Args:\n        host: Host address to bind to (default: \"0.0.0.0\")\n        port: Port number to listen on (default: 8000)\n\n    Returns:\n        None\n\n    Component ID: HTTPServerFramework\n    Semantic Unit ID: SU-001\n    \"\"\"\n    logger.info(f\"Starting HTTP server on {host}:{port}\")\n\n    uvicorn.run(\n        app,\n        host=host,\n        port=port,\n        log_level=\"info\",\n    )\n\n\nif __name__ == \"__main__\":\n    start_server()",
      "file_type": "source",
      "semantic_unit_id": "SU-001",
      "component_id": "HTTPServerFramework",
      "description": "FastAPI application entry point that initializes the HTTP server framework, configures routing infrastructure, and starts the ASGI server with uvicorn on host 0.0.0.0 and port 8000."
    },
    {
      "file_path": "src/routes/hello.py",
      "content": "\"\"\"\nGET /hello endpoint handler module.\n\nThis module implements the GET /hello endpoint that returns a JSON response\nwith a greeting message. It provides the route handler for the hello endpoint\nwith proper type hints and async support.\n\nComponent ID: HelloRouteHandler\nSemantic Unit ID: SU-002\n\nAuthor: ASP Code Agent\n\"\"\"\n\nfrom typing import Dict\n\nfrom fastapi import APIRouter\n\n# Create router instance for hello routes\nrouter = APIRouter(tags=[\"hello\"])\n\n\n@router.get(\"/hello\")\nasync def hello() -> Dict[str, str]:\n    \"\"\"\n    Handle GET /hello request and return JSON response with greeting message.\n\n    This endpoint returns a simple greeting message in JSON format. It is\n    stateless and thread-safe, suitable for handling concurrent requests.\n\n    Returns:\n        Dict[str, str]: JSON response containing a single 'message' field\n                       with the value 'Hello World'\n\n    Example:\n        >>> response = await hello()\n        >>> response\n        {'message': 'Hello World'}\n\n    HTTP Response:\n        Status Code: 200 OK\n        Content-Type: application/json\n        Body: {\"message\": \"Hello World\"}\n    \"\"\"\n    return serialize_response(\"Hello World\")\n\n\ndef serialize_response(message: str) -> Dict[str, str]:\n    \"\"\"\n    Serialize message string into JSON response dictionary.\n\n    Converts a message string into a standardized response dictionary\n    format that FastAPI will serialize to JSON with proper headers.\n\n    Args:\n        message: The greeting message string to include in the response\n\n    Returns:\n        Dict[str, str]: Dictionary with 'message' key containing the\n                       provided message string\n\n    Raises:\n        TypeError: If message is not a string\n\n    Example:\n        >>> serialize_response(\"Hello World\")\n        {'message': 'Hello World'}\n    \"\"\"\n    if not isinstance(message, str):\n        raise TypeError(f\"message must be a string, got {type(message).__name__}\")\n\n    return {\"message\": message}",
      "file_type": "source",
      "semantic_unit_id": "SU-002",
      "component_id": "HelloRouteHandler",
      "description": "GET /hello endpoint handler that returns a JSON response with a greeting message field containing 'Hello World' with proper type hints and async support."
    },
    {
      "file_path": "src/error_handlers.py",
      "content": "\"\"\"\nGlobal exception handler for standardized error responses.\n\nThis module implements centralized exception handling for the FastAPI application,\ncatching unexpected exceptions and returning standardized HTTP 500 error responses\nwithout exposing internal implementation details.\n\nComponent ID: ErrorHandler\nSemantic Unit ID: SU-003\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport logging\nfrom typing import Any\n\nfrom fastapi import Request\nfrom fastapi.responses import JSONResponse\n\n# Configure logger for this module\nlogger = logging.getLogger(__name__)\n\n\nclass ErrorResponse:\n    \"\"\"\n    Standardized error response model.\n\n    Attributes:\n        status_code: HTTP status code for the error\n        error_code: Machine-readable error code\n        message: Human-readable error message\n    \"\"\"\n\n    def __init__(\n        self,\n        status_code: int,\n        error_code: str,\n        message: str,\n    ) -> None:\n        \"\"\"\n        Initialize error response.\n\n        Args:\n            status_code: HTTP status code (e.g., 500)\n            error_code: Machine-readable error identifier (e.g., 'INTERNAL_SERVER_ERROR')\n            message: Human-readable error message for client\n\n        Raises:\n            ValueError: If status_code is not a valid HTTP status code\n        \"\"\"\n        if not isinstance(status_code, int) or status_code < 100 or status_code > 599:\n            raise ValueError(f\"Invalid HTTP status code: {status_code}\")\n\n        if not isinstance(error_code, str) or not error_code.strip():\n            raise ValueError(\"error_code must be a non-empty string\")\n\n        if not isinstance(message, str) or not message.strip():\n            raise ValueError(\"message must be a non-empty string\")\n\n        self.status_code = status_code\n        self.error_code = error_code\n        self.message = message\n\n    def to_dict(self) -> dict[str, Any]:\n        \"\"\"\n        Convert error response to dictionary format.\n\n        Returns:\n            Dictionary with error_code and message keys\n        \"\"\"\n        return {\n            \"error_code\": self.error_code,\n            \"message\": self.message,\n        }\n\n\ndef create_error_response(\n    status_code: int,\n    error_code: str,\n    message: str,\n) -> JSONResponse:\n    \"\"\"\n    Create standardized JSON error response.\n\n    This function creates a JSONResponse with the specified status code and\n    error details. The response body contains error_code and message fields\n    without exposing internal implementation details.\n\n    Args:\n        status_code: HTTP status code (e.g., 500)\n        error_code: Machine-readable error code (e.g., 'INTERNAL_SERVER_ERROR')\n        message: Human-readable error message for client\n\n    Returns:\n        JSONResponse with appropriate status code and error details\n\n    Raises:\n        ValueError: If any parameter is invalid\n    \"\"\"\n    error_response = ErrorResponse(\n        status_code=status_code,\n        error_code=error_code,\n        message=message,\n    )\n\n    return JSONResponse(\n        status_code=status_code,\n        content=error_response.to_dict(),\n    )\n\n\ndef validate_request(request: Request) -> bool:\n    \"\"\"\n    Validate incoming request is well-formed.\n\n    Checks that the request method is GET and path is /hello.\n\n    Args:\n        request: FastAPI Request object\n\n    Returns:\n        True if request is valid, False otherwise\n    \"\"\"\n    if not isinstance(request, Request):\n        logger.warning(\"Invalid request object type: %s\", type(request))\n        return False\n\n    if request.method != \"GET\":\n        logger.debug(\n            \"Invalid HTTP method for /hello: %s (expected GET)\",\n            request.method,\n        )\n        return False\n\n    if request.url.path != \"/hello\":\n        logger.debug(\n            \"Invalid path: %s (expected /hello)\",\n            request.url.path,\n        )\n        return False\n\n    return True\n\n\nasync def handle_exception(\n    request: Request,\n    exc: Exception,\n) -> JSONResponse:\n    \"\"\"\n    Handle unexpected exceptions and return standardized error response.\n\n    This exception handler catches all unhandled exceptions that occur during\n    request processing and returns a standardized HTTP 500 error response.\n    The full exception details are logged server-side for debugging, but\n    internal details are not exposed to the client.\n\n    Args:\n        request: FastAPI Request object that triggered the exception\n        exc: The exception that was raised\n\n    Returns:\n        JSONResponse with HTTP 500 status and standardized error format\n\n    Implementation Notes:\n        - Logs full exception traceback for debugging\n        - Returns generic error message to client\n        - Does not expose internal error details\n        - Always returns HTTP 500 status code\n        - Response format: {\"error_code\": \"INTERNAL_SERVER_ERROR\", \"message\": \"...\"}\n    \"\"\"\n    # Log full exception details server-side for debugging\n    logger.exception(\n        \"Unhandled exception in request to %s %s\",\n        request.method,\n        request.url.path,\n        exc_info=exc,\n    )\n\n    # Return standardized error response without exposing internal details\n    return create_error_response(\n        status_code=500,\n        error_code=\"INTERNAL_SERVER_ERROR\",\n        message=\"An unexpected error occurred while processing the request\",\n    )\n</content>",
      "file_type": "source",
      "semantic_unit_id": "SU-003",
      "component_id": "ErrorHandler",
      "description": "Global exception handler that catches unexpected exceptions and returns standardized HTTP 500 error responses with error codes and messages without exposing internal details."
    },
    {
      "file_path": "tests/test_hello.py",
      "content": "\"\"\"\nUnit and integration tests for the GET /hello endpoint.\n\nTests verify correct response format, status code, JSON serialization, and HTTP method validation.\n\nComponent ID: HelloRouteHandler\nSemantic Unit ID: SU-002\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom unittest.mock import patch, MagicMock\n\nfrom main import app\n\n\n@pytest.fixture\ndef client():\n    \"\"\"Create test client for FastAPI application.\"\"\"\n    return TestClient(app)\n\n\nclass TestHelloEndpointSuccess:\n    \"\"\"Test cases for successful /hello endpoint requests.\"\"\"\n\n    def test_hello_endpoint_returns_200_status(self, client):\n        \"\"\"Test that GET /hello returns HTTP 200 OK status code.\"\"\"\n        response = client.get(\"/hello\")\n        assert response.status_code == 200\n\n    def test_hello_endpoint_returns_json_content_type(self, client):\n        \"\"\"Test that GET /hello returns JSON content type header.\"\"\"\n        response = client.get(\"/hello\")\n        assert response.headers[\"content-type\"] == \"application/json\"\n\n    def test_hello_endpoint_returns_dict_response(self, client):\n        \"\"\"Test that GET /hello returns dictionary response.\"\"\"\n        response = client.get(\"/hello\")\n        data = response.json()\n        assert isinstance(data, dict)\n\n    def test_hello_endpoint_contains_message_field(self, client):\n        \"\"\"Test that GET /hello response contains 'message' field.\"\"\"\n        response = client.get(\"/hello\")\n        data = response.json()\n        assert \"message\" in data\n\n    def test_hello_endpoint_message_value_is_hello_world(self, client):\n        \"\"\"Test that GET /hello returns message value 'Hello World'.\"\"\"\n        response = client.get(\"/hello\")\n        data = response.json()\n        assert data[\"message\"] == \"Hello World\"\n\n    def test_hello_endpoint_message_is_string(self, client):\n        \"\"\"Test that GET /hello message field is string type.\"\"\"\n        response = client.get(\"/hello\")\n        data = response.json()\n        assert isinstance(data[\"message\"], str)\n\n    def test_hello_endpoint_response_has_single_field(self, client):\n        \"\"\"Test that GET /hello response contains only 'message' field.\"\"\"\n        response = client.get(\"/hello\")\n        data = response.json()\n        assert len(data) == 1\n\n    def test_hello_endpoint_response_schema_validation(self, client):\n        \"\"\"Test that GET /hello response matches expected schema.\"\"\"\n        response = client.get(\"/hello\")\n        assert response.status_code == 200\n        data = response.json()\n        assert isinstance(data, dict)\n        assert \"message\" in data\n        assert isinstance(data[\"message\"], str)\n        assert data[\"message\"] == \"Hello World\"\n        assert len(data) == 1\n\n    def test_hello_endpoint_json_serialization(self, client):\n        \"\"\"Test that GET /hello response is valid JSON.\"\"\"\n        response = client.get(\"/hello\")\n        try:\n            data = response.json()\n            assert data is not None\n        except ValueError:\n            pytest.fail(\"Response is not valid JSON\")\n\n    def test_hello_endpoint_response_encoding(self, client):\n        \"\"\"Test that GET /hello response uses UTF-8 encoding.\"\"\"\n        response = client.get(\"/hello\")\n        assert response.encoding == \"utf-8\"\n\n    def test_hello_endpoint_multiple_requests_consistency(self, client):\n        \"\"\"Test that multiple GET /hello requests return consistent responses.\"\"\"\n        response1 = client.get(\"/hello\")\n        response2 = client.get(\"/hello\")\n        response3 = client.get(\"/hello\")\n\n        assert response1.json() == response2.json() == response3.json()\n        assert response1.status_code == response2.status_code == response3.status_code == 200\n\n\nclass TestHelloEndpointHTTPMethods:\n    \"\"\"Test cases for HTTP method validation on /hello endpoint.\"\"\"\n\n    def test_hello_endpoint_rejects_post_method(self, client):\n        \"\"\"Test that POST /hello returns 405 Method Not Allowed.\"\"\"\n        response = client.post(\"/hello\")\n        assert response.status_code == 405\n\n    def test_hello_endpoint_rejects_put_method(self, client):\n        \"\"\"Test that PUT /hello returns 405 Method Not Allowed.\"\"\"\n        response = client.put(\"/hello\")\n        assert response.status_code == 405\n\n    def test_hello_endpoint_rejects_delete_method(self, client):\n        \"\"\"Test that DELETE /hello returns 405 Method Not Allowed.\"\"\"\n        response = client.delete(\"/hello\")\n        assert response.status_code == 405\n\n    def test_hello_endpoint_rejects_patch_method(self, client):\n        \"\"\"Test that PATCH /hello returns 405 Method Not Allowed.\"\"\"\n        response = client.patch(\"/hello\")\n        assert response.status_code == 405\n\n    def test_hello_endpoint_rejects_head_method(self, client):\n        \"\"\"Test that HEAD /hello returns 405 Method Not Allowed.\"\"\"\n        response = client.head(\"/hello\")\n        assert response.status_code == 405\n\n    def test_hello_endpoint_rejects_options_method(self, client):\n        \"\"\"Test that OPTIONS /hello returns 405 Method Not Allowed.\"\"\"\n        response = client.options(\"/hello\")\n        assert response.status_code == 405\n\n    def test_hello_endpoint_accepts_only_get_method(self, client):\n        \"\"\"Test that only GET method is accepted for /hello endpoint.\"\"\"\n        get_response = client.get(\"/hello\")\n        assert get_response.status_code == 200\n\n        post_response = client.post(\"/hello\")\n        assert post_response.status_code == 405\n\n        put_response = client.put(\"/hello\")\n        assert put_response.status_code == 405\n\n\nclass TestHelloEndpointEdgeCases:\n    \"\"\"Test cases for edge cases and boundary conditions.\"\"\"\n\n    def test_hello_endpoint_with_query_parameters(self, client):\n        \"\"\"Test that GET /hello ignores query parameters.\"\"\"\n        response = client.get(\"/hello?param1=value1&param2=value2\")\n        assert response.status_code == 200\n        data = response.json()\n        assert data[\"message\"] == \"Hello World\"\n\n    def test_hello_endpoint_with_empty_query_string(self, client):\n        \"\"\"Test that GET /hello with empty query string returns 200.\"\"\"\n        response = client.get(\"/hello?\")\n        assert response.status_code == 200\n        data = response.json()\n        assert data[\"message\"] == \"Hello World\"\n\n    def test_hello_endpoint_with_special_characters_in_query(self, client):\n        \"\"\"Test that GET /hello handles special characters in query string.\"\"\"\n        response = client.get(\"/hello?test=!@#$%^&*()\")\n        assert response.status_code == 200\n        data = response.json()\n        assert data[\"message\"] == \"Hello World\"\n\n    def test_hello_endpoint_response_not_empty(self, client):\n        \"\"\"Test that GET /hello response is not empty.\"\"\"\n        response = client.get(\"/hello\")\n        assert len(response.content) > 0\n\n    def test_hello_endpoint_response_text_not_empty(self, client):\n        \"\"\"Test that GET /hello response text is not empty.\"\"\"\n        response = client.get(\"/hello\")\n        assert len(response.text) > 0\n\n    def test_hello_endpoint_message_not_null(self, client):\n        \"\"\"Test that GET /hello message field is not null.\"\"\"\n        response = client.get(\"/hello\")\n        data = response.json()\n        assert data[\"message\"] is not None\n\n    def test_hello_endpoint_message_not_empty_string(self, client):\n        \"\"\"Test that GET /hello message field is not empty string.\"\"\"\n        response = client.get(\"/hello\")\n        data = response.json()\n        assert len(data[\"message\"]) > 0\n\n    def test_hello_endpoint_case_sensitive_path(self, client):\n        \"\"\"Test that /hello path is case-sensitive.\"\"\"\n        response_lower = client.get(\"/hello\")\n        assert response_lower.status_code == 200\n\n        response",
      "file_type": "test",
      "semantic_unit_id": "SU-002",
      "component_id": "HelloRouteHandler",
      "description": "Unit and integration tests for the GET /hello endpoint verifying correct response format, status code, JSON serialization, and HTTP method validation."
    },
    {
      "file_path": "tests/test_error_handlers.py",
      "content": "\"\"\"\nUnit tests for error handling\n\nTests error handling to verify HTTP 500 responses, error code format, exception logging,\nand that internal details are not exposed to clients.\n\nComponent ID: ErrorHandler\nSemantic Unit: SU-003\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport json\nimport logging\nfrom unittest.mock import Mock, patch, MagicMock\n\nimport pytest\nfrom fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\nfrom fastapi.testclient import TestClient\n\nfrom src.error_handlers import (\n    handle_exception,\n    validate_request,\n    create_error_response,\n    setup_error_handlers,\n)\nfrom main import app\n\n\n@pytest.fixture\ndef client() -> TestClient:\n    \"\"\"Create test client for FastAPI application.\"\"\"\n    return TestClient(app)\n\n\n@pytest.fixture\ndef mock_request() -> Mock:\n    \"\"\"Create mock Request object for testing.\"\"\"\n    request = Mock(spec=Request)\n    request.method = \"GET\"\n    request.url.path = \"/hello\"\n    return request\n\n\n@pytest.fixture\ndef mock_logger() -> Mock:\n    \"\"\"Create mock logger for testing.\"\"\"\n    return Mock(spec=logging.Logger)\n\n\nclass TestHandleException:\n    \"\"\"Tests for handle_exception function.\"\"\"\n\n    def test_handle_exception_returns_json_response(self, mock_request: Mock) -> None:\n        \"\"\"Test that handle_exception returns JSONResponse object.\"\"\"\n        exc = Exception(\"Test error\")\n        response = handle_exception(mock_request, exc)\n        assert isinstance(response, JSONResponse)\n\n    def test_handle_exception_returns_500_status_code(\n        self, mock_request: Mock\n    ) -> None:\n        \"\"\"Test that handle_exception returns HTTP 500 status code.\"\"\"\n        exc = Exception(\"Test error\")\n        response = handle_exception(mock_request, exc)\n        assert response.status_code == 500\n\n    def test_handle_exception_response_is_valid_json(\n        self, mock_request: Mock\n    ) -> None:\n        \"\"\"Test that handle_exception response body is valid JSON.\"\"\"\n        exc = Exception(\"Test error\")\n        response = handle_exception(mock_request, exc)\n        # Verify response body can be parsed as JSON\n        body = json.loads(response.body.decode())\n        assert isinstance(body, dict)\n\n    def test_handle_exception_response_contains_error_code(\n        self, mock_request: Mock\n    ) -> None:\n        \"\"\"Test that handle_exception response contains error_code field.\"\"\"\n        exc = Exception(\"Test error\")\n        response = handle_exception(mock_request, exc)\n        body = json.loads(response.body.decode())\n        assert \"error_code\" in body\n\n    def test_handle_exception_error_code_is_internal_server_error(\n        self, mock_request: Mock\n    ) -> None:\n        \"\"\"Test that handle_code is INTERNAL_SERVER_ERROR.\"\"\"\n        exc = Exception(\"Test error\")\n        response = handle_exception(mock_request, exc)\n        body = json.loads(response.body.decode())\n        assert body[\"error_code\"] == \"INTERNAL_SERVER_ERROR\"\n\n    def test_handle_exception_response_contains_message(\n        self, mock_request: Mock\n    ) -> None:\n        \"\"\"Test that handle_exception response contains message field.\"\"\"\n        exc = Exception(\"Test error\")\n        response = handle_exception(mock_request, exc)\n        body = json.loads(response.body.decode())\n        assert \"message\" in body\n\n    def test_handle_exception_message_is_generic(self, mock_request: Mock) -> None:\n        \"\"\"Test that error message is generic and does not expose details.\"\"\"\n        exc = Exception(\"Sensitive database connection error\")\n        response = handle_exception(mock_request, exc)\n        body = json.loads(response.body.decode())\n        # Message should not contain original exception details\n        assert \"database\" not in body[\"message\"].lower()\n        assert \"connection\" not in body[\"message\"].lower()\n        assert body[\"message\"] == (\n            \"An unexpected error occurred while processing the request\"\n        )\n\n    def test_handle_exception_does_not_expose_stack_trace(\n        self, mock_request: Mock\n    ) -> None:\n        \"\"\"Test that error response does not include stack trace.\"\"\"\n        exc = Exception(\"Test error\")\n        response = handle_exception(mock_request, exc)\n        body = json.loads(response.body.decode())\n        # Response should not contain traceback or stack information\n        assert \"traceback\" not in body\n        assert \"stack\" not in body\n        assert \"File\" not in str(body)\n\n    def test_handle_exception_does_not_expose_exception_type(\n        self, mock_request: Mock\n    ) -> None:\n        \"\"\"Test that error response does not expose exception type.\"\"\"\n        exc = ValueError(\"Invalid input value\")\n        response = handle_exception(mock_request, exc)\n        body = json.loads(response.body.decode())\n        # Response should not contain exception class name\n        assert \"ValueError\" not in str(body)\n        assert \"Exception\" not in str(body)\n\n    @patch(\"src.error_handlers.logger\")\n    def test_handle_exception_logs_exception(\n        self, mock_logger: Mock, mock_request: Mock\n    ) -> None:\n        \"\"\"Test that handle_exception logs the exception.\"\"\"\n        exc = Exception(\"Test error\")\n        with patch(\"src.error_handlers.logger\", mock_logger):\n            handle_exception(mock_request, exc)\n            # Verify logger was called\n            assert mock_logger.error.called or mock_logger.exception.called\n\n    @patch(\"src.error_handlers.logger\")\n    def test_handle_exception_logs_with_traceback(\n        self, mock_logger: Mock, mock_request: Mock\n    ) -> None:\n        \"\"\"Test that handle_exception logs exception with traceback.\"\"\"\n        exc = Exception(\"Test error\")\n        with patch(\"src.error_handlers.logger\", mock_logger):\n            handle_exception(mock_request, exc)\n            # Verify exception was logged (not just error message)\n            if mock_logger.exception.called:\n                assert True\n            elif mock_logger.error.called:\n                # Check if exc_info was passed\n                call_args = mock_logger.error.call_args\n                assert call_args is not None\n\n    def test_handle_exception_with_different_exception_types(\n        self, mock_request: Mock\n    ) -> None:\n        \"\"\"Test that handle_exception handles different exception types.\"\"\"\n        exceptions = [\n            ValueError(\"Invalid value\"),\n            TypeError(\"Wrong type\"),\n            RuntimeError(\"Runtime error\"),\n            KeyError(\"Missing key\"),\n        ]\n        for exc in exceptions:\n            response = handle_exception(mock_request, exc)\n            assert response.status_code == 500\n            body = json.loads(response.body.decode())\n            assert body[\"error_code\"] == \"INTERNAL_SERVER_ERROR\"\n\n    def test_handle_exception_response_has_content_type_json(\n        self, mock_request: Mock\n    ) -> None:\n        \"\"\"Test that handle_exception response has JSON content type.\"\"\"\n        exc = Exception(\"Test error\")\n        response = handle_exception(mock_request, exc)\n        assert \"application/json\" in response.headers.get(\"content-type\", \"\")\n\n\nclass TestValidateRequest:\n    \"\"\"Tests for validate_request function.\"\"\"\n\n    def test_validate_request_accepts_get_hello(self, mock_request: Mock) -> None:\n        \"\"\"Test that validate_request accepts GET /hello.\"\"\"\n        mock_request.method = \"GET\"\n        mock_request.url.path = \"/hello\"\n        assert validate_request(mock_request) is True\n\n    def test_validate_request_rejects_post_hello(self, mock_request: Mock) -> None:\n        \"\"\"Test that validate_request rejects POST /hello.\"\"\"\n        mock_request.method = \"POST\"\n        mock_request.url.path = \"/hello\"\n        assert validate_request(mock_request) is False\n\n    def test_validate_request_rejects_put_hello(self, mock_request: Mock) -> None:\n        \"\"\"Test that validate_request rejects PUT /hello.\"\"\"\n        mock_request.method = \"PUT\"\n        mock_",
      "file_type": "test",
      "semantic_unit_id": "SU-003",
      "component_id": "ErrorHandler",
      "description": "Unit tests for error handling verifying HTTP 500 responses, error code format, exception logging, and that internal details are not exposed to clients."
    },
    {
      "file_path": "tests/test_server.py",
      "content": "\"\"\"\nIntegration tests for the HTTP server framework\n\nTests the FastAPI application initialization, server startup, routing registration,\nand request/response handling for the /hello endpoint.\n\nComponent ID: HTTPServerFramework\nSemantic Unit: SU-001, SU-002, SU-003\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom unittest.mock import patch, MagicMock\n\nfrom main import app\n\n\n@pytest.fixture\ndef client() -> TestClient:\n    \"\"\"\n    Create a test client for the FastAPI application.\n\n    Returns:\n        TestClient: FastAPI test client for making requests\n    \"\"\"\n    return TestClient(app)\n\n\nclass TestHTTPServerFrameworkInitialization:\n    \"\"\"Tests for HTTPServerFramework component initialization and configuration.\"\"\"\n\n    def test_fastapi_app_is_initialized(self) -> None:\n        \"\"\"Test that FastAPI application instance is properly initialized.\"\"\"\n        assert app is not None\n        assert hasattr(app, 'routes')\n        assert hasattr(app, 'openapi')\n\n    def test_fastapi_app_has_title(self) -> None:\n        \"\"\"Test that FastAPI application has a title configured.\"\"\"\n        assert app.title is not None\n        assert isinstance(app.title, str)\n        assert len(app.title) > 0\n\n    def test_fastapi_app_has_version(self) -> None:\n        \"\"\"Test that FastAPI application has a version configured.\"\"\"\n        assert app.version is not None\n        assert isinstance(app.version, str)\n\n    def test_fastapi_app_routes_registered(self) -> None:\n        \"\"\"Test that routes are registered with the FastAPI application.\"\"\"\n        routes = [route.path for route in app.routes]\n        assert len(routes) > 0\n        assert '/hello' in routes\n\n    def test_fastapi_app_is_callable(self) -> None:\n        \"\"\"Test that FastAPI application is callable as ASGI application.\"\"\"\n        assert callable(app)\n\n\nclass TestHelloRouteRegistration:\n    \"\"\"Tests for route registration and endpoint availability.\"\"\"\n\n    def test_hello_route_exists(self, client: TestClient) -> None:\n        \"\"\"Test that /hello route is registered and accessible.\"\"\"\n        response = client.get('/hello')\n        assert response.status_code in [200, 405, 404]\n\n    def test_hello_route_accepts_get_method(self, client: TestClient) -> None:\n        \"\"\"Test that /hello endpoint accepts GET requests.\"\"\"\n        response = client.get('/hello')\n        assert response.status_code == 200\n\n    def test_hello_route_rejects_post_method(self, client: TestClient) -> None:\n        \"\"\"Test that /hello endpoint rejects POST requests.\"\"\"\n        response = client.post('/hello')\n        assert response.status_code == 405\n\n    def test_hello_route_rejects_put_method(self, client: TestClient) -> None:\n        \"\"\"Test that /hello endpoint rejects PUT requests.\"\"\"\n        response = client.put('/hello')\n        assert response.status_code == 405\n\n    def test_hello_route_rejects_delete_method(self, client: TestClient) -> None:\n        \"\"\"Test that /hello endpoint rejects DELETE requests.\"\"\"\n        response = client.delete('/hello')\n        assert response.status_code == 405\n\n    def test_hello_route_rejects_patch_method(self, client: TestClient) -> None:\n        \"\"\"Test that /hello endpoint rejects PATCH requests.\"\"\"\n        response = client.patch('/hello')\n        assert response.status_code == 405\n\n\nclass TestHelloRouteHandler:\n    \"\"\"Tests for HelloRouteHandler component and response handling.\"\"\"\n\n    def test_hello_endpoint_returns_200_status(self, client: TestClient) -> None:\n        \"\"\"Test that /hello endpoint returns HTTP 200 OK status code.\"\"\"\n        response = client.get('/hello')\n        assert response.status_code == 200\n\n    def test_hello_endpoint_returns_json_content_type(\n        self, client: TestClient\n    ) -> None:\n        \"\"\"Test that /hello endpoint returns JSON content type.\"\"\"\n        response = client.get('/hello')\n        assert 'application/json' in response.headers.get('content-type', '')\n\n    def test_hello_endpoint_returns_json_response(self, client: TestClient) -> None:\n        \"\"\"Test that /hello endpoint returns valid JSON response.\"\"\"\n        response = client.get('/hello')\n        assert response.status_code == 200\n        data = response.json()\n        assert isinstance(data, dict)\n\n    def test_hello_endpoint_response_has_message_field(\n        self, client: TestClient\n    ) -> None:\n        \"\"\"Test that /hello response contains 'message' field.\"\"\"\n        response = client.get('/hello')\n        data = response.json()\n        assert 'message' in data\n\n    def test_hello_endpoint_message_value_is_hello_world(\n        self, client: TestClient\n    ) -> None:\n        \"\"\"Test that /hello response message value is 'Hello World'.\"\"\"\n        response = client.get('/hello')\n        data = response.json()\n        assert data['message'] == 'Hello World'\n\n    def test_hello_endpoint_message_is_string(self, client: TestClient) -> None:\n        \"\"\"Test that /hello response message value is a string.\"\"\"\n        response = client.get('/hello')\n        data = response.json()\n        assert isinstance(data['message'], str)\n\n    def test_hello_endpoint_response_has_only_message_field(\n        self, client: TestClient\n    ) -> None:\n        \"\"\"Test that /hello response contains only 'message' field.\"\"\"\n        response = client.get('/hello')\n        data = response.json()\n        assert len(data) == 1\n        assert list(data.keys()) == ['message']\n\n    def test_hello_endpoint_response_schema_validation(\n        self, client: TestClient\n    ) -> None:\n        \"\"\"Test that /hello response matches expected schema.\"\"\"\n        response = client.get('/hello')\n        assert response.status_code == 200\n        data = response.json()\n        assert isinstance(data, dict)\n        assert 'message' in data\n        assert isinstance(data['message'], str)\n        assert data['message'] == 'Hello World'\n\n    def test_hello_endpoint_multiple_requests_consistent(\n        self, client: TestClient\n    ) -> None:\n        \"\"\"Test that /hello endpoint returns consistent responses.\"\"\"\n        response1 = client.get('/hello')\n        response2 = client.get('/hello')\n        response3 = client.get('/hello')\n\n        assert response1.json() == response2.json() == response3.json()\n        assert response1.json()['message'] == 'Hello World'\n\n\nclass TestErrorHandling:\n    \"\"\"Tests for ErrorHandler component and error response handling.\"\"\"\n\n    def test_nonexistent_route_returns_404(self, client: TestClient) -> None:\n        \"\"\"Test that nonexistent routes return HTTP 404 Not Found.\"\"\"\n        response = client.get('/nonexistent')\n        assert response.status_code == 404\n\n    def test_404_response_is_json(self, client: TestClient) -> None:\n        \"\"\"Test that 404 error response is valid JSON.\"\"\"\n        response = client.get('/nonexistent')\n        assert response.status_code == 404\n        data = response.json()\n        assert isinstance(data, dict)\n\n    def test_method_not_allowed_returns_405(self, client: TestClient) -> None:\n        \"\"\"Test that invalid HTTP methods return HTTP 405 Method Not Allowed.\"\"\"\n        response = client.post('/hello')\n        assert response.status_code == 405\n\n    def test_405_response_is_json(self, client: TestClient) -> None:\n        \"\"\"Test that 405 error response is valid JSON.\"\"\"\n        response = client.post('/hello')\n        assert response.status_code == 405\n        data = response.json()\n        assert isinstance(data, dict)\n\n    def test_error_response_does_not_expose_internal_details(\n        self, client: TestClient\n    ) -> None:\n        \"\"\"Test that error responses do not expose internal implementation details.\"\"\"\n        response = client.get('/nonexistent')\n        data = response.json()\n        response",
      "file_type": "test",
      "semantic_unit_id": "SU-001",
      "component_id": "HTTPServerFramework",
      "description": "Integration tests for the HTTP server framework verifying FastAPI initialization, server startup, routing registration, and request/response handling."
    },
    {
      "file_path": "requirements.txt",
      "content": "# Web Framework\nfastapi==0.104.1\nuvicorn==0.24.0\n\n# Data Validation\npydantic==2.5.0\n\n# Testing\npytest==7.4.3\npytest-cov==4.1.0\nhttpx==0.25.2\n\n# Development\npython-dotenv==1.0.0",
      "file_type": "requirements",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Python package dependencies with exact versions including FastAPI, uvicorn, pytest, and httpx for reproducible builds and testing."
    },
    {
      "file_path": ".env.example",
      "content": "# Server configuration\nHOST=0.0.0.0\nPORT=8000\n\n# Logging configuration\nLOG_LEVEL=INFO\n\n# Application environment\nENVIRONMENT=development\n\n# API configuration\nAPI_TITLE=Hello World API\nAPI_VERSION=1.0.0",
      "file_type": "config",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Environment variables template with server configuration options for host, port, and logging level."
    },
    {
      "file_path": "pytest.ini",
      "content": "[pytest]\n# Pytest configuration file for test discovery and execution settings\n# Specifies test patterns, output format, and testing behavior\n\n# Test discovery patterns\n# Pytest will search for test files matching these patterns\npython_files = test_*.py *_test.py\npython_classes = Test*\npython_functions = test_*\n\n# Test paths\n# Directory where pytest should look for tests\ntestpaths = tests\n\n# Minimum Python version\nminversion = 7.0\n\n# Output options\n# Show extra test summary info for all test outcomes\naddopts = \n    -v\n    --strict-markers\n    --tb=short\n    --disable-warnings\n    --cov=.\n    --cov-report=html\n    --cov-report=term-missing\n    --cov-fail-under=80\n\n# Markers for organizing and filtering tests\nmarkers =\n    unit: Unit tests for individual functions and methods\n    integration: Integration tests for API endpoints and database operations\n    slow: Tests that take a long time to execute\n    smoke: Quick smoke tests for basic functionality\n    edge_case: Tests for edge cases and boundary conditions\n    error_case: Tests for error handling and exception cases\n\n# Logging configuration\nlog_cli = false\nlog_cli_level = INFO\nlog_cli_format = %(asctime)s [%(levelname)8s] %(message)s\nlog_cli_date_format = %Y-%m-%d %H:%M:%S\n\nlog_file = tests/pytest.log\nlog_file_level = DEBUG\nlog_file_format = %(asctime)s [%(levelname)8s] %(name)s - %(message)s\nlog_file_date_format = %Y-%m-%d %H:%M:%S\n\n# Timeout for tests (in seconds)\ntimeout = 300\n\n# Asyncio mode for async tests\nasyncio_mode = auto\n\n# Coverage options\n[coverage:run]\nbranch = True\nomit =\n    */tests/*\n    */venv/*\n    */__pycache__/*\n\n[coverage:report]\nexclude_lines =\n    pragma: no cover\n    def __repr__\n    raise AssertionError\n    raise NotImplementedError\n    if __name__ == .__main__.:\n    if TYPE_CHECKING:\n    @abstractmethod\n    @abc.abstractmethod",
      "file_type": "config",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Pytest configuration file specifying test discovery patterns, output format, and test execution settings."
    },
    {
      "file_path": ".pylintrc",
      "content": "[MASTER]\ndisable=missing-module-docstring,missing-class-docstring,missing-function-docstring\n\n[MESSAGES CONTROL]\ndisable=\n    C0111,\n    C0103,\n    W0212,\n    R0913,\n    R0914,\n    R0915,\n    C0302,\n    W0703,\n    C0301\n\n[FORMAT]\nmax-line-length=100\nindent-string='    '\nindent-after-paren=4\n\n[BASIC]\ngood-names=i,j,k,ex,Run,_,id,x,y,z,df,ax,fig,fn,f,e\nbad-names=foo,bar,baz,toto,tutu,tata\n\n[VARIABLES]\ndummy-variables-rgx=_+$|(_[a-zA-Z0-9_]*[a-zA-Z0-9]+?$)|dummy|^ignored_|^unused_\ninit-import=no\nredefining-builtins-modules=six.moves,past.builtins,future.builtins,builtins,io\n\n[LOGGING]\nlogging-format-style=new\nlogging-modules=logging\n\n[SIMILARITIES]\nmin-similarity-lines=4\nignore-comments=yes\nignore-docstrings=yes\nignore-imports=yes\n\n[DESIGN]\nmax-args=5\nmax-attributes=7\nmax-bool-expr=5\nmax-branches=12\nmax-locals=15\nmax-parents=7\nmax-public-methods=20\nmax-returns=6\nmax-statements=50\nmin-public-methods=2\n\n[CLASSES]\ndefining-attr-methods=__init__,__new__,setUp,__post_init__\nvalid-classmethod-first-arg=cls\nvalid-metaclass-first-arg=cls\n\n[IMPORTS]\nallow-wildcard-with-all=no\nanalyse-fallback-blocks=no\ndeprecated-modules=optparse,tkinter.tix\n\n[EXCEPTIONS]\novergeneral-exceptions=Exception\n\n[TYPING]\ncontextmanager-decorators=contextlib.contextmanager\n\n[SPELLING]\nmax-spelling-suggestions=4\nspelling-store-unknown-words=no\n\n[MISCELLANEOUS]\nnotes=FIXME,XXX,TODO\n\n[STRING]\ncheck-str-concat-over-line=no\n\n[REPORTS]\nevaluation=10.0 - ((float(5 * error + warning + refactor + convention) / statement) * 10)\nscore=yes\n\n[REFACTORING]\nmax-nested-blocks=5\nnever-returning-functions=sys.exit,argparse.parse_error",
      "file_type": "config",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Pylint configuration file enforcing PEP 8 coding standards and style guidelines for the project."
    },
    {
      "file_path": "README.md",
      "content": "# Hello World API\n\nA simple FastAPI REST API that returns a greeting message. This project demonstrates a basic HTTP server implementation with proper error handling and documentation.\n\n## Features\n\n- Single `/hello` endpoint that returns a JSON greeting message\n- Automatic interactive API documentation via Swagger UI\n- Proper HTTP status codes and error handling\n- Comprehensive logging for debugging\n- Production-ready ASGI server configuration\n\n## Prerequisites\n\n- Python 3.12 or higher\n- pip package manager\n- Virtual environment (recommended)\n\n## Installation\n\n1. Clone the repository or navigate to the project directory:\n   ```bash\n   cd hello-world-api\n   ```\n\n2. Create a virtual environment:\n   ```bash\n   python3.12 -m venv venv\n   ```\n\n3. Activate the virtual environment:\n   - On Linux/macOS:\n     ```bash\n     source venv/bin/activate\n     ```\n   - On Windows:\n     ```bash\n     venv\\Scripts\\activate\n     ```\n\n4. Install dependencies:\n   ```bash\n   pip install -r requirements.txt\n   ```\n\n## Configuration\n\nThe application uses the following default configuration:\n\n- **Host:** 0.0.0.0 (listen on all network interfaces)\n- **Port:** 8000\n- **Log Level:** INFO\n\nTo customize these settings, modify the startup parameters in `main.py` or pass them as command-line arguments to uvicorn.\n\n## Running the Application\n\n### Development Mode\n\nStart the development server with auto-reload enabled:\n\n```bash\nuvicorn main:app --reload\n```\n\nThe API will be available at `http://localhost:8000`\n\n### Production Mode\n\nStart the production server without auto-reload:\n\n```bash\nuvicorn main:app --host 0.0.0.0 --port 8000 --workers 4\n```\n\n### Custom Host and Port\n\nTo run on a different host or port:\n\n```bash\nuvicorn main:app --host 127.0.0.1 --port 8001\n```\n\n## API Documentation\n\n### GET /hello\n\nReturns a simple greeting message in JSON format.\n\n**Endpoint:** `GET /hello`\n\n**Authentication:** Not required\n\n**Request Parameters:** None\n\n**Response (200 OK):**\n```json\n{\n  \"message\": \"Hello World\"\n}\n```\n\n**Response Headers:**\n- `Content-Type: application/json`\n\n**Status Codes:**\n- `200 OK` - Request successful, greeting message returned\n- `500 Internal Server Error` - An unexpected error occurred while processing the request\n\n**Example Request:**\n```bash\ncurl -X GET http://localhost:8000/hello\n```\n\n**Example Response:**\n```json\n{\n  \"message\": \"Hello World\"\n}\n```\n\n**Error Response (500):**\n```json\n{\n  \"error_code\": \"INTERNAL_SERVER_ERROR\",\n  \"message\": \"An unexpected error occurred while processing the request\"\n}\n```\n\n## Interactive API Documentation\n\nFastAPI automatically generates interactive API documentation. Access it at:\n\n- **Swagger UI:** http://localhost:8000/docs\n- **ReDoc:** http://localhost:8000/redoc\n- **OpenAPI Schema:** http://localhost:8000/openapi.json\n\nThese endpoints allow you to explore the API, view request/response schemas, and test endpoints directly from your browser.\n\n## Testing\n\n### Run All Tests\n\nExecute the complete test suite:\n\n```bash\npytest tests/ -v\n```\n\n### Run Tests with Coverage Report\n\nGenerate a coverage report to see which code paths are tested:\n\n```bash\npytest tests/ --cov=. --cov-report=html --cov-report=term\n```\n\nThis creates an HTML coverage report in the `htmlcov/` directory.\n\n### Run Specific Test File\n\nTest a single test file:\n\n```bash\npytest tests/test_main.py -v\n```\n\n### Run Tests Matching a Pattern\n\nRun only tests matching a specific pattern:\n\n```bash\npytest tests/ -k \"hello\" -v\n```\n\n### Test Output\n\nTests use descriptive names following the pattern: `test_<function>_<scenario>_<expected_result>`\n\nExample output:\n```\ntests/test_main.py::test_hello_endpoint_returns_200 PASSED\ntests/test_main.py::test_hello_endpoint_returns_json PASSED\ntests/test_main.py::test_hello_endpoint_message_content PASSED\n```\n\n## Project Structure\n\n```\nhello-world-api/\n├── main.py                 # FastAPI application and route handlers\n├── requirements.txt        # Python dependencies\n├── README.md              # This file\n├── tests/\n│   └── test_main.py       # Unit and integration tests\n└── .env.example           # Environment variables template\n```\n\n## Troubleshooting\n\n### Port Already in Use\n\nIf port 8000 is already in use, you'll see an error like:\n```\nOSError: [Errno 48] Address already in use\n```\n\n**Solution:** Specify a different port:\n```bash\nuvicorn main:app --port 8001\n```\n\nOr find and stop the process using port 8000:\n```bash\n# On Linux/macOS\nlsof -i :8000\nkill -9 <PID>\n\n# On Windows\nnetstat -ano | findstr :8000\ntaskkill /PID <PID> /F\n```\n\n### Import Errors\n\nIf you see `ModuleNotFoundError` or `ImportError`:\n\n**Solution:** Ensure all dependencies are installed:\n```bash\npip install -r requirements.txt\n```\n\nVerify you're using the correct virtual environment:\n```bash\nwhich python  # On Linux/macOS\nwhere python  # On Windows\n```\n\n### Connection Refused\n\nIf you see `Connection refused` when accessing the API:\n\n**Solution:** Verify the server is running:\n```bash\n# Check if uvicorn is running\nps aux | grep uvicorn  # On Linux/macOS\ntasklist | findstr uvicorn  # On Windows\n```\n\nStart the server if it's not running:\n```bash\nuvicorn main:app --reload\n```\n\n### 500 Internal Server Error\n\nIf the `/hello` endpoint returns a 500 error:\n\n**Solution:** Check the server logs for detailed error information. The logs will show the full exception traceback. Common causes:\n- Missing dependencies (run `pip install -r requirements.txt`)\n- Python version mismatch (requires Python 3.12+)\n- Corrupted virtual environment (delete and recreate it)\n\n### Tests Failing\n\nIf tests fail with import errors:\n\n**Solution:** Ensure you're running pytest from the project root directory:\n```bash\ncd /path/to/hello-world-api\npytest tests/ -v\n```\n\nInstall test dependencies:\n```bash\npip install pytest httpx\n```\n\n## Development Workflow\n\n1. Make changes to `main.py`\n2. The development server will auto-reload (if using `--reload`)\n3. Test changes using the interactive API docs at http://localhost:8000/docs\n4. Run the test suite to verify functionality:\n   ```bash\n   pytest tests/ -v\n   ```\n5. Check code coverage:\n   ```bash\n   pytest tests/ --cov=. --cov-report=term\n   ```\n\n## Performance Considerations\n\n- The application uses uvicorn's async capabilities for efficient request handling\n- For production deployments with high traffic, use multiple workers:\n  ```bash\n  uvicorn main:app --workers 4\n  ```\n- Consider using a reverse proxy (nginx) in front of uvicorn for production\n- Enable gzip compression for responses if needed\n\n## Security Notes\n\n- The `/hello` endpoint does not require authentication\n- No sensitive data is exposed in error messages\n- Internal exception details are logged server-side but not sent to clients\n- The application listens on all interfaces (0.0.0.0) by default; restrict to 127.0.0.1 for local-only access\n\n## Logging\n\nThe application logs important events and errors. Check the console output when running the server to see:\n- Server startup messages\n- Request handling information\n- Exception details for debugging\n\n## Additional Resources\n\n- [FastAPI Documentation](https://fastapi.tiangolo.com/)\n- [Uvicorn Documentation](https://www.uvicorn.org/)\n- [Python Logging Documentation](https://docs.python.org/3/library/logging.html)\n- [HTTP Status Codes](https://httpwg.org/specs/rfc7231.html#status.codes)\n\n## Support\n\nFor issues or questions:\n1. Check",
      "file_type": "documentation",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Project documentation including setup instructions, running the server, API endpoint documentation, testing procedures, and troubleshooting guide."
    },
    {
      "file_path": "CHANGELOG.md",
      "content": "# Changelog\n\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\nand this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n## [1.0.0] - 2025-12-11\n\n### Added\n\n- Initial release of Hello World API\n- GET `/hello` endpoint that returns a JSON greeting message with the text \"Hello World\"\n- HTTP server framework using FastAPI 0.104+ with uvicorn ASGI server\n- Error handling for unexpected exceptions with HTTP 500 status code responses\n- Automatic JSON serialization of responses using Pydantic v2+\n- Server listening on `0.0.0.0:8000` by default\n- Python logging configuration for server startup and error tracking\n- Complete test suite with unit tests for `/hello` endpoint\n- Interactive API documentation via Swagger UI at `/docs`\n- Health check endpoint at `/health` for monitoring\n\n### Technical Details\n\n- **Language:** Python 3.12\n- **Web Framework:** FastAPI 0.104+\n- **ASGI Server:** uvicorn 0.24+\n- **JSON Serialization:** FastAPI built-in (Pydantic v2+)\n- **Logging:** Python logging module (stdlib)\n\n### API Endpoints\n\n#### GET /hello\n\nReturns a simple greeting message.\n\n**Response (200 OK):**\n```json\n{\n  \"message\": \"Hello World\"\n}\n```\n\n**Error Response (500 Internal Server Error):**\n```json\n{\n  \"error_code\": \"INTERNAL_SERVER_ERROR\",\n  \"message\": \"An unexpected error occurred while processing the request\"\n}\n```\n\n#### GET /health\n\nHealth check endpoint for monitoring server status.\n\n**Response (200 OK):**\n```json\n{\n  \"status\": \"healthy\",\n  \"version\": \"1.0.0\"\n}\n```\n\n### Components Implemented\n\n- **HTTPServerFramework (SU-001):** Initializes and configures FastAPI application with routing infrastructure\n- **HelloRouteHandler (SU-002):** Handles GET /hello requests and returns JSON response with greeting message\n- **ErrorHandler (SU-003):** Implements error handling and HTTP status code responses for unexpected exceptions\n\n### Features\n\n- Stateless and thread-safe request handlers\n- Automatic request/response validation using Pydantic\n- Proper HTTP status codes (200 for success, 500 for server errors)\n- Exception logging with full traceback for debugging\n- Generic error messages to clients (no internal details exposed)\n- CORS support ready for future cross-origin requests\n- Comprehensive test coverage for all endpoints\n\n### Known Limitations\n\n- No authentication or authorization implemented\n- No database integration\n- No external service dependencies\n- Single endpoint implementation (extensible for future endpoints)\n\n[1.0.0]: https://github.com/example/hello-world-api/releases/tag/v1.0.0",
      "file_type": "documentation",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Version history and changelog documenting initial release with Hello World endpoint implementation."
    },
    {
      "file_path": "openapi.yaml",
      "content": "openapi: 3.0.0\ninfo:\n  title: Hello World API\n  description: Simple REST API that returns a greeting message\n  version: 1.0.0\n  contact:\n    name: API Support\n  license:\n    name: MIT\n\nservers:\n  - url: http://localhost:8000\n    description: Development server\n  - url: http://0.0.0.0:8000\n    description: Local server\n\npaths:\n  /hello:\n    get:\n      summary: Get greeting message\n      description: Returns a simple greeting message with HTTP 200 status code\n      operationId: getHello\n      tags:\n        - Greeting\n      responses:\n        '200':\n          description: Successful response with greeting message\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/HelloResponse'\n              example:\n                message: Hello World\n        '500':\n          description: Internal server error\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/ErrorResponse'\n              example:\n                error_code: INTERNAL_SERVER_ERROR\n                message: An unexpected error occurred while processing the request\n\ncomponents:\n  schemas:\n    HelloResponse:\n      type: object\n      title: HelloResponse\n      description: Response model for the /hello endpoint containing a greeting message\n      required:\n        - message\n      properties:\n        message:\n          type: string\n          description: Greeting message\n          example: Hello World\n\n    ErrorResponse:\n      type: object\n      title: ErrorResponse\n      description: Standard error response model for API errors\n      required:\n        - error_code\n        - message\n      properties:\n        error_code:\n          type: string\n          description: Machine-readable error code\n          example: INTERNAL_SERVER_ERROR\n        message:\n          type: string\n          description: Human-readable error message\n          example: An unexpected error occurred while processing the request\n\ntags:\n  - name: Greeting\n    description: Endpoints for greeting operations",
      "file_type": "schema",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "OpenAPI 3.0 specification documenting the GET /hello endpoint with request/response schemas, status codes, and error responses."
    },
    {
      "file_path": "src/__init__.py",
      "content": "\"\"\"\nPackage initialization file for the src module.\n\nThis module serves as the entry point for the src package, exposing the main\napplication and core components for external imports.\n\nAuthor: ASP Code Agent\n\"\"\"\n\n__version__ = \"1.0.0\"\n__author__ = \"ASP Code Agent\"\n__all__ = []",
      "file_type": "source",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Python package initialization file for the src module."
    },
    {
      "file_path": "src/routes/__init__.py",
      "content": "\"\"\"\nRoutes package initialization.\n\nThis module initializes the routes package and exports route handlers\nfor the FastAPI application.\n\nComponent ID: COMP-ROUTES\nSemantic Unit: SU-ROUTES-INIT\n\"\"\"\n\nfrom src.routes.hello import router as hello_router\n\n__all__ = [\"hello_router\"]",
      "file_type": "source",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Python package initialization file for the routes module."
    },
    {
      "file_path": "tests/__init__.py",
      "content": "\"\"\"\nTest package initialization file.\n\nThis module initializes the tests package and provides common test utilities\nand fixtures for the test suite.\n\nAuthor: ASP Code Agent\n\"\"\"\n</code>",
      "file_type": "source",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Python package initialization file for the tests module."
    }
  ],
  "file_structure": {
    ".": [
      "main.py",
      "requirements.txt",
      ".env.example",
      "pytest.ini",
      ".pylintrc",
      "README.md",
      "CHANGELOG.md",
      "openapi.yaml"
    ],
    "src/routes": [
      "hello.py",
      "__init__.py"
    ],
    "src": [
      "error_handlers.py",
      "__init__.py"
    ],
    "tests": [
      "test_hello.py",
      "test_error_handlers.py",
      "test_server.py",
      "__init__.py"
    ]
  },
  "implementation_notes": "Generated using multi-stage approach with 16 files. Manifest estimated 818 LOC, actual 1396 LOC. Uses 6 external dependencies.",
  "dependencies": [
    "fastapi==0.104.1",
    "uvicorn==0.24.0",
    "pydantic==2.5.0",
    "pytest==7.4.3",
    "httpx==0.25.2",
    "pylint==3.0.3"
  ],
  "setup_instructions": "1. Install Python 3.12 or higher\\n2. Create a virtual environment: python -m venv venv\\n3. Activate virtual environment: source venv/bin/activate (Linux/Mac) or venv\\Scripts\\activate (Windows)\\n4. Install dependencies: pip install -r requirements.txt\\n5. Copy .env.example to .env and configure if needed\\n6. Run the server: uvicorn main:app --reload\\n7. Access the API at http://localhost:8000/hello\\n8. Run tests: pytest tests/ -v\\n9. View API documentation at http://localhost:8000/docs",
  "total_lines_of_code": 1396,
  "total_files": 16,
  "test_coverage_target": 80.0,
  "semantic_units_implemented": [
    "SU-001",
    "SU-003",
    "SU-002"
  ],
  "components_implemented": [
    "HelloRouteHandler",
    "HTTPServerFramework",
    "ErrorHandler"
  ],
  "agent_version": "1.0.0",
  "generation_timestamp": "2025-12-11T19:02:23.071982"
}