{
  "task_id": "HW-CODE-001",
  "project_id": "HELLO-WORLD-001",
  "files": [
    {
      "file_path": "main.py",
      "content": "import logging\nimport signal\nimport sys\nfrom contextlib import asynccontextmanager\nfrom typing import Any\n\nimport uvicorn\nfrom fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\n\nlogger = logging.getLogger(__name__)\n\n\nclass HelloResponse:\n    \"\"\"Response model for /hello endpoint.\"\"\"\n\n    def __init__(self, message: str) -> None:\n        \"\"\"\n        Initialize HelloResponse.\n\n        Args:\n            message: The greeting message to return\n        \"\"\"\n        self.message = message\n\n    def to_dict(self) -> dict[str, str]:\n        \"\"\"\n        Convert response to dictionary.\n\n        Returns:\n            Dictionary with message key\n        \"\"\"\n        return {\"message\": self.message}\n\n\nclass HTTPServerFramework:\n    \"\"\"\n    HTTP Server Framework component.\n\n    Initializes and configures the HTTP server framework with routing\n    infrastructure using FastAPI and uvicorn ASGI server.\n\n    Component ID: HTTPServerFramework\n    Semantic Unit ID: SU-001\n    \"\"\"\n\n    def __init__(self) -> None:\n        \"\"\"Initialize HTTPServerFramework.\"\"\"\n        self.app: FastAPI | None = None\n        self._shutdown_event = False\n\n    def initialize_app(self) -> FastAPI:\n        \"\"\"\n        Create and return a configured FastAPI application instance.\n\n        Returns:\n            FastAPI: Configured FastAPI application instance\n\n        Raises:\n            RuntimeError: If app initialization fails\n        \"\"\"\n        try:\n            logger.info(\"Initializing FastAPI application\")\n\n            @asynccontextmanager\n            async def lifespan(app: FastAPI):\n                \"\"\"Handle application startup and shutdown events.\"\"\"\n                logger.info(\"FastAPI application startup\")\n                yield\n                logger.info(\"FastAPI application shutdown\")\n\n            self.app = FastAPI(\n                title=\"Hello World API\",\n                description=\"Simple REST API that returns a greeting message\",\n                version=\"1.0.0\",\n                lifespan=lifespan,\n            )\n\n            logger.info(\"FastAPI application initialized successfully\")\n            return self.app\n\n        except Exception as e:\n            logger.error(f\"Failed to initialize FastAPI application: {str(e)}\")\n            raise RuntimeError(\n                f\"Failed to initialize FastAPI application: {str(e)}\"\n            ) from e\n\n    def configure_routes(self, app: FastAPI) -> None:\n        \"\"\"\n        Register all route handlers with the FastAPI application.\n\n        Args:\n            app: FastAPI application instance to configure\n\n        Raises:\n            ValueError: If app is None or invalid\n        \"\"\"\n        if app is None:\n            raise ValueError(\"FastAPI application instance cannot be None\")\n\n        try:\n            logger.info(\"Configuring routes\")\n\n            hello_handler = HelloRouteHandler()\n            app.get(\"/hello\")(hello_handler.hello)\n\n            logger.info(\"Routes configured successfully\")\n\n        except Exception as e:\n            logger.error(f\"Failed to configure routes: {str(e)}\")\n            raise\n\n    def start_server(\n        self, app: FastAPI, host: str = \"0.0.0.0\", port: int = 8000\n    ) -> None:\n        \"\"\"\n        Start the HTTP server on specified host and port.\n\n        Args:\n            app: FastAPI application instance to run\n            host: Host address to bind to (default: 0.0.0.0)\n            port: Port number to listen on (default: 8000)\n\n        Raises:\n            ValueError: If host or port are invalid\n            RuntimeError: If server fails to start\n        \"\"\"\n        if app is None:\n            raise ValueError(\"FastAPI application instance cannot be None\")\n\n        if not isinstance(port, int) or port < 1 or port > 65535:\n            raise ValueError(f\"Invalid port number: {port}\")\n\n        if not isinstance(host, str) or not host:\n            raise ValueError(f\"Invalid host: {host}\")\n\n        try:\n            logger.info(f\"Starting HTTP server on {host}:{port}\")\n\n            def signal_handler(signum: int, frame: Any) -> None:\n                \"\"\"Handle shutdown signals gracefully.\"\"\"\n                logger.info(f\"Received signal {signum}, initiating graceful shutdown\")\n                self._shutdown_event = True\n                sys.exit(0)\n\n            signal.signal(signal.SIGTERM, signal_handler)\n            signal.signal(signal.SIGINT, signal_handler)\n\n            config = uvicorn.Config(\n                app=app,\n                host=host,\n                port=port,\n                log_level=\"info\",\n                access_log=True,\n            )\n            server = uvicorn.Server(config)\n\n            logger.info(f\"HTTP server started successfully on {host}:{port}\")\n            server.run()\n\n        except Exception as e:\n            logger.error(f\"Failed to start HTTP server: {str(e)}\")\n            raise RuntimeError(f\"Failed to start HTTP server: {str(e)}\") from e\n\n\nclass HelloRouteHandler:\n    \"\"\"\n    Hello Route Handler component.\n\n    Handles GET /hello requests and returns serialized JSON response\n    with greeting message.\n\n    Component ID: HelloRouteHandler\n    Semantic Unit ID: SU-002\n    \"\"\"\n\n    def hello(self) -> dict[str, str]:\n        \"\"\"\n        Handle GET /hello request and return greeting message as JSON.\n\n        Returns:\n            dict[str, str]: Dictionary with message key containing \"Hello World\"\n\n        Example:\n            >>> handler = HelloRouteHandler()\n            >>> response = handler.hello()\n            >>> response[\"message\"]\n            'Hello World'\n        \"\"\"\n        logger.debug(\"Processing GET /hello request\")\n        message = \"Hello World\"\n        response = self.serialize_response(message)\n        logger.debug(f\"Returning response: {response}\")\n        return response\n\n    def serialize_response(self, message: str) -> dict[str, str]:\n        \"\"\"\n        Serialize message into JSON response structure.\n\n        Args:\n            message: The message string to serialize\n\n        Returns:\n            dict[str, str]: Serialized response with message key\n\n        Raises:\n            ValueError: If message is not a string or is empty\n        \"\"\"\n        if not isinstance(message, str):\n            raise ValueError(f\"Message must be a string, got {type(message)}\")\n\n        if not message:\n            raise ValueError(\"Message cannot be empty\")\n\n        response = HelloResponse(message)\n        return response.to_dict()\n\n\nclass ErrorHandler:\n    \"\"\"\n    Error Handler component.\n\n    Implements error handling and HTTP status code responses for the\n    hello endpoint with global exception handling.\n\n    Component ID: ErrorHandler\n    Semantic Unit ID: SU-003\n    \"\"\"\n\n    @staticmethod\n    def handle_exception(request: Request, exc: Exception) -> JSONResponse:\n        \"\"\"\n        Handle unexpected exceptions and return 500 error response.\n\n        Args:\n            request: The incoming HTTP request\n            exc: The exception that was raised\n\n        Returns:\n            JSONResponse: JSON response with error details and 500 status code\n        \"\"\"\n        logger.error(\n            f\"Unhandled exception in {request.method} {request.url.path}: {str(exc)}\",\n            exc_info=True,\n        )\n\n        error_response = ErrorHandler.format_error_response(\n            status_code=500,\n            error_code=\"INTERNAL_SERVER_ERROR\",\n            message=\"An unexpected error occurred while processing the request\",\n        )\n\n        return JSONResponse(status_code=500, content=error_response)\n\n    @staticmethod\n    def validate_request(request: Request) -> bool:\n        \"\"\"\n        Validate incoming request is well-formed.\n\n        Args:\n            request: The incoming HTTP request to validate\n\n        Returns:\n            bool: True if request is valid, False otherwise\n        \"\"\"\n        if request is None:\n            logger.warning(\"Request object is None\")\n            return False\n\n        if not hasattr(request, \"method\") or not request.method:\n            logger.warning(\"Request has no valid method\")\n            return False\n\n        if not hasattr(request, \"url\") or not request.url:\n            logger.warning(\"Request has no valid URL\")\n            return False\n\n        logger.debug(f\"Request validation passed for {request.method} {request.url.path}\")\n        return True\n\n    @staticmethod\n    def format_error_response(\n        status_code: int, error_code: str, message: str\n    )",
      "file_type": "source",
      "semantic_unit_id": "SU-001",
      "component_id": "HTTPServerFramework",
      "description": "FastAPI application entry point that initializes the HTTP server framework, configures routes, and starts the uvicorn ASGI server on port 8000 with graceful shutdown handling."
    },
    {
      "file_path": "src/__init__.py",
      "content": "\"\"\"\nPackage initialization file for src module.\n\nThis module serves as the entry point for the src package, exposing\nthe main application and key components for external imports.\n\nAuthor: ASP Code Agent\n\"\"\"\n\n__version__ = \"1.0.0\"\n__author__ = \"ASP Code Agent\"\n__all__ = [\"app\"]",
      "file_type": "source",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Python package initialization file for src module."
    },
    {
      "file_path": "src/routes/__init__.py",
      "content": "\"\"\"\nRoutes package initialization.\n\nThis module initializes the routes package and exports route handlers\nfor the FastAPI application.\n\nComponent ID: COMP-ROUTES\nSemantic Unit: SU-ROUTES-INIT\n\"\"\"\n\nfrom src.routes.hello import router as hello_router\n\n__all__ = [\"hello_router\"]",
      "file_type": "source",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Python package initialization file for routes module."
    },
    {
      "file_path": "src/routes/hello.py",
      "content": "\"\"\"\nFastAPI route handler for GET /hello endpoint.\n\nThis module implements the HelloRouteHandler component (SU-002) that handles\nGET /hello requests and returns a JSON response with a greeting message.\nThe endpoint uses Pydantic response models for type safety and automatic\nJSON serialization.\n\nComponent ID: HelloRouteHandler\nSemantic Unit ID: SU-002\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport logging\nfrom typing import Any\n\nfrom fastapi import APIRouter, Request\nfrom fastapi.responses import JSONResponse\n\nfrom src.schemas.response import HelloResponse\n\n\n# Configure logging for this module\nlogger = logging.getLogger(__name__)\n\n# Create router instance for hello routes\nrouter = APIRouter(\n    prefix=\"\",\n    tags=[\"hello\"],\n    responses={\n        500: {\n            \"description\": \"Internal server error\",\n            \"content\": {\n                \"application/json\": {\n                    \"example\": {\n                        \"error_code\": \"INTERNAL_SERVER_ERROR\",\n                        \"message\": \"An unexpected error occurred while processing the request\",\n                    }\n                }\n            },\n        }\n    },\n)\n\n\ndef serialize_response(message: str) -> dict[str, str]:\n    \"\"\"\n    Serialize message into JSON response structure.\n\n    This function takes a message string and returns a dictionary\n    with the proper response structure for the /hello endpoint.\n\n    Args:\n        message: The greeting message to serialize.\n\n    Returns:\n        dict[str, str]: Dictionary with 'message' key containing the greeting.\n\n    Raises:\n        ValueError: If message is None or not a string.\n\n    Example:\n        >>> response = serialize_response(\"Hello World\")\n        >>> response\n        {'message': 'Hello World'}\n    \"\"\"\n    if message is None:\n        logger.error(\"Message cannot be None\")\n        raise ValueError(\"Message cannot be None\")\n\n    if not isinstance(message, str):\n        logger.error(f\"Message must be string, got {type(message).__name__}\")\n        raise ValueError(f\"Message must be string, got {type(message).__name__}\")\n\n    if not message.strip():\n        logger.error(\"Message cannot be empty or whitespace\")\n        raise ValueError(\"Message cannot be empty or whitespace\")\n\n    return {\"message\": message}\n\n\n@router.get(\n    \"/hello\",\n    response_model=HelloResponse,\n    status_code=200,\n    summary=\"Get greeting message\",\n    description=\"Returns a simple greeting message with HTTP 200 status code\",\n    responses={\n        200: {\n            \"description\": \"Successful response with greeting message\",\n            \"content\": {\n                \"application/json\": {\n                    \"example\": {\"message\": \"Hello World\"}\n                }\n            },\n        }\n    },\n)\ndef hello() -> HelloResponse:\n    \"\"\"\n    Handle GET /hello request and return greeting message as JSON.\n\n    This endpoint returns a simple greeting message in JSON format.\n    No query parameters or request body are required. The response\n    is automatically serialized by FastAPI using the HelloResponse\n    Pydantic model.\n\n    Returns:\n        HelloResponse: Pydantic model containing the greeting message.\n\n    Raises:\n        Exception: Any unexpected runtime errors are caught by the\n                   global exception handler and returned as HTTP 500.\n\n    Example:\n        >>> response = hello()\n        >>> response.message\n        'Hello World'\n\n    HTTP Status Codes:\n        200: Success - greeting message returned\n        500: Internal server error - unexpected exception occurred\n    \"\"\"\n    try:\n        logger.info(\"Processing GET /hello request\")\n\n        # Create response with greeting message\n        message = \"Hello World\"\n        response_data = serialize_response(message)\n\n        logger.info(f\"Successfully processed /hello request: {response_data}\")\n\n        # Return HelloResponse model (FastAPI automatically serializes to JSON)\n        return HelloResponse(message=response_data[\"message\"])\n\n    except ValueError as e:\n        logger.error(f\"Validation error in /hello handler: {str(e)}\")\n        raise\n\n    except Exception as e:\n        logger.error(\n            f\"Unexpected error in /hello handler: {str(e)}\",\n            exc_info=True,\n        )\n        raise\n\n\ndef format_error_response(\n    status_code: int,\n    error_code: str,\n    message: str,\n) -> dict[str, Any]:\n    \"\"\"\n    Format error response with status code, error code, and message.\n\n    This function creates a standardized error response structure\n    that is returned to clients when errors occur.\n\n    Args:\n        status_code: HTTP status code for the error.\n        error_code: Machine-readable error code (e.g., 'INTERNAL_SERVER_ERROR').\n        message: Human-readable error message.\n\n    Returns:\n        dict[str, Any]: Formatted error response dictionary.\n\n    Raises:\n        ValueError: If any parameter is invalid.\n\n    Example:\n        >>> error = format_error_response(500, \"INTERNAL_SERVER_ERROR\", \"Server error\")\n        >>> error\n        {'error_code': 'INTERNAL_SERVER_ERROR', 'message': 'Server error'}\n    \"\"\"\n    if not isinstance(status_code, int) or status_code < 100 or status_code > 599:\n        raise ValueError(f\"Invalid status code: {status_code}\")\n\n    if not isinstance(error_code, str) or not error_code.strip():\n        raise ValueError(\"Error code must be a non-empty string\")\n\n    if not isinstance(message, str) or not message.strip():\n        raise ValueError(\"Message must be a non-empty string\")\n\n    return {\n        \"error_code\": error_code,\n        \"message\": message,\n    }\n\n\ndef validate_request(request: Request) -> bool:\n    \"\"\"\n    Validate incoming request is well-formed.\n\n    This function performs basic validation on the incoming request\n    to ensure it meets expected criteria. FastAPI handles most validation\n    automatically, but this function can be used for custom validation.\n\n    Args:\n        request: The incoming HTTP request object.\n\n    Returns:\n        bool: True if request is valid, False otherwise.\n\n    Raises:\n        ValueError: If request is None or invalid type.\n\n    Example:\n        >>> from fastapi import Request\n        >>> # In actual usage with a real request object\n        >>> is_valid = validate_request(request)\n        >>> is_valid\n        True\n    \"\"\"\n    if request is None:\n        logger.error(\"Request object cannot be None\")\n        raise ValueError(\"Request object cannot be None\")\n\n    if not hasattr(request, \"method\"):\n        logger.error(\"Request object missing 'method' attribute\")\n        raise ValueError(\"Request object missing 'method' attribute\")\n\n    # Validate request method is GET (FastAPI router handles this)\n    if request.method != \"GET\":\n        logger.warning(f\"Invalid request method: {request.method}\")\n        return False\n\n    return True\n\n\ndef handle_exception(request: Request, exc: Exception) -> JSONResponse:\n    \"\"\"\n    Handle unexpected exceptions and return 500 error response.\n\n    This function is used as a global exception handler to catch\n    any unhandled exceptions and return a properly formatted JSON\n    error response with HTTP 500 status code.\n\n    Args:\n        request: The incoming HTTP request that caused the exception.\n        exc: The exception that was raised.\n\n    Returns:\n        JSONResponse: JSON response with error details and HTTP 500 status.\n\n    Example:\n        >>> from fastapi import Request\n        >>> exc = Exception(\"Test error\")\n        >>> response = handle_exception(request, exc)\n        >>> response.status_code\n        500\n    \"\"\"\n    logger.error(\n        f\"Unhandled exception in request to {request.url}: {str(exc)}\",\n        exc_info=True,\n    )\n\n    error_response = format_error_response(\n        status_code=500,\n        error_code=\"INTERNAL_SERVER_ERROR\",\n        message=\"An unexpected error occurred while processing the request\",\n    )\n\n    return JSONResponse(\n        status_code=500,\n        content=error_response,\n    )\n</content>",
      "file_type": "source",
      "semantic_unit_id": "SU-002",
      "component_id": "HelloRouteHandler",
      "description": "FastAPI route handler for GET /hello endpoint that returns a JSON response with greeting message using Pydantic response model for type safety."
    },
    {
      "file_path": "src/schemas/__init__.py",
      "content": "\"\"\"\nSchemas package initialization.\n\nThis module serves as the package initialization file for the schemas module,\nproviding centralized imports and exports of all schema definitions used throughout\nthe application.\n\nComponent ID: COMP-SCHEMAS\nSemantic Unit: SU-SCHEMAS\n\"\"\"\n\n__all__ = [\n    \"HelloResponse\",\n]\n</code>",
      "file_type": "source",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Python package initialization file for schemas module."
    },
    {
      "file_path": "src/schemas/response.py",
      "content": "\"\"\"\nResponse schema models for API endpoints.\n\nThis module defines Pydantic models for serializing HTTP responses,\nensuring type safety and automatic JSON validation.\n\nComponent ID: HelloRouteHandler\nSemantic Unit ID: SU-002\n\nAuthor: ASP Code Agent\n\"\"\"\n\nfrom pydantic import BaseModel, Field\n\n\nclass HelloResponse(BaseModel):\n    \"\"\"\n    Response model for the GET /hello endpoint.\n\n    Represents the JSON response structure returned by the hello endpoint,\n    containing a greeting message.\n\n    Attributes:\n        message: A greeting message string with value 'Hello World'.\n\n    Example:\n        >>> response = HelloResponse(message=\"Hello World\")\n        >>> response.model_dump_json()\n        '{\"message\":\"Hello World\"}'\n    \"\"\"\n\n    message: str = Field(\n        ...,\n        description=\"Greeting message\",\n        example=\"Hello World\",\n        min_length=1,\n        max_length=255,\n    )\n\n    class Config:\n        \"\"\"Pydantic model configuration.\"\"\"\n\n        json_schema_extra = {\n            \"example\": {\"message\": \"Hello World\"},\n        }\n        str_strip_whitespace = True\n</content>",
      "file_type": "source",
      "semantic_unit_id": "SU-002",
      "component_id": "HelloRouteHandler",
      "description": "Pydantic response schema models for serializing the hello endpoint response with message field validation."
    },
    {
      "file_path": "src/handlers/__init__.py",
      "content": "\"\"\"\nHandlers package initialization.\n\nThis module initializes the handlers package and exports all handler components\nfor use throughout the application.\n\nComponent ID: COMP-HANDLERS\nSemantic Unit: SU-HANDLERS-INIT\n\"\"\"\n\nfrom src.handlers.hello import hello_handler\n\n__all__ = [\n    \"hello_handler\",\n]",
      "file_type": "source",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Python package initialization file for handlers module."
    },
    {
      "file_path": "src/handlers/error_handler.py",
      "content": "\"\"\"\nGlobal exception handler for the Hello World API.\n\nThis module implements a global exception handler that catches unhandled exceptions\nand returns formatted JSON error responses with HTTP 500 status code, error codes,\nand descriptive messages without exposing stack traces to clients.\n\nComponent ID: ErrorHandler\nSemantic Unit ID: SU-003\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport logging\nfrom typing import Any\n\nfrom fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\n\nfrom src.schemas.error import ErrorResponse\n\n\n# Configure logger for error handling\nlogger = logging.getLogger(__name__)\n\n\ndef format_error_response(\n    status_code: int,\n    error_code: str,\n    message: str,\n) -> dict[str, Any]:\n    \"\"\"\n    Format error response with status code, error code, and message.\n\n    This function creates a standardized error response structure that is\n    returned to clients when exceptions occur. The response includes the\n    HTTP status code, a machine-readable error code, and a human-readable\n    message. Stack traces are never included in the response.\n\n    Args:\n        status_code: HTTP status code (e.g., 500)\n        error_code: Machine-readable error code (e.g., \"INTERNAL_SERVER_ERROR\")\n        message: Human-readable error message\n\n    Returns:\n        dict[str, Any]: Formatted error response with keys:\n            - status_code: HTTP status code\n            - error_code: Machine-readable error identifier\n            - message: Human-readable error description\n\n    Example:\n        >>> response = format_error_response(500, \"INTERNAL_SERVER_ERROR\", \"An error occurred\")\n        >>> response[\"status_code\"]\n        500\n        >>> response[\"error_code\"]\n        \"INTERNAL_SERVER_ERROR\"\n    \"\"\"\n    return {\n        \"status_code\": status_code,\n        \"error_code\": error_code,\n        \"message\": message,\n    }\n\n\ndef validate_request(request: Request) -> bool:\n    \"\"\"\n    Validate incoming request is well-formed.\n\n    This function performs basic validation on incoming requests to ensure\n    they are properly formatted. Currently validates that the request method\n    is supported (FastAPI handles method validation automatically for routes).\n\n    Args:\n        request: FastAPI Request object containing request metadata\n\n    Returns:\n        bool: True if request is valid, False otherwise\n\n    Example:\n        >>> from fastapi import Request\n        >>> # In actual usage with a real request\n        >>> is_valid = validate_request(request)\n        >>> is_valid\n        True\n    \"\"\"\n    # FastAPI automatically handles method validation for registered routes\n    # This function is provided for extensibility and explicit validation\n    if not request.method:\n        logger.warning(\"Request validation failed: missing HTTP method\")\n        return False\n\n    if not request.url:\n        logger.warning(\"Request validation failed: missing URL\")\n        return False\n\n    return True\n\n\nasync def handle_exception(request: Request, exc: Exception) -> JSONResponse:\n    \"\"\"\n    Handle unexpected exceptions and return 500 error response.\n\n    This is a global exception handler that catches all unhandled exceptions\n    that occur during request processing. It logs the exception details for\n    debugging purposes but returns a sanitized error response to the client\n    without exposing sensitive information like stack traces.\n\n    The handler:\n    1. Logs the full exception details (including stack trace) for debugging\n    2. Extracts the request path and method for context\n    3. Returns a JSON response with HTTP 500 status code\n    4. Includes a machine-readable error code and user-friendly message\n    5. Never exposes stack traces or internal implementation details\n\n    Args:\n        request: FastAPI Request object containing request metadata\n        exc: The exception that was raised during request processing\n\n    Returns:\n        JSONResponse: JSON response with HTTP 500 status code and error details\n\n    Example:\n        >>> from fastapi import Request\n        >>> from fastapi.testclient import TestClient\n        >>> # In actual usage, this is called automatically by FastAPI\n        >>> # when an unhandled exception occurs\n    \"\"\"\n    # Log full exception details for debugging (includes stack trace)\n    logger.error(\n        \"Unhandled exception occurred\",\n        exc_info=True,\n        extra={\n            \"request_method\": request.method,\n            \"request_path\": request.url.path,\n            \"request_query\": str(request.url.query),\n            \"exception_type\": type(exc).__name__,\n            \"exception_message\": str(exc),\n        },\n    )\n\n    # Format error response without exposing stack trace\n    error_response = format_error_response(\n        status_code=500,\n        error_code=\"INTERNAL_SERVER_ERROR\",\n        message=\"An unexpected error occurred while processing the request\",\n    )\n\n    # Return JSON response with HTTP 500 status code\n    return JSONResponse(\n        status_code=500,\n        content=error_response,\n    )\n\n\ndef register_exception_handlers(app: FastAPI) -> None:\n    \"\"\"\n    Register global exception handlers with FastAPI application.\n\n    This function registers the global exception handler with the FastAPI\n    application instance. The handler will catch all unhandled exceptions\n    that occur during request processing and return formatted JSON error\n    responses.\n\n    Args:\n        app: FastAPI application instance to register handlers with\n\n    Returns:\n        None\n\n    Example:\n        >>> from fastapi import FastAPI\n        >>> app = FastAPI()\n        >>> register_exception_handlers(app)\n    \"\"\"\n    app.add_exception_handler(Exception, handle_exception)\n    logger.info(\"Global exception handlers registered successfully\")\n</content>",
      "file_type": "source",
      "semantic_unit_id": "SU-003",
      "component_id": "ErrorHandler",
      "description": "Global exception handler that catches unhandled exceptions and returns formatted JSON error responses with HTTP 500 status code, error codes, and descriptive messages without exposing stack traces."
    },
    {
      "file_path": "src/schemas/error.py",
      "content": "\"\"\"\nError Response Schema Models\n\nPydantic models for formatting standardized error responses with status code, error code, and message fields.\n\nComponent ID: ErrorHandler\nSemantic Unit: SU-003\n\nAuthor: ASP Code Agent\n\"\"\"\n\nfrom typing import Any, Optional\n\nfrom pydantic import BaseModel, Field\n\n\nclass ErrorResponse(BaseModel):\n    \"\"\"\n    Standard error response schema for API errors.\n\n    Attributes:\n        error_code: Machine-readable error code (e.g., 'INTERNAL_SERVER_ERROR')\n        message: Human-readable error message\n        status_code: HTTP status code associated with the error\n        details: Optional additional error details for debugging\n\n    Example:\n        >>> error = ErrorResponse(\n        ...     error_code=\"INTERNAL_SERVER_ERROR\",\n        ...     message=\"An unexpected error occurred while processing the request\",\n        ...     status_code=500\n        ... )\n        >>> error.error_code\n        'INTERNAL_SERVER_ERROR'\n    \"\"\"\n\n    error_code: str = Field(\n        ...,\n        description=\"Machine-readable error code\",\n        min_length=1,\n        max_length=100,\n    )\n    message: str = Field(\n        ...,\n        description=\"Human-readable error message\",\n        min_length=1,\n        max_length=500,\n    )\n    status_code: int = Field(\n        ...,\n        description=\"HTTP status code\",\n        ge=400,\n        le=599,\n    )\n    details: Optional[dict[str, Any]] = Field(\n        default=None,\n        description=\"Optional additional error details\",\n    )\n\n    class Config:\n        \"\"\"Pydantic model configuration.\"\"\"\n\n        json_schema_extra = {\n            \"example\": {\n                \"error_code\": \"INTERNAL_SERVER_ERROR\",\n                \"message\": \"An unexpected error occurred while processing the request\",\n                \"status_code\": 500,\n                \"details\": None,\n            }\n        }\n\n\nclass ValidationErrorResponse(BaseModel):\n    \"\"\"\n    Validation error response schema for request validation failures.\n\n    Attributes:\n        error_code: Always 'VALIDATION_ERROR' for validation failures\n        message: Description of validation failure\n        status_code: Always 400 for validation errors\n        details: Dictionary containing field-level validation errors\n\n    Example:\n        >>> error = ValidationErrorResponse(\n        ...     error_code=\"VALIDATION_ERROR\",\n        ...     message=\"Request validation failed\",\n        ...     status_code=400,\n        ...     details={\"field_name\": [\"error message\"]}\n        ... )\n    \"\"\"\n\n    error_code: str = Field(\n        default=\"VALIDATION_ERROR\",\n        description=\"Error code for validation failures\",\n    )\n    message: str = Field(\n        default=\"Request validation failed\",\n        description=\"Validation error message\",\n    )\n    status_code: int = Field(\n        default=400,\n        description=\"HTTP status code for validation errors\",\n    )\n    details: dict[str, Any] = Field(\n        default_factory=dict,\n        description=\"Field-level validation error details\",\n    )\n\n    class Config:\n        \"\"\"Pydantic model configuration.\"\"\"\n\n        json_schema_extra = {\n            \"example\": {\n                \"error_code\": \"VALIDATION_ERROR\",\n                \"message\": \"Request validation failed\",\n                \"status_code\": 400,\n                \"details\": {\"field_name\": [\"error message\"]},\n            }\n        }\n\n\nclass ServerErrorResponse(BaseModel):\n    \"\"\"\n    Server error response schema for internal server errors.\n\n    Attributes:\n        error_code: Always 'INTERNAL_SERVER_ERROR' for server errors\n        message: Description of the server error\n        status_code: Always 500 for server errors\n        request_id: Optional request ID for error tracking and debugging\n\n    Example:\n        >>> error = ServerErrorResponse(\n        ...     error_code=\"INTERNAL_SERVER_ERROR\",\n        ...     message=\"An unexpected error occurred while processing the request\",\n        ...     status_code=500,\n        ...     request_id=\"req-12345\"\n        ... )\n    \"\"\"\n\n    error_code: str = Field(\n        default=\"INTERNAL_SERVER_ERROR\",\n        description=\"Error code for server errors\",\n    )\n    message: str = Field(\n        default=\"An unexpected error occurred while processing the request\",\n        description=\"Server error message\",\n    )\n    status_code: int = Field(\n        default=500,\n        description=\"HTTP status code for server errors\",\n    )\n    request_id: Optional[str] = Field(\n        default=None,\n        description=\"Request ID for error tracking\",\n        max_length=100,\n    )\n\n    class Config:\n        \"\"\"Pydantic model configuration.\"\"\"\n\n        json_schema_extra = {\n            \"example\": {\n                \"error_code\": \"INTERNAL_SERVER_ERROR\",\n                \"message\": \"An unexpected error occurred while processing the request\",\n                \"status_code\": 500,\n                \"request_id\": \"req-12345\",\n            }\n        }",
      "file_type": "source",
      "semantic_unit_id": "SU-003",
      "component_id": "ErrorHandler",
      "description": "Pydantic error response schema models for formatting error responses with status code, error code, and message fields."
    },
    {
      "file_path": "src/config.py",
      "content": "\"\"\"\nApplication Configuration Module\n\nProvides centralized configuration for the HTTP server including host, port, and logging settings.\nThis module defines all configuration constants and environment-based settings used throughout\nthe application.\n\nComponent ID: COMP-CONFIG-001\nSemantic Unit: SU-CONFIG-001\n\"\"\"\n\nimport logging\nimport os\nfrom typing import Final\n\n# Server Configuration\nSERVER_HOST: Final[str] = os.getenv(\"SERVER_HOST\", \"0.0.0.0\")\nSERVER_PORT: Final[int] = int(os.getenv(\"SERVER_PORT\", \"8000\"))\nSERVER_RELOAD: Final[bool] = os.getenv(\"SERVER_RELOAD\", \"False\").lower() == \"true\"\n\n# Application Configuration\nAPP_NAME: Final[str] = \"Hello World API\"\nAPP_VERSION: Final[str] = \"1.0.0\"\nAPP_DESCRIPTION: Final[str] = \"Simple REST API that returns a greeting message\"\n\n# Logging Configuration\nLOG_LEVEL: Final[str] = os.getenv(\"LOG_LEVEL\", \"INFO\")\nLOG_FORMAT: Final[str] = (\n    \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\n\n# Configure logging\nlogging.basicConfig(\n    level=getattr(logging, LOG_LEVEL.upper(), logging.INFO),\n    format=LOG_FORMAT,\n)\n\nlogger: logging.Logger = logging.getLogger(__name__)\n\n\ndef get_logger(name: str) -> logging.Logger:\n    \"\"\"\n    Get a configured logger instance for a specific module.\n\n    Args:\n        name: The name of the logger (typically __name__ from calling module)\n\n    Returns:\n        logging.Logger: Configured logger instance\n\n    Example:\n        >>> logger = get_logger(__name__)\n        >>> logger.info(\"Application started\")\n    \"\"\"\n    return logging.getLogger(name)\n</",
      "file_type": "config",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Application configuration module with server settings including host, port, and logging configuration."
    },
    {
      "file_path": "tests/__init__.py",
      "content": "\"\"\"\nTest package initialization file.\n\nThis module initializes the tests package and provides common test utilities\nand fixtures for all test modules.\n\nAuthor: ASP Code Agent\n\"\"\"\n</code>",
      "file_type": "test",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Python package initialization file for tests module."
    },
    {
      "file_path": "tests/test_hello.py",
      "content": "import pytest\nfrom fastapi.testclient import TestClient\nfrom unittest.mock import patch, MagicMock\nimport json\n\nfrom main import app\n\n\n@pytest.fixture\ndef client():\n    \"\"\"\n    Create a test client for the FastAPI application.\n    \n    Provides a TestClient instance for making HTTP requests to the application\n    during testing without requiring a running server.\n    \n    Yields:\n        TestClient: FastAPI test client for making requests\n    \"\"\"\n    return TestClient(app)\n\n\nclass TestHelloEndpointBasic:\n    \"\"\"\n    Test suite for basic GET /hello endpoint functionality.\n    \n    Tests the core behavior of the /hello endpoint including response status,\n    content type, and response structure.\n    \n    Component ID: HelloRouteHandler\n    Semantic Unit: SU-002\n    \"\"\"\n\n    def test_hello_endpoint_returns_200_status(self, client):\n        \"\"\"\n        Test that GET /hello endpoint returns HTTP 200 OK status code.\n        \n        Verifies that successful requests to the /hello endpoint return\n        the correct HTTP 200 status code.\n        \"\"\"\n        response = client.get(\"/hello\")\n        assert response.status_code == 200\n\n    def test_hello_endpoint_returns_json_content_type(self, client):\n        \"\"\"\n        Test that GET /hello endpoint returns application/json content type.\n        \n        Verifies that the response includes the correct Content-Type header\n        indicating JSON format.\n        \"\"\"\n        response = client.get(\"/hello\")\n        assert response.headers[\"content-type\"] == \"application/json\"\n\n    def test_hello_endpoint_returns_dict_response(self, client):\n        \"\"\"\n        Test that GET /hello endpoint returns a dictionary response.\n        \n        Verifies that the response body can be parsed as JSON and is\n        a dictionary object.\n        \"\"\"\n        response = client.get(\"/hello\")\n        data = response.json()\n        assert isinstance(data, dict)\n\n    def test_hello_endpoint_response_has_message_field(self, client):\n        \"\"\"\n        Test that GET /hello endpoint response contains 'message' field.\n        \n        Verifies that the response JSON includes the required 'message' key.\n        \"\"\"\n        response = client.get(\"/hello\")\n        data = response.json()\n        assert \"message\" in data\n\n    def test_hello_endpoint_message_value_is_string(self, client):\n        \"\"\"\n        Test that 'message' field in response is a string.\n        \n        Verifies that the message value is of string type.\n        \"\"\"\n        response = client.get(\"/hello\")\n        data = response.json()\n        assert isinstance(data[\"message\"], str)\n\n    def test_hello_endpoint_message_value_is_hello_world(self, client):\n        \"\"\"\n        Test that 'message' field contains 'Hello World' text.\n        \n        Verifies that the endpoint returns the correct greeting message.\n        \"\"\"\n        response = client.get(\"/hello\")\n        data = response.json()\n        assert data[\"message\"] == \"Hello World\"\n\n    def test_hello_endpoint_response_has_only_message_field(self, client):\n        \"\"\"\n        Test that response contains only the 'message' field.\n        \n        Verifies that the response structure is minimal and contains\n        no unexpected additional fields.\n        \"\"\"\n        response = client.get(\"/hello\")\n        data = response.json()\n        assert len(data) == 1\n        assert list(data.keys()) == [\"message\"]\n\n\nclass TestHelloEndpointResponseStructure:\n    \"\"\"\n    Test suite for GET /hello endpoint response structure and serialization.\n    \n    Tests the JSON serialization, response format, and data structure\n    of the /hello endpoint response.\n    \n    Component ID: HelloRouteHandler\n    Semantic Unit: SU-002\n    \"\"\"\n\n    def test_hello_endpoint_response_is_valid_json(self, client):\n        \"\"\"\n        Test that GET /hello endpoint returns valid JSON.\n        \n        Verifies that the response body is valid JSON that can be parsed\n        without errors.\n        \"\"\"\n        response = client.get(\"/hello\")\n        try:\n            json.loads(response.text)\n            is_valid_json = True\n        except json.JSONDecodeError:\n            is_valid_json = False\n        assert is_valid_json\n\n    def test_hello_endpoint_response_serialization(self, client):\n        \"\"\"\n        Test that response is properly serialized to JSON format.\n        \n        Verifies that the response text matches the expected JSON structure\n        when serialized.\n        \"\"\"\n        response = client.get(\"/hello\")\n        expected_json = '{\"message\":\"Hello World\"}'\n        actual_json = response.text.replace(\" \", \"\")\n        assert actual_json == expected_json\n\n    def test_hello_endpoint_response_encoding(self, client):\n        \"\"\"\n        Test that response uses UTF-8 encoding.\n        \n        Verifies that the response is properly encoded in UTF-8 format.\n        \"\"\"\n        response = client.get(\"/hello\")\n        assert response.encoding == \"utf-8\"\n\n    def test_hello_endpoint_response_headers_include_content_length(self, client):\n        \"\"\"\n        Test that response includes Content-Length header.\n        \n        Verifies that the response includes the Content-Length header\n        indicating the size of the response body.\n        \"\"\"\n        response = client.get(\"/hello\")\n        assert \"content-length\" in response.headers\n\n    def test_hello_endpoint_response_body_not_empty(self, client):\n        \"\"\"\n        Test that response body is not empty.\n        \n        Verifies that the response contains actual content.\n        \"\"\"\n        response = client.get(\"/hello\")\n        assert len(response.text) > 0\n\n    def test_hello_endpoint_response_text_contains_hello_world(self, client):\n        \"\"\"\n        Test that response text contains 'Hello World' string.\n        \n        Verifies that the raw response text includes the greeting message.\n        \"\"\"\n        response = client.get(\"/hello\")\n        assert \"Hello World\" in response.text\n\n\nclass TestHelloEndpointHTTPMethods:\n    \"\"\"\n    Test suite for HTTP method validation on /hello endpoint.\n    \n    Tests that the /hello endpoint only accepts GET requests and rejects\n    other HTTP methods with appropriate error responses.\n    \n    Component ID: ErrorHandler\n    Semantic Unit: SU-003\n    \"\"\"\n\n    def test_hello_endpoint_rejects_post_request(self, client):\n        \"\"\"\n        Test that POST requests to /hello are rejected with 405 status.\n        \n        Verifies that the endpoint returns Method Not Allowed for POST requests.\n        \"\"\"\n        response = client.post(\"/hello\")\n        assert response.status_code == 405\n\n    def test_hello_endpoint_rejects_put_request(self, client):\n        \"\"\"\n        Test that PUT requests to /hello are rejected with 405 status.\n        \n        Verifies that the endpoint returns Method Not Allowed for PUT requests.\n        \"\"\"\n        response = client.put(\"/hello\")\n        assert response.status_code == 405\n\n    def test_hello_endpoint_rejects_delete_request(self, client):\n        \"\"\"\n        Test that DELETE requests to /hello are rejected with 405 status.\n        \n        Verifies that the endpoint returns Method Not Allowed for DELETE requests.\n        \"\"\"\n        response = client.delete(\"/hello\")\n        assert response.status_code == 405\n\n    def test_hello_endpoint_rejects_patch_request(self, client):\n        \"\"\"\n        Test that PATCH requests to /hello are rejected with 405 status.\n        \n        Verifies that the endpoint returns Method Not Allowed for PATCH requests.\n        \"\"\"\n        response = client.patch(\"/hello\")\n        assert response.status_code == 405\n\n    def test_hello_endpoint_rejects_head_request(self, client):\n        \"\"\"\n        Test that HEAD requests to /hello are rejected with 405 status.\n        \n        Verifies that the endpoint returns Method Not Allowed for HEAD requests.\n        \"\"\"\n        response = client.head(\"/hello\")\n        assert response.status_code == 405\n\n    def test_hello_endpoint_rejects_options_request(self, client):\n        \"\"\"\n        Test that OPTIONS requests to /hello are rejected with 405 status.",
      "file_type": "test",
      "semantic_unit_id": "SU-002",
      "component_id": "HelloRouteHandler",
      "description": "Unit and integration tests for GET /hello endpoint verifying correct response structure, status code, content type, and response serialization."
    },
    {
      "file_path": "tests/test_error_handler.py",
      "content": "\"\"\"\nUnit tests for error handler\n\nTests the error handler to verify exception catching, error response formatting,\nHTTP 500 status codes, and that stack traces are not exposed to clients.\n\nComponent ID: ErrorHandler\nSemantic Unit ID: SU-003\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport json\nimport logging\nfrom typing import Any\nfrom unittest.mock import Mock, patch\n\nimport pytest\nfrom fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\nfrom fastapi.testclient import TestClient\nfrom starlette.exceptions import HTTPException\n\nfrom main import app\nfrom src.handlers.error_handler import (\n    ErrorHandler,\n    format_error_response,\n    handle_exception,\n    validate_request,\n)\n\n\n@pytest.fixture\ndef client() -> TestClient:\n    \"\"\"Create test client for FastAPI application.\"\"\"\n    return TestClient(app)\n\n\n@pytest.fixture\ndef error_handler() -> ErrorHandler:\n    \"\"\"Create ErrorHandler instance for testing.\"\"\"\n    return ErrorHandler()\n\n\n@pytest.fixture\ndef mock_request() -> Mock:\n    \"\"\"Create mock Request object for testing.\"\"\"\n    request = Mock(spec=Request)\n    request.method = \"GET\"\n    request.url = \"http://localhost:8000/hello\"\n    request.headers = {\"content-type\": \"application/json\"}\n    return request\n\n\nclass TestFormatErrorResponse:\n    \"\"\"Tests for format_error_response function.\"\"\"\n\n    def test_format_error_response_returns_dict(self) -> None:\n        \"\"\"Test that format_error_response returns a dictionary.\"\"\"\n        result = format_error_response(500, \"INTERNAL_SERVER_ERROR\", \"Test error\")\n        assert isinstance(result, dict)\n\n    def test_format_error_response_includes_error_code(self) -> None:\n        \"\"\"Test that formatted response includes error_code field.\"\"\"\n        result = format_error_response(500, \"INTERNAL_SERVER_ERROR\", \"Test error\")\n        assert \"error_code\" in result\n        assert result[\"error_code\"] == \"INTERNAL_SERVER_ERROR\"\n\n    def test_format_error_response_includes_message(self) -> None:\n        \"\"\"Test that formatted response includes message field.\"\"\"\n        result = format_error_response(500, \"INTERNAL_SERVER_ERROR\", \"Test error\")\n        assert \"message\" in result\n        assert result[\"message\"] == \"Test error\"\n\n    def test_format_error_response_includes_status_code(self) -> None:\n        \"\"\"Test that formatted response includes status_code field.\"\"\"\n        result = format_error_response(500, \"INTERNAL_SERVER_ERROR\", \"Test error\")\n        assert \"status_code\" in result\n        assert result[\"status_code\"] == 500\n\n    def test_format_error_response_with_different_status_codes(self) -> None:\n        \"\"\"Test format_error_response with various HTTP status codes.\"\"\"\n        test_cases = [\n            (400, \"BAD_REQUEST\", \"Invalid input\"),\n            (404, \"NOT_FOUND\", \"Resource not found\"),\n            (500, \"INTERNAL_SERVER_ERROR\", \"Server error\"),\n            (503, \"SERVICE_UNAVAILABLE\", \"Service unavailable\"),\n        ]\n        for status_code, error_code, message in test_cases:\n            result = format_error_response(status_code, error_code, message)\n            assert result[\"status_code\"] == status_code\n            assert result[\"error_code\"] == error_code\n            assert result[\"message\"] == message\n\n    def test_format_error_response_with_empty_message(self) -> None:\n        \"\"\"Test format_error_response with empty message string.\"\"\"\n        result = format_error_response(500, \"INTERNAL_SERVER_ERROR\", \"\")\n        assert result[\"message\"] == \"\"\n        assert result[\"error_code\"] == \"INTERNAL_SERVER_ERROR\"\n\n    def test_format_error_response_with_long_message(self) -> None:\n        \"\"\"Test format_error_response with very long message.\"\"\"\n        long_message = \"x\" * 1000\n        result = format_error_response(500, \"INTERNAL_SERVER_ERROR\", long_message)\n        assert result[\"message\"] == long_message\n        assert len(result[\"message\"]) == 1000\n\n    def test_format_error_response_structure_is_json_serializable(self) -> None:\n        \"\"\"Test that formatted response can be serialized to JSON.\"\"\"\n        result = format_error_response(500, \"INTERNAL_SERVER_ERROR\", \"Test error\")\n        json_str = json.dumps(result)\n        assert isinstance(json_str, str)\n        parsed = json.loads(json_str)\n        assert parsed[\"status_code\"] == 500\n\n\nclass TestValidateRequest:\n    \"\"\"Tests for validate_request function.\"\"\"\n\n    def test_validate_request_accepts_get_method(self, mock_request: Mock) -> None:\n        \"\"\"Test that validate_request accepts GET requests.\"\"\"\n        mock_request.method = \"GET\"\n        result = validate_request(mock_request)\n        assert result is True\n\n    def test_validate_request_rejects_post_method(self, mock_request: Mock) -> None:\n        \"\"\"Test that validate_request rejects POST requests.\"\"\"\n        mock_request.method = \"POST\"\n        result = validate_request(mock_request)\n        assert result is False\n\n    def test_validate_request_rejects_put_method(self, mock_request: Mock) -> None:\n        \"\"\"Test that validate_request rejects PUT requests.\"\"\"\n        mock_request.method = \"PUT\"\n        result = validate_request(mock_request)\n        assert result is False\n\n    def test_validate_request_rejects_delete_method(self, mock_request: Mock) -> None:\n        \"\"\"Test that validate_request rejects DELETE requests.\"\"\"\n        mock_request.method = \"DELETE\"\n        result = validate_request(mock_request)\n        assert result is False\n\n    def test_validate_request_rejects_patch_method(self, mock_request: Mock) -> None:\n        \"\"\"Test that validate_request rejects PATCH requests.\"\"\"\n        mock_request.method = \"PATCH\"\n        result = validate_request(mock_request)\n        assert result is False\n\n    def test_validate_request_rejects_head_method(self, mock_request: Mock) -> None:\n        \"\"\"Test that validate_request rejects HEAD requests.\"\"\"\n        mock_request.method = \"HEAD\"\n        result = validate_request(mock_request)\n        assert result is False\n\n    def test_validate_request_rejects_options_method(self, mock_request: Mock) -> None:\n        \"\"\"Test that validate_request rejects OPTIONS requests.\"\"\"\n        mock_request.method = \"OPTIONS\"\n        result = validate_request(mock_request)\n        assert result is False\n\n    def test_validate_request_case_sensitive(self, mock_request: Mock) -> None:\n        \"\"\"Test that validate_request is case-sensitive for method names.\"\"\"\n        mock_request.method = \"get\"\n        result = validate_request(mock_request)\n        assert result is False\n\n    def test_validate_request_with_none_method(self, mock_request: Mock) -> None:\n        \"\"\"Test validate_request handles None method gracefully.\"\"\"\n        mock_request.method = None\n        result = validate_request(mock_request)\n        assert result is False\n\n\nclass TestHandleException:\n    \"\"\"Tests for handle_exception function.\"\"\"\n\n    def test_handle_exception_returns_json_response(\n        self, mock_request: Mock\n    ) -> None:\n        \"\"\"Test that handle_exception returns JSONResponse.\"\"\"\n        exc = Exception(\"Test exception\")\n        result = handle_exception(mock_request, exc)\n        assert isinstance(result, JSONResponse)\n\n    def test_handle_exception_returns_500_status_code(\n        self, mock_request: Mock\n    ) -> None:\n        \"\"\"Test that handle_exception returns HTTP 500 status code.\"\"\"\n        exc = Exception(\"Test exception\")\n        result = handle_exception(mock_request, exc)\n        assert result.status_code == 500\n\n    def test_handle_exception_response_contains_error_code(\n        self, mock_request: Mock\n    ) -> None:\n        \"\"\"Test that exception response contains INTERNAL_SERVER_ERROR code.\"\"\"\n        exc = Exception(\"Test exception\")\n        result = handle_exception(mock_request, exc)",
      "file_type": "test",
      "semantic_unit_id": "SU-003",
      "component_id": "ErrorHandler",
      "description": "Unit tests for error handler verifying exception catching, error response formatting, HTTP 500 status codes, and that stack traces are not exposed to clients."
    },
    {
      "file_path": "tests/test_main.py",
      "content": "import pytest\nfrom fastapi.testclient import TestClient\nfrom unittest.mock import patch, MagicMock\nimport json\n\nfrom main import app\n\n\n@pytest.fixture\ndef client():\n    \"\"\"\n    Create a test client for the FastAPI application.\n    \n    Provides a TestClient instance that can be used to make HTTP requests\n    to the FastAPI application without running a live server.\n    \n    Yields:\n        TestClient: FastAPI test client for making requests\n    \"\"\"\n    return TestClient(app)\n\n\nclass TestApplicationInitialization:\n    \"\"\"Tests for FastAPI application initialization and configuration.\"\"\"\n    \n    def test_app_is_fastapi_instance(self):\n        \"\"\"Test that app is a valid FastAPI instance.\"\"\"\n        from fastapi import FastAPI\n        assert isinstance(app, FastAPI)\n    \n    def test_app_has_title(self):\n        \"\"\"Test that FastAPI app has a title configured.\"\"\"\n        assert app.title is not None\n        assert isinstance(app.title, str)\n        assert len(app.title) > 0\n    \n    def test_app_has_routes(self):\n        \"\"\"Test that FastAPI app has routes registered.\"\"\"\n        routes = [route.path for route in app.routes]\n        assert len(routes) > 0\n    \n    def test_hello_route_is_registered(self):\n        \"\"\"Test that /hello route is registered in the application.\"\"\"\n        routes = [route.path for route in app.routes]\n        assert \"/hello\" in routes\n    \n    def test_hello_route_accepts_get_method(self):\n        \"\"\"Test that /hello route accepts GET HTTP method.\"\"\"\n        hello_route = None\n        for route in app.routes:\n            if route.path == \"/hello\":\n                hello_route = route\n                break\n        \n        assert hello_route is not None\n        assert \"GET\" in hello_route.methods\n\n\nclass TestHelloEndpoint:\n    \"\"\"Tests for GET /hello endpoint functionality.\"\"\"\n    \n    def test_hello_endpoint_returns_200_status(self, client):\n        \"\"\"Test that GET /hello returns HTTP 200 OK status code.\"\"\"\n        response = client.get(\"/hello\")\n        assert response.status_code == 200\n    \n    def test_hello_endpoint_returns_json_content_type(self, client):\n        \"\"\"Test that GET /hello returns application/json content type.\"\"\"\n        response = client.get(\"/hello\")\n        assert \"application/json\" in response.headers.get(\"content-type\", \"\")\n    \n    def test_hello_endpoint_returns_json_response(self, client):\n        \"\"\"Test that GET /hello returns valid JSON response.\"\"\"\n        response = client.get(\"/hello\")\n        try:\n            data = response.json()\n            assert isinstance(data, dict)\n        except json.JSONDecodeError:\n            pytest.fail(\"Response is not valid JSON\")\n    \n    def test_hello_endpoint_response_has_message_field(self, client):\n        \"\"\"Test that GET /hello response contains 'message' field.\"\"\"\n        response = client.get(\"/hello\")\n        data = response.json()\n        assert \"message\" in data\n    \n    def test_hello_endpoint_message_value_is_hello_world(self, client):\n        \"\"\"Test that GET /hello returns 'Hello World' as message value.\"\"\"\n        response = client.get(\"/hello\")\n        data = response.json()\n        assert data[\"message\"] == \"Hello World\"\n    \n    def test_hello_endpoint_message_is_string(self, client):\n        \"\"\"Test that message field in response is a string.\"\"\"\n        response = client.get(\"/hello\")\n        data = response.json()\n        assert isinstance(data[\"message\"], str)\n    \n    def test_hello_endpoint_response_structure(self, client):\n        \"\"\"Test that GET /hello response has expected structure.\"\"\"\n        response = client.get(\"/hello\")\n        data = response.json()\n        assert isinstance(data, dict)\n        assert len(data) == 1\n        assert \"message\" in data\n        assert data[\"message\"] == \"Hello World\"\n    \n    def test_hello_endpoint_multiple_requests_consistent(self, client):\n        \"\"\"Test that multiple requests to /hello return consistent responses.\"\"\"\n        response1 = client.get(\"/hello\")\n        response2 = client.get(\"/hello\")\n        response3 = client.get(\"/hello\")\n        \n        assert response1.json() == response2.json() == response3.json()\n    \n    def test_hello_endpoint_response_not_empty(self, client):\n        \"\"\"Test that GET /hello response is not empty.\"\"\"\n        response = client.get(\"/hello\")\n        data = response.json()\n        assert data\n        assert data[\"message\"]\n        assert len(data[\"message\"]) > 0\n\n\nclass TestHTTPMethods:\n    \"\"\"Tests for HTTP method handling on /hello endpoint.\"\"\"\n    \n    def test_hello_endpoint_post_method_not_allowed(self, client):\n        \"\"\"Test that POST /hello returns 405 Method Not Allowed.\"\"\"\n        response = client.post(\"/hello\")\n        assert response.status_code == 405\n    \n    def test_hello_endpoint_put_method_not_allowed(self, client):\n        \"\"\"Test that PUT /hello returns 405 Method Not Allowed.\"\"\"\n        response = client.put(\"/hello\")\n        assert response.status_code == 405\n    \n    def test_hello_endpoint_delete_method_not_allowed(self, client):\n        \"\"\"Test that DELETE /hello returns 405 Method Not Allowed.\"\"\"\n        response = client.delete(\"/hello\")\n        assert response.status_code == 405\n    \n    def test_hello_endpoint_patch_method_not_allowed(self, client):\n        \"\"\"Test that PATCH /hello returns 405 Method Not Allowed.\"\"\"\n        response = client.patch(\"/hello\")\n        assert response.status_code == 405\n    \n    def test_hello_endpoint_head_method_allowed(self, client):\n        \"\"\"Test that HEAD /hello is handled (may return 200 or 405).\"\"\"\n        response = client.head(\"/hello\")\n        assert response.status_code in [200, 405]\n\n\nclass TestErrorHandling:\n    \"\"\"Tests for error handling and exception responses.\"\"\"\n    \n    def test_nonexistent_route_returns_404(self, client):\n        \"\"\"Test that request to nonexistent route returns 404 Not Found.\"\"\"\n        response = client.get(\"/nonexistent\")\n        assert response.status_code == 404\n    \n    def test_404_response_is_json(self, client):\n        \"\"\"Test that 404 response is valid JSON.\"\"\"\n        response = client.get(\"/nonexistent\")\n        try:\n            data = response.json()\n            assert isinstance(data, dict)\n        except json.JSONDecodeError:\n            pytest.fail(\"404 response is not valid JSON\")\n    \n    def test_invalid_path_returns_404(self, client):\n        \"\"\"Test that invalid path returns 404 Not Found.\"\"\"\n        response = client.get(\"/invalid/path/here\")\n        assert response.status_code == 404\n    \n    def test_hello_endpoint_with_query_parameters(self, client):\n        \"\"\"Test that GET /hello with query parameters still returns 200.\"\"\"\n        response = client.get(\"/hello?param=value\")\n        assert response.status_code == 200\n        data = response.json()\n        assert data[\"message\"] == \"Hello World\"\n    \n    def test_hello_endpoint_with_multiple_query_parameters(self, client):\n        \"\"\"Test that GET /hello with multiple query parameters returns 200.\"\"\"\n        response = client.get(\"/hello?param1=value1&param2=value2\")\n        assert response.status_code == 200\n        data = response.json()\n        assert data[\"message\"] == \"Hello World\"\n\n\nclass TestResponseHeaders:\n    \"\"\"Tests for HTTP response headers.\"\"\"\n    \n    def test_hello_endpoint_has_content_type_header(self, client):\n        \"\"\"Test that GET /hello response includes Content-Type header.\"\"\"\n        response = client.get(\"/hello\")\n        assert \"content-type\" in response.headers\n    \n    def test_hello_endpoint_content_type_is_json(self, client):\n        \"\"\"Test that Content-Type header specifies JSON.\"\"\"\n        response = client.get(\"/hello\")\n        content_type = response",
      "file_type": "test",
      "semantic_unit_id": "SU-001",
      "component_id": "HTTPServerFramework",
      "description": "Integration tests for FastAPI application initialization, route registration, server startup, and HTTP request/response handling."
    },
    {
      "file_path": "tests/conftest.py",
      "content": "import pytest\nfrom fastapi.testclient import TestClient\nfrom typing import Generator\n\nfrom main import app\n\n\n@pytest.fixture\ndef client() -> TestClient:\n    \"\"\"\n    Provide a FastAPI TestClient instance for testing HTTP endpoints.\n    \n    This fixture creates a test client that can be used to make requests\n    to the FastAPI application without running an actual server.\n    \n    Yields:\n        TestClient: A test client instance for the FastAPI application\n        \n    Example:\n        >>> def test_hello(client):\n        ...     response = client.get(\"/hello\")\n        ...     assert response.status_code == 200\n    \"\"\"\n    return TestClient(app)\n\n\n@pytest.fixture\ndef sample_hello_response() -> dict[str, str]:\n    \"\"\"\n    Provide a sample response structure for the /hello endpoint.\n    \n    Returns:\n        dict[str, str]: Expected response structure with message field\n        \n    Example:\n        >>> response = sample_hello_response()\n        >>> response[\"message\"]\n        'Hello World'\n    \"\"\"\n    return {\"message\": \"Hello World\"}\n\n\n@pytest.fixture\ndef sample_error_response() -> dict[str, str]:\n    \"\"\"\n    Provide a sample error response structure for error cases.\n    \n    Returns:\n        dict[str, str]: Expected error response structure with error code and message\n        \n    Example:\n        >>> error = sample_error_response()\n        >>> error[\"error_code\"]\n        'INTERNAL_SERVER_ERROR'\n    \"\"\"\n    return {\n        \"error_code\": \"INTERNAL_SERVER_ERROR\",\n        \"message\": \"An unexpected error occurred while processing the request\"\n    }\n\n\n@pytest.fixture\ndef valid_request_headers() -> dict[str, str]:\n    \"\"\"\n    Provide valid HTTP request headers for testing.\n    \n    Returns:\n        dict[str, str]: Dictionary of valid HTTP headers\n        \n    Example:\n        >>> headers = valid_request_headers()\n        >>> headers[\"Accept\"]\n        'application/json'\n    \"\"\"\n    return {\n        \"Accept\": \"application/json\",\n        \"User-Agent\": \"TestClient/1.0\"\n    }\n\n\n@pytest.fixture(autouse=True)\ndef reset_app_state() -> Generator[None, None, None]:\n    \"\"\"\n    Reset application state before and after each test.\n    \n    This fixture ensures that each test starts with a clean state\n    and any side effects are cleaned up after the test completes.\n    \n    Yields:\n        None\n    \"\"\"\n    # Setup: Initialize any test state if needed\n    yield\n    # Teardown: Clean up any test state if needed\n\n\ndef pytest_configure(config) -> None:\n    \"\"\"\n    Configure pytest with custom markers and settings.\n    \n    Args:\n        config: pytest configuration object\n    \"\"\"\n    config.addinivalue_line(\n        \"markers\", \"integration: mark test as an integration test\"\n    )\n    config.addinivalue_line(\n        \"markers\", \"unit: mark test as a unit test\"\n    )\n    config.addinivalue_line(\n        \"markers\", \"slow: mark test as slow running\"\n    )\n\n\ndef pytest_collection_modifyitems(config, items) -> None:\n    \"\"\"\n    Modify test collection to add markers based on test location.\n    \n    Args:\n        config: pytest configuration object\n        items: list of collected test items\n    \"\"\"\n    for item in items:\n        # Mark tests in test_main.py as unit tests\n        if \"test_main.py\" in str(item.fspath):\n            item.add_marker(pytest.mark.unit)\n        # Mark tests in test_integration.py as integration tests\n        elif \"test_integration.py\" in str(item.fspath):\n            item.add_marker(pytest.mark.integration)\n</s>",
      "file_type": "test",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Pytest configuration and fixtures providing FastAPI TestClient instance and test utilities for all test modules."
    },
    {
      "file_path": "requirements.txt",
      "content": "# Web Framework\nfastapi==0.104.1\nuvicorn==0.24.0\n\n# Data Validation\npydantic==2.5.0\n\n# Testing\nhttpx==0.25.2\npytest==7.4.3\n\n# Development\npytest-cov==4.1.0",
      "file_type": "requirements",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Python package dependencies with exact versions for FastAPI, uvicorn, pydantic, pytest, and httpx for reproducible builds."
    },
    {
      "file_path": ".env.example",
      "content": "# Server configuration\nHOST=0.0.0.0\nPORT=8000\n\n# Logging configuration\nLOG_LEVEL=INFO\n\n# Application environment\nENVIRONMENT=development\n\n# Debug mode\nDEBUG=True",
      "file_type": "config",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Environment variables template with server host, port, and logging level configuration for local development."
    },
    {
      "file_path": "pytest.ini",
      "content": "[pytest]\n# Pytest configuration file for test discovery, execution, and reporting\n# Specifies test patterns, output options, markers, and other testing behaviors\n\n# Test discovery patterns\n# Pytest will search for test files matching these patterns\npython_files = test_*.py *_test.py\npython_classes = Test*\npython_functions = test_*\n\n# Minimum Python version requirement\nminversion = 7.0\n\n# Test paths - directories where pytest should look for tests\ntestpaths = tests\n\n# Add current directory to Python path for imports\npythonpath = .\n\n# Output options\n# Show extra test summary info for all test outcomes\naddopts = \n    -v\n    --strict-markers\n    --tb=short\n    --disable-warnings\n    -ra\n\n# Coverage options (when using pytest-cov)\n# Uncomment to enable coverage reporting\n# addopts = --cov=. --cov-report=html --cov-report=term-missing\n\n# Markers for categorizing tests\nmarkers =\n    unit: Unit tests for individual functions and components\n    integration: Integration tests for API endpoints and database operations\n    slow: Tests that take longer to execute\n    smoke: Quick smoke tests for basic functionality\n    edge_case: Tests for edge cases and boundary conditions\n    error_case: Tests for error handling and exception cases\n\n# Logging configuration\nlog_cli = false\nlog_cli_level = INFO\nlog_cli_format = %(asctime)s [%(levelname)8s] %(message)s\nlog_cli_date_format = %Y-%m-%d %H:%M:%S\n\nlog_file = tests/pytest.log\nlog_file_level = DEBUG\nlog_file_format = %(asctime)s [%(levelname)8s] %(filename)s:%(lineno)d - %(funcName)s() - %(message)s\nlog_file_date_format = %Y-%m-%d %H:%M:%S\n\n# Timeout for tests (in seconds) - prevents hanging tests\n# Requires pytest-timeout plugin\n# timeout = 300\n\n# Asyncio mode for async tests\n# asyncio_mode = auto\n\n# Doctest options\ndoctest_optionflags = NORMALIZE_WHITESPACE ELLIPSIS\n\n# Ignore certain warnings\nfilterwarnings =\n    ignore::DeprecationWarning\n    ignore::PendingDeprecationWarning",
      "file_type": "config",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Pytest configuration file specifying test discovery patterns, output options, and test markers."
    },
    {
      "file_path": ".pylintrc",
      "content": "[MASTER]\n# Pylint configuration file\n# Enforces PEP 8 style guidelines and code quality standards\n# Reference: https://pylint.pycqa.org/en/latest/\n\n[MESSAGES CONTROL]\n# Disable specific warnings that conflict with project standards\ndisable=\n    missing-module-docstring,\n    too-few-public-methods,\n    duplicate-code,\n\n[FORMAT]\n# Maximum number of characters on a single line\nmax-line-length=100\n\n# Number of spaces for indentation\nindent-string='    '\n\n# Expected format of line ending (empty, LF or CRLF)\nexpected-line-ending-format=LF\n\n[BASIC]\n# Good variable names which should always be accepted, separated by a comma\ngood-names=i,j,k,ex,Run,_,id,x,y,z,df,ax,fig\n\n# Bad variable names which should always be rejected, separated by a comma\nbad-names=foo,bar,baz,toto,tutu,tata\n\n# Naming style for modules\nmodule-naming-style=snake_case\n\n# Naming style for constants\nconst-naming-style=UPPER_CASE\n\n# Naming style for classes\nclass-naming-style=PascalCase\n\n# Naming style for functions\nfunction-naming-style=snake_case\n\n# Naming style for methods\nmethod-naming-style=snake_case\n\n# Naming style for attributes\nattr-naming-style=snake_case\n\n# Naming style for arguments\nargument-naming-style=snake_case\n\n# Naming style for variables\nvariable-naming-style=snake_case\n\n# Minimum name length for function/method names\nmin-name-length=2\n\n# Regular expression matching correct function names\nfunction-rgx=[a-z_][a-z0-9_]*$\n\n# Regular expression matching correct variable names\nvariable-rgx=[a-z_][a-z0-9_]*$\n\n[DESIGN]\n# Maximum number of arguments for function / method\nmax-args=5\n\n# Maximum number of attributes for a class\nmax-attributes=7\n\n# Maximum number of boolean arguments for function / method\nmax-bool-args=3\n\n# Maximum number of branch for function / method body\nmax-branches=12\n\n# Maximum number of locals for function / method body\nmax-locals=15\n\n# Maximum number of parents for a class\nmax-parents=7\n\n# Maximum number of public methods for a class\nmax-public-methods=20\n\n# Maximum number of return / yield for function / method body\nmax-returns=6\n\n# Maximum number of statements in function / method body\nmax-statements=50\n\n[SIMILARITIES]\n# Minimum lines number d a similarity to trigger notice\nmin-similarity-lines=4\n\n# Ignore comments and docstrings when computing similarities\nignore-comments=yes\n\n# Ignore docstrings when computing similarities\nignore-docstrings=yes\n\n# Ignore imports when computing similarities\nignore-imports=yes\n\n[LOGGING]\n# Format of logging function call\nlogging-format-style=new\n\n# Logging modules which allow lazy formatting of the message string\nlogging-modules=logging\n\n[VARIABLES]\n# List of additional names supposed to be defined in builtins\nadditional-builtins=\n\n# Tells whether unused global variables should be treated as a violation\nallow-global-unused-variables=yes\n\n# List of strings which can identify a callback function by name\ncallbacks=cb_,_cb\n\n# A regular expression matching the name of dummy variables\ndummy-variables-rgx=_+$|(_[a-zA-Z0-9_]*[a-zA-Z0-9]+?$)|^ignored_|^unused_\n\n# Argument names that match this expression will be ignored\nignored-argument-names=_.*|^ignored_|^unused_\n\n# Tells whether we should check for unused import in __init__ files\ninit-import=no\n\n# List of qualified module names which can have objects that can change during runtime and shouldn't be flagged as unused\nredefining-builtins-modules=six.moves,past.builtins,future.builtins,builtins,io\n\n[CLASSES]\n# List of method names used to declare an abstract method\ndefining-attr-methods=__init__,__new__,setUp,__post_init__\n\n# List of member names, which should be excluded from the protected access warning\nexclude-protected=_asdict,_fields,_replace,_source,_make,os._exit\n\n# List of valid names for the first argument in a class method\nvalid-classmethod-first-arg=cls\n\n# List of valid names for the first argument in a metaclass class method\nvalid-metaclass-classmethod-first-arg=cls\n\n[IMPORTS]\n# Force import order to recognize a module as part of a local package\nallow-wildcard-with-all=no\n\n# Analyse import fallback blocks\nanalyse-fallback-blocks=no\n\n# Deprecated modules which should not be used, separated by a comma\ndeprecated-modules=optparse,tkinter.tix\n\n[EXCEPTIONS]\n# Exceptions that will emit a warning when being caught\novergeneral-exceptions=BaseException,Exception\n\n[TYPING]\n# Set the maximum number of positional arguments accepted by function stubs\nmax-positional-arguments-for-function-stubs=5\n\n[DOCSTRING]\n# Accept missing docstrings for magic methods\naccept-no-docstring-init=no\n\n# Docstring style to use\ndocstring-min-length=10\n\n[SPELLING]\n# Limits count of emitted suggestions for spelling mistakes\nmax-spelling-suggestions=4\n\n# Tell whether to store unknown words to indicated private dictionary in\n# --spelling-private-dict-file option instead of raising a message\nspelling-store-unknown-words=no\n\n[MISCELLANEOUS]\n# List of note tags to take in consideration, separated by a comma\nnotes=FIXME,XXX,TODO\n\n# Regular expression of note tags to take in consideration\nnotes-rgx=\n\n[REPORTS]\n# Set the output format\noutput-format=text\n\n# Tells whether to display a full report or only the messages\nreports=no\n\n# Tells whether to display a score\nscore=yes\n\n[TOOL:PYTEST]\n# Pytest configuration is handled in pytest.ini\n\n[TOOL:COVERAGE]\n# Coverage configuration is handled in .coveragerc or pyproject.toml",
      "file_type": "config",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Pylint configuration file enforcing PEP 8 style guidelines and code quality standards."
    },
    {
      "file_path": "README.md",
      "content": "# Hello World API\n\nA simple FastAPI REST API that returns a greeting message. This project demonstrates a basic HTTP server implementation with a single endpoint that responds with a JSON message.\n\n## Features\n\n- Single `/hello` endpoint that returns a JSON greeting message\n- Built with FastAPI for high performance and automatic API documentation\n- Uvicorn ASGI server for production-ready deployment\n- Global exception handling with proper HTTP error responses\n- Type-safe request/response handling with Pydantic\n- Comprehensive error handling and logging\n- Easy to extend with additional endpoints\n\n## Prerequisites\n\n- Python 3.12 or higher\n- pip package manager\n- Virtual environment (recommended)\n\n## Installation\n\n### 1. Clone or Download the Project\n\n```bash\ncd hello-world-api\n```\n\n### 2. Create a Virtual Environment\n\n```bash\npython3 -m venv venv\n```\n\n### 3. Activate the Virtual Environment\n\n**On macOS/Linux:**\n```bash\nsource venv/bin/activate\n```\n\n**On Windows:**\n```bash\nvenv\\Scripts\\activate\n```\n\n### 4. Install Dependencies\n\n```bash\npip install -r requirements.txt\n```\n\n## Configuration\n\nThe application uses default configuration values and does not require environment variables for basic operation.\n\n### Optional Environment Variables\n\nYou can customize the server behavior by setting environment variables:\n\n```bash\n# Server host (default: 0.0.0.0)\nexport SERVER_HOST=0.0.0.0\n\n# Server port (default: 8000)\nexport SERVER_PORT=8000\n\n# Log level (default: INFO)\nexport LOG_LEVEL=INFO\n```\n\n## Running the Application\n\n### Development Mode\n\nStart the development server with auto-reload enabled:\n\n```bash\npython main.py\n```\n\nOr use uvicorn directly:\n\n```bash\nuvicorn main:app --reload --host 0.0.0.0 --port 8000\n```\n\nThe API will be available at `http://localhost:8000`\n\n### Production Mode\n\nStart the production server without auto-reload:\n\n```bash\nuvicorn main:app --host 0.0.0.0 --port 8000 --workers 4\n```\n\nFor containerized deployments (Docker):\n\n```bash\ndocker run -p 8000:8000 hello-world-api:latest\n```\n\n## API Documentation\n\n### GET /hello\n\nReturns a simple greeting message in JSON format.\n\n**Endpoint:** `GET /localhost:8000/hello`\n\n**Authentication:** Not required\n\n**Request Parameters:** None\n\n**Request Body:** None\n\n**Response (200 OK):**\n```json\n{\n  \"message\": \"Hello World\"\n}\n```\n\n**Response Headers:**\n```\nContent-Type: application/json\n```\n\n**Status Codes:**\n- `200 OK` - Request successful, greeting message returned\n- `500 Internal Server Error` - An unexpected error occurred while processing the request\n\n**Example Request:**\n```bash\ncurl -X GET http://localhost:8000/hello\n```\n\n**Example Response:**\n```json\n{\n  \"message\": \"Hello World\"\n}\n```\n\n**Example with Python requests library:**\n```python\nimport requests\n\nresponse = requests.get('http://localhost:8000/hello')\nprint(response.json())  # Output: {'message': 'Hello World'}\nprint(response.status_code)  # Output: 200\n```\n\n### Error Response Format\n\nWhen an error occurs, the API returns a JSON response with the following structure:\n\n```json\n{\n  \"error_code\": \"INTERNAL_SERVER_ERROR\",\n  \"message\": \"An unexpected error occurred while processing the request\"\n}\n```\n\n**Status Code:** `500 Internal Server Error`\n\n## Testing\n\n### Run All Tests\n\n```bash\npytest tests/ -v\n```\n\n### Run Tests with Coverage Report\n\n```bash\npytest tests/ --cov=. --cov-report=html\n```\n\nThis generates an HTML coverage report in the `htmlcov/` directory.\n\n### Run Specific Test File\n\n```bash\npytest tests/test_main.py -v\n```\n\n### Run Tests with Detailed Output\n\n```bash\npytest tests/ -vv -s\n```\n\nThe `-s` flag shows print statements and logging output.\n\n## Interactive API Documentation\n\nFastAPI automatically generates interactive API documentation. Access it while the server is running:\n\n### Swagger UI\n```\nhttp://localhost:8000/docs\n```\n\nProvides an interactive interface to test API endpoints directly in the browser.\n\n### ReDoc\n```\nhttp://localhost:8000/redoc\n```\n\nProvides an alternative API documentation view.\n\n### OpenAPI Schema\n```\nhttp://localhost:8000/openapi.json\n```\n\nReturns the OpenAPI specification in JSON format.\n\n## Project Structure\n\n```\nhello-world-api/\n main.py                 # FastAPI application and route handlers\n requirements.txt        # Python dependencies\n README.md              # This file\n tests/\n    test_main.py       # Unit and integration tests\n venv/                  # Virtual environment (created during setup)\n```\n\n## Development Workflow\n\n### 1. Make Changes\n\nEdit `main.py` to add new endpoints or modify existing ones.\n\n### 2. Test Changes\n\nRun tests to verify your changes:\n```bash\npytest tests/ -v\n```\n\n### 3. Check Code Quality\n\nEnsure your code follows PEP 8 standards:\n```bash\npylint main.py\n```\n\n### 4. Run the Server\n\nTest your changes locally:\n```bash\npython main.py\n```\n\n## Troubleshooting\n\n### Port Already in Use\n\nIf port 8000 is already in use, you can specify a different port:\n\n```bash\nuvicorn main:app --port 8001\n```\n\nOr set the environment variable:\n```bash\nexport SERVER_PORT=8001\npython main.py\n```\n\n**To find and kill the process using port 8000:**\n\n**On macOS/Linux:**\n```bash\nlsof -i :8000\nkill -9 <PID>\n```\n\n**On Windows:**\n```bash\nnetstat -ano | findstr :8000\ntaskkill /PID <PID> /F\n```\n\n### Import Errors\n\nIf you encounter import errors, ensure all dependencies are installed:\n\n```bash\npip install -r requirements.txt\n```\n\nVerify the virtual environment is activated:\n```bash\nwhich python  # macOS/Linux\nwhere python  # Windows\n```\n\n### Module Not Found: fastapi\n\nInstall FastAPI and dependencies:\n```bash\npip install fastapi uvicorn\n```\n\nOr reinstall all requirements:\n```bash\npip install --upgrade -r requirements.txt\n```\n\n### Server Won't Start\n\nCheck if the application has syntax errors:\n```bash\npython -m py_compile main.py\n```\n\nRun the server with verbose output:\n```bash\nuvicorn main:app --log-level debug\n```\n\n### Tests Fail\n\nEnsure pytest is installed:\n```bash\npip install pytest httpx\n```\n\nRun tests with verbose output to see detailed error messages:\n```bash\npytest tests/ -vv -s\n```\n\n### Connection Refused\n\nIf you get \"Connection refused\" when accessing the API:\n\n1. Verify the server is running:\n```bash\ncurl http://localhost:8000/hello\n```\n\n2. Check the server is listening on the correct port:\n```bash\nnetstat -an | grep 8000  # macOS/Linux\nnetstat -ano | findstr 8000  # Windows\n```\n\n3. Verify the correct URL is being used (include `/hello` endpoint)\n\n### Slow Response Times\n\nIf the API responds slowly:\n\n1. Check system resources (CPU, memory):\n```bash\ntop  # macOS/Linux\ntasklist  # Windows\n```\n\n2. Run with multiple workers for production:\n```bash\nuvicorn main:app --workers 4\n```\n\n3. Check for blocking operations in the code\n\n## Performance Considerations\n\n- The `/hello` endpoint is designed to respond in under 100ms\n- No database queries or external API calls are made\n- Response is cached in memory (no I/O operations)\n- Suitable for high-throughput scenarios with proper load balancing\n\n## Security Notes\n\n- The `/hello` endpoint does not require authentication\n- No sensitive data is exposed in responses\n- All inputs are validated by FastAPI/Pydantic\n- Error responses do not expose internal stack traces to clients\n- HTTPS should be configured at the infrastructure level (reverse proxy, load balancer)\n\n## Extending the Application\n\n### Add a New Endpoint\n\nEdit `main.py` and add a new route:\n\n```python\n@",
      "file_type": "documentation",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Project documentation including overview, setup instructions, running the server, testing, API documentation for /hello endpoint, and troubleshooting guide."
    },
    {
      "file_path": "ARCHITECTURE.md",
      "content": "# Architecture Documentation\n\n## Overview\n\nThis document describes the architecture of the Hello World API, a simple three-tier HTTP service built with FastAPI. The system demonstrates clean separation of concerns with three primary components: HTTPServerFramework, HelloRouteHandler, and ErrorHandler.\n\n## Architecture Diagram\n\n```\n\n                     HTTP Client Request                      \n\n                             \n                             \n\n              HTTPServerFramework (SU-001)                    \n  \n    initialize_app()  FastAPI instance                   \n    configure_routes(app)  Register route handlers       \n    start_server(app, host, port)  Start ASGI server    \n  \n\n                             \n                \n                                         \n                                         \n       \n     HelloRouteHandler         ErrorHandler        \n         (SU-002)                 (SU-003)         \n       \n      hello()                 handle_exception() \n      serialize_response      validate_request() \n                               format_error_resp()\n       \n                                         \n                \n                             \n                             \n                \n                   HTTP Response (JSON)   \n                  200 OK or 500 Error     \n                \n```\n\n## Component Descriptions\n\n### 1. HTTPServerFramework (SU-001)\n\n**Responsibility:** Initializes and configures the HTTP server framework with routing infrastructure.\n\n**Technology Stack:**\n- FastAPI 0.104+\n- Uvicorn 0.24+ (ASGI server)\n- Python 3.12 with typing module\n\n**Key Methods:**\n\n#### `initialize_app()  FastAPI`\nCreates and returns a configured FastAPI application instance with:\n- Application title and description\n- CORS configuration (allow all origins for development)\n- Default settings for JSON serialization\n- Logging configuration for startup/shutdown events\n\n#### `configure_routes(app: FastAPI)  None`\nRegisters all route handlers with the FastAPI application:\n- Registers HelloRouteHandler.hello() as GET /hello endpoint\n- Registers global exception handler for error handling\n- Configures middleware if needed\n\n#### `start_server(app: FastAPI, host: str, port: int)  None`\nStarts the HTTP server on specified host and port:\n- Default: host='0.0.0.0', port=8000\n- Uses uvicorn as ASGI server\n- Implements graceful shutdown handling for SIGTERM/SIGINT signals\n- Logs server startup and shutdown events\n\n**Dependencies:** None (foundational component)\n\n**Implementation Notes:**\n- Use FastAPI 0.104+ framework for HTTP server\n- Initialize with default settings\n- Configure CORS if needed (allow all origins for development)\n- Use uvicorn as ASGI server with host='0.0.0.0' and port=8000 by default\n- Implement graceful shutdown handling\n- Log server startup and shutdown events\n\n---\n\n### 2. HelloRouteHandler (SU-002)\n\n**Responsibility:** Handles GET /hello requests and returns serialized JSON response with greeting message.\n\n**Key Methods:**\n\n#### `hello()  dict[str, str]`\nHandles GET /hello request and returns greeting message as JSON:\n- No query parameters or request body required\n- Always returns HTTP 200 status code on success\n- Returns dictionary with key 'message' and value 'Hello World'\n- FastAPI automatically serializes to JSON with Content-Type: application/json\n\n#### `serialize_response(message: str)  dict[str, str]`\nSerializes message into JSON response structure:\n- Takes a string message as input\n- Returns dictionary with 'message' key\n- Ensures type safety with Pydantic Response model\n\n**Dependencies:** HTTPServerFramework\n\n**Implementation Notes:**\n- Implement as FastAPI route handler decorated with @app.get('/hello')\n- Return dictionary with key 'message' and value 'Hello World'\n- FastAPI automatically serializes to JSON with Content-Type: application/json\n- Use Response model with Pydantic for type safety\n- No query parameters or request body required\n- Always return HTTP 200 status code on success\n\n**Response Example:**\n```json\n{\n  \"message\": \"Hello World\"\n}\n```\n\n---\n\n### 3. ErrorHandler (SU-003)\n\n**Responsibility:** Implements error handling and HTTP status code responses for the hello endpoint.\n\n**Key Methods:**\n\n#### `handle_exception(request: Request, exc: Exception)  JSONResponse`\nHandles unexpected exceptions and returns 500 error response:\n- Catches all unhandled exceptions\n- Logs exception details (stack trace, timestamp) for debugging\n- Returns JSON response with status 500\n- Does not expose stack traces to client\n\n#### `validate_request(request: Request)  bool`\nValidates incoming request is well-formed:\n- Verifies request method is GET (FastAPI handles this automatically)\n- Checks for malformed headers or body\n- Returns True if valid, False otherwise\n\n#### `format_error_response(status_code: int, error_code: str, message: str)  dict[str, Any]`\nFormats error response with status code, error code, and message:\n- Creates consistent error response structure\n- Includes status_code, error_code, and message fields\n- Returns dictionary ready for JSON serialization\n\n**Dependencies:** HTTPServerFramework, HelloRouteHandler\n\n**Implementation Notes:**\n- Implement global exception handler using FastAPI @app.exception_handler(Exception)\n- Catch all unhandled exceptions and return JSON response with status 500\n- Log exception details (stack trace, timestamp) for debugging\n- Return error response with structure: `{\"error_code\": \"INTERNAL_SERVER_ERROR\", \"message\": \"An unexpected error occurred while processing the request\"}`\n- Use try-except blocks in route handler to catch any runtime errors\n- Validate request method is GET (FastAPI handles this automatically)\n- Return appropriate HTTP status codes: 200 for success, 500 for server errors\n\n**Error Response Example:**\n```json\n{\n  \"error_code\": \"INTERNAL_SERVER_ERROR\",\n  \"message\": \"An unexpected error occurred while processing the request\"\n}\n```\n\n---\n\n## API Contracts\n\n### GET /hello\n\n**Description:** Returns a simple greeting message with HTTP 200 status code\n\n**Request:**\n- Method: GET\n- Path: /hello\n- Query Parameters: None\n- Request Body: None\n- Authentication Required: No\n- Rate Limit: None\n\n**Response (Success):**\n- Status Code: 200 OK\n- Content-Type: application/json\n- Body:\n  ```json\n  {\n    \"message\": \"Hello World\"\n  }\n  ```\n\n**Response (Error):**\n- Status Code: 500 Internal Server Error\n- Content-Type: application/json\n- Body:\n  ```json\n  {\n    \"error_code\": \"INTERNAL_SERVER_ERROR\",\n    \"message\": \"An unexpected error occurred while processing the request\"\n  }\n  ```\n\n**Error Responses:**\n- 500 INTERNAL_SERVER_ERROR: An unexpected error occurred while processing the request\n- 405 METHOD_NOT_ALLOWED: Only GET requests are accepted (handled by FastAPI automatically)\n\n---\n\n## Dependency Relationships\n\n```\nHTTPServerFramework (SU-001)\n    \n     HelloRouteHandler (SU-002)",
      "file_type": "documentation",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Architecture documentation describing the three-tier design with HTTPServerFramework, HelloRouteHandler, and ErrorHandler components with dependency relationships."
    }
  ],
  "file_structure": {
    ".": [
      "main.py",
      "requirements.txt",
      ".env.example",
      "pytest.ini",
      ".pylintrc",
      "README.md",
      "ARCHITECTURE.md"
    ],
    "src": [
      "__init__.py",
      "config.py"
    ],
    "src/routes": [
      "__init__.py",
      "hello.py"
    ],
    "src/schemas": [
      "__init__.py",
      "response.py",
      "error.py"
    ],
    "src/handlers": [
      "__init__.py",
      "error_handler.py"
    ],
    "tests": [
      "__init__.py",
      "test_hello.py",
      "test_error_handler.py",
      "test_main.py",
      "conftest.py"
    ]
  },
  "implementation_notes": "Generated using multi-stage approach with 20 files. Manifest estimated 1328 LOC, actual 2111 LOC. Uses 6 external dependencies.",
  "dependencies": [
    "fastapi==0.104.1",
    "uvicorn==0.24.0",
    "pydantic==2.5.0",
    "pytest==7.4.3",
    "httpx==0.25.2",
    "pylint==3.0.3"
  ],
  "setup_instructions": "1. Install Python 3.12 or higher\\n2. Create virtual environment: python -m venv venv\\n3. Activate virtual environment: source venv/bin/activate (Linux/Mac) or venv\\Scripts\\activate (Windows)\\n4. Install dependencies: pip install -r requirements.txt\\n5. Copy environment template: cp .env.example .env\\n6. Run tests: pytest tests/ -v\\n7. Start server: python main.py or uvicorn main:app --reload\\n8. Access API: http://localhost:8000/hello\\n9. View API docs: http://localhost:8000/docs",
  "total_lines_of_code": 2111,
  "total_files": 21,
  "test_coverage_target": 80.0,
  "semantic_units_implemented": [
    "SU-001",
    "SU-002",
    "SU-003"
  ],
  "components_implemented": [
    "HTTPServerFramework",
    "HelloRouteHandler",
    "ErrorHandler"
  ],
  "agent_version": "1.0.0",
  "generation_timestamp": "2025-12-15T15:15:44.116240"
}