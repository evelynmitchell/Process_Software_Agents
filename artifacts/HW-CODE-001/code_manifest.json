{
  "task_id": "HW-CODE-001",
  "project_id": "PROJECT-001",
  "files": [
    {
      "file_path": "src/main.py",
      "content": "\"\"\"\nFastAPI Hello World Application\n\nSimple REST API with a single /hello endpoint that returns a greeting message with timestamp.\n\nComponent ID: COMP-001\nSemantic Unit: SU-001\n\nAuthor: ASP Code Agent\n\"\"\"\n\nfrom datetime import datetime\nfrom typing import Dict\nimport logging\n\nfrom fastapi import FastAPI, HTTPException\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom pydantic import BaseModel\n\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\nclass HelloResponse(BaseModel):\n    \"\"\"Response model for /hello endpoint.\"\"\"\n    message: str\n    timestamp: str\n    status: str\n\n\nclass ErrorResponse(BaseModel):\n    \"\"\"Response model for error responses.\"\"\"\n    code: str\n    message: str\n\n\n# Initialize FastAPI application\napp = FastAPI(\n    title=\"Hello World API\",\n    description=\"Simple REST API that returns a Hello World greeting message\",\n    version=\"1.0.0\",\n)\n\n# Add CORS middleware\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n\nclass HelloWorldHandler:\n    \"\"\"Handles GET /hello requests and returns Hello World response with timestamp.\"\"\"\n    \n    @staticmethod\n    def format_response(message: str) -> Dict[str, str]:\n        \"\"\"\n        Formats response with message, timestamp, and status.\n        \n        Args:\n            message: The message to include in the response\n            \n        Returns:\n            dict: Formatted response with message, timestamp, and status\n        \"\"\"\n        timestamp = datetime.utcnow().isoformat() + 'Z'\n        return {\n            \"message\": message,\n            \"timestamp\": timestamp,\n            \"status\": \"success\"\n        }\n    \n    @staticmethod\n    def get_hello() -> Dict[str, str]:\n        \"\"\"\n        Returns Hello World response with current timestamp.\n        \n        Returns:\n            dict: Response containing Hello World message, timestamp, and status\n        \"\"\"\n        return HelloWorldHandler.format_response(\"Hello World\")\n\n\n# Initialize handler\nhello_handler = HelloWorldHandler()\n\n\n@app.get(\n    \"/hello\",\n    response_model=HelloResponse,\n    responses={\n        200: {\"description\": \"Successful response with Hello World message\"},\n        500: {\n            \"description\": \"Internal server error\",\n            \"model\": ErrorResponse\n        }\n    }\n)\ndef hello() -> HelloResponse:\n    \"\"\"\n    Return a Hello World greeting message with timestamp.\n\n    Returns:\n        HelloResponse: JSON response with greeting message, timestamp, and status\n\n    Raises:\n        HTTPException: 500 status code for internal server errors\n\n    Example:\n        >>> response = hello()\n        >>> response.message\n        'Hello World'\n        >>> response.status\n        'success'\n    \"\"\"\n    try:\n        logger.info(\"Processing GET /hello request\")\n        response_data = hello_handler.get_hello()\n        logger.info(\"Successfully processed GET /hello request\")\n        return HelloResponse(**response_data)\n    except Exception as e:\n        logger.error(f\"Error processing /hello request: {str(e)}\")\n        raise HTTPException(\n            status_code=500,\n            detail={\n                \"code\": \"INTERNAL_ERROR\",\n                \"message\": \"Internal server error\"\n            }\n        )\n\n\n@app.get(\"/health\")\ndef health_check() -> Dict[str, str]:\n    \"\"\"\n    Health check endpoint for monitoring.\n\n    Returns:\n        dict: Status information\n    \"\"\"\n    return {\"status\": \"healthy\", \"version\": \"1.0.0\"}\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)",
      "file_type": "source",
      "semantic_unit_id": "SU-001",
      "component_id": "COMP-001",
      "description": "FastAPI application entry point with CORS middleware, router registration, and startup configuration"
    },
    {
      "file_path": "src/api/auth.py",
      "content": "\"\"\"\nAuthentication API endpoints for user registration, login, token refresh, and logout.\n\nThis module provides JWT-based authentication endpoints including user registration,\nlogin, token refresh, and logout functionality with proper security measures.\n\nComponent ID: COMP-002\nSemantic Unit: SU-002\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport logging\nfrom datetime import datetime, timedelta\nfrom typing import Dict, Optional\n\nfrom fastapi import APIRouter, Depends, HTTPException, status\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nfrom pydantic import BaseModel, EmailStr, Field\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy.exc import IntegrityError\n\nfrom src.database.connection import get_db_session\nfrom src.models.user import User\nfrom src.utils.jwt_utils import (\n    create_access_token,\n    create_refresh_token,\n    verify_token,\n    decode_token,\n    blacklist_token\n)\nfrom src.utils.password import hash_password, verify_password\n\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Initialize router and security\nrouter = APIRouter(prefix=\"/auth\", tags=[\"authentication\"])\nsecurity = HTTPBearer()\n\n\n# Request/Response Models\nclass UserRegistrationRequest(BaseModel):\n    \"\"\"Request model for user registration.\"\"\"\n    email: EmailStr = Field(..., description=\"User email address\")\n    password: str = Field(..., min_length=8, max_length=128, description=\"User password\")\n    first_name: str = Field(..., min_length=1, max_length=50, description=\"User first name\")\n    last_name: str = Field(..., min_length=1, max_length=50, description=\"User last name\")\n\n\nclass UserLoginRequest(BaseModel):\n    \"\"\"Request model for user login.\"\"\"\n    email: EmailStr = Field(..., description=\"User email address\")\n    password: str = Field(..., description=\"User password\")\n\n\nclass TokenRefreshRequest(BaseModel):\n    \"\"\"Request model for token refresh.\"\"\"\n    refresh_token: str = Field(..., description=\"Valid refresh token\")\n\n\nclass AuthResponse(BaseModel):\n    \"\"\"Response model for authentication endpoints.\"\"\"\n    access_token: str = Field(..., description=\"JWT access token\")\n    refresh_token: str = Field(..., description=\"JWT refresh token\")\n    token_type: str = Field(default=\"bearer\", description=\"Token type\")\n    expires_in: int = Field(..., description=\"Token expiration time in seconds\")\n    user_id: int = Field(..., description=\"Authenticated user ID\")\n\n\nclass MessageResponse(BaseModel):\n    \"\"\"Response model for simple message responses.\"\"\"\n    message: str = Field(..., description=\"Response message\")\n    timestamp: str = Field(..., description=\"Response timestamp\")\n\n\nclass UserResponse(BaseModel):\n    \"\"\"Response model for user information.\"\"\"\n    id: int = Field(..., description=\"User ID\")\n    email: str = Field(..., description=\"User email\")\n    first_name: str = Field(..., description=\"User first name\")\n    last_name: str = Field(..., description=\"User last name\")\n    created_at: str = Field(..., description=\"User creation timestamp\")\n    is_active: bool = Field(..., description=\"User active status\")\n\n\n# Dependency functions\nasync def get_current_user(\n    credentials: HTTPAuthorizationCredentials = Depends(security),\n    db: Session = Depends(get_db_session)\n) -> User:\n    \"\"\"\n    Get current authenticated user from JWT token.\n    \n    Args:\n        credentials: HTTP authorization credentials\n        db: Database session\n        \n    Returns:\n        User: Current authenticated user\n        \n    Raises:\n        HTTPException: If token is invalid or user not found\n    \"\"\"\n    try:\n        token = credentials.credentials\n        \n        # Verify token is not blacklisted\n        if not verify_token(token):\n            logger.warning(\"Attempt to use blacklisted token\")\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Token has been revoked\",\n                headers={\"WWW-Authenticate\": \"Bearer\"},\n            )\n        \n        # Decode token to get user ID\n        payload = decode_token(token)\n        user_id = payload.get(\"sub\")\n        \n        if user_id is None:\n            logger.warning(\"Token missing user ID\")\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Invalid token payload\",\n                headers={\"WWW-Authenticate\": \"Bearer\"},\n            )\n        \n        # Get user from database\n        user = db.query(User).filter(User.id == int(user_id)).first()\n        if user is None:\n            logger.warning(f\"User not found for ID: {user_id}\")\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"User not found\",\n                headers={\"WWW-Authenticate\": \"Bearer\"},\n            )\n        \n        if not user.is_active:\n            logger.warning(f\"Inactive user attempted access: {user.email}\")\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"User account is inactive\",\n                headers={\"WWW-Authenticate\": \"Bearer\"},\n            )\n        \n        return user\n        \n    except HTTPException:\n        raise\n    except Exception as e:\n        logger.error(f\"Error validating token: {str(e)}\")\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Could not validate credentials\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n\n\n# Authentication endpoints\n@router.post(\"/register\", response_model=AuthResponse, status_code=status.HTTP_201_CREATED)\nasync def register_user(\n    user_data: UserRegistrationRequest,\n    db: Session = Depends(get_db_session)\n) -> AuthResponse:\n    \"\"\"\n    Register a new user account.\n    \n    Args:\n        user_data: User registration information\n        db: Database session\n        \n    Returns:\n        AuthResponse: Authentication tokens and user information\n        \n    Raises:\n        HTTPException: If email already exists or registration fails\n    \"\"\"\n    try:\n        # Check if user already exists\n        existing_user = db.query(User).filter(User.email == user_data.email).first()\n        if existing_user:\n            logger.warning(f\"Registration attempt with existing email: {user_data.email}\")\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Email address already registered\"\n            )\n        \n        # Hash password\n        hashed_password = hash_password(user_data.password)\n        \n        # Create new user\n        new_user = User(\n            email=user_data.email,\n            password_hash=hashed_password,\n            first_name=user_data.first_name,\n            last_name=user_data.last_name,\n            is_active=True,\n            created_at=datetime.utcnow()\n        )\n        \n        db.add(new_user)\n        db.commit()\n        db.refresh(new_user)\n        \n        # Generate tokens\n        access_token = create_access_token(data={\"sub\": str(new_user.id)})\n        refresh_token = create_refresh_token(data={\"sub\": str(new_user.id)})\n        \n        logger.info(f\"User registered successfully: {new_user.email}\")\n        \n        return AuthResponse(\n            access_token=access_token,\n            refresh_token=refresh_token,\n            token_type=\"bearer\",\n            expires_in=3600,  # 1 hour\n            user_id=new_user.id\n        )\n        \n    except HTTPException:\n        db.rollback()\n        raise\n    except IntegrityError as e:\n        db.rollback()\n        logger.error(f\"Database integrity error during registration: {str(e)}\")\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Email address already registered\"\n        )\n    except Exception as e:\n        db.rollback()\n        logger.error(f\"Error during user registration: {str(e)}\")\n        raise HTTPException",
      "file_type": "source",
      "semantic_unit_id": "SU-002",
      "component_id": "COMP-002",
      "description": "Authentication API endpoints for user registration, login, token refresh, and logout with JWT token management"
    },
    {
      "file_path": "src/api/tasks.py",
      "content": "\"\"\"\nTask Management API Endpoints\n\nProvides CRUD operations for task management with user authentication and filtering.\nHandles task creation, retrieval, updates, and deletion with proper authorization.\n\nComponent ID: COMP-003\nSemantic Unit: SU-003\n\nAuthor: ASP Code Agent\n\"\"\"\n\nfrom datetime import datetime\nfrom typing import List, Optional\nimport logging\n\nfrom fastapi import APIRouter, Depends, HTTPException, status, Query\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy.exc import SQLAlchemyError\n\nfrom src.models.task import Task, TaskCreate, TaskUpdate, TaskResponse, TaskStatus, TaskPriority\nfrom src.models.user import User\nfrom src.utils.jwt_utils import get_current_user\nfrom src.database.connection import get_db\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Create router for task endpoints\nrouter = APIRouter(prefix=\"/tasks\", tags=[\"tasks\"])\n\n\n@router.post(\"/\", response_model=TaskResponse, status_code=status.HTTP_201_CREATED)\ndef create_task(\n    task_data: TaskCreate,\n    current_user: User = Depends(get_current_user),\n    db: Session = Depends(get_db)\n) -> TaskResponse:\n    \"\"\"\n    Create a new task for the authenticated user.\n\n    Args:\n        task_data: Task creation data including title, description, priority, due_date\n        current_user: Authenticated user from JWT token\n        db: Database session\n\n    Returns:\n        TaskResponse: Created task with generated ID and timestamps\n\n    Raises:\n        HTTPException: 400 if validation fails, 500 if database error occurs\n\n    Example:\n        POST /tasks\n        {\n            \"title\": \"Complete project\",\n            \"description\": \"Finish the task management API\",\n            \"priority\": \"high\",\n            \"due_date\": \"2024-12-31T23:59:59Z\"\n        }\n    \"\"\"\n    try:\n        # Validate task data\n        if not task_data.title or len(task_data.title.strip()) == 0:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Task title cannot be empty\"\n            )\n\n        if task_data.title and len(task_data.title) > 200:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Task title cannot exceed 200 characters\"\n            )\n\n        if task_data.description and len(task_data.description) > 1000:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Task description cannot exceed 1000 characters\"\n            )\n\n        # Validate due date is in the future\n        if task_data.due_date and task_data.due_date <= datetime.utcnow():\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Due date must be in the future\"\n            )\n\n        # Create new task\n        db_task = Task(\n            title=task_data.title.strip(),\n            description=task_data.description.strip() if task_data.description else None,\n            priority=task_data.priority or TaskPriority.MEDIUM,\n            due_date=task_data.due_date,\n            status=TaskStatus.PENDING,\n            user_id=current_user.id,\n            created_at=datetime.utcnow(),\n            updated_at=datetime.utcnow()\n        )\n\n        db.add(db_task)\n        db.commit()\n        db.refresh(db_task)\n\n        logger.info(f\"Task created successfully: ID={db_task.id}, User={current_user.id}\")\n        return TaskResponse.from_orm(db_task)\n\n    except HTTPException:\n        raise\n    except SQLAlchemyError as e:\n        logger.error(f\"Database error creating task: {str(e)}\")\n        db.rollback()\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Failed to create task due to database error\"\n        )\n    except Exception as e:\n        logger.error(f\"Unexpected error creating task: {str(e)}\")\n        db.rollback()\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"An unexpected error occurred while creating the task\"\n        )\n\n\n@router.get(\"/\", response_model=List[TaskResponse])\ndef get_tasks(\n    status_filter: Optional[TaskStatus] = Query(None, description=\"Filter tasks by status\"),\n    priority_filter: Optional[TaskPriority] = Query(None, description=\"Filter tasks by priority\"),\n    skip: int = Query(0, ge=0, description=\"Number of tasks to skip\"),\n    limit: int = Query(100, ge=1, le=1000, description=\"Maximum number of tasks to return\"),\n    current_user: User = Depends(get_current_user),\n    db: Session = Depends(get_db)\n) -> List[TaskResponse]:\n    \"\"\"\n    Retrieve tasks for the authenticated user with optional filtering and pagination.\n\n    Args:\n        status_filter: Optional status filter (pending, in_progress, completed, cancelled)\n        priority_filter: Optional priority filter (low, medium, high, urgent)\n        skip: Number of tasks to skip for pagination\n        limit: Maximum number of tasks to return\n        current_user: Authenticated user from JWT token\n        db: Database session\n\n    Returns:\n        List[TaskResponse]: List of user's tasks matching the filters\n\n    Raises:\n        HTTPException: 500 if database error occurs\n\n    Example:\n        GET /tasks?status=pending&priority=high&skip=0&limit=10\n    \"\"\"\n    try:\n        # Build query for user's tasks\n        query = db.query(Task).filter(Task.user_id == current_user.id)\n\n        # Apply status filter\n        if status_filter:\n            query = query.filter(Task.status == status_filter)\n\n        # Apply priority filter\n        if priority_filter:\n            query = query.filter(Task.priority == priority_filter)\n\n        # Apply ordering (most recent first)\n        query = query.order_by(Task.created_at.desc())\n\n        # Apply pagination\n        tasks = query.offset(skip).limit(limit).all()\n\n        logger.info(f\"Retrieved {len(tasks)} tasks for user {current_user.id}\")\n        return [TaskResponse.from_orm(task) for task in tasks]\n\n    except SQLAlchemyError as e:\n        logger.error(f\"Database error retrieving tasks: {str(e)}\")\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Failed to retrieve tasks due to database error\"\n        )\n    except Exception as e:\n        logger.error(f\"Unexpected error retrieving tasks: {str(e)}\")\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"An unexpected error occurred while retrieving tasks\"\n        )\n\n\n@router.get(\"/{task_id}\", response_model=TaskResponse)\ndef get_task(\n    task_id: int,\n    current_user: User = Depends(get_current_user),\n    db: Session = Depends(get_db)\n) -> TaskResponse:\n    \"\"\"\n    Retrieve a specific task by ID for the authenticated user.\n\n    Args:\n        task_id: ID of the task to retrieve\n        current_user: Authenticated user from JWT token\n        db: Database session\n\n    Returns:\n        TaskResponse: Task details if found and owned by user\n\n    Raises:\n        HTTPException: 404 if task not found or not owned by user, 500 if database error\n\n    Example:\n        GET /tasks/123\n    \"\"\"\n    try:\n        # Validate task_id\n        if task_id <= 0:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Task ID must be a positive integer\"\n            )\n\n        # Query for task owned by current user\n        task = db.query(Task).filter(\n            Task.id ==",
      "file_type": "source",
      "semantic_unit_id": "SU-003",
      "component_id": "COMP-003",
      "description": "Task management API endpoints for CRUD operations with authentication middleware and user-specific filtering"
    },
    {
      "file_path": "src/models/user.py",
      "content": "\"\"\"\nUser database model with SQLAlchemy ORM\n\nDefines the User model with authentication fields, profile data, and task relationships.\nIncludes password hashing, email validation, and audit timestamps.\n\nComponent ID: COMP-004\nSemantic Unit: SU-004\n\nAuthor: ASP Code Generator\n\"\"\"\n\nfrom datetime import datetime\nfrom typing import Optional, List\nimport re\nfrom sqlalchemy import Column, Integer, String, DateTime, Boolean, Text\nfrom sqlalchemy.orm import relationship, validates\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom werkzeug.security import generate_password_hash, check_password_hash\n\nBase = declarative_base()\n\n\nclass User(Base):\n    \"\"\"\n    User model for authentication and profile management.\n    \n    Stores user credentials, profile information, and maintains relationships\n    with tasks and other user-related entities.\n    \n    Attributes:\n        id: Primary key identifier\n        username: Unique username for login\n        email: Unique email address\n        password_hash: Hashed password for authentication\n        first_name: User's first name\n        last_name: User's last name\n        is_active: Whether the user account is active\n        is_verified: Whether the user's email is verified\n        created_at: Account creation timestamp\n        updated_at: Last modification timestamp\n        last_login: Last successful login timestamp\n        bio: Optional user biography\n        avatar_url: Optional profile picture URL\n    \"\"\"\n    \n    __tablename__ = 'users'\n    \n    # Primary key\n    id = Column(Integer, primary_key=True, index=True)\n    \n    # Authentication fields\n    username = Column(String(50), unique=True, nullable=False, index=True)\n    email = Column(String(255), unique=True, nullable=False, index=True)\n    password_hash = Column(String(255), nullable=False)\n    \n    # Profile fields\n    first_name = Column(String(100), nullable=False)\n    last_name = Column(String(100), nullable=False)\n    bio = Column(Text, nullable=True)\n    avatar_url = Column(String(500), nullable=True)\n    \n    # Status fields\n    is_active = Column(Boolean, default=True, nullable=False)\n    is_verified = Column(Boolean, default=False, nullable=False)\n    \n    # Audit timestamps\n    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)\n    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)\n    last_login = Column(DateTime, nullable=True)\n    \n    # Relationships\n    tasks = relationship(\"Task\", back_populates=\"user\", cascade=\"all, delete-orphan\")\n    \n    def __init__(self, username: str, email: str, password: str, \n                 first_name: str, last_name: str, bio: Optional[str] = None,\n                 avatar_url: Optional[str] = None) -> None:\n        \"\"\"\n        Initialize a new User instance.\n        \n        Args:\n            username: Unique username for the user\n            email: User's email address\n            password: Plain text password (will be hashed)\n            first_name: User's first name\n            last_name: User's last name\n            bio: Optional biography text\n            avatar_url: Optional profile picture URL\n            \n        Raises:\n            ValueError: If username, email, or password validation fails\n        \"\"\"\n        self.username = username\n        self.email = email\n        self.set_password(password)\n        self.first_name = first_name\n        self.last_name = last_name\n        self.bio = bio\n        self.avatar_url = avatar_url\n        self.is_active = True\n        self.is_verified = False\n        self.created_at = datetime.utcnow()\n        self.updated_at = datetime.utcnow()\n    \n    def set_password(self, password: str) -> None:\n        \"\"\"\n        Hash and set the user's password.\n        \n        Args:\n            password: Plain text password to hash and store\n            \n        Raises:\n            ValueError: If password doesn't meet security requirements\n        \"\"\"\n        if not password:\n            raise ValueError(\"Password cannot be empty\")\n        \n        if len(password) < 8:\n            raise ValueError(\"Password must be at least 8 characters long\")\n        \n        if not re.search(r'[A-Z]', password):\n            raise ValueError(\"Password must contain at least one uppercase letter\")\n        \n        if not re.search(r'[a-z]', password):\n            raise ValueError(\"Password must contain at least one lowercase letter\")\n        \n        if not re.search(r'\\d', password):\n            raise ValueError(\"Password must contain at least one digit\")\n        \n        self.password_hash = generate_password_hash(password, method='pbkdf2:sha256')\n    \n    def check_password(self, password: str) -> bool:\n        \"\"\"\n        Verify a password against the stored hash.\n        \n        Args:\n            password: Plain text password to verify\n            \n        Returns:\n            bool: True if password matches, False otherwise\n        \"\"\"\n        if not password or not self.password_hash:\n            return False\n        \n        return check_password_hash(self.password_hash, password)\n    \n    def update_last_login(self) -> None:\n        \"\"\"Update the last_login timestamp to current time.\"\"\"\n        self.last_login = datetime.utcnow()\n        self.updated_at = datetime.utcnow()\n    \n    def activate(self) -> None:\n        \"\"\"Activate the user account.\"\"\"\n        self.is_active = True\n        self.updated_at = datetime.utcnow()\n    \n    def deactivate(self) -> None:\n        \"\"\"Deactivate the user account.\"\"\"\n        self.is_active = False\n        self.updated_at = datetime.utcnow()\n    \n    def verify_email(self) -> None:\n        \"\"\"Mark the user's email as verified.\"\"\"\n        self.is_verified = True\n        self.updated_at = datetime.utcnow()\n    \n    def update_profile(self, first_name: Optional[str] = None, \n                      last_name: Optional[str] = None,\n                      bio: Optional[str] = None,\n                      avatar_url: Optional[str] = None) -> None:\n        \"\"\"\n        Update user profile information.\n        \n        Args:\n            first_name: New first name (optional)\n            last_name: New last name (optional)\n            bio: New biography (optional)\n            avatar_url: New avatar URL (optional)\n        \"\"\"\n        if first_name is not None:\n            self.first_name = first_name\n        \n        if last_name is not None:\n            self.last_name = last_name\n        \n        if bio is not None:\n            self.bio = bio\n        \n        if avatar_url is not None:\n            self.avatar_url = avatar_url\n        \n        self.updated_at = datetime.utcnow()\n    \n    @property\n    def full_name(self) -> str:\n        \"\"\"Get the user's full name.\"\"\"\n        return f\"{self.first_name} {self.last_name}\".strip()\n    \n    @property\n    def is_authenticated(self) -> bool:\n        \"\"\"Check if user is authenticated (active and verified).\"\"\"\n        return self.is_active and self.is_verified\n    \n    @validates('username')\n    def validate_username(self, key: str, username: str) -> str:\n        \"\"\"\n        Validate username format and requirements.\n        \n        Args:\n            key: Field name being validated\n            username: Username value to validate\n            \n        Returns:\n            str: Validated username\n            \n        Raises:\n            ValueError: If username validation fails\n        \"\"\"\n        if not username:\n            raise ValueError(\"Username cannot be empty\")\n        \n        if len(username) < 3:\n            raise ValueError(\"Username must be at least 3 characters long\")\n        \n        if len(username) > 50:\n            raise ValueError(\"Username cannot exceed 50 characters\")\n        \n        if not re.match(r'^[a-zA-Z0-9_-]+",
      "file_type": "source",
      "semantic_unit_id": "SU-004",
      "component_id": "COMP-004",
      "description": "User database model with SQLAlchemy ORM including authentication fields, profile data, and task relationships"
    },
    {
      "file_path": "src/models/task.py",
      "content": "\"\"\"\nTask database model with SQLAlchemy ORM\n\nDefines the Task model with title, description, status, priority, and user relationship.\n\nComponent ID: COMP-005\nSemantic Unit: SU-005\n\nAuthor: ASP Code Generator\n\"\"\"\n\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Optional\n\nfrom sqlalchemy import Column, Integer, String, Text, DateTime, ForeignKey, Enum as SQLEnum\nfrom sqlalchemy.orm import relationship\n\nfrom src.database.connection import Base\n\n\nclass TaskStatus(str, Enum):\n    \"\"\"Enumeration for task status values.\"\"\"\n    PENDING = \"pending\"\n    IN_PROGRESS = \"in_progress\"\n    COMPLETED = \"completed\"\n    CANCELLED = \"cancelled\"\n\n\nclass TaskPriority(str, Enum):\n    \"\"\"Enumeration for task priority values.\"\"\"\n    LOW = \"low\"\n    MEDIUM = \"medium\"\n    HIGH = \"high\"\n    URGENT = \"urgent\"\n\n\nclass Task(Base):\n    \"\"\"\n    Task model representing a user task in the system.\n    \n    Attributes:\n        id: Primary key identifier\n        title: Task title (required, max 200 characters)\n        description: Detailed task description (optional)\n        status: Current task status (default: pending)\n        priority: Task priority level (default: medium)\n        user_id: Foreign key to user who owns the task\n        created_at: Timestamp when task was created\n        updated_at: Timestamp when task was last modified\n        due_date: Optional due date for task completion\n        \n    Relationships:\n        user: User who owns this task\n    \"\"\"\n    \n    __tablename__ = \"tasks\"\n    \n    # Primary key\n    id = Column(Integer, primary_key=True, index=True, autoincrement=True)\n    \n    # Task details\n    title = Column(String(200), nullable=False, index=True)\n    description = Column(Text, nullable=True)\n    \n    # Task metadata\n    status = Column(\n        SQLEnum(TaskStatus),\n        nullable=False,\n        default=TaskStatus.PENDING,\n        index=True\n    )\n    priority = Column(\n        SQLEnum(TaskPriority),\n        nullable=False,\n        default=TaskPriority.MEDIUM,\n        index=True\n    )\n    \n    # Timestamps\n    created_at = Column(\n        DateTime,\n        nullable=False,\n        default=datetime.utcnow,\n        index=True\n    )\n    updated_at = Column(\n        DateTime,\n        nullable=False,\n        default=datetime.utcnow,\n        onupdate=datetime.utcnow\n    )\n    due_date = Column(DateTime, nullable=True, index=True)\n    \n    # Foreign key relationship\n    user_id = Column(\n        Integer,\n        ForeignKey(\"users.id\", ondelete=\"CASCADE\"),\n        nullable=False,\n        index=True\n    )\n    \n    # Relationships\n    user = relationship(\"User\", back_populates=\"tasks\")\n    \n    def __repr__(self) -> str:\n        \"\"\"\n        String representation of Task instance.\n        \n        Returns:\n            str: Human-readable representation of the task\n        \"\"\"\n        return (\n            f\"<Task(id={self.id}, title='{self.title}', \"\n            f\"status='{self.status.value}', priority='{self.priority.value}', \"\n            f\"user_id={self.user_id})>\"\n        )\n    \n    def __str__(self) -> str:\n        \"\"\"\n        String representation for display purposes.\n        \n        Returns:\n            str: Display-friendly task representation\n        \"\"\"\n        return f\"Task: {self.title} ({self.status.value})\"\n    \n    def to_dict(self) -> dict:\n        \"\"\"\n        Convert task instance to dictionary representation.\n        \n        Returns:\n            dict: Dictionary containing all task attributes\n        \"\"\"\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"status\": self.status.value if self.status else None,\n            \"priority\": self.priority.value if self.priority else None,\n            \"user_id\": self.user_id,\n            \"created_at\": self.created_at.isoformat() if self.created_at else None,\n            \"updated_at\": self.updated_at.isoformat() if self.updated_at else None,\n            \"due_date\": self.due_date.isoformat() if self.due_date else None,\n        }\n    \n    def is_overdue(self) -> bool:\n        \"\"\"\n        Check if task is overdue based on due_date.\n        \n        Returns:\n            bool: True if task has due_date and it's in the past, False otherwise\n        \"\"\"\n        if not self.due_date:\n            return False\n        return datetime.utcnow() > self.due_date\n    \n    def is_completed(self) -> bool:\n        \"\"\"\n        Check if task is completed.\n        \n        Returns:\n            bool: True if task status is completed, False otherwise\n        \"\"\"\n        return self.status == TaskStatus.COMPLETED\n    \n    def is_active(self) -> bool:\n        \"\"\"\n        Check if task is active (not completed or cancelled).\n        \n        Returns:\n            bool: True if task is pending or in progress, False otherwise\n        \"\"\"\n        return self.status in [TaskStatus.PENDING, TaskStatus.IN_PROGRESS]\n    \n    def mark_completed(self) -> None:\n        \"\"\"\n        Mark task as completed and update timestamp.\n        \"\"\"\n        self.status = TaskStatus.COMPLETED\n        self.updated_at = datetime.utcnow()\n    \n    def mark_in_progress(self) -> None:\n        \"\"\"\n        Mark task as in progress and update timestamp.\n        \"\"\"\n        self.status = TaskStatus.IN_PROGRESS\n        self.updated_at = datetime.utcnow()\n    \n    def mark_cancelled(self) -> None:\n        \"\"\"\n        Mark task as cancelled and update timestamp.\n        \"\"\"\n        self.status = TaskStatus.CANCELLED\n        self.updated_at = datetime.utcnow()\n    \n    def update_priority(self, priority: TaskPriority) -> None:\n        \"\"\"\n        Update task priority and timestamp.\n        \n        Args:\n            priority: New priority level for the task\n            \n        Raises:\n            ValueError: If priority is not a valid TaskPriority enum value\n        \"\"\"\n        if not isinstance(priority, TaskPriority):\n            raise ValueError(f\"Priority must be a TaskPriority enum value, got {type(priority)}\")\n        \n        self.priority = priority\n        self.updated_at = datetime.utcnow()\n    \n    def set_due_date(self, due_date: Optional[datetime]) -> None:\n        \"\"\"\n        Set or update task due date.\n        \n        Args:\n            due_date: New due date for the task, or None to remove due date\n            \n        Raises:\n            ValueError: If due_date is in the past\n        \"\"\"\n        if due_date is not None and due_date < datetime.utcnow():\n            raise ValueError(\"Due date cannot be in the past\")\n        \n        self.due_date = due_date\n        self.updated_at = datetime.utcnow()\n    \n    @classmethod\n    def get_valid_statuses(cls) -> list[str]:\n        \"\"\"\n        Get list of valid task status values.\n        \n        Returns:\n            list[str]: List of valid status string values\n        \"\"\"\n        return [status.value for status in TaskStatus]\n    \n    @classmethod\n    def get_valid_priorities(cls) -> list[str]:\n        \"\"\"\n        Get list of valid task priority values.\n        \n        Returns:\n            list[str]: List of valid priority string values\n        \"\"\"\n        return [priority.value for priority in TaskPriority]",
      "file_type": "source",
      "semantic_unit_id": "SU-005",
      "component_id": "COMP-005",
      "description": "Task database model with SQLAlchemy ORM including title, description, status, priority, and user foreign key"
    },
    {
      "file_path": "src/schemas/user.py",
      "content": "\"\"\"\nPydantic schemas for user data validation\n\nThis module defines Pydantic models for user-related data validation including\nregistration, login, authentication, and API response schemas.\n\nComponent ID: COMP-006\nSemantic Unit: SU-006\n\nAuthor: ASP Code Agent\n\"\"\"\n\nfrom datetime import datetime\nfrom typing import Optional\nfrom pydantic import BaseModel, EmailStr, Field, validator\nimport re\n\n\nclass UserRegistrationRequest(BaseModel):\n    \"\"\"\n    Schema for user registration requests.\n    \n    Validates user input for account creation including email format,\n    password strength, and username requirements.\n    \"\"\"\n    username: str = Field(\n        ...,\n        min_length=3,\n        max_length=50,\n        description=\"Username must be 3-50 characters long\"\n    )\n    email: EmailStr = Field(\n        ...,\n        description=\"Valid email address required\"\n    )\n    password: str = Field(\n        ...,\n        min_length=8,\n        max_length=128,\n        description=\"Password must be 8-128 characters long\"\n    )\n    full_name: Optional[str] = Field(\n        None,\n        max_length=100,\n        description=\"Optional full name, max 100 characters\"\n    )\n\n    @validator('username')\n    def validate_username(cls, v: str) -> str:\n        \"\"\"\n        Validate username format.\n        \n        Args:\n            v: Username string to validate\n            \n        Returns:\n            str: Validated username\n            \n        Raises:\n            ValueError: If username contains invalid characters\n        \"\"\"\n        if not re.match(r'^[a-zA-Z0-9_-]+$', v):\n            raise ValueError('Username can only contain letters, numbers, underscores, and hyphens')\n        return v.lower()\n\n    @validator('password')\n    def validate_password_strength(cls, v: str) -> str:\n        \"\"\"\n        Validate password strength requirements.\n        \n        Args:\n            v: Password string to validate\n            \n        Returns:\n            str: Validated password\n            \n        Raises:\n            ValueError: If password doesn't meet strength requirements\n        \"\"\"\n        if not re.search(r'[A-Z]', v):\n            raise ValueError('Password must contain at least one uppercase letter')\n        if not re.search(r'[a-z]', v):\n            raise ValueError('Password must contain at least one lowercase letter')\n        if not re.search(r'\\d', v):\n            raise ValueError('Password must contain at least one digit')\n        if not re.search(r'[!@#$%^&*(),.?\":{}|<>]', v):\n            raise ValueError('Password must contain at least one special character')\n        return v\n\n    @validator('full_name')\n    def validate_full_name(cls, v: Optional[str]) -> Optional[str]:\n        \"\"\"\n        Validate full name format if provided.\n        \n        Args:\n            v: Full name string to validate\n            \n        Returns:\n            Optional[str]: Validated full name or None\n            \n        Raises:\n            ValueError: If full name contains invalid characters\n        \"\"\"\n        if v is not None:\n            v = v.strip()\n            if not v:\n                return None\n            if not re.match(r'^[a-zA-Z\\s\\'-]+$', v):\n                raise ValueError('Full name can only contain letters, spaces, hyphens, and apostrophes')\n        return v\n\n\nclass UserLoginRequest(BaseModel):\n    \"\"\"\n    Schema for user login requests.\n    \n    Validates user credentials for authentication.\n    \"\"\"\n    username: str = Field(\n        ...,\n        min_length=1,\n        max_length=50,\n        description=\"Username or email address\"\n    )\n    password: str = Field(\n        ...,\n        min_length=1,\n        max_length=128,\n        description=\"User password\"\n    )\n\n    @validator('username')\n    def validate_username_or_email(cls, v: str) -> str:\n        \"\"\"\n        Validate username or email format for login.\n        \n        Args:\n            v: Username or email string to validate\n            \n        Returns:\n            str: Validated username/email\n        \"\"\"\n        return v.strip().lower()\n\n\nclass UserResponse(BaseModel):\n    \"\"\"\n    Schema for user data in API responses.\n    \n    Contains safe user information without sensitive data like passwords.\n    \"\"\"\n    id: int = Field(..., description=\"Unique user identifier\")\n    username: str = Field(..., description=\"User's username\")\n    email: str = Field(..., description=\"User's email address\")\n    full_name: Optional[str] = Field(None, description=\"User's full name\")\n    is_active: bool = Field(True, description=\"Whether user account is active\")\n    created_at: datetime = Field(..., description=\"Account creation timestamp\")\n    updated_at: datetime = Field(..., description=\"Last account update timestamp\")\n\n    class Config:\n        \"\"\"Pydantic model configuration.\"\"\"\n        from_attributes = True\n        json_encoders = {\n            datetime: lambda v: v.isoformat() + 'Z'\n        }\n\n\nclass UserUpdateRequest(BaseModel):\n    \"\"\"\n    Schema for user profile update requests.\n    \n    Allows partial updates to user profile information.\n    \"\"\"\n    email: Optional[EmailStr] = Field(\n        None,\n        description=\"New email address\"\n    )\n    full_name: Optional[str] = Field(\n        None,\n        max_length=100,\n        description=\"Updated full name\"\n    )\n\n    @validator('full_name')\n    def validate_full_name_update(cls, v: Optional[str]) -> Optional[str]:\n        \"\"\"\n        Validate full name format for updates.\n        \n        Args:\n            v: Full name string to validate\n            \n        Returns:\n            Optional[str]: Validated full name or None\n            \n        Raises:\n            ValueError: If full name contains invalid characters\n        \"\"\"\n        if v is not None:\n            v = v.strip()\n            if not v:\n                return None\n            if not re.match(r'^[a-zA-Z\\s\\'-]+$', v):\n                raise ValueError('Full name can only contain letters, spaces, hyphens, and apostrophes')\n        return v\n\n\nclass PasswordChangeRequest(BaseModel):\n    \"\"\"\n    Schema for password change requests.\n    \n    Validates current password and new password for security.\n    \"\"\"\n    current_password: str = Field(\n        ...,\n        min_length=1,\n        max_length=128,\n        description=\"Current password for verification\"\n    )\n    new_password: str = Field(\n        ...,\n        min_length=8,\n        max_length=128,\n        description=\"New password to set\"\n    )\n\n    @validator('new_password')\n    def validate_new_password_strength(cls, v: str) -> str:\n        \"\"\"\n        Validate new password strength requirements.\n        \n        Args:\n            v: New password string to validate\n            \n        Returns:\n            str: Validated new password\n            \n        Raises:\n            ValueError: If password doesn't meet strength requirements\n        \"\"\"\n        if not re.search(r'[A-Z]', v):\n            raise ValueError('Password must contain at least one uppercase letter')\n        if not re.search(r'[a-z]', v):\n            raise ValueError('Password must contain at least one lowercase letter')\n        if not re.search(r'\\d', v):\n            raise ValueError('Password must contain at least one digit')\n        if not re.search(r'[!@#$%^&*(),.?\":{}|<>]', v):\n            raise ValueError('Password must contain at least one special character')\n        return v\n\n\nclass TokenResponse(BaseModel):\n    \"\"\"\n    Schema for authentication token responses.\n    \n    Contains JWT access token and token metadata.\n    \"\"\"\n    access_token: str = Field(..., description=\"JWT access token\")\n    token_type: str = Field(default=\"bearer\", description=\"Token type\")\n    expires_in: int = Field(..., description=\"Token expiration time in seconds\")\n    user: UserResponse = Field(..., description=\"Authenticated user information\")\n\n\nclass UserListResponse(BaseModel):\n    \"\"\"\n    Schema for paginated user list responses",
      "file_type": "source",
      "semantic_unit_id": "SU-006",
      "component_id": "COMP-006",
      "description": "Pydantic schemas for user data validation including registration, login, and response models"
    },
    {
      "file_path": "src/schemas/task.py",
      "content": "\"\"\"\nPydantic schemas for task data validation.\n\nThis module defines the data validation schemas for task-related operations\nincluding create, update, and response models with status enums.\n\nComponent ID: COMP-007\nSemantic Unit: SU-007\n\nAuthor: ASP Code Agent\n\"\"\"\n\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Optional\nfrom uuid import UUID\n\nfrom pydantic import BaseModel, Field, validator\n\n\nclass TaskStatus(str, Enum):\n    \"\"\"Enumeration of possible task statuses.\"\"\"\n    \n    PENDING = \"pending\"\n    IN_PROGRESS = \"in_progress\"\n    COMPLETED = \"completed\"\n    CANCELLED = \"cancelled\"\n    FAILED = \"failed\"\n\n\nclass TaskPriority(str, Enum):\n    \"\"\"Enumeration of task priority levels.\"\"\"\n    \n    LOW = \"low\"\n    MEDIUM = \"medium\"\n    HIGH = \"high\"\n    URGENT = \"urgent\"\n\n\nclass TaskCreateRequest(BaseModel):\n    \"\"\"Schema for creating a new task.\"\"\"\n    \n    title: str = Field(\n        ...,\n        min_length=1,\n        max_length=200,\n        description=\"Task title\"\n    )\n    description: Optional[str] = Field(\n        None,\n        max_length=2000,\n        description=\"Detailed task description\"\n    )\n    priority: TaskPriority = Field(\n        TaskPriority.MEDIUM,\n        description=\"Task priority level\"\n    )\n    due_date: Optional[datetime] = Field(\n        None,\n        description=\"Task due date and time\"\n    )\n    tags: Optional[list[str]] = Field(\n        None,\n        description=\"List of task tags\"\n    )\n    \n    @validator('title')\n    def validate_title(cls, v: str) -> str:\n        \"\"\"Validate task title is not empty after stripping whitespace.\"\"\"\n        if not v.strip():\n            raise ValueError('Title cannot be empty or whitespace only')\n        return v.strip()\n    \n    @validator('description')\n    def validate_description(cls, v: Optional[str]) -> Optional[str]:\n        \"\"\"Validate and clean task description.\"\"\"\n        if v is not None:\n            v = v.strip()\n            if not v:\n                return None\n        return v\n    \n    @validator('due_date')\n    def validate_due_date(cls, v: Optional[datetime]) -> Optional[datetime]:\n        \"\"\"Validate due date is not in the past.\"\"\"\n        if v is not None and v < datetime.utcnow():\n            raise ValueError('Due date cannot be in the past')\n        return v\n    \n    @validator('tags')\n    def validate_tags(cls, v: Optional[list[str]]) -> Optional[list[str]]:\n        \"\"\"Validate and clean task tags.\"\"\"\n        if v is not None:\n            # Remove empty tags and duplicates while preserving order\n            cleaned_tags = []\n            seen = set()\n            for tag in v:\n                tag = tag.strip().lower()\n                if tag and tag not in seen:\n                    cleaned_tags.append(tag)\n                    seen.add(tag)\n            return cleaned_tags if cleaned_tags else None\n        return v\n\n\nclass TaskUpdateRequest(BaseModel):\n    \"\"\"Schema for updating an existing task.\"\"\"\n    \n    title: Optional[str] = Field(\n        None,\n        min_length=1,\n        max_length=200,\n        description=\"Updated task title\"\n    )\n    description: Optional[str] = Field(\n        None,\n        max_length=2000,\n        description=\"Updated task description\"\n    )\n    status: Optional[TaskStatus] = Field(\n        None,\n        description=\"Updated task status\"\n    )\n    priority: Optional[TaskPriority] = Field(\n        None,\n        description=\"Updated task priority\"\n    )\n    due_date: Optional[datetime] = Field(\n        None,\n        description=\"Updated task due date\"\n    )\n    tags: Optional[list[str]] = Field(\n        None,\n        description=\"Updated list of task tags\"\n    )\n    \n    @validator('title')\n    def validate_title(cls, v: Optional[str]) -> Optional[str]:\n        \"\"\"Validate task title is not empty after stripping whitespace.\"\"\"\n        if v is not None:\n            v = v.strip()\n            if not v:\n                raise ValueError('Title cannot be empty or whitespace only')\n        return v\n    \n    @validator('description')\n    def validate_description(cls, v: Optional[str]) -> Optional[str]:\n        \"\"\"Validate and clean task description.\"\"\"\n        if v is not None:\n            v = v.strip()\n            if not v:\n                return None\n        return v\n    \n    @validator('due_date')\n    def validate_due_date(cls, v: Optional[datetime]) -> Optional[datetime]:\n        \"\"\"Validate due date is not in the past.\"\"\"\n        if v is not None and v < datetime.utcnow():\n            raise ValueError('Due date cannot be in the past')\n        return v\n    \n    @validator('tags')\n    def validate_tags(cls, v: Optional[list[str]]) -> Optional[list[str]]:\n        \"\"\"Validate and clean task tags.\"\"\"\n        if v is not None:\n            # Remove empty tags and duplicates while preserving order\n            cleaned_tags = []\n            seen = set()\n            for tag in v:\n                tag = tag.strip().lower()\n                if tag and tag not in seen:\n                    cleaned_tags.append(tag)\n                    seen.add(tag)\n            return cleaned_tags if cleaned_tags else None\n        return v\n\n\nclass TaskResponse(BaseModel):\n    \"\"\"Schema for task response data.\"\"\"\n    \n    id: UUID = Field(..., description=\"Unique task identifier\")\n    title: str = Field(..., description=\"Task title\")\n    description: Optional[str] = Field(None, description=\"Task description\")\n    status: TaskStatus = Field(..., description=\"Current task status\")\n    priority: TaskPriority = Field(..., description=\"Task priority level\")\n    due_date: Optional[datetime] = Field(None, description=\"Task due date\")\n    tags: Optional[list[str]] = Field(None, description=\"Task tags\")\n    created_at: datetime = Field(..., description=\"Task creation timestamp\")\n    updated_at: datetime = Field(..., description=\"Last update timestamp\")\n    completed_at: Optional[datetime] = Field(\n        None,\n        description=\"Task completion timestamp\"\n    )\n    \n    class Config:\n        \"\"\"Pydantic model configuration.\"\"\"\n        \n        json_encoders = {\n            datetime: lambda v: v.isoformat() + 'Z' if v else None,\n            UUID: str\n        }\n        schema_extra = {\n            \"example\": {\n                \"id\": \"550e8400-e29b-41d4-a716-446655440000\",\n                \"title\": \"Complete project documentation\",\n                \"description\": \"Write comprehensive documentation for the API\",\n                \"status\": \"in_progress\",\n                \"priority\": \"high\",\n                \"due_date\": \"2024-01-15T10:00:00Z\",\n                \"tags\": [\"documentation\", \"api\", \"urgent\"],\n                \"created_at\": \"2024-01-01T09:00:00Z\",\n                \"updated_at\": \"2024-01-02T14:30:00Z\",\n                \"completed_at\": None\n            }\n        }\n\n\nclass TaskListResponse(BaseModel):\n    \"\"\"Schema for paginated task list response.\"\"\"\n    \n    tasks: list[TaskResponse] = Field(..., description=\"List of tasks\")\n    total: int = Field(..., ge=0, description=\"Total number of tasks\")\n    page: int = Field(..., ge=1, description=\"Current page number\")\n    page_size: int = Field(..., ge=1, le=100, description=\"Number of items per page\")\n    total_pages: int = Field(..., ge=0, description=\"Total number of pages\")\n    \n    class Config:\n        \"\"\"Pydantic model configuration.\"\"\"\n        \n        schema_extra = {\n            \"example\": {\n                \"tasks\": [\n                    {\n                        \"id\": \"550e8400-e29b-41d4-a716-446655440000\",\n                        \"title\": \"",
      "file_type": "source",
      "semantic_unit_id": "SU-007",
      "component_id": "COMP-007",
      "description": "Pydantic schemas for task data validation including create, update, and response models with status enums"
    },
    {
      "file_path": "src/utils/jwt_utils.py",
      "content": "\"\"\"\nJWT token generation, validation, and decoding utilities.\n\nProvides utilities for creating and validating JWT access and refresh tokens\nwith proper security practices and error handling.\n\nComponent ID: COMP-008\nSemantic Unit: SU-008\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport logging\nfrom datetime import datetime, timedelta, timezone\nfrom typing import Any, Dict, Optional, Union\n\nimport jwt\nfrom jwt.exceptions import DecodeError, ExpiredSignatureError, InvalidTokenError\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass JWTError(Exception):\n    \"\"\"Base exception for JWT-related errors.\"\"\"\n    pass\n\n\nclass TokenExpiredError(JWTError):\n    \"\"\"Raised when a JWT token has expired.\"\"\"\n    pass\n\n\nclass TokenInvalidError(JWTError):\n    \"\"\"Raised when a JWT token is invalid or malformed.\"\"\"\n    pass\n\n\nclass JWTUtils:\n    \"\"\"\n    JWT token utilities for generating, validating, and decoding tokens.\n    \n    Supports both access and refresh tokens with configurable expiration times\n    and proper security practices.\n    \"\"\"\n    \n    def __init__(\n        self,\n        secret_key: str,\n        algorithm: str = \"HS256\",\n        access_token_expire_minutes: int = 30,\n        refresh_token_expire_days: int = 7\n    ) -> None:\n        \"\"\"\n        Initialize JWT utilities with configuration.\n        \n        Args:\n            secret_key: Secret key for signing tokens\n            algorithm: JWT signing algorithm (default: HS256)\n            access_token_expire_minutes: Access token expiration in minutes\n            refresh_token_expire_days: Refresh token expiration in days\n            \n        Raises:\n            ValueError: If secret_key is empty or None\n        \"\"\"\n        if not secret_key:\n            raise ValueError(\"Secret key cannot be empty or None\")\n            \n        self.secret_key = secret_key\n        self.algorithm = algorithm\n        self.access_token_expire_minutes = access_token_expire_minutes\n        self.refresh_token_expire_days = refresh_token_expire_days\n        \n        logger.info(\n            \"JWT utilities initialized with algorithm=%s, \"\n            \"access_expire=%d min, refresh_expire=%d days\",\n            algorithm, access_token_expire_minutes, refresh_token_expire_days\n        )\n    \n    def generate_access_token(\n        self,\n        subject: str,\n        additional_claims: Optional[Dict[str, Any]] = None,\n        expires_delta: Optional[timedelta] = None\n    ) -> str:\n        \"\"\"\n        Generate a JWT access token.\n        \n        Args:\n            subject: Token subject (typically user ID or username)\n            additional_claims: Additional claims to include in token\n            expires_delta: Custom expiration time (overrides default)\n            \n        Returns:\n            str: Encoded JWT access token\n            \n        Raises:\n            ValueError: If subject is empty or None\n            JWTError: If token generation fails\n        \"\"\"\n        if not subject:\n            raise ValueError(\"Subject cannot be empty or None\")\n            \n        try:\n            now = datetime.now(timezone.utc)\n            \n            if expires_delta:\n                expire = now + expires_delta\n            else:\n                expire = now + timedelta(minutes=self.access_token_expire_minutes)\n            \n            payload = {\n                \"sub\": subject,\n                \"iat\": now,\n                \"exp\": expire,\n                \"type\": \"access\"\n            }\n            \n            if additional_claims:\n                payload.update(additional_claims)\n            \n            token = jwt.encode(payload, self.secret_key, algorithm=self.algorithm)\n            \n            logger.debug(\n                \"Generated access token for subject=%s, expires=%s\",\n                subject, expire.isoformat()\n            )\n            \n            return token\n            \n        except Exception as e:\n            logger.error(\"Failed to generate access token: %s\", str(e))\n            raise JWTError(f\"Token generation failed: {str(e)}\") from e\n    \n    def generate_refresh_token(\n        self,\n        subject: str,\n        additional_claims: Optional[Dict[str, Any]] = None,\n        expires_delta: Optional[timedelta] = None\n    ) -> str:\n        \"\"\"\n        Generate a JWT refresh token.\n        \n        Args:\n            subject: Token subject (typically user ID or username)\n            additional_claims: Additional claims to include in token\n            expires_delta: Custom expiration time (overrides default)\n            \n        Returns:\n            str: Encoded JWT refresh token\n            \n        Raises:\n            ValueError: If subject is empty or None\n            JWTError: If token generation fails\n        \"\"\"\n        if not subject:\n            raise ValueError(\"Subject cannot be empty or None\")\n            \n        try:\n            now = datetime.now(timezone.utc)\n            \n            if expires_delta:\n                expire = now + expires_delta\n            else:\n                expire = now + timedelta(days=self.refresh_token_expire_days)\n            \n            payload = {\n                \"sub\": subject,\n                \"iat\": now,\n                \"exp\": expire,\n                \"type\": \"refresh\"\n            }\n            \n            if additional_claims:\n                payload.update(additional_claims)\n            \n            token = jwt.encode(payload, self.secret_key, algorithm=self.algorithm)\n            \n            logger.debug(\n                \"Generated refresh token for subject=%s, expires=%s\",\n                subject, expire.isoformat()\n            )\n            \n            return token\n            \n        except Exception as e:\n            logger.error(\"Failed to generate refresh token: %s\", str(e))\n            raise JWTError(f\"Token generation failed: {str(e)}\") from e\n    \n    def decode_token(\n        self,\n        token: str,\n        verify_exp: bool = True,\n        verify_signature: bool = True\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Decode and validate a JWT token.\n        \n        Args:\n            token: JWT token to decode\n            verify_exp: Whether to verify token expiration\n            verify_signature: Whether to verify token signature\n            \n        Returns:\n            dict: Decoded token payload\n            \n        Raises:\n            ValueError: If token is empty or None\n            TokenExpiredError: If token has expired\n            TokenInvalidError: If token is invalid or malformed\n        \"\"\"\n        if not token:\n            raise ValueError(\"Token cannot be empty or None\")\n            \n        try:\n            options = {\n                \"verify_exp\": verify_exp,\n                \"verify_signature\": verify_signature\n            }\n            \n            payload = jwt.decode(\n                token,\n                self.secret_key,\n                algorithms=[self.algorithm],\n                options=options\n            )\n            \n            logger.debug(\n                \"Successfully decoded token for subject=%s\",\n                payload.get(\"sub\", \"unknown\")\n            )\n            \n            return payload\n            \n        except ExpiredSignatureError as e:\n            logger.warning(\"Token has expired: %s\", str(e))\n            raise TokenExpiredError(\"Token has expired\") from e\n            \n        except (DecodeError, InvalidTokenError) as e:\n            logger.warning(\"Invalid token: %s\", str(e))\n            raise TokenInvalidError(\"Token is invalid or malformed\") from e\n            \n        except Exception as e:\n            logger.error(\"Failed to decode token: %s\", str(e))\n            raise TokenInvalidError(f\"Token decoding failed: {str(e)}\") from e\n    \n    def validate_token(\n        self,\n        token: str,\n        expected_type: Optional[str] = None\n    ) -> bool:\n        \"\"\"\n        Validate a JWT token without raising exceptions.\n        \n        Args:\n            token: JWT token to validate\n            expected_type: Expected token type (\"access\" or \"refresh\")\n            \n        Returns:\n            bool: True if token is valid, False otherwise\n        \"\"\"\n        try:\n            payload = self.decode_token(token)\n            \n            if expected_type:\n                token_type = payload.get(\"type\")\n                if token_type != expected_type:\n                    logger.warning(\n                        \"Token type mismatch: expected=%s, actual=%s\",\n                        expected_type, token_type",
      "file_type": "source",
      "semantic_unit_id": "SU-008",
      "component_id": "COMP-008",
      "description": "JWT token generation, validation, decoding utilities with access and refresh token support"
    },
    {
      "file_path": "src/utils/password.py",
      "content": "\"\"\"\nPassword hashing and verification utilities using bcrypt.\n\nThis module provides secure password hashing and verification functionality\nusing bcrypt with configurable salt rounds for optimal security.\n\nComponent ID: COMP-009\nSemantic Unit: SU-009\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport bcrypt\nimport logging\nfrom typing import Union\n\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Default salt rounds for bcrypt hashing\nDEFAULT_SALT_ROUNDS = 12\n\n\nclass PasswordHashingError(Exception):\n    \"\"\"Exception raised when password hashing operations fail.\"\"\"\n    pass\n\n\nclass PasswordVerificationError(Exception):\n    \"\"\"Exception raised when password verification operations fail.\"\"\"\n    pass\n\n\ndef hash_password(password: str, salt_rounds: int = DEFAULT_SALT_ROUNDS) -> str:\n    \"\"\"\n    Hash a password using bcrypt with specified salt rounds.\n    \n    Args:\n        password: The plain text password to hash\n        salt_rounds: Number of salt rounds for bcrypt (default: 12)\n        \n    Returns:\n        str: The hashed password as a string\n        \n    Raises:\n        PasswordHashingError: If password hashing fails\n        ValueError: If password is empty or salt_rounds is invalid\n        \n    Example:\n        >>> hashed = hash_password(\"my_secure_password\")\n        >>> len(hashed) > 0\n        True\n    \"\"\"\n    if not password:\n        raise ValueError(\"Password cannot be empty\")\n        \n    if not isinstance(password, str):\n        raise ValueError(\"Password must be a string\")\n        \n    if not isinstance(salt_rounds, int) or salt_rounds < 4 or salt_rounds > 31:\n        raise ValueError(\"Salt rounds must be an integer between 4 and 31\")\n    \n    try:\n        # Convert password to bytes\n        password_bytes = password.encode('utf-8')\n        \n        # Generate salt with specified rounds\n        salt = bcrypt.gensalt(rounds=salt_rounds)\n        \n        # Hash the password\n        hashed_bytes = bcrypt.hashpw(password_bytes, salt)\n        \n        # Convert back to string for storage\n        hashed_password = hashed_bytes.decode('utf-8')\n        \n        logger.debug(f\"Password hashed successfully with {salt_rounds} salt rounds\")\n        return hashed_password\n        \n    except Exception as e:\n        logger.error(f\"Password hashing failed: {str(e)}\")\n        raise PasswordHashingError(f\"Failed to hash password: {str(e)}\") from e\n\n\ndef verify_password(password: str, hashed_password: str) -> bool:\n    \"\"\"\n    Verify a password against its hash using bcrypt.\n    \n    Args:\n        password: The plain text password to verify\n        hashed_password: The hashed password to verify against\n        \n    Returns:\n        bool: True if password matches hash, False otherwise\n        \n    Raises:\n        PasswordVerificationError: If password verification fails\n        ValueError: If password or hashed_password is empty\n        \n    Example:\n        >>> hashed = hash_password(\"test_password\")\n        >>> verify_password(\"test_password\", hashed)\n        True\n        >>> verify_password(\"wrong_password\", hashed)\n        False\n    \"\"\"\n    if not password:\n        raise ValueError(\"Password cannot be empty\")\n        \n    if not hashed_password:\n        raise ValueError(\"Hashed password cannot be empty\")\n        \n    if not isinstance(password, str):\n        raise ValueError(\"Password must be a string\")\n        \n    if not isinstance(hashed_password, str):\n        raise ValueError(\"Hashed password must be a string\")\n    \n    try:\n        # Convert inputs to bytes\n        password_bytes = password.encode('utf-8')\n        hashed_bytes = hashed_password.encode('utf-8')\n        \n        # Verify password using bcrypt\n        is_valid = bcrypt.checkpw(password_bytes, hashed_bytes)\n        \n        logger.debug(f\"Password verification completed: {'success' if is_valid else 'failed'}\")\n        return is_valid\n        \n    except Exception as e:\n        logger.error(f\"Password verification failed: {str(e)}\")\n        raise PasswordVerificationError(f\"Failed to verify password: {str(e)}\") from e\n\n\ndef is_password_strong(password: str, min_length: int = 8) -> tuple[bool, list[str]]:\n    \"\"\"\n    Check if a password meets basic strength requirements.\n    \n    Args:\n        password: The password to check\n        min_length: Minimum required password length (default: 8)\n        \n    Returns:\n        tuple: (is_strong: bool, issues: list[str])\n               is_strong is True if password is strong\n               issues contains list of strength issues found\n               \n    Raises:\n        ValueError: If password is not a string or min_length is invalid\n        \n    Example:\n        >>> is_strong, issues = is_password_strong(\"WeakPass\")\n        >>> is_strong\n        False\n        >>> \"No digits found\" in issues\n        True\n    \"\"\"\n    if not isinstance(password, str):\n        raise ValueError(\"Password must be a string\")\n        \n    if not isinstance(min_length, int) or min_length < 1:\n        raise ValueError(\"Minimum length must be a positive integer\")\n    \n    issues = []\n    \n    # Check length\n    if len(password) < min_length:\n        issues.append(f\"Password must be at least {min_length} characters long\")\n    \n    # Check for uppercase letters\n    if not any(c.isupper() for c in password):\n        issues.append(\"No uppercase letters found\")\n    \n    # Check for lowercase letters\n    if not any(c.islower() for c in password):\n        issues.append(\"No lowercase letters found\")\n    \n    # Check for digits\n    if not any(c.isdigit() for c in password):\n        issues.append(\"No digits found\")\n    \n    # Check for special characters\n    special_chars = \"!@#$%^&*()_+-=[]{}|;:,.<>?\"\n    if not any(c in special_chars for c in password):\n        issues.append(\"No special characters found\")\n    \n    is_strong = len(issues) == 0\n    \n    logger.debug(f\"Password strength check: {'strong' if is_strong else 'weak'} \"\n                f\"({len(issues)} issues found)\")\n    \n    return is_strong, issues",
      "file_type": "source",
      "semantic_unit_id": "SU-009",
      "component_id": "COMP-009",
      "description": "Password hashing and verification utilities using bcrypt with salt rounds configuration"
    },
    {
      "file_path": "src/database/connection.py",
      "content": "\"\"\"\nSQLAlchemy database connection setup and session management.\n\nProvides database connection configuration, session factory, and base model\nfor the Hello World API application.\n\nComponent ID: COMP-010\nSemantic Unit: SU-010\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport os\nfrom typing import Generator, Optional\nfrom contextlib import contextmanager\nimport logging\n\nfrom sqlalchemy import create_engine, Engine, event\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom sqlalchemy.pool import StaticPool\nfrom sqlalchemy.exc import SQLAlchemyError\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Base class for all database models\nBase = declarative_base()\n\n# Global database engine and session factory\n_engine: Optional[Engine] = None\n_session_factory: Optional[sessionmaker] = None\n\n\nclass DatabaseConfig:\n    \"\"\"Database configuration settings.\"\"\"\n    \n    def __init__(self) -> None:\n        \"\"\"Initialize database configuration from environment variables.\"\"\"\n        self.database_url = os.getenv(\n            \"DATABASE_URL\", \n            \"sqlite:///./hello_world.db\"\n        )\n        self.echo_sql = os.getenv(\"DATABASE_ECHO\", \"false\").lower() == \"true\"\n        self.pool_size = int(os.getenv(\"DATABASE_POOL_SIZE\", \"5\"))\n        self.max_overflow = int(os.getenv(\"DATABASE_MAX_OVERFLOW\", \"10\"))\n        self.pool_timeout = int(os.getenv(\"DATABASE_POOL_TIMEOUT\", \"30\"))\n        self.pool_recycle = int(os.getenv(\"DATABASE_POOL_RECYCLE\", \"3600\"))\n    \n    def get_engine_kwargs(self) -> dict:\n        \"\"\"Get SQLAlchemy engine configuration parameters.\"\"\"\n        kwargs = {\n            \"echo\": self.echo_sql,\n        }\n        \n        # SQLite-specific configuration\n        if self.database_url.startswith(\"sqlite\"):\n            kwargs.update({\n                \"poolclass\": StaticPool,\n                \"connect_args\": {\"check_same_thread\": False},\n            })\n        else:\n            # PostgreSQL/MySQL configuration\n            kwargs.update({\n                \"pool_size\": self.pool_size,\n                \"max_overflow\": self.max_overflow,\n                \"pool_timeout\": self.pool_timeout,\n                \"pool_recycle\": self.pool_recycle,\n            })\n        \n        return kwargs\n\n\ndef create_database_engine(config: Optional[DatabaseConfig] = None) -> Engine:\n    \"\"\"\n    Create and configure SQLAlchemy database engine.\n    \n    Args:\n        config: Database configuration. If None, creates default config.\n        \n    Returns:\n        Engine: Configured SQLAlchemy engine\n        \n    Raises:\n        SQLAlchemyError: If engine creation fails\n    \"\"\"\n    if config is None:\n        config = DatabaseConfig()\n    \n    try:\n        engine = create_engine(\n            config.database_url,\n            **config.get_engine_kwargs()\n        )\n        \n        # Add connection event listeners\n        _setup_engine_events(engine)\n        \n        logger.info(f\"Database engine created for URL: {config.database_url}\")\n        return engine\n        \n    except Exception as e:\n        logger.error(f\"Failed to create database engine: {e}\")\n        raise SQLAlchemyError(f\"Database engine creation failed: {e}\") from e\n\n\ndef _setup_engine_events(engine: Engine) -> None:\n    \"\"\"Set up SQLAlchemy engine event listeners.\"\"\"\n    \n    @event.listens_for(engine, \"connect\")\n    def set_sqlite_pragma(dbapi_connection, connection_record):\n        \"\"\"Enable foreign key constraints for SQLite connections.\"\"\"\n        if engine.url.drivername == \"sqlite\":\n            cursor = dbapi_connection.cursor()\n            cursor.execute(\"PRAGMA foreign_keys=ON\")\n            cursor.close()\n    \n    @event.listens_for(engine, \"engine_connect\")\n    def receive_engine_connect(conn, branch):\n        \"\"\"Log database connections.\"\"\"\n        logger.debug(\"Database connection established\")\n\n\ndef initialize_database(config: Optional[DatabaseConfig] = None) -> None:\n    \"\"\"\n    Initialize global database engine and session factory.\n    \n    Args:\n        config: Database configuration. If None, creates default config.\n        \n    Raises:\n        SQLAlchemyError: If initialization fails\n    \"\"\"\n    global _engine, _session_factory\n    \n    try:\n        _engine = create_database_engine(config)\n        _session_factory = sessionmaker(\n            bind=_engine,\n            autocommit=False,\n            autoflush=False,\n            expire_on_commit=False\n        )\n        \n        logger.info(\"Database initialized successfully\")\n        \n    except Exception as e:\n        logger.error(f\"Database initialization failed: {e}\")\n        raise SQLAlchemyError(f\"Database initialization failed: {e}\") from e\n\n\ndef create_tables() -> None:\n    \"\"\"\n    Create all database tables defined by models.\n    \n    Raises:\n        SQLAlchemyError: If table creation fails\n    \"\"\"\n    if _engine is None:\n        raise SQLAlchemyError(\"Database not initialized. Call initialize_database() first.\")\n    \n    try:\n        Base.metadata.create_all(bind=_engine)\n        logger.info(\"Database tables created successfully\")\n        \n    except Exception as e:\n        logger.error(f\"Failed to create database tables: {e}\")\n        raise SQLAlchemyError(f\"Table creation failed: {e}\") from e\n\n\ndef drop_tables() -> None:\n    \"\"\"\n    Drop all database tables.\n    \n    Raises:\n        SQLAlchemyError: If table dropping fails\n    \"\"\"\n    if _engine is None:\n        raise SQLAlchemyError(\"Database not initialized. Call initialize_database() first.\")\n    \n    try:\n        Base.metadata.drop_all(bind=_engine)\n        logger.info(\"Database tables dropped successfully\")\n        \n    except Exception as e:\n        logger.error(f\"Failed to drop database tables: {e}\")\n        raise SQLAlchemyError(f\"Table dropping failed: {e}\") from e\n\n\ndef get_session() -> Session:\n    \"\"\"\n    Create a new database session.\n    \n    Returns:\n        Session: SQLAlchemy database session\n        \n    Raises:\n        SQLAlchemyError: If session creation fails\n    \"\"\"\n    if _session_factory is None:\n        raise SQLAlchemyError(\"Database not initialized. Call initialize_database() first.\")\n    \n    try:\n        return _session_factory()\n        \n    except Exception as e:\n        logger.error(f\"Failed to create database session: {e}\")\n        raise SQLAlchemyError(f\"Session creation failed: {e}\") from e\n\n\n@contextmanager\ndef get_db_session() -> Generator[Session, None, None]:\n    \"\"\"\n    Context manager for database sessions with automatic cleanup.\n    \n    Yields:\n        Session: SQLAlchemy database session\n        \n    Raises:\n        SQLAlchemyError: If session operations fail\n    \"\"\"\n    session = get_session()\n    try:\n        yield session\n        session.commit()\n        \n    except Exception as e:\n        session.rollback()\n        logger.error(f\"Database session error: {e}\")\n        raise SQLAlchemyError(f\"Database operation failed: {e}\") from e\n        \n    finally:\n        session.close()\n\n\ndef get_engine() -> Engine:\n    \"\"\"\n    Get the global database engine.\n    \n    Returns:\n        Engine: SQLAlchemy database engine\n        \n    Raises:\n        SQLAlchemyError: If engine is not initialized\n    \"\"\"\n    if _engine is None:\n        raise SQLAlchemyError(\"Database not initialized. Call initialize_database() first.\")\n    \n    return _engine\n\n\ndef close_database() -> None:\n    \"\"\"Close database connections and cleanup resources.\"\"\"\n    global _engine, _session_factory\n    \n    if _engine is not None:\n        _engine.dispose()\n        _engine = None\n        _session_factory = None\n        logger.info(\"Database connections closed\")\n\n\ndef health_check() -> bool:\n    \"\"\"\n    Check database connectivity.",
      "file_type": "source",
      "semantic_unit_id": "SU-010",
      "component_id": "COMP-010",
      "description": "SQLAlchemy database connection setup, session management, and base model configuration"
    },
    {
      "file_path": "src/database/migrations/001_initial_schema.py",
      "content": "\"\"\"Initial database schema migration\n\nCreates user and task tables with proper indexes and constraints.\n\nRevision ID: 001\nRevises: \nCreate Date: 2024-01-01 00:00:00.000000\n\nComponent ID: COMP-011\nSemantic Unit: SU-011\n\"\"\"\nfrom alembic import op\nimport sqlalchemy as sa\nfrom sqlalchemy.dialects import postgresql\n\n\n# revision identifiers, used by Alembic.\nrevision = '001'\ndown_revision = None\nbranch_labels = None\ndepends_on = None\n\n\ndef upgrade() -> None:\n    \"\"\"Create initial database schema with users and tasks tables.\"\"\"\n    \n    # Create users table\n    op.create_table(\n        'users',\n        sa.Column('id', sa.Integer(), nullable=False),\n        sa.Column('email', sa.String(length=255), nullable=False),\n        sa.Column('username', sa.String(length=50), nullable=False),\n        sa.Column('password_hash', sa.String(length=255), nullable=False),\n        sa.Column('first_name', sa.String(length=100), nullable=True),\n        sa.Column('last_name', sa.String(length=100), nullable=True),\n        sa.Column('is_active', sa.Boolean(), nullable=False, default=True),\n        sa.Column('is_verified', sa.Boolean(), nullable=False, default=False),\n        sa.Column('created_at', sa.DateTime(timezone=True), nullable=False, \n                 server_default=sa.text('CURRENT_TIMESTAMP')),\n        sa.Column('updated_at', sa.DateTime(timezone=True), nullable=False,\n                 server_default=sa.text('CURRENT_TIMESTAMP')),\n        sa.Column('last_login_at', sa.DateTime(timezone=True), nullable=True),\n        sa.PrimaryKeyConstraint('id'),\n        sa.UniqueConstraint('email'),\n        sa.UniqueConstraint('username')\n    )\n    \n    # Create indexes for users table\n    op.create_index('idx_users_email', 'users', ['email'])\n    op.create_index('idx_users_username', 'users', ['username'])\n    op.create_index('idx_users_is_active', 'users', ['is_active'])\n    op.create_index('idx_users_created_at', 'users', ['created_at'])\n    \n    # Create tasks table\n    op.create_table(\n        'tasks',\n        sa.Column('id', sa.Integer(), nullable=False),\n        sa.Column('title', sa.String(length=200), nullable=False),\n        sa.Column('description', sa.Text(), nullable=True),\n        sa.Column('status', sa.String(length=20), nullable=False, default='pending'),\n        sa.Column('priority', sa.String(length=10), nullable=False, default='medium'),\n        sa.Column('user_id', sa.Integer(), nullable=False),\n        sa.Column('due_date', sa.DateTime(timezone=True), nullable=True),\n        sa.Column('completed_at', sa.DateTime(timezone=True), nullable=True),\n        sa.Column('created_at', sa.DateTime(timezone=True), nullable=False,\n                 server_default=sa.text('CURRENT_TIMESTAMP')),\n        sa.Column('updated_at', sa.DateTime(timezone=True), nullable=False,\n                 server_default=sa.text('CURRENT_TIMESTAMP')),\n        sa.PrimaryKeyConstraint('id'),\n        sa.ForeignKeyConstraint(['user_id'], ['users.id'], ondelete='CASCADE'),\n        sa.CheckConstraint(\n            \"status IN ('pending', 'in_progress', 'completed', 'cancelled')\",\n            name='check_task_status'\n        ),\n        sa.CheckConstraint(\n            \"priority IN ('low', 'medium', 'high', 'urgent')\",\n            name='check_task_priority'\n        )\n    )\n    \n    # Create indexes for tasks table\n    op.create_index('idx_tasks_user_id', 'tasks', ['user_id'])\n    op.create_index('idx_tasks_status', 'tasks', ['status'])\n    op.create_index('idx_tasks_priority', 'tasks', ['priority'])\n    op.create_index('idx_tasks_due_date', 'tasks', ['due_date'])\n    op.create_index('idx_tasks_created_at', 'tasks', ['created_at'])\n    op.create_index('idx_tasks_user_status', 'tasks', ['user_id', 'status'])\n    op.create_index('idx_tasks_user_priority', 'tasks', ['user_id', 'priority'])\n    \n    # Create trigger function for updating updated_at timestamp\n    op.execute(\"\"\"\n        CREATE OR REPLACE FUNCTION update_updated_at_column()\n        RETURNS TRIGGER AS $$\n        BEGIN\n            NEW.updated_at = CURRENT_TIMESTAMP;\n            RETURN NEW;\n        END;\n        $$ language 'plpgsql';\n    \"\"\")\n    \n    # Create triggers for updated_at columns\n    op.execute(\"\"\"\n        CREATE TRIGGER update_users_updated_at\n        BEFORE UPDATE ON users\n        FOR EACH ROW\n        EXECUTE FUNCTION update_updated_at_column();\n    \"\"\")\n    \n    op.execute(\"\"\"\n        CREATE TRIGGER update_tasks_updated_at\n        BEFORE UPDATE ON tasks\n        FOR EACH ROW\n        EXECUTE FUNCTION update_updated_at_column();\n    \"\"\")\n\n\ndef downgrade() -> None:\n    \"\"\"Drop all tables and related database objects.\"\"\"\n    \n    # Drop triggers\n    op.execute(\"DROP TRIGGER IF EXISTS update_tasks_updated_at ON tasks;\")\n    op.execute(\"DROP TRIGGER IF EXISTS update_users_updated_at ON users;\")\n    \n    # Drop trigger function\n    op.execute(\"DROP FUNCTION IF EXISTS update_updated_at_column();\")\n    \n    # Drop indexes for tasks table\n    op.drop_index('idx_tasks_user_priority', table_name='tasks')\n    op.drop_index('idx_tasks_user_status', table_name='tasks')\n    op.drop_index('idx_tasks_created_at', table_name='tasks')\n    op.drop_index('idx_tasks_due_date', table_name='tasks')\n    op.drop_index('idx_tasks_priority', table_name='tasks')\n    op.drop_index('idx_tasks_status', table_name='tasks')\n    op.drop_index('idx_tasks_user_id', table_name='tasks')\n    \n    # Drop tasks table\n    op.drop_table('tasks')\n    \n    # Drop indexes for users table\n    op.drop_index('idx_users_created_at', table_name='users')\n    op.drop_index('idx_users_is_active', table_name='users')\n    op.drop_index('idx_users_username', table_name='users')\n    op.drop_index('idx_users_email', table_name='users')\n    \n    # Drop users table\n    op.drop_table('users')",
      "file_type": "schema",
      "semantic_unit_id": "SU-011",
      "component_id": "COMP-011",
      "description": "Alembic migration script for creating initial user and task tables with indexes and constraints"
    },
    {
      "file_path": "src/middleware/auth.py",
      "content": "\"\"\"\nAuthentication middleware for protecting routes and extracting user information from JWT tokens.\n\nThis middleware validates JWT tokens, extracts user information, and provides\nauthentication protection for API endpoints.\n\nComponent ID: COMP-012\nSemantic Unit: SU-012\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport logging\nfrom typing import Optional, Callable, Any\nfrom fastapi import Request, HTTPException, status\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nfrom starlette.middleware.base import BaseHTTPMiddleware\nfrom starlette.responses import Response\n\nfrom src.utils.jwt_utils import decode_jwt_token, JWTError\nfrom src.models.user import User\n\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# HTTP Bearer token scheme\nsecurity = HTTPBearer(auto_error=False)\n\n\nclass AuthenticationError(Exception):\n    \"\"\"Custom exception for authentication errors.\"\"\"\n    \n    def __init__(self, message: str, status_code: int = status.HTTP_401_UNAUTHORIZED):\n        self.message = message\n        self.status_code = status_code\n        super().__init__(self.message)\n\n\nclass AuthMiddleware(BaseHTTPMiddleware):\n    \"\"\"\n    Authentication middleware for JWT token validation.\n    \n    This middleware intercepts requests, validates JWT tokens, and adds\n    user information to the request state for protected routes.\n    \"\"\"\n    \n    def __init__(self, app: Any, protected_paths: Optional[list[str]] = None):\n        \"\"\"\n        Initialize authentication middleware.\n        \n        Args:\n            app: FastAPI application instance\n            protected_paths: List of path patterns that require authentication\n        \"\"\"\n        super().__init__(app)\n        self.protected_paths = protected_paths or []\n        logger.info(\"AuthMiddleware initialized with %d protected paths\", len(self.protected_paths))\n    \n    async def dispatch(self, request: Request, call_next: Callable) -> Response:\n        \"\"\"\n        Process request through authentication middleware.\n        \n        Args:\n            request: Incoming HTTP request\n            call_next: Next middleware or route handler\n            \n        Returns:\n            Response: HTTP response from downstream handler\n            \n        Raises:\n            HTTPException: If authentication fails for protected routes\n        \"\"\"\n        try:\n            # Check if path requires authentication\n            if self._is_protected_path(request.url.path):\n                user = await self._authenticate_request(request)\n                request.state.user = user\n                request.state.authenticated = True\n                logger.debug(\"Authenticated user %s for path %s\", user.email, request.url.path)\n            else:\n                request.state.user = None\n                request.state.authenticated = False\n            \n            # Continue to next middleware or route handler\n            response = await call_next(request)\n            return response\n            \n        except AuthenticationError as e:\n            logger.warning(\"Authentication failed for path %s: %s\", request.url.path, e.message)\n            raise HTTPException(\n                status_code=e.status_code,\n                detail=e.message,\n                headers={\"WWW-Authenticate\": \"Bearer\"}\n            )\n        except Exception as e:\n            logger.error(\"Unexpected error in auth middleware: %s\", str(e))\n            raise HTTPException(\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n                detail=\"Internal server error\"\n            )\n    \n    def _is_protected_path(self, path: str) -> bool:\n        \"\"\"\n        Check if the given path requires authentication.\n        \n        Args:\n            path: Request path to check\n            \n        Returns:\n            bool: True if path requires authentication\n        \"\"\"\n        if not self.protected_paths:\n            return False\n        \n        # Check exact matches and wildcard patterns\n        for protected_path in self.protected_paths:\n            if protected_path.endswith(\"*\"):\n                # Wildcard pattern matching\n                prefix = protected_path[:-1]\n                if path.startswith(prefix):\n                    return True\n            elif path == protected_path:\n                # Exact path match\n                return True\n        \n        return False\n    \n    async def _authenticate_request(self, request: Request) -> User:\n        \"\"\"\n        Authenticate request using JWT token.\n        \n        Args:\n            request: HTTP request to authenticate\n            \n        Returns:\n            User: Authenticated user object\n            \n        Raises:\n            AuthenticationError: If authentication fails\n        \"\"\"\n        # Extract authorization header\n        authorization = request.headers.get(\"Authorization\")\n        if not authorization:\n            raise AuthenticationError(\"Missing authorization header\")\n        \n        # Parse Bearer token\n        if not authorization.startswith(\"Bearer \"):\n            raise AuthenticationError(\"Invalid authorization header format\")\n        \n        token = authorization[7:]  # Remove \"Bearer \" prefix\n        if not token:\n            raise AuthenticationError(\"Missing JWT token\")\n        \n        # Validate and decode JWT token\n        try:\n            payload = decode_jwt_token(token)\n        except JWTError as e:\n            raise AuthenticationError(f\"Invalid JWT token: {str(e)}\")\n        \n        # Extract user information from token payload\n        user_id = payload.get(\"user_id\")\n        email = payload.get(\"email\")\n        \n        if not user_id or not email:\n            raise AuthenticationError(\"Invalid token payload: missing user information\")\n        \n        # Create user object from token payload\n        user = User(\n            id=user_id,\n            email=email,\n            first_name=payload.get(\"first_name\", \"\"),\n            last_name=payload.get(\"last_name\", \"\"),\n            is_active=payload.get(\"is_active\", True)\n        )\n        \n        return user\n\n\ndef get_current_user(request: Request) -> Optional[User]:\n    \"\"\"\n    Get the current authenticated user from request state.\n    \n    Args:\n        request: HTTP request object\n        \n    Returns:\n        User: Current authenticated user or None if not authenticated\n    \"\"\"\n    return getattr(request.state, \"user\", None)\n\n\ndef require_authentication(request: Request) -> User:\n    \"\"\"\n    Require authentication and return current user.\n    \n    Args:\n        request: HTTP request object\n        \n    Returns:\n        User: Current authenticated user\n        \n    Raises:\n        HTTPException: If user is not authenticated\n    \"\"\"\n    user = get_current_user(request)\n    if not user:\n        logger.warning(\"Authentication required but no user found in request state\")\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Authentication required\",\n            headers={\"WWW-Authenticate\": \"Bearer\"}\n        )\n    \n    return user\n\n\ndef is_authenticated(request: Request) -> bool:\n    \"\"\"\n    Check if the current request is authenticated.\n    \n    Args:\n        request: HTTP request object\n        \n    Returns:\n        bool: True if request is authenticated\n    \"\"\"\n    return getattr(request.state, \"authenticated\", False)\n\n\nasync def extract_token_from_request(request: Request) -> Optional[str]:\n    \"\"\"\n    Extract JWT token from request headers.\n    \n    Args:\n        request: HTTP request object\n        \n    Returns:\n        str: JWT token if present, None otherwise\n    \"\"\"\n    try:\n        authorization = request.headers.get(\"Authorization\")\n        if not authorization or not authorization.startswith(\"Bearer \"):\n            return None\n        \n        token = authorization[7:]  # Remove \"Bearer \" prefix\n        return token if token else None\n        \n    except Exception as e:\n        logger.error(\"Error extracting token from request: %s\", str(e))\n        return None\n\n\ndef create_auth_middleware(protected_paths: Optional[list[str]] = None) -> type[AuthMiddleware]:\n    \"\"\"\n    Factory function to create authentication middleware with configuration.\n    \n    Args:\n        protected_paths: List of path patterns that require authentication\n        \n    Returns:\n        AuthMiddleware: Configured authentication middleware class\n    \"\"\"\n    class ConfiguredAuthMiddleware(AuthMiddleware):\n        def __init__(self, app: Any):\n            super().__init__(app, protected_paths)\n    \n    return ConfiguredAuthMiddleware",
      "file_type": "source",
      "semantic_unit_id": "SU-012",
      "component_id": "COMP-012",
      "description": "Authentication middleware for protecting routes and extracting user information from JWT tokens"
    },
    {
      "file_path": "tests/test_auth_api.py",
      "content": "\"\"\"\nComprehensive integration tests for authentication endpoints\n\nTests registration, login, token validation, and error scenarios for the auth API.\n\nComponent ID: COMP-002\nSemantic Unit: SU-002\n\nAuthor: ASP Code Generator\n\"\"\"\n\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom unittest.mock import Mock, patch\nimport json\nfrom datetime import datetime, timedelta\nimport jwt\n\nfrom src.api.auth import app\n\n\n@pytest.fixture\ndef client():\n    \"\"\"Create test client for FastAPI application.\"\"\"\n    return TestClient(app)\n\n\n@pytest.fixture\ndef mock_user_data():\n    \"\"\"Sample user data for testing.\"\"\"\n    return {\n        \"username\": \"testuser\",\n        \"email\": \"test@example.com\",\n        \"password\": \"SecurePass123!\"\n    }\n\n\n@pytest.fixture\ndef mock_login_data():\n    \"\"\"Sample login data for testing.\"\"\"\n    return {\n        \"username\": \"testuser\",\n        \"password\": \"SecurePass123!\"\n    }\n\n\n@pytest.fixture\ndef mock_jwt_token():\n    \"\"\"Generate a mock JWT token for testing.\"\"\"\n    payload = {\n        \"sub\": \"testuser\",\n        \"exp\": datetime.utcnow() + timedelta(hours=1),\n        \"iat\": datetime.utcnow()\n    }\n    return jwt.encode(payload, \"test_secret\", algorithm=\"HS256\")\n\n\n@pytest.fixture\ndef expired_jwt_token():\n    \"\"\"Generate an expired JWT token for testing.\"\"\"\n    payload = {\n        \"sub\": \"testuser\",\n        \"exp\": datetime.utcnow() - timedelta(hours=1),\n        \"iat\": datetime.utcnow() - timedelta(hours=2)\n    }\n    return jwt.encode(payload, \"test_secret\", algorithm=\"HS256\")\n\n\nclass TestUserRegistration:\n    \"\"\"Test cases for user registration endpoint.\"\"\"\n\n    def test_register_user_success(self, client, mock_user_data):\n        \"\"\"Test successful user registration with valid data.\"\"\"\n        with patch('src.api.auth.create_user') as mock_create:\n            mock_create.return_value = {\n                \"id\": 1,\n                \"username\": \"testuser\",\n                \"email\": \"test@example.com\",\n                \"created_at\": \"2023-01-01T00:00:00Z\"\n            }\n            \n            response = client.post(\"/auth/register\", json=mock_user_data)\n            \n            assert response.status_code == 201\n            data = response.json()\n            assert data[\"message\"] == \"User registered successfully\"\n            assert \"user\" in data\n            assert data[\"user\"][\"username\"] == \"testuser\"\n            assert data[\"user\"][\"email\"] == \"test@example.com\"\n            assert \"password\" not in data[\"user\"]\n\n    def test_register_user_missing_username(self, client):\n        \"\"\"Test registration fails with missing username.\"\"\"\n        user_data = {\n            \"email\": \"test@example.com\",\n            \"password\": \"SecurePass123!\"\n        }\n        \n        response = client.post(\"/auth/register\", json=user_data)\n        \n        assert response.status_code == 422\n        data = response.json()\n        assert \"detail\" in data\n\n    def test_register_user_missing_email(self, client):\n        \"\"\"Test registration fails with missing email.\"\"\"\n        user_data = {\n            \"username\": \"testuser\",\n            \"password\": \"SecurePass123!\"\n        }\n        \n        response = client.post(\"/auth/register\", json=user_data)\n        \n        assert response.status_code == 422\n        data = response.json()\n        assert \"detail\" in data\n\n    def test_register_user_missing_password(self, client):\n        \"\"\"Test registration fails with missing password.\"\"\"\n        user_data = {\n            \"username\": \"testuser\",\n            \"email\": \"test@example.com\"\n        }\n        \n        response = client.post(\"/auth/register\", json=user_data)\n        \n        assert response.status_code == 422\n        data = response.json()\n        assert \"detail\" in data\n\n    def test_register_user_invalid_email_format(self, client):\n        \"\"\"Test registration fails with invalid email format.\"\"\"\n        user_data = {\n            \"username\": \"testuser\",\n            \"email\": \"invalid-email\",\n            \"password\": \"SecurePass123!\"\n        }\n        \n        response = client.post(\"/auth/register\", json=user_data)\n        \n        assert response.status_code == 400\n        data = response.json()\n        assert data[\"error\"][\"code\"] == \"INVALID_EMAIL\"\n        assert \"Invalid email format\" in data[\"error\"][\"message\"]\n\n    def test_register_user_weak_password(self, client):\n        \"\"\"Test registration fails with weak password.\"\"\"\n        user_data = {\n            \"username\": \"testuser\",\n            \"email\": \"test@example.com\",\n            \"password\": \"weak\"\n        }\n        \n        response = client.post(\"/auth/register\", json=user_data)\n        \n        assert response.status_code == 400\n        data = response.json()\n        assert data[\"error\"][\"code\"] == \"WEAK_PASSWORD\"\n        assert \"Password must be at least 8 characters\" in data[\"error\"][\"message\"]\n\n    def test_register_user_duplicate_username(self, client, mock_user_data):\n        \"\"\"Test registration fails with duplicate username.\"\"\"\n        with patch('src.api.auth.create_user') as mock_create:\n            mock_create.side_effect = ValueError(\"Username already exists\")\n            \n            response = client.post(\"/auth/register\", json=mock_user_data)\n            \n            assert response.status_code == 409\n            data = response.json()\n            assert data[\"error\"][\"code\"] == \"USER_EXISTS\"\n            assert \"Username already exists\" in data[\"error\"][\"message\"]\n\n    def test_register_user_duplicate_email(self, client, mock_user_data):\n        \"\"\"Test registration fails with duplicate email.\"\"\"\n        with patch('src.api.auth.create_user') as mock_create:\n            mock_create.side_effect = ValueError(\"Email already exists\")\n            \n            response = client.post(\"/auth/register\", json=mock_user_data)\n            \n            assert response.status_code == 409\n            data = response.json()\n            assert data[\"error\"][\"code\"] == \"USER_EXISTS\"\n            assert \"Email already exists\" in data[\"error\"][\"message\"]\n\n    def test_register_user_empty_request_body(self, client):\n        \"\"\"Test registration fails with empty request body.\"\"\"\n        response = client.post(\"/auth/register\", json={})\n        \n        assert response.status_code == 422\n        data = response.json()\n        assert \"detail\" in data\n\n    def test_register_user_malformed_json(self, client):\n        \"\"\"Test registration fails with malformed JSON.\"\"\"\n        response = client.post(\n            \"/auth/register\",\n            data=\"invalid json\",\n            headers={\"Content-Type\": \"application/json\"}\n        )\n        \n        assert response.status_code == 422\n\n    def test_register_user_database_error(self, client, mock_user_data):\n        \"\"\"Test registration handles database errors gracefully.\"\"\"\n        with patch('src.api.auth.create_user') as mock_create:\n            mock_create.side_effect = Exception(\"Database connection failed\")\n            \n            response = client.post(\"/auth/register\", json=mock_user_data)\n            \n            assert response.status_code == 500\n            data = response.json()\n            assert data[\"error\"][\"code\"] == \"INTERNAL_ERROR\"\n            assert \"Internal server error\" in data[\"error\"][\"message\"]\n\n\nclass TestUserLogin:\n    \"\"\"Test cases for user login endpoint.\"\"\"\n\n    def test_login_user_success(self, client, mock_login_data, mock_jwt_token):\n        \"\"\"Test successful user login with valid credentials.\"\"\"\n        with patch('src.api.auth.authenticate_user') as mock_auth, \\\n             patch('src.api.auth.create_access_token') as mock_token:\n            \n            mock_auth.return_value = {\n                \"id\": 1,\n                \"username\": \"testuser\",\n                \"email\": \"test@example.",
      "file_type": "test",
      "semantic_unit_id": "SU-002",
      "component_id": "COMP-002",
      "description": "Comprehensive integration tests for authentication endpoints including registration, login, token validation, and error scenarios"
    },
    {
      "file_path": "tests/test_tasks_api.py",
      "content": "\"\"\"\nIntegration tests for task CRUD operations API\n\nTests all task endpoints including authentication, filtering, and authorization scenarios.\nCovers CRUD operations, user permissions, and edge cases.\n\nComponent ID: COMP-003\nSemantic Unit: SU-003\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom unittest.mock import Mock, patch\nfrom datetime import datetime, timezone\nimport json\n\nfrom src.api.tasks import app\nfrom src.models.task import Task, TaskStatus, TaskPriority\nfrom src.models.user import User\nfrom src.auth.jwt_handler import create_access_token\n\n\n@pytest.fixture\ndef client():\n    \"\"\"Create test client for FastAPI application.\"\"\"\n    return TestClient(app)\n\n\n@pytest.fixture\ndef mock_user():\n    \"\"\"Create mock user for testing.\"\"\"\n    return User(\n        id=1,\n        username=\"testuser\",\n        email=\"test@example.com\",\n        hashed_password=\"$2b$12$test_hash\",\n        is_active=True\n    )\n\n\n@pytest.fixture\ndef mock_admin_user():\n    \"\"\"Create mock admin user for testing.\"\"\"\n    return User(\n        id=2,\n        username=\"admin\",\n        email=\"admin@example.com\",\n        hashed_password=\"$2b$12$admin_hash\",\n        is_active=True,\n        is_admin=True\n    )\n\n\n@pytest.fixture\ndef auth_token(mock_user):\n    \"\"\"Create valid JWT token for testing.\"\"\"\n    return create_access_token(data={\"sub\": str(mock_user.id)})\n\n\n@pytest.fixture\ndef admin_token(mock_admin_user):\n    \"\"\"Create valid admin JWT token for testing.\"\"\"\n    return create_access_token(data={\"sub\": str(mock_admin_user.id)})\n\n\n@pytest.fixture\ndef auth_headers(auth_token):\n    \"\"\"Create authorization headers with valid token.\"\"\"\n    return {\"Authorization\": f\"Bearer {auth_token}\"}\n\n\n@pytest.fixture\ndef admin_headers(admin_token):\n    \"\"\"Create authorization headers with admin token.\"\"\"\n    return {\"Authorization\": f\"Bearer {admin_token}\"}\n\n\n@pytest.fixture\ndef sample_task():\n    \"\"\"Create sample task for testing.\"\"\"\n    return Task(\n        id=1,\n        title=\"Test Task\",\n        description=\"Test task description\",\n        status=TaskStatus.TODO,\n        priority=TaskPriority.MEDIUM,\n        user_id=1,\n        created_at=datetime.now(timezone.utc),\n        updated_at=datetime.now(timezone.utc)\n    )\n\n\n@pytest.fixture\ndef sample_task_data():\n    \"\"\"Create sample task data for POST requests.\"\"\"\n    return {\n        \"title\": \"New Task\",\n        \"description\": \"New task description\",\n        \"priority\": \"high\",\n        \"due_date\": \"2024-12-31T23:59:59Z\"\n    }\n\n\nclass TestCreateTask:\n    \"\"\"Test cases for POST /tasks endpoint.\"\"\"\n\n    @patch('src.api.tasks.create_task')\n    @patch('src.api.tasks.get_current_user')\n    def test_create_task_success(self, mock_get_user, mock_create, client, mock_user, auth_headers, sample_task_data):\n        \"\"\"Test successful task creation with valid data.\"\"\"\n        mock_get_user.return_value = mock_user\n        created_task = Task(id=1, user_id=mock_user.id, **sample_task_data)\n        mock_create.return_value = created_task\n\n        response = client.post(\"/tasks\", json=sample_task_data, headers=auth_headers)\n\n        assert response.status_code == 201\n        data = response.json()\n        assert data[\"title\"] == sample_task_data[\"title\"]\n        assert data[\"description\"] == sample_task_data[\"description\"]\n        assert data[\"user_id\"] == mock_user.id\n        mock_create.assert_called_once()\n\n    def test_create_task_unauthorized(self, client, sample_task_data):\n        \"\"\"Test task creation without authentication token.\"\"\"\n        response = client.post(\"/tasks\", json=sample_task_data)\n\n        assert response.status_code == 401\n        data = response.json()\n        assert data[\"detail\"] == \"Not authenticated\"\n\n    def test_create_task_invalid_token(self, client, sample_task_data):\n        \"\"\"Test task creation with invalid authentication token.\"\"\"\n        headers = {\"Authorization\": \"Bearer invalid_token\"}\n        response = client.post(\"/tasks\", json=sample_task_data, headers=headers)\n\n        assert response.status_code == 401\n        data = response.json()\n        assert \"Invalid token\" in data[\"detail\"]\n\n    def test_create_task_missing_title(self, client, auth_headers):\n        \"\"\"Test task creation with missing required title field.\"\"\"\n        task_data = {\n            \"description\": \"Task without title\",\n            \"priority\": \"medium\"\n        }\n\n        response = client.post(\"/tasks\", json=task_data, headers=auth_headers)\n\n        assert response.status_code == 422\n        data = response.json()\n        assert \"title\" in str(data[\"detail\"])\n\n    def test_create_task_empty_title(self, client, auth_headers):\n        \"\"\"Test task creation with empty title.\"\"\"\n        task_data = {\n            \"title\": \"\",\n            \"description\": \"Task with empty title\",\n            \"priority\": \"medium\"\n        }\n\n        response = client.post(\"/tasks\", json=task_data, headers=auth_headers)\n\n        assert response.status_code == 422\n        data = response.json()\n        assert \"title\" in str(data[\"detail\"])\n\n    def test_create_task_invalid_priority(self, client, auth_headers):\n        \"\"\"Test task creation with invalid priority value.\"\"\"\n        task_data = {\n            \"title\": \"Test Task\",\n            \"description\": \"Task with invalid priority\",\n            \"priority\": \"invalid_priority\"\n        }\n\n        response = client.post(\"/tasks\", json=task_data, headers=auth_headers)\n\n        assert response.status_code == 422\n        data = response.json()\n        assert \"priority\" in str(data[\"detail\"])\n\n    def test_create_task_invalid_due_date(self, client, auth_headers):\n        \"\"\"Test task creation with invalid due date format.\"\"\"\n        task_data = {\n            \"title\": \"Test Task\",\n            \"description\": \"Task with invalid due date\",\n            \"priority\": \"medium\",\n            \"due_date\": \"invalid_date\"\n        }\n\n        response = client.post(\"/tasks\", json=task_data, headers=auth_headers)\n\n        assert response.status_code == 422\n        data = response.json()\n        assert \"due_date\" in str(data[\"detail\"])\n\n    @patch('src.api.tasks.create_task')\n    @patch('src.api.tasks.get_current_user')\n    def test_create_task_database_error(self, mock_get_user, mock_create, client, mock_user, auth_headers, sample_task_data):\n        \"\"\"Test task creation with database error.\"\"\"\n        mock_get_user.return_value = mock_user\n        mock_create.side_effect = Exception(\"Database connection failed\")\n\n        response = client.post(\"/tasks\", json=sample_task_data, headers=auth_headers)\n\n        assert response.status_code == 500\n        data = response.json()\n        assert data[\"detail\"] == \"Internal server error\"\n\n\nclass TestGetTasks:\n    \"\"\"Test cases for GET /tasks endpoint.\"\"\"\n\n    @patch('src.api.tasks.get_tasks_by_user')\n    @patch('src.api.tasks.get_current_user')\n    def test_get_tasks_success(self, mock_get_user, mock_get_tasks, client, mock_user, auth_headers, sample_task):\n        \"\"\"Test successful retrieval of user tasks.\"\"\"\n        mock_get_user.return_value = mock_user\n        mock_get_tasks.return_value = [sample_task]\n\n        response = client.get(\"/tasks\", headers=auth_headers)\n\n        assert response.status_code == 200\n        data = response.json()\n        assert len(data) == 1\n        assert data",
      "file_type": "test",
      "semantic_unit_id": "SU-003",
      "component_id": "COMP-003",
      "description": "Integration tests for task CRUD operations with authentication, filtering, and authorization scenarios"
    },
    {
      "file_path": "tests/test_user_model.py",
      "content": "\"\"\"\nUnit tests for User model\n\nTests user model validation, relationships, and database operations including\npassword hashing, email validation, and user creation/retrieval.\n\nComponent ID: COMP-004\nSemantic Unit: SU-004\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport pytest\nfrom datetime import datetime, timezone\nfrom unittest.mock import Mock, patch\nfrom sqlalchemy.exc import IntegrityError\nfrom sqlalchemy.orm import Session\n\nfrom src.models.user import User, UserCreate, UserResponse\n\n\nclass TestUserModel:\n    \"\"\"Test cases for User SQLAlchemy model.\"\"\"\n\n    def test_user_model_creation_with_valid_data(self):\n        \"\"\"Test that User model can be created with valid data.\"\"\"\n        user = User(\n            email=\"test@example.com\",\n            username=\"testuser\",\n            hashed_password=\"hashed_password_123\",\n            full_name=\"Test User\"\n        )\n        \n        assert user.email == \"test@example.com\"\n        assert user.username == \"testuser\"\n        assert user.hashed_password == \"hashed_password_123\"\n        assert user.full_name == \"Test User\"\n        assert user.is_active is True\n        assert isinstance(user.created_at, datetime)\n        assert isinstance(user.updated_at, datetime)\n\n    def test_user_model_creation_with_minimal_data(self):\n        \"\"\"Test that User model can be created with minimal required data.\"\"\"\n        user = User(\n            email=\"minimal@example.com\",\n            username=\"minimal\",\n            hashed_password=\"hashed_pass\"\n        )\n        \n        assert user.email == \"minimal@example.com\"\n        assert user.username == \"minimal\"\n        assert user.hashed_password == \"hashed_pass\"\n        assert user.full_name is None\n        assert user.is_active is True\n\n    def test_user_model_string_representation(self):\n        \"\"\"Test User model __str__ method returns username.\"\"\"\n        user = User(\n            email=\"test@example.com\",\n            username=\"testuser\",\n            hashed_password=\"hashed_password\"\n        )\n        \n        assert str(user) == \"testuser\"\n\n    def test_user_model_repr_representation(self):\n        \"\"\"Test User model __repr__ method returns proper representation.\"\"\"\n        user = User(\n            email=\"test@example.com\",\n            username=\"testuser\",\n            hashed_password=\"hashed_password\"\n        )\n        user.id = 1\n        \n        assert repr(user) == \"<User(id=1, username='testuser', email='test@example.com')>\"\n\n    def test_user_model_timestamps_auto_set(self):\n        \"\"\"Test that created_at and updated_at are automatically set.\"\"\"\n        before_creation = datetime.now(timezone.utc)\n        user = User(\n            email=\"timestamp@example.com\",\n            username=\"timestamp\",\n            hashed_password=\"hashed_password\"\n        )\n        after_creation = datetime.now(timezone.utc)\n        \n        assert before_creation <= user.created_at <= after_creation\n        assert before_creation <= user.updated_at <= after_creation\n\n    def test_user_model_default_is_active_true(self):\n        \"\"\"Test that is_active defaults to True.\"\"\"\n        user = User(\n            email=\"active@example.com\",\n            username=\"active\",\n            hashed_password=\"hashed_password\"\n        )\n        \n        assert user.is_active is True\n\n    def test_user_model_can_set_is_active_false(self):\n        \"\"\"Test that is_active can be set to False.\"\"\"\n        user = User(\n            email=\"inactive@example.com\",\n            username=\"inactive\",\n            hashed_password=\"hashed_password\",\n            is_active=False\n        )\n        \n        assert user.is_active is False\n\n\nclass TestUserCreateSchema:\n    \"\"\"Test cases for UserCreate Pydantic schema.\"\"\"\n\n    def test_user_create_with_valid_data(self):\n        \"\"\"Test UserCreate schema with valid data.\"\"\"\n        user_data = {\n            \"email\": \"create@example.com\",\n            \"username\": \"createuser\",\n            \"password\": \"securepassword123\",\n            \"full_name\": \"Create User\"\n        }\n        \n        user_create = UserCreate(**user_data)\n        \n        assert user_create.email == \"create@example.com\"\n        assert user_create.username == \"createuser\"\n        assert user_create.password == \"securepassword123\"\n        assert user_create.full_name == \"Create User\"\n\n    def test_user_create_with_minimal_data(self):\n        \"\"\"Test UserCreate schema with minimal required data.\"\"\"\n        user_data = {\n            \"email\": \"minimal@example.com\",\n            \"username\": \"minimal\",\n            \"password\": \"password123\"\n        }\n        \n        user_create = UserCreate(**user_data)\n        \n        assert user_create.email == \"minimal@example.com\"\n        assert user_create.username == \"minimal\"\n        assert user_create.password == \"password123\"\n        assert user_create.full_name is None\n\n    def test_user_create_email_validation_invalid_format(self):\n        \"\"\"Test UserCreate schema rejects invalid email format.\"\"\"\n        user_data = {\n            \"email\": \"invalid-email\",\n            \"username\": \"testuser\",\n            \"password\": \"password123\"\n        }\n        \n        with pytest.raises(ValueError, match=\"value is not a valid email address\"):\n            UserCreate(**user_data)\n\n    def test_user_create_email_validation_empty_string(self):\n        \"\"\"Test UserCreate schema rejects empty email.\"\"\"\n        user_data = {\n            \"email\": \"\",\n            \"username\": \"testuser\",\n            \"password\": \"password123\"\n        }\n        \n        with pytest.raises(ValueError):\n            UserCreate(**user_data)\n\n    def test_user_create_username_validation_too_short(self):\n        \"\"\"Test UserCreate schema rejects username shorter than 3 characters.\"\"\"\n        user_data = {\n            \"email\": \"test@example.com\",\n            \"username\": \"ab\",\n            \"password\": \"password123\"\n        }\n        \n        with pytest.raises(ValueError, match=\"String should have at least 3 characters\"):\n            UserCreate(**user_data)\n\n    def test_user_create_username_validation_too_long(self):\n        \"\"\"Test UserCreate schema rejects username longer than 50 characters.\"\"\"\n        user_data = {\n            \"email\": \"test@example.com\",\n            \"username\": \"a\" * 51,\n            \"password\": \"password123\"\n        }\n        \n        with pytest.raises(ValueError, match=\"String should have at most 50 characters\"):\n            UserCreate(**user_data)\n\n    def test_user_create_password_validation_too_short(self):\n        \"\"\"Test UserCreate schema rejects password shorter than 8 characters.\"\"\"\n        user_data = {\n            \"email\": \"test@example.com\",\n            \"username\": \"testuser\",\n            \"password\": \"short\"\n        }\n        \n        with pytest.raises(ValueError, match=\"String should have at least 8 characters\"):\n            UserCreate(**user_data)\n\n    def test_user_create_full_name_validation_too_long(self):\n        \"\"\"Test UserCreate schema rejects full_name longer than 100 characters.\"\"\"\n        user_data = {\n            \"email\": \"test@example.com\",\n            \"username\": \"testuser\",\n            \"password\": \"password123\",\n            \"full_name\": \"a\" * 101\n        }\n        \n        with pytest.raises(ValueError, match=\"String should have at most 100 characters\"):\n            UserCreate(**user_data)\n\n    def test_user_create_username_alphanumeric_validation(self):\n        \"\"\"Test UserCreate schema accepts alphanumeric usernames with underscores.\"\"\"\n        valid_usernames = [\"user123\", \"test_user\", \"User_123\", \"username\"]\n        \n        for username in valid_usernames:\n            user_data = {\n                \"email\": \"test@example.com\",\n                \"username\": username,\n                \"password\": \"password123\"\n            }",
      "file_type": "test",
      "semantic_unit_id": "SU-004",
      "component_id": "COMP-004",
      "description": "Unit tests for user model including validation, relationships, and database operations"
    },
    {
      "file_path": "tests/test_task_model.py",
      "content": "\"\"\"\nUnit tests for Task model\n\nTests task model validation, status transitions, user relationships, and database operations.\n\nComponent ID: COMP-005\nSemantic Unit: SU-005\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport pytest\nfrom datetime import datetime, timedelta\nfrom unittest.mock import Mock, patch\nfrom sqlalchemy.exc import IntegrityError\nfrom pydantic import ValidationError\n\nfrom src.models.task import Task, TaskStatus, TaskPriority, TaskCreate, TaskUpdate\n\n\nclass TestTaskModel:\n    \"\"\"Test suite for Task model class.\"\"\"\n\n    def test_task_model_creation_with_valid_data(self):\n        \"\"\"Test that Task model can be created with valid data.\"\"\"\n        task_data = {\n            \"title\": \"Test Task\",\n            \"description\": \"Test description\",\n            \"status\": TaskStatus.TODO,\n            \"priority\": TaskPriority.MEDIUM,\n            \"user_id\": 1\n        }\n        task = Task(**task_data)\n        \n        assert task.title == \"Test Task\"\n        assert task.description == \"Test description\"\n        assert task.status == TaskStatus.TODO\n        assert task.priority == TaskPriority.MEDIUM\n        assert task.user_id == 1\n        assert isinstance(task.created_at, datetime)\n        assert isinstance(task.updated_at, datetime)\n\n    def test_task_model_creation_with_minimal_data(self):\n        \"\"\"Test that Task model can be created with minimal required data.\"\"\"\n        task_data = {\n            \"title\": \"Minimal Task\",\n            \"user_id\": 1\n        }\n        task = Task(**task_data)\n        \n        assert task.title == \"Minimal Task\"\n        assert task.description is None\n        assert task.status == TaskStatus.TODO  # Default value\n        assert task.priority == TaskPriority.MEDIUM  # Default value\n        assert task.user_id == 1\n        assert task.due_date is None\n        assert task.completed_at is None\n\n    def test_task_model_creation_with_due_date(self):\n        \"\"\"Test that Task model can be created with due date.\"\"\"\n        due_date = datetime.utcnow() + timedelta(days=7)\n        task_data = {\n            \"title\": \"Task with Due Date\",\n            \"user_id\": 1,\n            \"due_date\": due_date\n        }\n        task = Task(**task_data)\n        \n        assert task.due_date == due_date\n\n    def test_task_model_string_representation(self):\n        \"\"\"Test that Task model has proper string representation.\"\"\"\n        task = Task(title=\"Test Task\", user_id=1)\n        \n        assert str(task) == \"Test Task\"\n        assert repr(task) == f\"<Task(id=None, title='Test Task', status=TaskStatus.TODO)>\"\n\n    def test_task_model_with_id_representation(self):\n        \"\"\"Test that Task model string representation includes ID when available.\"\"\"\n        task = Task(id=123, title=\"Test Task\", user_id=1)\n        \n        assert repr(task) == f\"<Task(id=123, title='Test Task', status=TaskStatus.TODO)>\"\n\n\nclass TestTaskValidation:\n    \"\"\"Test suite for Task model validation.\"\"\"\n\n    def test_task_title_required(self):\n        \"\"\"Test that task title is required.\"\"\"\n        with pytest.raises(ValidationError) as exc_info:\n            Task(user_id=1)\n        \n        assert \"title\" in str(exc_info.value)\n\n    def test_task_title_not_empty(self):\n        \"\"\"Test that task title cannot be empty string.\"\"\"\n        with pytest.raises(ValidationError) as exc_info:\n            Task(title=\"\", user_id=1)\n        \n        assert \"title\" in str(exc_info.value)\n\n    def test_task_title_not_whitespace_only(self):\n        \"\"\"Test that task title cannot be whitespace only.\"\"\"\n        with pytest.raises(ValidationError) as exc_info:\n            Task(title=\"   \", user_id=1)\n        \n        assert \"title\" in str(exc_info.value)\n\n    def test_task_title_max_length(self):\n        \"\"\"Test that task title has maximum length limit.\"\"\"\n        long_title = \"x\" * 201  # Assuming 200 char limit\n        with pytest.raises(ValidationError) as exc_info:\n            Task(title=long_title, user_id=1)\n        \n        assert \"title\" in str(exc_info.value)\n\n    def test_task_description_max_length(self):\n        \"\"\"Test that task description has maximum length limit.\"\"\"\n        long_description = \"x\" * 1001  # Assuming 1000 char limit\n        with pytest.raises(ValidationError) as exc_info:\n            Task(title=\"Test\", description=long_description, user_id=1)\n        \n        assert \"description\" in str(exc_info.value)\n\n    def test_task_user_id_required(self):\n        \"\"\"Test that user_id is required.\"\"\"\n        with pytest.raises(ValidationError) as exc_info:\n            Task(title=\"Test Task\")\n        \n        assert \"user_id\" in str(exc_info.value)\n\n    def test_task_user_id_positive(self):\n        \"\"\"Test that user_id must be positive.\"\"\"\n        with pytest.raises(ValidationError) as exc_info:\n            Task(title=\"Test Task\", user_id=0)\n        \n        assert \"user_id\" in str(exc_info.value)\n\n    def test_task_user_id_negative(self):\n        \"\"\"Test that user_id cannot be negative.\"\"\"\n        with pytest.raises(ValidationError) as exc_info:\n            Task(title=\"Test Task\", user_id=-1)\n        \n        assert \"user_id\" in str(exc_info.value)\n\n    def test_task_due_date_future_validation(self):\n        \"\"\"Test that due date can be in the future.\"\"\"\n        future_date = datetime.utcnow() + timedelta(days=1)\n        task = Task(title=\"Test Task\", user_id=1, due_date=future_date)\n        \n        assert task.due_date == future_date\n\n    def test_task_due_date_past_validation(self):\n        \"\"\"Test that due date can be in the past (for flexibility).\"\"\"\n        past_date = datetime.utcnow() - timedelta(days=1)\n        task = Task(title=\"Test Task\", user_id=1, due_date=past_date)\n        \n        assert task.due_date == past_date\n\n\nclass TestTaskStatus:\n    \"\"\"Test suite for TaskStatus enum and status transitions.\"\"\"\n\n    def test_task_status_enum_values(self):\n        \"\"\"Test that TaskStatus enum has expected values.\"\"\"\n        assert TaskStatus.TODO == \"todo\"\n        assert TaskStatus.IN_PROGRESS == \"in_progress\"\n        assert TaskStatus.COMPLETED == \"completed\"\n        assert TaskStatus.CANCELLED == \"cancelled\"\n\n    def test_task_default_status(self):\n        \"\"\"Test that task has default status of TODO.\"\"\"\n        task = Task(title=\"Test Task\", user_id=1)\n        \n        assert task.status == TaskStatus.TODO\n\n    def test_task_status_transition_todo_to_in_progress(self):\n        \"\"\"Test valid status transition from TODO to IN_PROGRESS.\"\"\"\n        task = Task(title=\"Test Task\", user_id=1, status=TaskStatus.TODO)\n        task.status = TaskStatus.IN_PROGRESS\n        \n        assert task.status == TaskStatus.IN_PROGRESS\n\n    def test_task_status_transition_in_progress_to_completed(self):\n        \"\"\"Test valid status transition from IN_PROGRESS to COMPLETED.\"\"\"\n        task = Task(title=\"Test Task\", user_id=1, status=TaskStatus.IN_PROGRESS)\n        task.status = TaskStatus.COMPLETED\n        \n        assert task.status == TaskStatus.COMPLETED\n\n    def test_task_status_transition_any_to_cancelled(self):\n        \"\"\"Test that task can be cancelled from any status.\"\"\"\n        task = Task(title=\"Test Task\", user_id=1, status=TaskStatus.TODO)\n        task.status = TaskStatus.CANCELLED\n        assert",
      "file_type": "test",
      "semantic_unit_id": "SU-005",
      "component_id": "COMP-005",
      "description": "Unit tests for task model including validation, status transitions, and user relationships"
    },
    {
      "file_path": "tests/test_jwt_utils.py",
      "content": "\"\"\"\nUnit tests for JWT utilities\n\nTests JWT token generation, validation, expiration handling, and malformed token scenarios.\n\nComponent ID: COMP-008\nSemantic Unit: SU-008\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport pytest\nfrom datetime import datetime, timedelta, timezone\nfrom unittest.mock import patch, MagicMock\nimport jwt\nfrom freezegun import freeze_time\n\nfrom src.utils.jwt_utils import (\n    JWTUtils,\n    TokenExpiredError,\n    InvalidTokenError,\n    TokenValidationError\n)\n\n\n@pytest.fixture\ndef jwt_utils():\n    \"\"\"Create JWTUtils instance with test configuration.\"\"\"\n    return JWTUtils(\n        secret_key=\"test_secret_key_12345\",\n        algorithm=\"HS256\",\n        access_token_expire_minutes=30,\n        refresh_token_expire_days=7\n    )\n\n\n@pytest.fixture\ndef sample_payload():\n    \"\"\"Sample JWT payload for testing.\"\"\"\n    return {\n        \"user_id\": \"123\",\n        \"username\": \"testuser\",\n        \"email\": \"test@example.com\",\n        \"role\": \"user\"\n    }\n\n\n@pytest.fixture\ndef expired_token(jwt_utils, sample_payload):\n    \"\"\"Generate an expired token for testing.\"\"\"\n    with freeze_time(\"2023-01-01 12:00:00\"):\n        token = jwt_utils.generate_access_token(sample_payload)\n    return token\n\n\nclass TestJWTUtilsInitialization:\n    \"\"\"Test JWT utilities initialization and configuration.\"\"\"\n\n    def test_jwt_utils_initialization_with_defaults(self):\n        \"\"\"Test JWTUtils initialization with default values.\"\"\"\n        jwt_util = JWTUtils()\n        \n        assert jwt_util.algorithm == \"HS256\"\n        assert jwt_util.access_token_expire_minutes == 15\n        assert jwt_util.refresh_token_expire_days == 30\n        assert jwt_util.secret_key is not None\n\n    def test_jwt_utils_initialization_with_custom_values(self):\n        \"\"\"Test JWTUtils initialization with custom configuration.\"\"\"\n        jwt_util = JWTUtils(\n            secret_key=\"custom_secret\",\n            algorithm=\"HS512\",\n            access_token_expire_minutes=60,\n            refresh_token_expire_days=14\n        )\n        \n        assert jwt_util.secret_key == \"custom_secret\"\n        assert jwt_util.algorithm == \"HS512\"\n        assert jwt_util.access_token_expire_minutes == 60\n        assert jwt_util.refresh_token_expire_days == 14\n\n    def test_jwt_utils_initialization_with_empty_secret_raises_error(self):\n        \"\"\"Test that empty secret key raises ValueError.\"\"\"\n        with pytest.raises(ValueError, match=\"Secret key cannot be empty\"):\n            JWTUtils(secret_key=\"\")\n\n    def test_jwt_utils_initialization_with_none_secret_raises_error(self):\n        \"\"\"Test that None secret key raises ValueError.\"\"\"\n        with pytest.raises(ValueError, match=\"Secret key cannot be empty\"):\n            JWTUtils(secret_key=None)\n\n\nclass TestAccessTokenGeneration:\n    \"\"\"Test access token generation functionality.\"\"\"\n\n    def test_generate_access_token_success(self, jwt_utils, sample_payload):\n        \"\"\"Test successful access token generation.\"\"\"\n        token = jwt_utils.generate_access_token(sample_payload)\n        \n        assert isinstance(token, str)\n        assert len(token) > 0\n        assert token.count('.') == 2  # JWT has 3 parts separated by dots\n\n    def test_generate_access_token_includes_payload_data(self, jwt_utils, sample_payload):\n        \"\"\"Test that generated token includes payload data.\"\"\"\n        token = jwt_utils.generate_access_token(sample_payload)\n        decoded = jwt.decode(token, jwt_utils.secret_key, algorithms=[jwt_utils.algorithm])\n        \n        assert decoded[\"user_id\"] == sample_payload[\"user_id\"]\n        assert decoded[\"username\"] == sample_payload[\"username\"]\n        assert decoded[\"email\"] == sample_payload[\"email\"]\n        assert decoded[\"role\"] == sample_payload[\"role\"]\n\n    def test_generate_access_token_includes_expiration(self, jwt_utils, sample_payload):\n        \"\"\"Test that generated token includes expiration time.\"\"\"\n        with freeze_time(\"2023-01-01 12:00:00\") as frozen_time:\n            token = jwt_utils.generate_access_token(sample_payload)\n            decoded = jwt.decode(token, jwt_utils.secret_key, algorithms=[jwt_utils.algorithm])\n            \n            expected_exp = datetime.now(timezone.utc) + timedelta(minutes=30)\n            actual_exp = datetime.fromtimestamp(decoded[\"exp\"], timezone.utc)\n            \n            assert abs((actual_exp - expected_exp).total_seconds()) < 1\n\n    def test_generate_access_token_includes_issued_at(self, jwt_utils, sample_payload):\n        \"\"\"Test that generated token includes issued at time.\"\"\"\n        with freeze_time(\"2023-01-01 12:00:00\"):\n            token = jwt_utils.generate_access_token(sample_payload)\n            decoded = jwt.decode(token, jwt_utils.secret_key, algorithms=[jwt_utils.algorithm])\n            \n            expected_iat = datetime.now(timezone.utc)\n            actual_iat = datetime.fromtimestamp(decoded[\"iat\"], timezone.utc)\n            \n            assert abs((actual_iat - expected_iat).total_seconds()) < 1\n\n    def test_generate_access_token_includes_token_type(self, jwt_utils, sample_payload):\n        \"\"\"Test that generated token includes token type.\"\"\"\n        token = jwt_utils.generate_access_token(sample_payload)\n        decoded = jwt.decode(token, jwt_utils.secret_key, algorithms=[jwt_utils.algorithm])\n        \n        assert decoded[\"token_type\"] == \"access\"\n\n    def test_generate_access_token_with_empty_payload(self, jwt_utils):\n        \"\"\"Test access token generation with empty payload.\"\"\"\n        token = jwt_utils.generate_access_token({})\n        decoded = jwt.decode(token, jwt_utils.secret_key, algorithms=[jwt_utils.algorithm])\n        \n        assert \"exp\" in decoded\n        assert \"iat\" in decoded\n        assert \"token_type\" in decoded\n        assert decoded[\"token_type\"] == \"access\"\n\n    def test_generate_access_token_with_none_payload_raises_error(self, jwt_utils):\n        \"\"\"Test that None payload raises TypeError.\"\"\"\n        with pytest.raises(TypeError):\n            jwt_utils.generate_access_token(None)\n\n\nclass TestRefreshTokenGeneration:\n    \"\"\"Test refresh token generation functionality.\"\"\"\n\n    def test_generate_refresh_token_success(self, jwt_utils, sample_payload):\n        \"\"\"Test successful refresh token generation.\"\"\"\n        token = jwt_utils.generate_refresh_token(sample_payload)\n        \n        assert isinstance(token, str)\n        assert len(token) > 0\n        assert token.count('.') == 2\n\n    def test_generate_refresh_token_includes_payload_data(self, jwt_utils, sample_payload):\n        \"\"\"Test that generated refresh token includes payload data.\"\"\"\n        token = jwt_utils.generate_refresh_token(sample_payload)\n        decoded = jwt.decode(token, jwt_utils.secret_key, algorithms=[jwt_utils.algorithm])\n        \n        assert decoded[\"user_id\"] == sample_payload[\"user_id\"]\n        assert decoded[\"username\"] == sample_payload[\"username\"]\n\n    def test_generate_refresh_token_has_longer_expiration(self, jwt_utils, sample_payload):\n        \"\"\"Test that refresh token has longer expiration than access token.\"\"\"\n        with freeze_time(\"2023-01-01 12:00:00\"):\n            access_token = jwt_utils.generate_access_token(sample_payload)\n            refresh_token = jwt_utils.generate_refresh_token(sample_payload)\n            \n            access_decoded = jwt.decode(access_token, jwt_utils.secret_key, algorithms=[jwt_utils.algorithm])\n            refresh_decoded = jwt.decode(refresh_token, jwt_utils.secret_key,",
      "file_type": "test",
      "semantic_unit_id": "SU-008",
      "component_id": "COMP-008",
      "description": "Unit tests for JWT utilities including token generation, validation, expiration, and malformed token handling"
    },
    {
      "file_path": "tests/test_password.py",
      "content": "\"\"\"\nUnit tests for password hashing and verification utilities.\n\nTests password hashing, verification, and various password scenarios including\nedge cases and security requirements.\n\nComponent ID: COMP-009\nSemantic Unit: SU-009\n\nAuthor: ASP Code Generator\n\"\"\"\n\nimport pytest\nfrom unittest.mock import patch, MagicMock\nimport bcrypt\nfrom src.utils.password import (\n    hash_password,\n    verify_password,\n    generate_salt,\n    is_password_strong,\n    PasswordStrengthError\n)\n\n\nclass TestHashPassword:\n    \"\"\"Test cases for password hashing functionality.\"\"\"\n\n    def test_hash_password_returns_string(self):\n        \"\"\"Test that hash_password returns a string.\"\"\"\n        password = \"test_password_123\"\n        hashed = hash_password(password)\n        assert isinstance(hashed, str)\n\n    def test_hash_password_returns_different_hash_each_time(self):\n        \"\"\"Test that hash_password returns different hashes for same password.\"\"\"\n        password = \"test_password_123\"\n        hash1 = hash_password(password)\n        hash2 = hash_password(password)\n        assert hash1 != hash2\n\n    def test_hash_password_with_empty_string(self):\n        \"\"\"Test that hash_password handles empty string.\"\"\"\n        password = \"\"\n        hashed = hash_password(password)\n        assert isinstance(hashed, str)\n        assert len(hashed) > 0\n\n    def test_hash_password_with_unicode_characters(self):\n        \"\"\"Test that hash_password handles unicode characters.\"\"\"\n        password = \"pssw0rd___\"\n        hashed = hash_password(password)\n        assert isinstance(hashed, str)\n        assert len(hashed) > 0\n\n    def test_hash_password_with_very_long_password(self):\n        \"\"\"Test that hash_password handles very long passwords.\"\"\"\n        password = \"a\" * 1000\n        hashed = hash_password(password)\n        assert isinstance(hashed, str)\n        assert len(hashed) > 0\n\n    def test_hash_password_with_special_characters(self):\n        \"\"\"Test that hash_password handles special characters.\"\"\"\n        password = \"!@#$%^&*()_+-=[]{}|;:,.<>?\"\n        hashed = hash_password(password)\n        assert isinstance(hashed, str)\n        assert len(hashed) > 0\n\n    def test_hash_password_with_whitespace(self):\n        \"\"\"Test that hash_password handles passwords with whitespace.\"\"\"\n        password = \"  password with spaces  \"\n        hashed = hash_password(password)\n        assert isinstance(hashed, str)\n        assert len(hashed) > 0\n\n    @patch('src.utils.password.bcrypt.hashpw')\n    def test_hash_password_uses_bcrypt(self, mock_hashpw):\n        \"\"\"Test that hash_password uses bcrypt for hashing.\"\"\"\n        mock_hashpw.return_value = b'$2b$12$mocked_hash'\n        password = \"test_password\"\n        \n        hash_password(password)\n        \n        mock_hashpw.assert_called_once()\n        args = mock_hashpw.call_args[0]\n        assert args[0] == password.encode('utf-8')\n\n    def test_hash_password_with_none_raises_error(self):\n        \"\"\"Test that hash_password raises error for None input.\"\"\"\n        with pytest.raises(TypeError):\n            hash_password(None)\n\n\nclass TestVerifyPassword:\n    \"\"\"Test cases for password verification functionality.\"\"\"\n\n    def test_verify_password_correct_password_returns_true(self):\n        \"\"\"Test that verify_password returns True for correct password.\"\"\"\n        password = \"correct_password_123\"\n        hashed = hash_password(password)\n        assert verify_password(password, hashed) is True\n\n    def test_verify_password_incorrect_password_returns_false(self):\n        \"\"\"Test that verify_password returns False for incorrect password.\"\"\"\n        password = \"correct_password_123\"\n        wrong_password = \"wrong_password_456\"\n        hashed = hash_password(password)\n        assert verify_password(wrong_password, hashed) is False\n\n    def test_verify_password_empty_password_with_hash(self):\n        \"\"\"Test that verify_password handles empty password with valid hash.\"\"\"\n        password = \"\"\n        hashed = hash_password(password)\n        assert verify_password(password, hashed) is True\n        assert verify_password(\"not_empty\", hashed) is False\n\n    def test_verify_password_with_unicode_characters(self):\n        \"\"\"Test that verify_password works with unicode characters.\"\"\"\n        password = \"pssw0rd___\"\n        hashed = hash_password(password)\n        assert verify_password(password, hashed) is True\n        assert verify_password(\"different_unicode_\", hashed) is False\n\n    def test_verify_password_case_sensitive(self):\n        \"\"\"Test that verify_password is case sensitive.\"\"\"\n        password = \"CaseSensitive123\"\n        hashed = hash_password(password)\n        assert verify_password(password, hashed) is True\n        assert verify_password(\"casesensitive123\", hashed) is False\n        assert verify_password(\"CASESENSITIVE123\", hashed) is False\n\n    def test_verify_password_with_whitespace_differences(self):\n        \"\"\"Test that verify_password is sensitive to whitespace.\"\"\"\n        password = \"password with spaces\"\n        hashed = hash_password(password)\n        assert verify_password(password, hashed) is True\n        assert verify_password(\" password with spaces\", hashed) is False\n        assert verify_password(\"password with spaces \", hashed) is False\n\n    def test_verify_password_with_invalid_hash_format(self):\n        \"\"\"Test that verify_password handles invalid hash format.\"\"\"\n        password = \"test_password\"\n        invalid_hash = \"not_a_valid_bcrypt_hash\"\n        assert verify_password(password, invalid_hash) is False\n\n    def test_verify_password_with_empty_hash(self):\n        \"\"\"Test that verify_password handles empty hash.\"\"\"\n        password = \"test_password\"\n        assert verify_password(password, \"\") is False\n\n    def test_verify_password_with_none_inputs(self):\n        \"\"\"Test that verify_password handles None inputs.\"\"\"\n        password = \"test_password\"\n        hashed = hash_password(password)\n        \n        with pytest.raises(TypeError):\n            verify_password(None, hashed)\n        \n        with pytest.raises(TypeError):\n            verify_password(password, None)\n\n    @patch('src.utils.password.bcrypt.checkpw')\n    def test_verify_password_uses_bcrypt(self, mock_checkpw):\n        \"\"\"Test that verify_password uses bcrypt for verification.\"\"\"\n        mock_checkpw.return_value = True\n        password = \"test_password\"\n        hashed = \"$2b$12$mocked_hash\"\n        \n        result = verify_password(password, hashed)\n        \n        mock_checkpw.assert_called_once_with(\n            password.encode('utf-8'),\n            hashed.encode('utf-8')\n        )\n        assert result is True\n\n\nclass TestGenerateSalt:\n    \"\"\"Test cases for salt generation functionality.\"\"\"\n\n    def test_generate_salt_returns_bytes(self):\n        \"\"\"Test that generate_salt returns bytes.\"\"\"\n        salt = generate_salt()\n        assert isinstance(salt, bytes)\n\n    def test_generate_salt_returns_different_values(self):\n        \"\"\"Test that generate_salt returns different values each time.\"\"\"\n        salt1 = generate_salt()\n        salt2 = generate_salt()\n        assert salt1 != salt2\n\n    def test_generate_salt_has_correct_length(self):\n        \"\"\"Test that generate_salt returns salt with correct length.\"\"\"\n        salt = generate_salt()\n        # bcrypt salt should be 29 characters when base64 encoded\n        assert len(salt) == 29\n\n    def test_generate_salt_with_custom_rounds(self):\n        \"\"\"Test that generate_salt accepts custom rounds parameter.\"\"\"\n        salt = generate",
      "file_type": "test",
      "semantic_unit_id": "SU-009",
      "component_id": "COMP-009",
      "description": "Unit tests for password hashing and verification with various password scenarios"
    },
    {
      "file_path": "tests/test_middleware_auth.py",
      "content": "\"\"\"\nUnit tests for authentication middleware\n\nTests JWT token validation, expiration handling, and missing token scenarios.\n\nComponent ID: COMP-012\nSemantic Unit: SU-012\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport pytest\nfrom unittest.mock import Mock, patch, MagicMock\nfrom datetime import datetime, timedelta, timezone\nimport jwt\nfrom fastapi import HTTPException, Request\nfrom fastapi.responses import JSONResponse\n\nfrom src.middleware.auth import AuthMiddleware, verify_token, get_current_user\n\n\nclass TestAuthMiddleware:\n    \"\"\"Test cases for AuthMiddleware class.\"\"\"\n\n    @pytest.fixture\n    def auth_middleware(self):\n        \"\"\"Create AuthMiddleware instance for testing.\"\"\"\n        app = Mock()\n        return AuthMiddleware(app)\n\n    @pytest.fixture\n    def mock_request(self):\n        \"\"\"Create mock request object.\"\"\"\n        request = Mock(spec=Request)\n        request.headers = {}\n        request.url.path = \"/api/test\"\n        request.method = \"GET\"\n        return request\n\n    @pytest.fixture\n    def valid_token(self):\n        \"\"\"Create valid JWT token for testing.\"\"\"\n        payload = {\n            \"sub\": \"test_user\",\n            \"exp\": datetime.now(timezone.utc) + timedelta(hours=1),\n            \"iat\": datetime.now(timezone.utc),\n            \"user_id\": \"123\",\n            \"email\": \"test@example.com\"\n        }\n        return jwt.encode(payload, \"test_secret\", algorithm=\"HS256\")\n\n    @pytest.fixture\n    def expired_token(self):\n        \"\"\"Create expired JWT token for testing.\"\"\"\n        payload = {\n            \"sub\": \"test_user\",\n            \"exp\": datetime.now(timezone.utc) - timedelta(hours=1),\n            \"iat\": datetime.now(timezone.utc) - timedelta(hours=2),\n            \"user_id\": \"123\",\n            \"email\": \"test@example.com\"\n        }\n        return jwt.encode(payload, \"test_secret\", algorithm=\"HS256\")\n\n    @pytest.fixture\n    def invalid_token(self):\n        \"\"\"Create invalid JWT token for testing.\"\"\"\n        return \"invalid.jwt.token\"\n\n    @pytest.mark.asyncio\n    async def test_middleware_allows_public_endpoints(self, auth_middleware, mock_request):\n        \"\"\"Test that middleware allows access to public endpoints without token.\"\"\"\n        mock_request.url.path = \"/health\"\n        mock_call_next = Mock()\n        mock_response = Mock()\n        mock_call_next.return_value = mock_response\n\n        result = await auth_middleware.dispatch(mock_request, mock_call_next)\n\n        assert result == mock_response\n        mock_call_next.assert_called_once_with(mock_request)\n\n    @pytest.mark.asyncio\n    async def test_middleware_allows_docs_endpoints(self, auth_middleware, mock_request):\n        \"\"\"Test that middleware allows access to documentation endpoints.\"\"\"\n        mock_request.url.path = \"/docs\"\n        mock_call_next = Mock()\n        mock_response = Mock()\n        mock_call_next.return_value = mock_response\n\n        result = await auth_middleware.dispatch(mock_request, mock_call_next)\n\n        assert result == mock_response\n        mock_call_next.assert_called_once_with(mock_request)\n\n    @pytest.mark.asyncio\n    async def test_middleware_blocks_protected_endpoint_without_token(self, auth_middleware, mock_request):\n        \"\"\"Test that middleware blocks protected endpoints when no token provided.\"\"\"\n        mock_request.url.path = \"/api/protected\"\n        mock_call_next = Mock()\n\n        result = await auth_middleware.dispatch(mock_request, mock_call_next)\n\n        assert isinstance(result, JSONResponse)\n        assert result.status_code == 401\n        mock_call_next.assert_not_called()\n\n    @pytest.mark.asyncio\n    @patch('src.middleware.auth.verify_token')\n    async def test_middleware_allows_valid_token(self, mock_verify, auth_middleware, mock_request, valid_token):\n        \"\"\"Test that middleware allows access with valid token.\"\"\"\n        mock_request.headers = {\"Authorization\": f\"Bearer {valid_token}\"}\n        mock_request.url.path = \"/api/protected\"\n        mock_verify.return_value = {\"user_id\": \"123\", \"email\": \"test@example.com\"}\n        mock_call_next = Mock()\n        mock_response = Mock()\n        mock_call_next.return_value = mock_response\n\n        result = await auth_middleware.dispatch(mock_request, mock_call_next)\n\n        assert result == mock_response\n        mock_call_next.assert_called_once_with(mock_request)\n        mock_verify.assert_called_once_with(valid_token)\n\n    @pytest.mark.asyncio\n    @patch('src.middleware.auth.verify_token')\n    async def test_middleware_blocks_expired_token(self, mock_verify, auth_middleware, mock_request, expired_token):\n        \"\"\"Test that middleware blocks access with expired token.\"\"\"\n        mock_request.headers = {\"Authorization\": f\"Bearer {expired_token}\"}\n        mock_request.url.path = \"/api/protected\"\n        mock_verify.side_effect = HTTPException(status_code=401, detail=\"Token expired\")\n        mock_call_next = Mock()\n\n        result = await auth_middleware.dispatch(mock_request, mock_call_next)\n\n        assert isinstance(result, JSONResponse)\n        assert result.status_code == 401\n        mock_call_next.assert_not_called()\n\n    @pytest.mark.asyncio\n    @patch('src.middleware.auth.verify_token')\n    async def test_middleware_blocks_invalid_token(self, mock_verify, auth_middleware, mock_request, invalid_token):\n        \"\"\"Test that middleware blocks access with invalid token.\"\"\"\n        mock_request.headers = {\"Authorization\": f\"Bearer {invalid_token}\"}\n        mock_request.url.path = \"/api/protected\"\n        mock_verify.side_effect = HTTPException(status_code=401, detail=\"Invalid token\")\n        mock_call_next = Mock()\n\n        result = await auth_middleware.dispatch(mock_request, mock_call_next)\n\n        assert isinstance(result, JSONResponse)\n        assert result.status_code == 401\n        mock_call_next.assert_not_called()\n\n    @pytest.mark.asyncio\n    async def test_middleware_handles_malformed_authorization_header(self, auth_middleware, mock_request):\n        \"\"\"Test that middleware handles malformed Authorization header.\"\"\"\n        mock_request.headers = {\"Authorization\": \"InvalidFormat\"}\n        mock_request.url.path = \"/api/protected\"\n        mock_call_next = Mock()\n\n        result = await auth_middleware.dispatch(mock_request, mock_call_next)\n\n        assert isinstance(result, JSONResponse)\n        assert result.status_code == 401\n        mock_call_next.assert_not_called()\n\n    @pytest.mark.asyncio\n    async def test_middleware_handles_empty_bearer_token(self, auth_middleware, mock_request):\n        \"\"\"Test that middleware handles empty Bearer token.\"\"\"\n        mock_request.headers = {\"Authorization\": \"Bearer \"}\n        mock_request.url.path = \"/api/protected\"\n        mock_call_next = Mock()\n\n        result = await auth_middleware.dispatch(mock_request, mock_call_next)\n\n        assert isinstance(result, JSONResponse)\n        assert result.status_code == 401\n        mock_call_next.assert_not_called()\n\n\nclass TestVerifyToken:\n    \"\"\"Test cases for verify_token function.\"\"\"\n\n    @pytest.fixture\n    def valid_payload(self):\n        \"\"\"Create valid token payload.\"\"\"\n        return {\n            \"sub\": \"test_user\",\n            \"exp\": datetime.now(timezone.utc) + timedelta(hours=1),\n            \"iat\": datetime.now(timezone.utc),\n            \"user_id\": \"123\",\n            \"email\": \"test@example.com\"\n        }\n\n    @pytest.fixture\n    def expired_payload(self):\n        \"\"\"Create expired token payload.\"\"\"\n        return {\n            \"sub\": \"test_user",
      "file_type": "test",
      "semantic_unit_id": "SU-012",
      "component_id": "COMP-012",
      "description": "Unit tests for authentication middleware including valid tokens, expired tokens, and missing tokens"
    },
    {
      "file_path": "tests/conftest.py",
      "content": "\"\"\"\nPytest configuration and fixtures for Hello World API tests.\n\nProvides test database setup, test client fixtures, and mock data generation\nfor comprehensive testing of the Hello World API application.\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport os\nimport tempfile\nfrom datetime import datetime, timezone\nfrom typing import Generator, Any, Dict\nfrom unittest.mock import Mock, patch\n\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom sqlalchemy.pool import StaticPool\n\nfrom src.main import app\nfrom src.database.connection import get_db, Base\n\n\n@pytest.fixture(scope=\"session\")\ndef test_database_url() -> str:\n    \"\"\"\n    Create a temporary SQLite database URL for testing.\n    \n    Returns:\n        str: SQLite database URL for testing\n    \"\"\"\n    # Create temporary file for test database\n    db_fd, db_path = tempfile.mkstemp(suffix='.db')\n    os.close(db_fd)\n    \n    # Ensure cleanup after tests\n    def cleanup():\n        if os.path.exists(db_path):\n            os.unlink(db_path)\n    \n    # Register cleanup function\n    import atexit\n    atexit.register(cleanup)\n    \n    return f\"sqlite:///{db_path}\"\n\n\n@pytest.fixture(scope=\"session\")\ndef test_engine(test_database_url: str):\n    \"\"\"\n    Create SQLAlchemy engine for test database.\n    \n    Args:\n        test_database_url: Database URL for testing\n        \n    Returns:\n        Engine: SQLAlchemy engine instance\n    \"\"\"\n    engine = create_engine(\n        test_database_url,\n        connect_args={\n            \"check_same_thread\": False,\n        },\n        poolclass=StaticPool,\n        echo=False  # Set to True for SQL debugging\n    )\n    \n    # Create all tables\n    Base.metadata.create_all(bind=engine)\n    \n    yield engine\n    \n    # Cleanup\n    Base.metadata.drop_all(bind=engine)\n    engine.dispose()\n\n\n@pytest.fixture(scope=\"function\")\ndef test_db_session(test_engine) -> Generator[Session, None, None]:\n    \"\"\"\n    Create a database session for testing with automatic rollback.\n    \n    Args:\n        test_engine: SQLAlchemy engine for testing\n        \n    Yields:\n        Session: Database session for testing\n    \"\"\"\n    TestingSessionLocal = sessionmaker(\n        autocommit=False,\n        autoflush=False,\n        bind=test_engine\n    )\n    \n    session = TestingSessionLocal()\n    \n    try:\n        yield session\n    finally:\n        session.rollback()\n        session.close()\n\n\n@pytest.fixture(scope=\"function\")\ndef client(test_db_session: Session) -> TestClient:\n    \"\"\"\n    Create FastAPI test client with test database session.\n    \n    Args:\n        test_db_session: Database session for testing\n        \n    Returns:\n        TestClient: FastAPI test client instance\n    \"\"\"\n    def override_get_db():\n        try:\n            yield test_db_session\n        finally:\n            pass\n    \n    app.dependency_overrides[get_db] = override_get_db\n    \n    with TestClient(app) as test_client:\n        yield test_client\n    \n    # Clean up dependency override\n    app.dependency_overrides.clear()\n\n\n@pytest.fixture\ndef mock_datetime_now():\n    \"\"\"\n    Mock datetime.utcnow() to return a fixed timestamp for testing.\n    \n    Returns:\n        Mock: Mocked datetime with fixed timestamp\n    \"\"\"\n    fixed_datetime = datetime(2024, 1, 15, 12, 30, 45, tzinfo=timezone.utc)\n    \n    with patch('src.main.datetime') as mock_dt:\n        mock_dt.utcnow.return_value = fixed_datetime\n        mock_dt.timezone = timezone\n        yield mock_dt\n\n\n@pytest.fixture\ndef sample_hello_response() -> Dict[str, str]:\n    \"\"\"\n    Generate sample Hello World API response for testing.\n    \n    Returns:\n        dict: Sample response matching API contract\n    \"\"\"\n    return {\n        \"message\": \"Hello World\",\n        \"timestamp\": \"2024-01-15T12:30:45.000000Z\",\n        \"status\": \"success\"\n    }\n\n\n@pytest.fixture\ndef mock_internal_error():\n    \"\"\"\n    Mock internal server error for error handling tests.\n    \n    Returns:\n        Mock: Mock that raises an exception when called\n    \"\"\"\n    def raise_error(*args, **kwargs):\n        raise Exception(\"Simulated internal error\")\n    \n    return Mock(side_effect=raise_error)\n\n\n@pytest.fixture(scope=\"function\")\ndef clean_environment():\n    \"\"\"\n    Ensure clean environment variables for testing.\n    \n    Yields:\n        None: Clean environment context\n    \"\"\"\n    # Store original environment\n    original_env = os.environ.copy()\n    \n    # Set test environment variables\n    test_env_vars = {\n        \"TESTING\": \"true\",\n        \"LOG_LEVEL\": \"DEBUG\",\n        \"DATABASE_URL\": \"sqlite:///test.db\"\n    }\n    \n    for key, value in test_env_vars.items():\n        os.environ[key] = value\n    \n    try:\n        yield\n    finally:\n        # Restore original environment\n        os.environ.clear()\n        os.environ.update(original_env)\n\n\n@pytest.fixture\ndef performance_timer():\n    \"\"\"\n    Timer fixture for performance testing.\n    \n    Returns:\n        callable: Timer function that returns elapsed time\n    \"\"\"\n    import time\n    \n    start_times = {}\n    \n    def timer(operation: str = \"default\") -> float:\n        current_time = time.perf_counter()\n        \n        if operation not in start_times:\n            start_times[operation] = current_time\n            return 0.0\n        else:\n            elapsed = current_time - start_times[operation]\n            del start_times[operation]\n            return elapsed\n    \n    return timer\n\n\n@pytest.fixture\ndef mock_response_formatter():\n    \"\"\"\n    Mock response formatter for testing response structure.\n    \n    Returns:\n        Mock: Mock formatter function\n    \"\"\"\n    def format_response(message: str) -> Dict[str, str]:\n        return {\n            \"message\": message,\n            \"timestamp\": \"2024-01-15T12:30:45.000000Z\",\n            \"status\": \"success\"\n        }\n    \n    return Mock(side_effect=format_response)\n\n\n@pytest.fixture(autouse=True)\ndef reset_app_state():\n    \"\"\"\n    Reset application state before each test.\n    \n    This fixture automatically runs before each test to ensure\n    clean application state and prevent test interference.\n    \"\"\"\n    # Clear any cached data or state\n    app.dependency_overrides.clear()\n    \n    yield\n    \n    # Cleanup after test\n    app.dependency_overrides.clear()\n\n\n# Pytest configuration\ndef pytest_configure(config):\n    \"\"\"\n    Configure pytest with custom markers and settings.\n    \n    Args:\n        config: Pytest configuration object\n    \"\"\"\n    config.addinivalue_line(\n        \"markers\", \"unit: mark test as a unit test\"\n    )\n    config.addinivalue_line(\n        \"markers\", \"integration: mark test as an integration test\"\n    )\n    config.addinivalue_line(\n        \"markers\", \"performance: mark test as a performance test\"\n    )\n    config.addinivalue_line(\n        \"markers\", \"error_handling: mark test as error handling test\"\n    )\n\n\ndef pytest_collection_modifyitems(config, items):\n    \"\"\"\n    Modify test collection to add markers based on test names.\n    \n    Args:\n        config: Pytest configuration object\n        items: List of collected test items\n    \"\"\"\n    for item in items:\n        # Add markers based on test file location\n        if \"unit\" in str(item.fspath):\n            item.add_marker(pytest.mark.unit)\n        elif \"integration\" in str(item.fspath):\n            item.add_marker(",
      "file_type": "test",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Pytest configuration with test database setup, fixtures for test client, and mock data generation"
    },
    {
      "file_path": "requirements.txt",
      "content": "# Web Framework\nfastapi==0.104.1\nuvicorn[standard]==0.24.0\n\n# Data Validation\npydantic==2.5.0\n\n# Database\nsqlalchemy==2.0.23\nalembic==1.12.1\n\n# Database Drivers\npsycopg2-binary==2.9.9\nasyncpg==0.29.0\n\n# Authentication & Security\npython-jose[cryptography]==3.3.0\npasslib[bcrypt]==1.7.4\npython-multipart==0.0.6\n\n# HTTP Client\nhttpx==0.25.2\nrequests==2.31.0\n\n# Environment & Configuration\npython-dotenv==1.0.0\n\n# Date & Time\npython-dateutil==2.8.2\n\n# Testing\npytest==7.4.3\npytest-asyncio==0.21.1\npytest-cov==4.1.0\n\n# Development Tools\nblack==23.11.0\nflake8==6.1.0\nmypy==1.7.1\n\n# Logging\nstructlog==23.2.0",
      "file_type": "requirements",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Python dependencies with exact versions for FastAPI, SQLAlchemy, JWT, testing, and database drivers"
    },
    {
      "file_path": "requirements-dev.txt",
      "content": "# Core Development Dependencies\npytest==7.4.3\npytest-cov==4.1.0\npytest-mock==3.12.0\n\n# Code Quality Tools\nblack==23.11.0\nflake8==6.1.0\nisort==5.12.0\nmypy==1.7.1\n\n# Development Server\nuvicorn[standard]==0.24.0\n\n# Debugging and Profiling\npdb-attach==3.2.0\npy-spy==0.3.14\n\n# Documentation\nsphinx==7.2.6\nsphinx-rtd-theme==1.3.0",
      "file_type": "requirements",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Development dependencies including testing tools, linters, formatters, and debugging utilities"
    },
    {
      "file_path": ".env.example",
      "content": "# Environment Configuration Template\n# Copy this file to .env and fill in the actual values\n\n# Application Configuration\nAPP_NAME=Hello World API\nAPP_VERSION=1.0.0\nAPP_DESCRIPTION=Simple REST API that returns a greeting message\nDEBUG=false\nLOG_LEVEL=INFO\n\n# Server Configuration\nHOST=0.0.0.0\nPORT=8000\nRELOAD=false\n\n# Security Configuration\nSECRET_KEY=your-secret-key-here-change-in-production\nJWT_SECRET_KEY=your-jwt-secret-key-here-change-in-production\nJWT_ALGORITHM=HS256\nJWT_EXPIRE_MINUTES=30\n\n# Database Configuration (if needed for future expansion)\nDATABASE_URL=sqlite:///./app.db\nDATABASE_ECHO=false\n\n# CORS Configuration\nCORS_ORIGINS=[\"http://localhost:3000\", \"http://localhost:8080\"]\nCORS_ALLOW_CREDENTIALS=true\nCORS_ALLOW_METHODS=[\"GET\", \"POST\", \"PUT\", \"DELETE\"]\nCORS_ALLOW_HEADERS=[\"*\"]\n\n# Timezone Configuration\nTIMEZONE=UTC",
      "file_type": "config",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Environment variables template with database URL, JWT secrets, and application configuration"
    },
    {
      "file_path": "alembic.ini",
      "content": "# Alembic Config file, generic single-database configuration.\n\n[alembic]\n# path to migration scripts\nscript_location = alembic\n\n# template used to generate migration file names; The default value is %%(rev)s_%%(slug)s\n# Uncomment the line below if you want the files to be prepended with date and time\n# file_template = %%(year)d_%%(month).2d_%%(day).2d_%%(hour).2d%%(minute).2d-%%(rev)s_%%(slug)s\n\n# sys.path path, will be prepended to sys.path if present.\n# defaults to the current working directory.\nprepend_sys_path = .\n\n# timezone to use when rendering the date within the migration file\n# as well as the filename.\n# If specified, requires the python-dateutil library that can be\n# installed by adding `alembic[tz]` to the pip requirements\n# string value is passed to dateutil.tz.gettz()\n# leave blank for localtime\n# timezone =\n\n# max length of characters to apply to the\n# \"slug\" field\n# truncate_slug_length = 40\n\n# set to 'true' to run the environment during\n# the 'revision' command, regardless of autogenerate\n# revision_environment = false\n\n# set to 'true' to allow .pyc and .pyo files without\n# a source .py file to be detected as revisions in the\n# versions/ directory\n# sourceless = false\n\n# version path separator; As mentioned above, this is the character used to split\n# version_locations. The default within new alembic.ini files is \"os\", which uses\n# os.pathsep. If this key is omitted entirely, it falls back to the legacy\n# behavior of splitting on spaces and/or commas.\n# Valid values for version_path_separator are:\n#\n# version_path_separator = :\n# version_path_separator = ;\n# version_path_separator = space\nversion_path_separator = os\n\n# set to 'true' to search source files recursively\n# in each \"version_locations\" directory\n# new in Alembic version 1.10\n# recursive_version_locations = false\n\n# the output encoding used when revision files\n# are written from script.py.mako\n# output_encoding = utf-8\n\nsqlalchemy.url = sqlite:///./app.db\n\n\n[post_write_hooks]\n# post_write_hooks defines scripts or Python functions that are run\n# on newly generated revision scripts.  See the documentation for further\n# detail and examples\n\n# format using \"black\" - use the console_scripts runner, against the \"black\" entrypoint\n# hooks = black\n# black.type = console_scripts\n# black.entrypoint = black\n# black.options = -l 79 REVISION_SCRIPT_FILENAME\n\n# lint with attempts to fix using \"ruff\" - use the exec runner, execute a binary\n# hooks = ruff\n# ruff.type = exec\n# ruff.executable = %(here)s/.venv/bin/ruff\n# ruff.options = --fix REVISION_SCRIPT_FILENAME\n\n# Logging configuration\n[loggers]\nkeys = root,sqlalchemy,alembic\n\n[handlers]\nkeys = console\n\n[formatters]\nkeys = generic\n\n[logger_root]\nlevel = WARN\nhandlers = console\nqualname =\n\n[logger_sqlalchemy]\nlevel = WARN\nhandlers =\nqualname = sqlalchemy.engine\n\n[logger_alembic]\nlevel = INFO\nhandlers =\nqualname = alembic\n\n[handler_console]\nclass = StreamHandler\nargs = (sys.stderr,)\nlevel = NOTSET\nformatter = generic\n\n[formatter_generic]\nformat = %(levelname)-5.5s [%(name)s] %(message)s\ndatefmt = %H:%M:%S",
      "file_type": "config",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Alembic configuration for database migrations with SQLAlchemy URL and migration settings"
    },
    {
      "file_path": "pytest.ini",
      "content": "[pytest]\ntestpaths = tests\npython_files = test_*.py\npython_classes = Test*\npython_functions = test_*\naddopts = \n    --verbose\n    --tb=short\n    --strict-markers\n    --disable-warnings\n    --cov=.\n    --cov-report=term-missing\n    --cov-report=html:htmlcov\n    --cov-fail-under=80\n\nmarkers =\n    unit: Unit tests\n    integration: Integration tests\n    slow: Slow running tests\n\nfilterwarnings =\n    ignore::DeprecationWarning\n    ignore::PendingDeprecationWarning",
      "file_type": "config",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Pytest configuration with test discovery, coverage settings, and test database configuration"
    },
    {
      "file_path": ".pylintrc",
      "content": "[MASTER]\n\n# Pylint configuration file for Hello World API\n# Generated for Python 3.12 FastAPI project following PEP 8 standards\n\n[MAIN]\n\n# Analyse import fallback blocks. This can be used to support both Python 2 and\n# 3 compatible code, which means that the block might have code that exists\n# only in one or both versions of the interpreter.\nanalyse-fallback-blocks=no\n\n# Load and enable all available extensions. Use --list-extensions to see a\n# list all available extensions.\n#enable-all-extensions=\n\n# In error mode, messages with a category in this list are fatal. Either give\n# the full message id or the symbolic name.\nfail-on=\n\n# Files or directories to be skipped. They should be base names, not paths.\nignore=CVS\n\n# Add files or directories matching the regex patterns to the ignore-list.\n# The regex matches against paths and can be in Posix or Windows format.\nignore-paths=\n\n# Files or directories matching the regex patterns are skipped. The regex\n# matches against base names, not paths. The default value ignores Emacs file\n# locks\nignore-patterns=^\\.#\n\n# List of module names for which member attributes should not be checked\n# (useful for modules/projects where namespaces are manipulated during runtime\n# and thus existing member attributes cannot be deduced by static analysis). It\n# supports qualified module names, as well as Unix pattern matching.\nignored-modules=\n\n# Python code to execute, usually for sys.path manipulation such as\n# pygtk.require().\n#init-hook=\n\n# Use multiple processes to speed up Pylint. Specifying 0 will auto-detect the\n# number of processors available to use, and will cap the count on Windows to\n# avoid hangs.\njobs=1\n\n# Control the amount of potential inferred values when inferring a single\n# object. This can help the performance when dealing with large functions or\n# complex, nested conditions.\nlimit-inference-results=100\n\n# List of plugins (as comma separated values of python module names) to load,\n# usually to register additional checkers.\nload-plugins=\n\n# Pickle collected data for later comparisons.\npersistent=yes\n\n# Minimum Python version to use for version dependent checks. Will default to\n# the version used to run pylint.\npy-version=3.12\n\n# Discover python modules and packages in the file system subtree.\nrecursive=no\n\n# When enabled, pylint would attempt to guess common misconfiguration and emit\n# user-friendly hints instead of false-positive error messages.\nsuggestion-mode=yes\n\n# Allow loading of arbitrary C extensions. Extensions are imported into the\n# active Python interpreter and may run arbitrary code.\nunsafe-load-any-extension=no\n\n# In verbose mode, extra non-checker-related info will be displayed.\n#verbose=\n\n[REPORTS]\n\n# Python expression which should return a score less than or equal to 10. You\n# have access to the variables 'fatal', 'error', 'warning', 'refactor',\n# 'convention', and 'info' which contain the number of messages in each\n# category, as well as 'statement' which is the total number of statements\n# analyzed. This score is used by the global evaluation report (RP0004).\nevaluation=max(0, 0 if fatal else 10.0 - ((float(5 * error + warning + refactor + convention) / statement) * 10))\n\n# Template used to display messages. This is a python new-style format string\n# used to format the message information. See doc for all details.\nmsg-template=\n\n# Set the output format. Available formats are text, parseable, colorized, json\n# and msvs (visual studio). You can also give a reporter class, e.g.\n# mypackage.mymodule.MyReporterClass.\n#output-format=\n\n# Tells whether to display a full report or only the messages.\nreports=no\n\n# Activate the evaluation score.\nscore=yes\n\n[MESSAGES CONTROL]\n\n# Only show warnings with the listed confidence levels. Leave empty to show\n# all. Valid levels: CONTROL_FLOW, HIGH, INFERENCE, INFERENCE_FAILURE,\n# UNDEFINED.\nconfidence=HIGH,\n           CONTROL_FLOW,\n           INFERENCE,\n           INFERENCE_FAILURE,\n           UNDEFINED\n\n# Disable the message, report, category or checker with the given id(s). You\n# can either give multiple identifiers separated by comma (,) or put this\n# option multiple times (only on the command line, not in the configuration\n# file where it should appear only once). You can also use \"--disable=all\" to\n# disable everything first and then re-enable specific checks. For example, if\n# you want to run only the similarities checker, you can use \"--disable=all\n# --enable=similarities\". If you want to run only the classes checker, but have\n# no Warning level messages displayed, use \"--disable=all --enable=classes\n# --disable=W\".\ndisable=raw-checker-failed,\n        bad-inline-option,\n        locally-disabled,\n        file-ignored,\n        suppressed-message,\n        useless-suppression,\n        deprecated-pragma,\n        use-symbolic-message-instead,\n        missing-module-docstring,\n        too-few-public-methods,\n        fixme\n\n# Enable the message, report, category or checker with the given id(s). You can\n# either give multiple identifier separated by comma (,) or put this option\n# multiple time (only on the command line, not in the configuration file where\n# it should appear only once). See also the \"--disable\" option for examples.\nenable=c-extension-no-member\n\n[MISCELLANEOUS]\n\n# List of note tags to take in consideration, separated by a comma.\nnotes=FIXME,\n      XXX,\n      TODO\n\n[LOGGING]\n\n# The type of string formatting that logging methods do. `old` means using %\n# formatting, `new` is for `{}` formatting.\nlogging-format-style=old\n\n# Logging modules to check that the string format arguments are in logging\n# function parameter format.\nlogging-modules=logging\n\n[SIMILARITIES]\n\n# Comments are removed from the similarity computation\nignore-comments=yes\n\n# Docstrings are removed from the similarity computation\nignore-docstrings=yes\n\n# Imports are removed from the similarity computation\nignore-imports=yes\n\n# Signatures are removed from the similarity computation\nignore-signatures=yes\n\n# Minimum lines number of a similarity.\nmin-similarity-lines=4\n\n[SPELLING]\n\n# Limits count of emitted suggestions for spelling mistakes.\nmax-spelling-suggestions=4\n\n# Spelling dictionary name. Available dictionaries: none. To make it work,\n# install the 'python-enchant' package.\nspelling-dict=\n\n# List of comma separated words that should be considered directives if they\n# appear at the beginning of a comment and should not be checked.\nspelling-ignore-comment-directives=fmt: off,fmt: on,noqa:,noqa,nosec,isort:skip,mypy:\n\n# List of comma separated words that should not be checked.\nspelling-ignore-words=\n\n# A path to a file that contains the private dictionary; one word per line.\nspelling-private-dict-file=\n\n# Tells whether to store unknown words to the private dictionary (see the\n# --spelling-private-dict-file option) instead of raising a message.\nspelling-store-unknown-words=no\n\n[FORMAT]\n\n# Expected format of line ending, e.g. empty (any line ending), LF or CRLF.\nexpected-line-ending-format=\n\n# Regexp for a line that is allowed to be longer than the limit.\nignore-long-lines=^\\s*(# )?<?https?://\\S+>?$\n\n# Number of spaces of indent required inside a hanging or continued line.\nindent-after-paren=4\n\n# String used as indentation unit. This is usually \"    \" (4 spaces) or \"\\t\" (1\n# tab).\nindent-string='    '\n\n# Maximum number of characters on a single line.\nmax-line-length=88\n\n# Maximum number of lines in a module.\nmax-module-lines=1000\n\n# Allow the body of a class to be on the same line as the declaration if body\n# contains single statement.\nsingle-line-class-stmt=no\n\n# Allow the body of an if to be on the same line as the test if there is no\n# else.\nsingle-line-if-stmt=no\n\n[VARIABLES",
      "file_type": "config",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Pylint configuration with code quality rules, disabled warnings, and project-specific settings"
    },
    {
      "file_path": ".gitignore",
      "content": "# Byte-compiled / optimized / DLL files\n__pycache__/\n*.py[cod]\n*$py.class\n\n# C extensions\n*.so\n\n# Distribution / packaging\n.Python\nbuild/\ndevelop-eggs/\ndist/\ndownloads/\neggs/\n.eggs/\nlib/\nlib64/\nparts/\nsdist/\nvar/\nwheels/\nshare/python-wheels/\n*.egg-info/\n.installed.cfg\n*.egg\nMANIFEST\n\n# PyInstaller\n#  Usually these files are written by a python script from a template\n#  before PyInstaller builds the exe, so as to inject date/other infos into it.\n*.manifest\n*.spec\n\n# Installer logs\npip-log.txt\npip-delete-this-directory.txt\n\n# Unit test / coverage reports\nhtmlcov/\n.tox/\n.nox/\n.coverage\n.coverage.*\n.cache\nnosetests.xml\ncoverage.xml\n*.cover\n*.py,cover\n.hypothesis/\n.pytest_cache/\ncover/\n\n# Translations\n*.mo\n*.pot\n\n# Django stuff:\n*.log\nlocal_settings.py\ndb.sqlite3\ndb.sqlite3-journal\n\n# Flask stuff:\ninstance/\n.webassets-cache\n\n# Scrapy stuff:\n.scrapy\n\n# Sphinx documentation\ndocs/_build/\n\n# PyBuilder\n.pybuilder/\ntarget/\n\n# Jupyter Notebook\n.ipynb_checkpoints\n\n# IPython\nprofile_default/\nipython_config.py\n\n# pyenv\n#   For a library or package, you might want to ignore these files since the code is\n#   intended to run in multiple environments; otherwise, check them in:\n# .python-version\n\n# pipenv\n#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.\n#   However, in case of collaboration, if having platform-specific dependencies or dependencies\n#   having no cross-platform support, pipenv may install dependencies that don't work, or not\n#   install all needed dependencies.\n#Pipfile.lock\n\n# poetry\n#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.\n#   This is especially recommended for binary packages to ensure reproducibility, and is more\n#   commonly ignored for libraries.\n#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control\n#poetry.lock\n\n# pdm\n#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.\n#pdm.lock\n#   pdm stores project-wide configurations in .pdm.toml, but it is recommended to not include it\n#   in version control.\n#   https://pdm.fming.dev/#use-with-ide\n.pdm.toml\n\n# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm\n__pypackages__/\n\n# Celery stuff\ncelerybeat-schedule\ncelerybeat.pid\n\n# SageMath parsed files\n*.sage.py\n\n# Environments\n.env\n.venv\nenv/\nvenv/\nENV/\nenv.bak/\nvenv.bak/\n\n# Spyder project settings\n.spyderproject\n.spyproject\n\n# Rope project settings\n.ropeproject\n\n# mkdocs documentation\n/site\n\n# mypy\n.mypy_cache/\n.dmypy.json\ndmypy.json\n\n# Pyre type checker\n.pyre/\n\n# pytype static type analyzer\n.pytype/\n\n# Cython debug symbols\ncython_debug/\n\n# PyCharm\n#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can\n#  be added to the global gitignore or merged into this project gitignore.  For a PyCharm\n#  project, it is recommended to ignore only the following files and directories:\n.idea/\n\n# VS Code\n.vscode/\n\n# Sublime Text\n*.sublime-project\n*.sublime-workspace\n\n# Vim\n*.swp\n*.swo\n*~\n\n# Emacs\n*~\n\\#*\\#\n/.emacs.desktop\n/.emacs.desktop.lock\n*.elc\nauto-save-list\ntramp\n.\\#*\n\n# macOS\n.DS_Store\n.AppleDouble\n.LSOverride\n\n# Windows\nThumbs.db\nehthumbs.db\nDesktop.ini\n$RECYCLE.BIN/\n\n# Linux\n*~\n\n# Database files\n*.db\n*.sqlite\n*.sqlite3\n\n# Log files\n*.log\nlogs/\n\n# Temporary files\n*.tmp\n*.temp\ntemp/\ntmp/",
      "file_type": "config",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Git ignore patterns for Python cache files, environment files, database files, and IDE configurations"
    },
    {
      "file_path": "README.md",
      "content": "# Hello World API\n\nA simple FastAPI REST API that returns a \"Hello World\" greeting message with timestamp.\n\n## Features\n\n- Single `/hello` endpoint that returns JSON greeting with timestamp\n- FastAPI automatic documentation at `/docs` and `/redoc`\n- Lightweight and fast ASGI-based server\n- ISO 8601 UTC timestamp formatting\n- Comprehensive error handling\n\n## Prerequisites\n\n- Python 3.12 or higher\n- pip package manager\n\n## Installation\n\n1. Clone or download the project files\n\n2. Install dependencies:\n   ```bash\n   pip install -r requirements.txt\n   ```\n\n## Configuration\n\nNo configuration is required for this simple API. The application runs with default settings.\n\n## Running the Application\n\n### Development Mode\n\nStart the development server with auto-reload:\n\n```bash\nuvicorn main:app --reload\n```\n\nThe API will be available at http://localhost:8000\n\n### Production Mode\n\nStart the production server:\n\n```bash\nuvicorn main:app --host 0.0.0.0 --port 8000\n```\n\n### Custom Port\n\nTo run on a different port:\n\n```bash\nuvicorn main:app --port 8001\n```\n\n## API Documentation\n\n### GET /hello\n\nReturns a Hello World greeting message with current timestamp.\n\n**URL:** `/hello`\n\n**Method:** `GET`\n\n**Authentication:** None required\n\n**Request Parameters:** None\n\n**Response Format:**\n\n```json\n{\n  \"message\": \"Hello World\",\n  \"timestamp\": \"2023-12-07T10:30:45.123456Z\",\n  \"status\": \"success\"\n}\n```\n\n**Response Fields:**\n- `message` (string): Always returns \"Hello World\"\n- `timestamp` (string): Current UTC timestamp in ISO 8601 format\n- `status` (string): Always returns \"success\" for successful requests\n\n**Status Codes:**\n- `200 OK`: Success - greeting returned successfully\n- `500 Internal Server Error`: Server error occurred\n\n**Example Request:**\n```bash\ncurl -X GET \"http://localhost:8000/hello\"\n```\n\n**Example Response:**\n```json\n{\n  \"message\": \"Hello World\",\n  \"timestamp\": \"2023-12-07T15:42:33.789012Z\",\n  \"status\": \"success\"\n}\n```\n\n### Error Responses\n\nWhen an internal server error occurs:\n\n**Status Code:** `500 Internal Server Error`\n\n**Response Format:**\n```json\n{\n  \"code\": \"INTERNAL_ERROR\",\n  \"message\": \"Internal server error\"\n}\n```\n\n## Interactive API Documentation\n\nFastAPI automatically generates interactive API documentation:\n\n- **Swagger UI:** http://localhost:8000/docs\n- **ReDoc:** http://localhost:8000/redoc\n\nThese interfaces allow you to:\n- View all available endpoints\n- Test API calls directly from the browser\n- See request/response schemas\n- Download OpenAPI specification\n\n## Testing\n\n### Running Tests\n\nRun the complete test suite:\n\n```bash\npytest tests/ -v\n```\n\nRun tests with coverage report:\n\n```bash\npytest tests/ --cov=. --cov-report=html\n```\n\nView coverage report:\n```bash\nopen htmlcov/index.html\n```\n\n### Test Coverage\n\nThe test suite includes:\n- Unit tests for the HelloWorldHandler component\n- Integration tests for the /hello endpoint\n- Error handling tests\n- Response format validation tests\n- Timestamp format validation tests\n\n### Manual Testing\n\nTest the endpoint manually using curl:\n\n```bash\n# Test successful response\ncurl -X GET \"http://localhost:8000/hello\"\n\n# Test with verbose output to see headers\ncurl -v -X GET \"http://localhost:8000/hello\"\n```\n\n## Architecture\n\n### Component Overview\n\n- **HelloWorldHandler**: Core component that processes GET requests to /hello endpoint\n  - Generates Hello World message\n  - Creates ISO 8601 UTC timestamp\n  - Formats consistent JSON response\n  - Handles exceptions and returns appropriate error responses\n\n### Technology Stack\n\n- **Language:** Python 3.12\n- **Web Framework:** FastAPI 0.104+\n- **HTTP Server:** Uvicorn ASGI server\n- **Datetime Handling:** Python datetime module (stdlib)\n- **JSON Serialization:** FastAPI automatic JSON response\n\n### Design Principles\n\n- **Simplicity:** Minimal architecture with single endpoint\n- **Consistency:** Standardized response format\n- **Reliability:** Comprehensive error handling\n- **Performance:** Lightweight with minimal processing overhead\n- **Standards Compliance:** ISO 8601 timestamps, REST conventions\n\n## Development\n\n### Code Structure\n\n```\n.\n main.py              # FastAPI application and HelloWorldHandler\n tests/\n    test_main.py     # Unit and integration tests\n requirements.txt     # Python dependencies\n README.md           # This documentation\n```\n\n### Adding Features\n\nTo extend the API:\n\n1. Add new endpoint handlers to `main.py`\n2. Create corresponding tests in `tests/`\n3. Update this README with new endpoint documentation\n4. Update requirements.txt if new dependencies are needed\n\n## Troubleshooting\n\n### Common Issues\n\n#### Port Already in Use\n\n**Error:** `OSError: [Errno 48] Address already in use`\n\n**Solution:** Use a different port:\n```bash\nuvicorn main:app --port 8001\n```\n\nOr find and stop the process using port 8000:\n```bash\nlsof -ti:8000 | xargs kill -9\n```\n\n#### Import Errors\n\n**Error:** `ModuleNotFoundError: No module named 'fastapi'`\n\n**Solution:** Install dependencies:\n```bash\npip install -r requirements.txt\n```\n\n#### Python Version Issues\n\n**Error:** `SyntaxError` or compatibility issues\n\n**Solution:** Ensure Python 3.12+ is installed:\n```bash\npython --version\n```\n\nIf using an older version, upgrade Python or use pyenv:\n```bash\npyenv install 3.12.0\npyenv local 3.12.0\n```\n\n#### Permission Denied (Port 80/443)\n\n**Error:** `PermissionError: [Errno 13] Permission denied`\n\n**Solution:** Use a port above 1024 or run with sudo (not recommended):\n```bash\nuvicorn main:app --port 8000\n```\n\n#### Tests Failing\n\n**Error:** Test failures or import errors in tests\n\n**Solution:** \n1. Ensure all dependencies are installed:\n   ```bash\n   pip install -r requirements.txt\n   ```\n\n2. Run tests from project root directory:\n   ```bash\n   pytest tests/ -v\n   ```\n\n3. Check Python path if imports fail:\n   ```bash\n   export PYTHONPATH=\"${PYTHONPATH}:$(pwd)\"\n   pytest tests/ -v\n   ```\n\n### Performance Issues\n\n#### Slow Response Times\n\nIf responses are slower than expected:\n\n1. Check system resources:\n   ```bash\n   top\n   ```\n\n2. Use production ASGI server settings:\n   ```bash\n   uvicorn main:app --workers 4\n   ```\n\n3. Monitor response times:\n   ```bash\n   curl -w \"@curl-format.txt\" -o /dev/null -s \"http://localhost:8000/hello\"\n   ```\n\n### Debugging\n\n#### Enable Debug Logging\n\nAdd logging to troubleshoot issues:\n\n```python\nimport logging\nlogging.basicConfig(level=logging.DEBUG)\n```\n\n#### Check Application Health\n\nThe API doesn't include a dedicated health endpoint, but you can verify it's running:\n\n```bash\ncurl -f http://localhost:8000/hello || echo \"API is down\"\n```\n\n## Support\n\nFor issues or questions:\n\n1. Check this troubleshooting section\n2. Review the interactive API documentation at `/docs`\n3. Run the test suite to verify functionality\n4. Check application logs for error details\n\n## License\n\nThis is a simple demonstration API. Use and modify as needed for your projects.",
      "file_type": "documentation",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Comprehensive project documentation with setup instructions, API endpoints, authentication flow, and troubleshooting guide"
    },
    {
      "file_path": "docs/api_documentation.md",
      "content": "# Hello World API Documentation\n\nComplete API documentation for the Hello World REST API service.\n\n## Overview\n\nThe Hello World API is a simple REST service that provides a single endpoint returning a greeting message with timestamp information. This API demonstrates basic REST principles and JSON response formatting.\n\n**Base URL:** `http://localhost:8000`\n\n**API Version:** 1.0.0\n\n**Content Type:** `application/json`\n\n## Architecture\n\nThe API follows a minimal REST architecture with a single component:\n\n- **HelloWorldHandler**: Processes GET requests to `/hello` endpoint\n- **Framework**: FastAPI with automatic JSON serialization\n- **Server**: Uvicorn ASGI server\n- **Language**: Python 3.12\n\n## Authentication\n\nNo authentication is required for any endpoints in this API.\n\n## Rate Limiting\n\nNo rate limiting is currently implemented.\n\n## Endpoints\n\n### GET /hello\n\nReturns a Hello World greeting message with current timestamp.\n\n**URL:** `/hello`\n\n**Method:** `GET`\n\n**Authentication Required:** No\n\n**Parameters:** None\n\n#### Request\n\nNo request body or parameters required.\n\n```bash\ncurl -X GET \"http://localhost:8000/hello\"\n```\n\n#### Response\n\n**Success Response (200 OK):**\n\n```json\n{\n  \"message\": \"Hello World\",\n  \"timestamp\": \"2024-01-15T10:30:45.123456Z\",\n  \"status\": \"success\"\n}\n```\n\n**Response Schema:**\n\n| Field | Type | Description | Example |\n|-------|------|-------------|---------|\n| `message` | string | Static greeting message (always \"Hello World\") | `\"Hello World\"` |\n| `timestamp` | string | ISO 8601 UTC timestamp when response was generated | `\"2024-01-15T10:30:45.123456Z\"` |\n| `status` | string | Response status (always \"success\" for 200 responses) | `\"success\"` |\n\n**Response Headers:**\n\n```\nContent-Type: application/json\nContent-Length: 89\n```\n\n#### Error Responses\n\n**Internal Server Error (500):**\n\n```json\n{\n  \"detail\": \"Internal server error\"\n}\n```\n\n**Error Response Schema:**\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `detail` | string | Error description |\n\n#### Status Codes\n\n| Code | Description | When It Occurs |\n|------|-------------|----------------|\n| `200` | OK | Request processed successfully |\n| `500` | Internal Server Error | Unexpected server error during processing |\n\n#### Examples\n\n**Successful Request:**\n\n```bash\n# Request\ncurl -X GET \"http://localhost:8000/hello\" \\\n  -H \"Accept: application/json\"\n\n# Response\nHTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"message\": \"Hello World\",\n  \"timestamp\": \"2024-01-15T14:22:33.789012Z\",\n  \"status\": \"success\"\n}\n```\n\n**Using Python requests:**\n\n```python\nimport requests\n\nresponse = requests.get(\"http://localhost:8000/hello\")\nprint(f\"Status: {response.status_code}\")\nprint(f\"Response: {response.json()}\")\n\n# Output:\n# Status: 200\n# Response: {'message': 'Hello World', 'timestamp': '2024-01-15T14:22:33.789012Z', 'status': 'success'}\n```\n\n**Using JavaScript fetch:**\n\n```javascript\nfetch('http://localhost:8000/hello')\n  .then(response => response.json())\n  .then(data => {\n    console.log('Message:', data.message);\n    console.log('Timestamp:', data.timestamp);\n    console.log('Status:', data.status);\n  });\n```\n\n### GET /docs\n\nFastAPI automatically generates interactive API documentation.\n\n**URL:** `/docs`\n\n**Method:** `GET`\n\n**Description:** Swagger UI interface for testing API endpoints\n\n**Response:** HTML page with interactive API documentation\n\n### GET /redoc\n\nAlternative API documentation interface.\n\n**URL:** `/redoc`\n\n**Method:** `GET`\n\n**Description:** ReDoc interface for API documentation\n\n**Response:** HTML page with API documentation\n\n### GET /openapi.json\n\nOpenAPI specification in JSON format.\n\n**URL:** `/openapi.json`\n\n**Method:** `GET`\n\n**Description:** Machine-readable API specification\n\n**Response:** JSON OpenAPI 3.0 specification\n\n## Data Types\n\n### Timestamp Format\n\nAll timestamps in the API use ISO 8601 format in UTC timezone:\n\n- **Format:** `YYYY-MM-DDTHH:MM:SS.fffffZ`\n- **Example:** `2024-01-15T14:22:33.789012Z`\n- **Timezone:** Always UTC (indicated by 'Z' suffix)\n\n### String Fields\n\nAll string fields use UTF-8 encoding and are returned as JSON strings.\n\n## Error Handling\n\nThe API uses standard HTTP status codes and returns error information in JSON format.\n\n### Error Response Format\n\n```json\n{\n  \"detail\": \"Error description\"\n}\n```\n\n### Common Error Scenarios\n\n| Scenario | Status Code | Response |\n|----------|-------------|----------|\n| Server exception during processing | 500 | `{\"detail\": \"Internal server error\"}` |\n| Invalid HTTP method | 405 | `{\"detail\": \"Method Not Allowed\"}` |\n| Endpoint not found | 404 | `{\"detail\": \"Not Found\"}` |\n\n## Performance\n\n### Response Times\n\n- **Target Response Time:** < 10ms\n- **Processing Overhead:** Minimal (no database or external API calls)\n- **Concurrent Requests:** Supported via ASGI server\n\n### Optimization Notes\n\n- No database queries required\n- Static message content\n- Minimal timestamp generation overhead\n- FastAPI automatic JSON serialization\n\n## Security\n\n### Data Exposure\n\nThe API does not expose any sensitive information:\n\n- No server details in responses\n- No internal system paths\n- No configuration information\n- Only specified message, timestamp, and status fields\n\n### Input Validation\n\nNo user input is accepted by the `/hello` endpoint, eliminating input validation concerns.\n\n## Testing\n\n### Manual Testing\n\nTest the endpoint using curl:\n\n```bash\n# Basic functionality test\ncurl -X GET \"http://localhost:8000/hello\"\n\n# Test with verbose output\ncurl -v -X GET \"http://localhost:8000/hello\"\n\n# Test response headers\ncurl -I -X GET \"http://localhost:8000/hello\"\n```\n\n### Automated Testing\n\nExample test cases for the API:\n\n```python\ndef test_hello_endpoint_success():\n    \"\"\"Test successful hello endpoint response.\"\"\"\n    response = client.get(\"/hello\")\n    assert response.status_code == 200\n    \n    data = response.json()\n    assert data[\"message\"] == \"Hello World\"\n    assert data[\"status\"] == \"success\"\n    assert \"timestamp\" in data\n\ndef test_hello_endpoint_timestamp_format():\n    \"\"\"Test timestamp format is ISO 8601.\"\"\"\n    response = client.get(\"/hello\")\n    data = response.json()\n    \n    # Verify timestamp ends with 'Z' (UTC)\n    assert data[\"timestamp\"].endswith(\"Z\")\n    \n    # Verify timestamp can be parsed\n    from datetime import datetime\n    datetime.fromisoformat(data[\"timestamp\"].replace(\"Z\", \"+00:00\"))\n```\n\n## Integration\n\n### Client Libraries\n\nThe API can be consumed by any HTTP client library:\n\n**Python:**\n- `requests`\n- `httpx`\n- `urllib`\n\n**JavaScript:**\n- `fetch` (native)\n- `axios`\n- `node-fetch`\n\n**Java:**\n- `HttpClient`\n- `OkHttp`\n- `RestTemplate`\n\n### Response Parsing\n\nExample response parsing in different languages:\n\n**Python:**\n```python\nimport requests\nresponse = requests.get(\"http://localhost:8000/hello\")\ndata = response.json()\nmessage = data[\"message\"]\ntimestamp = data[\"timestamp\"]\n```\n\n**JavaScript:**\n```javascript\nconst response = await fetch(\"http://localhost:8000/hello\");\nconst data = await response.json();\nconst message = data.message;\nconst timestamp = data.timestamp;\n```\n\n**Java:**\n```java\n// Using Jackson ObjectMapper\nObjectMapper mapper = new ObjectMapper();\nJsonNode data = mapper.readTree(responseBody);\nString message = data.get(\"message\").asText();\nString timestamp = data.get(\"timestamp\").asText();\n```\n\n## Monitoring\n\n### Health Checks\n\nUse the `/hello`",
      "file_type": "documentation",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Detailed API documentation with endpoint descriptions, request/response examples, and authentication requirements"
    },
    {
      "file_path": "docker-compose.yml",
      "content": "version: '3.8'\n\nservices:\n  # PostgreSQL Database Service\n  postgres:\n    image: postgres:15-alpine\n    container_name: hello_world_postgres\n    environment:\n      POSTGRES_DB: hello_world_db\n      POSTGRES_USER: hello_user\n      POSTGRES_PASSWORD: hello_password\n      POSTGRES_HOST_AUTH_METHOD: trust\n    ports:\n      - \"5432:5432\"\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n      - ./init.sql:/docker-entrypoint-initdb.d/init.sql\n    networks:\n      - hello_world_network\n    healthcheck:\n      test: [\"CMD-SHELL\", \"pg_isready -U hello_user -d hello_world_db\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n      start_period: 30s\n\n  # Hello World API Application Service\n  app:\n    build:\n      context: .\n      dockerfile: Dockerfile\n    container_name: hello_world_app\n    environment:\n      - DATABASE_URL=postgresql://hello_user:hello_password@postgres:5432/hello_world_db\n      - ENVIRONMENT=development\n      - LOG_LEVEL=INFO\n      - HOST=0.0.0.0\n      - PORT=8000\n    ports:\n      - \"8000:8000\"\n    volumes:\n      - .:/app\n      - /app/__pycache__\n    networks:\n      - hello_world_network\n    depends_on:\n      postgres:\n        condition: service_healthy\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:8000/health\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n      start_period: 40s\n    restart: unless-stopped\n    command: uvicorn main:app --host 0.0.0.0 --port 8000 --reload\n\n  # Redis Cache Service (for future caching needs)\n  redis:\n    image: redis:7-alpine\n    container_name: hello_world_redis\n    ports:\n      - \"6379:6379\"\n    volumes:\n      - redis_data:/data\n    networks:\n      - hello_world_network\n    healthcheck:\n      test: [\"CMD\", \"redis-cli\", \"ping\"]\n      interval: 10s\n      timeout: 5s\n      retries: 3\n    restart: unless-stopped\n\n# Named volumes for data persistence\nvolumes:\n  postgres_data:\n    driver: local\n  redis_data:\n    driver: local\n\n# Custom network for service communication\nnetworks:\n  hello_world_network:\n    driver: bridge\n    ipam:\n      config:\n        - subnet: 172.20.0.0/16",
      "file_type": "config",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Docker Compose configuration for local development with PostgreSQL database and application services"
    },
    {
      "file_path": "Dockerfile",
      "content": "# Use Python 3.12 slim image as base\nFROM python:3.12-slim as base\n\n# Set environment variables\nENV PYTHONDONTWRITEBYTECODE=1 \\\n    PYTHONUNBUFFERED=1 \\\n    PYTHONPATH=/app \\\n    PIP_NO_CACHE_DIR=1 \\\n    PIP_DISABLE_PIP_VERSION_CHECK=1\n\n# Create non-root user for security\nRUN groupadd -r appuser && useradd -r -g appuser appuser\n\n# Set working directory\nWORKDIR /app\n\n# Install system dependencies\nRUN apt-get update && apt-get install -y --no-install-recommends \\\n    curl \\\n    && rm -rf /var/lib/apt/lists/*\n\n# Copy requirements first for better caching\nCOPY requirements.txt .\n\n# Install Python dependencies\nRUN pip install --no-cache-dir -r requirements.txt\n\n# Copy application code\nCOPY . .\n\n# Change ownership to non-root user\nRUN chown -R appuser:appuser /app\n\n# Switch to non-root user\nUSER appuser\n\n# Expose port\nEXPOSE 8000\n\n# Health check\nHEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \\\n    CMD curl -f http://localhost:8000/health || exit 1\n\n# Run the application\nCMD [\"uvicorn\", \"main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]",
      "file_type": "config",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Docker configuration for containerizing the FastAPI application with multi-stage build optimization"
    }
  ],
  "file_structure": {
    "src": [
      "main.py"
    ],
    "src/api": [
      "auth.py",
      "tasks.py"
    ],
    "src/models": [
      "user.py",
      "task.py"
    ],
    "src/schemas": [
      "user.py",
      "task.py"
    ],
    "src/utils": [
      "jwt_utils.py",
      "password.py"
    ],
    "src/database": [
      "connection.py"
    ],
    "src/database/migrations": [
      "001_initial_schema.py"
    ],
    "src/middleware": [
      "auth.py"
    ],
    "tests": [
      "test_auth_api.py",
      "test_tasks_api.py",
      "test_user_model.py",
      "test_task_model.py",
      "test_jwt_utils.py",
      "test_password.py",
      "test_middleware_auth.py",
      "conftest.py"
    ],
    ".": [
      "requirements.txt",
      "requirements-dev.txt",
      ".env.example",
      "alembic.ini",
      "pytest.ini",
      ".pylintrc",
      ".gitignore",
      "README.md",
      "docker-compose.yml",
      "Dockerfile"
    ],
    "docs": [
      "api_documentation.md"
    ]
  },
  "implementation_notes": "Generated using multi-stage approach with 31 files. Manifest estimated 4605 LOC, actual 4639 LOC. Uses 16 external dependencies.",
  "dependencies": [
    "fastapi==0.104.1",
    "uvicorn[standard]==0.24.0",
    "python-jose[cryptography]==3.3.0",
    "bcrypt==4.1.1",
    "pydantic==2.5.0",
    "sqlalchemy==2.0.23",
    "alembic==1.13.0",
    "psycopg2-binary==2.9.9",
    "python-multipart==0.0.6",
    "pytest==7.4.3",
    "pytest-asyncio==0.21.1",
    "httpx==0.25.2",
    "pytest-cov==4.1.0",
    "black==23.11.0",
    "pylint==3.0.3",
    "python-dotenv==1.0.0"
  ],
  "setup_instructions": "1. Install Python 3.11+\\n2. pip install -r requirements.txt\\n3. Copy .env.example to .env and configure variables\\n4. Start PostgreSQL (or use docker-compose up -d db)\\n5. Run migrations: alembic upgrade head\\n6. Start server: uvicorn src.main:app --reload\\n7. Run tests: pytest tests/ -v --cov=src\\n8. Access API docs at http://localhost:8000/docs",
  "total_lines_of_code": 4639,
  "total_files": 31,
  "test_coverage_target": 80.0,
  "semantic_units_implemented": [
    "SU-007",
    "SU-006",
    "SU-005",
    "SU-003",
    "SU-002",
    "SU-001",
    "SU-010",
    "SU-009",
    "SU-008",
    "SU-004",
    "SU-011",
    "SU-012"
  ],
  "components_implemented": [
    "COMP-011",
    "COMP-005",
    "COMP-003",
    "COMP-004",
    "COMP-010",
    "COMP-012",
    "COMP-002",
    "COMP-007",
    "COMP-008",
    "COMP-001",
    "COMP-009",
    "COMP-006"
  ],
  "agent_version": "1.0.0",
  "generation_timestamp": "2025-11-20T23:55:11.800653"
}