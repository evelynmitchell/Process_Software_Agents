{
  "task_id": "TASK-001",
  "api_contracts": [
    {
      "endpoint": "/api/auth/register",
      "method": "POST",
      "description": "Registers a new user account with email and password. Validates email format and password strength requirements (minimum 8 characters, at least one uppercase, one lowercase, one number, one special character). Returns JWT token upon successful registration.",
      "request_schema": {
        "email": "string (valid email format, max 255 characters, unique)",
        "password": "string (min 8 chars, max 128 chars, must contain uppercase, lowercase, number, special character)",
        "name": "string (min 2 chars, max 100 chars, alphanumeric and spaces only)"
      },
      "request_params": null,
      "response_schema": {
        "user": {
          "id": "string (UUID v4)",
          "email": "string",
          "name": "string",
          "createdAt": "string (ISO 8601 timestamp)"
        },
        "token": "string (JWT token, expires in 24 hours)"
      },
      "error_responses": [
        {
          "status": 400,
          "code": "INVALID_EMAIL_FORMAT",
          "message": "Email address format is invalid. Must be valid email format."
        },
        {
          "status": 400,
          "code": "WEAK_PASSWORD",
          "message": "Password does not meet security requirements. Must be at least 8 characters with uppercase, lowercase, number, and special character."
        },
        {
          "status": 400,
          "code": "INVALID_NAME",
          "message": "Name contains invalid characters or does not meet length requirements."
        },
        {
          "status": 409,
          "code": "EMAIL_ALREADY_EXISTS",
          "message": "An account with this email address already exists."
        },
        {
          "status": 500,
          "code": "INTERNAL_SERVER_ERROR",
          "message": "An unexpected error occurred during registration."
        }
      ],
      "authentication_required": false,
      "rate_limit": null
    },
    {
      "endpoint": "/api/auth/login",
      "method": "POST",
      "description": "Authenticates user with email and password credentials. Returns JWT token valid for 24 hours upon successful authentication. Implements rate limiting to prevent brute force attacks.",
      "request_schema": {
        "email": "string (valid email format)",
        "password": "string"
      },
      "request_params": null,
      "response_schema": {
        "user": {
          "id": "string (UUID v4)",
          "email": "string",
          "name": "string"
        },
        "token": "string (JWT token, expires in 24 hours)"
      },
      "error_responses": [
        {
          "status": 400,
          "code": "MISSING_CREDENTIALS",
          "message": "Email and password are required."
        },
        {
          "status": 401,
          "code": "INVALID_CREDENTIALS",
          "message": "Email or password is incorrect."
        },
        {
          "status": 429,
          "code": "TOO_MANY_ATTEMPTS",
          "message": "Too many failed login attempts. Please try again later."
        },
        {
          "status": 500,
          "code": "INTERNAL_SERVER_ERROR",
          "message": "An unexpected error occurred during authentication."
        }
      ],
      "authentication_required": false,
      "rate_limit": null
    },
    {
      "endpoint": "/api/tasks",
      "method": "GET",
      "description": "Retrieves a paginated list of tasks for the authenticated user. Supports filtering by status, priority, and due date range. Supports sorting by createdAt, updatedAt, dueDate, and priority fields.",
      "request_schema": null,
      "request_params": {
        "page": "number (optional, default 1, min 1)",
        "limit": "number (optional, default 20, min 1, max 100)",
        "status": "string (optional, enum: TODO, IN_PROGRESS, DONE)",
        "priority": "string (optional, enum: LOW, MEDIUM, HIGH)",
        "dueDateFrom": "string (optional, ISO 8601 date)",
        "dueDateTo": "string (optional, ISO 8601 date)",
        "sortBy": "string (optional, enum: createdAt, updatedAt, dueDate, priority, default: createdAt)",
        "sortOrder": "string (optional, enum: asc, desc, default: desc)"
      },
      "response_schema": {
        "tasks": [
          {
            "id": "string (UUID v4)",
            "title": "string",
            "description": "string (nullable)",
            "status": "string (enum: TODO, IN_PROGRESS, DONE)",
            "priority": "string (enum: LOW, MEDIUM, HIGH)",
            "dueDate": "string (ISO 8601 date, nullable)",
            "createdAt": "string (ISO 8601 timestamp)",
            "updatedAt": "string (ISO 8601 timestamp)",
            "version": "number (optimistic locking version)"
          }
        ],
        "pagination": {
          "page": "number",
          "limit": "number",
          "total": "number (total count of tasks matching filters)",
          "totalPages": "number"
        }
      },
      "error_responses": [
        {
          "status": 400,
          "code": "INVALID_PAGINATION",
          "message": "Page or limit parameters are invalid."
        },
        {
          "status": 400,
          "code": "INVALID_FILTER",
          "message": "Filter parameters contain invalid values."
        },
        {
          "status": 400,
          "code": "INVALID_DATE_RANGE",
          "message": "dueDateFrom must be before dueDateTo."
        },
        {
          "status": 401,
          "code": "UNAUTHORIZED",
          "message": "Authentication token is missing or invalid."
        },
        {
          "status": 500,
          "code": "INTERNAL_SERVER_ERROR",
          "message": "An unexpected error occurred while retrieving tasks."
        }
      ],
      "authentication_required": true,
      "rate_limit": null
    },
    {
      "endpoint": "/api/tasks/:id",
      "method": "GET",
      "description": "Retrieves a single task by ID for the authenticated user. Returns 404 if task does not exist or does not belong to the authenticated user.",
      "request_schema": null,
      "request_params": {
        "id": "string (UUID v4 format, path parameter)"
      },
      "response_schema": {
        "id": "string (UUID v4)",
        "title": "string",
        "description": "string (nullable)",
        "status": "string (enum: TODO, IN_PROGRESS, DONE)",
        "priority": "string (enum: LOW, MEDIUM, HIGH)",
        "dueDate": "string (ISO 8601 date, nullable)",
        "createdAt": "string (ISO 8601 timestamp)",
        "updatedAt": "string (ISO 8601 timestamp)",
        "version": "number (optimistic locking version)",
        "userId": "string (UUID v4)"
      },
      "error_responses": [
        {
          "status": 400,
          "code": "INVALID_TASK_ID",
          "message": "Task ID format is invalid. Must be valid UUID v4."
        },
        {
          "status": 401,
          "code": "UNAUTHORIZED",
          "message": "Authentication token is missing or invalid."
        },
        {
          "status": 404,
          "code": "TASK_NOT_FOUND",
          "message": "Task with specified ID does not exist or does not belong to user."
        },
        {
          "status": 500,
          "code": "INTERNAL_SERVER_ERROR",
          "message": "An unexpected error occurred while retrieving task."
        }
      ],
      "authentication_required": true,
      "rate_limit": null
    },
    {
      "endpoint": "/api/tasks",
      "method": "POST",
      "description": "Creates a new task for the authenticated user. Title is required, all other fields are optional. Status defaults to TODO, priority defaults to MEDIUM if not specified.",
      "request_schema": {
        "title": "string (required, min 1 char, max 200 chars)",
        "description": "string (optional, max 2000 chars)",
        "status": "string (optional, enum: TODO, IN_PROGRESS, DONE, default: TODO)",
        "priority": "string (optional, enum: LOW, MEDIUM, HIGH, default: MEDIUM)",
        "dueDate": "string (optional, ISO 8601 date, must be future date)"
      },
      "request_params": null,
      "response_schema": {
        "id": "string (UUID v4)",
        "title": "string",
        "description": "string (nullable)",
        "status": "string (enum: TODO, IN_PROGRESS, DONE)",
        "priority": "string (enum: LOW, MEDIUM, HIGH)",
        "dueDate": "string (ISO 8601 date, nullable)",
        "createdAt": "string (ISO 8601 timestamp)",
        "updatedAt": "string (ISO 8601 timestamp)",
        "version": "number (initial value: 1)",
        "userId": "string (UUID v4)"
      },
      "error_responses": [
        {
          "status": 400,
          "code": "MISSING_TITLE",
          "message": "Task title is required."
        },
        {
          "status": 400,
          "code": "TITLE_TOO_LONG",
          "message": "Task title exceeds maximum length of 200 characters."
        },
        {
          "status": 400,
          "code": "DESCRIPTION_TOO_LONG",
          "message": "Task description exceeds maximum length of 2000 characters."
        },
        {
          "status": 400,
          "code": "INVALID_STATUS",
          "message": "Status value is not valid. Must be TODO, IN_PROGRESS, or DONE."
        },
        {
          "status": 400,
          "code": "INVALID_PRIORITY",
          "message": "Priority value is not valid. Must be LOW, MEDIUM, or HIGH."
        },
        {
          "status": 400,
          "code": "INVALID_DUE_DATE",
          "message": "Due date must be a valid ISO 8601 date in the future."
        },
        {
          "status": 401,
          "code": "UNAUTHORIZED",
          "message": "Authentication token is missing or invalid."
        },
        {
          "status": 500,
          "code": "INTERNAL_SERVER_ERROR",
          "message": "An unexpected error occurred while creating task."
        }
      ],
      "authentication_required": true,
      "rate_limit": null
    },
    {
      "endpoint": "/api/tasks/:id",
      "method": "PUT",
      "description": "Updates an existing task for the authenticated user. Supports partial updates - only provided fields are updated. Implements optimistic locking using version field to prevent concurrent update conflicts.",
      "request_schema": {
        "title": "string (optional, min 1 char, max 200 chars)",
        "description": "string (optional, max 2000 chars, null to clear)",
        "status": "string (optional, enum: TODO, IN_PROGRESS, DONE)",
        "priority": "string (optional, enum: LOW, MEDIUM, HIGH)",
        "dueDate": "string (optional, ISO 8601 date, null to clear)",
        "version": "number (required for optimistic locking)"
      },
      "request_params": {
        "id": "string (UUID v4 format, path parameter)"
      },
      "response_schema": {
        "id": "string (UUID v4)",
        "title": "string",
        "description": "string (nullable)",
        "status": "string (enum: TODO, IN_PROGRESS, DONE)",
        "priority": "string (enum: LOW, MEDIUM, HIGH)",
        "dueDate": "string (ISO 8601 date, nullable)",
        "createdAt": "string (ISO 8601 timestamp)",
        "updatedAt": "string (ISO 8601 timestamp, updated to current time)",
        "version": "number (incremented by 1)",
        "userId": "string (UUID v4)"
      },
      "error_responses": [
        {
          "status": 400,
          "code": "INVALID_TASK_ID",
          "message": "Task ID format is invalid. Must be valid UUID v4."
        },
        {
          "status": 400,
          "code": "MISSING_VERSION",
          "message": "Version field is required for optimistic locking."
        },
        {
          "status": 400,
          "code": "TITLE_TOO_LONG",
          "message": "Task title exceeds maximum length of 200 characters."
        },
        {
          "status": 400,
          "code": "DESCRIPTION_TOO_LONG",
          "message": "Task description exceeds maximum length of 2000 characters."
        },
        {
          "status": 400,
          "code": "INVALID_STATUS",
          "message": "Status value is not valid. Must be TODO, IN_PROGRESS, or DONE."
        },
        {
          "status": 400,
          "code": "INVALID_PRIORITY",
          "message": "Priority value is not valid. Must be LOW, MEDIUM, or HIGH."
        },
        {
          "status": 400,
          "code": "INVALID_DUE_DATE",
          "message": "Due date must be a valid ISO 8601 date."
        },
        {
          "status": 401,
          "code": "UNAUTHORIZED",
          "message": "Authentication token is missing or invalid."
        },
        {
          "status": 404,
          "code": "TASK_NOT_FOUND",
          "message": "Task with specified ID does not exist or does not belong to user."
        },
        {
          "status": 409,
          "code": "VERSION_CONFLICT",
          "message": "Task has been modified by another request. Please refresh and try again."
        },
        {
          "status": 500,
          "code": "INTERNAL_SERVER_ERROR",
          "message": "An unexpected error occurred while updating task."
        }
      ],
      "authentication_required": true,
      "rate_limit": null
    },
    {
      "endpoint": "/api/tasks/:id",
      "method": "DELETE",
      "description": "Deletes a task by ID for the authenticated user. This is a hard delete operation. Returns 204 No Content on success.",
      "request_schema": null,
      "request_params": {
        "id": "string (UUID v4 format, path parameter)"
      },
      "response_schema": {},
      "error_responses": [
        {
          "status": 400,
          "code": "INVALID_TASK_ID",
          "message": "Task ID format is invalid. Must be valid UUID v4."
        },
        {
          "status": 401,
          "code": "UNAUTHORIZED",
          "message": "Authentication token is missing or invalid."
        },
        {
          "status": 404,
          "code": "TASK_NOT_FOUND",
          "message": "Task with specified ID does not exist or does not belong to user."
        },
        {
          "status": 500,
          "code": "INTERNAL_SERVER_ERROR",
          "message": "An unexpected error occurred while deleting task."
        }
      ],
      "authentication_required": true,
      "rate_limit": null
    },
    {
      "endpoint": "/api/health",
      "method": "GET",
      "description": "Health check endpoint to verify API service is running and database connection is healthy. Does not require authentication. Returns service status and current timestamp.",
      "request_schema": null,
      "request_params": null,
      "response_schema": {
        "status": "string (value: healthy)",
        "timestamp": "string (ISO 8601 timestamp)",
        "database": "string (value: connected or disconnected)"
      },
      "error_responses": [
        {
          "status": 503,
          "code": "SERVICE_UNAVAILABLE",
          "message": "Service is unhealthy. Database connection failed."
        }
      ],
      "authentication_required": false,
      "rate_limit": null
    }
  ],
  "data_schemas": [
    {
      "table_name": "users",
      "description": "Stores user account information including authentication credentials and profile data.",
      "columns": [
        {
          "name": "id",
          "type": "UUID",
          "constraints": "PRIMARY KEY, DEFAULT gen_random_uuid()"
        },
        {
          "name": "email",
          "type": "VARCHAR(255)",
          "constraints": "NOT NULL, UNIQUE"
        },
        {
          "name": "password_hash",
          "type": "VARCHAR(255)",
          "constraints": "NOT NULL"
        },
        {
          "name": "name",
          "type": "VARCHAR(100)",
          "constraints": "NOT NULL"
        },
        {
          "name": "created_at",
          "type": "TIMESTAMP WITH TIME ZONE",
          "constraints": "NOT NULL, DEFAULT CURRENT_TIMESTAMP"
        },
        {
          "name": "updated_at",
          "type": "TIMESTAMP WITH TIME ZONE",
          "constraints": "NOT NULL, DEFAULT CURRENT_TIMESTAMP"
        }
      ],
      "indexes": [
        "CREATE UNIQUE INDEX idx_users_email ON users(email);",
        "CREATE INDEX idx_users_created_at ON users(created_at DESC);"
      ],
      "relationships": [],
      "constraints": [
        "CHECK (char_length(email) >= 3 AND char_length(email) <= 255);",
        "CHECK (char_length(name) >= 2 AND char_length(name) <= 100);"
      ]
    },
    {
      "table_name": "tasks",
      "description": "Stores task information including title, description, status, priority, and due date. Each task belongs to a single user.",
      "columns": [
        {
          "name": "id",
          "type": "UUID",
          "constraints": "PRIMARY KEY, DEFAULT gen_random_uuid()"
        },
        {
          "name": "user_id",
          "type": "UUID",
          "constraints": "NOT NULL, FOREIGN KEY REFERENCES users(id)"
        },
        {
          "name": "title",
          "type": "VARCHAR(200)",
          "constraints": "NOT NULL"
        },
        {
          "name": "description",
          "type": "TEXT",
          "constraints": "NULL"
        },
        {
          "name": "status",
          "type": "VARCHAR(20)",
          "constraints": "NOT NULL, DEFAULT 'TODO'"
        },
        {
          "name": "priority",
          "type": "VARCHAR(20)",
          "constraints": "NOT NULL, DEFAULT 'MEDIUM'"
        },
        {
          "name": "due_date",
          "type": "DATE",
          "constraints": "NULL"
        },
        {
          "name": "version",
          "type": "INTEGER",
          "constraints": "NOT NULL, DEFAULT 1"
        },
        {
          "name": "created_at",
          "type": "TIMESTAMP WITH TIME ZONE",
          "constraints": "NOT NULL, DEFAULT CURRENT_TIMESTAMP"
        },
        {
          "name": "updated_at",
          "type": "TIMESTAMP WITH TIME ZONE",
          "constraints": "NOT NULL, DEFAULT CURRENT_TIMESTAMP"
        }
      ],
      "indexes": [
        "CREATE INDEX idx_tasks_user_id ON tasks(user_id);",
        "CREATE INDEX idx_tasks_status ON tasks(status);",
        "CREATE INDEX idx_tasks_priority ON tasks(priority);",
        "CREATE INDEX idx_tasks_due_date ON tasks(due_date) WHERE due_date IS NOT NULL;",
        "CREATE INDEX idx_tasks_created_at ON tasks(created_at DESC);",
        "CREATE INDEX idx_tasks_updated_at ON tasks(updated_at DESC);",
        "CREATE INDEX idx_tasks_user_status ON tasks(user_id, status);"
      ],
      "relationships": [
        "ALTER TABLE tasks ADD FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE;"
      ],
      "constraints": [
        "CHECK (char_length(title) >= 1 AND char_length(title) <= 200);",
        "CHECK (char_length(description) <= 2000);",
        "CHECK (status IN ('TODO', 'IN_PROGRESS', 'DONE'));",
        "CHECK (priority IN ('LOW', 'MEDIUM', 'HIGH'));",
        "CHECK (version >= 1);"
      ]
    },
    {
      "table_name": "audit_logs",
      "description": "Stores audit trail of task operations for compliance and debugging purposes. Records all create, update, and delete operations.",
      "columns": [
        {
          "name": "id",
          "type": "UUID",
          "constraints": "PRIMARY KEY, DEFAULT gen_random_uuid()"
        },
        {
          "name": "task_id",
          "type": "UUID",
          "constraints": "NOT NULL"
        },
        {
          "name": "user_id",
          "type": "UUID",
          "constraints": "NOT NULL, FOREIGN KEY REFERENCES users(id)"
        },
        {
          "name": "operation",
          "type": "VARCHAR(20)",
          "constraints": "NOT NULL"
        },
        {
          "name": "old_data",
          "type": "JSONB",
          "constraints": "NULL"
        },
        {
          "name": "new_data",
          "type": "JSONB",
          "constraints": "NULL"
        },
        {
          "name": "created_at",
          "type": "TIMESTAMP WITH TIME ZONE",
          "constraints": "NOT NULL, DEFAULT CURRENT_TIMESTAMP"
        }
      ],
      "indexes": [
        "CREATE INDEX idx_audit_logs_task_id ON audit_logs(task_id);",
        "CREATE INDEX idx_audit_logs_user_id ON audit_logs(user_id);",
        "CREATE INDEX idx_audit_logs_created_at ON audit_logs(created_at DESC);",
        "CREATE INDEX idx_audit_logs_operation ON audit_logs(operation);"
      ],
      "relationships": [
        "ALTER TABLE audit_logs ADD FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE;"
      ],
      "constraints": [
        "CHECK (operation IN ('CREATE', 'UPDATE', 'DELETE'));"
      ]
    }
  ],
  "component_logic": [
    {
      "component_name": "AuthenticationService",
      "semantic_unit_id": "SU-001",
      "responsibility": "Handles user registration, login, password hashing, and JWT token generation/validation. Enforces password strength requirements and email uniqueness.",
      "interfaces": [
        {
          "method": "register",
          "parameters": {
            "email": "string",
            "password": "string",
            "name": "string"
          },
          "returns": "Promise<{user: User, token: string}>",
          "description": "Registers a new user account with email, password, and name. Validates input, hashes password with bcrypt, creates user record, and generates JWT token."
        },
        {
          "method": "login",
          "parameters": {
            "email": "string",
            "password": "string"
          },
          "returns": "Promise<{user: User, token: string}>",
          "description": "Authenticates user with email and password credentials. Verifies password hash and generates JWT token on success."
        },
        {
          "method": "hashPassword",
          "parameters": {
            "password": "string"
          },
          "returns": "Promise<string>",
          "description": "Hashes password using bcrypt with cost factor 12."
        },
        {
          "method": "verifyPassword",
          "parameters": {
            "password": "string",
            "hash": "string"
          },
          "returns": "Promise<boolean>",
          "description": "Verifies plain text password against bcrypt hash."
        },
        {
          "method": "generateToken",
          "parameters": {
            "userId": "string",
            "email": "string"
          },
          "returns": "string",
          "description": "Generates JWT token with user ID and email payload. Token expires in 24 hours."
        },
        {
          "method": "verifyToken",
          "parameters": {
            "token": "string"
          },
          "returns": "{userId: string, email: string}",
          "description": "Verifies and decodes JWT token. Throws error if token is invalid or expired."
        }
      ],
      "dependencies": [
        "UserRepository",
        "bcrypt library",
        "jsonwebtoken library"
      ],
      "implementation_notes": "Use bcrypt.hash() with cost factor 12 for password hashing. Never store plain text passwords. Use bcrypt.compare() for password verification with constant-time comparison. Generate JWT tokens using jsonwebtoken.sign() with HS256 algorithm. Include userId and email in token payload. Set token expiration to 24 hours (expiresIn: '24h'). Store JWT secret in environment variable JWT_SECRET (minimum 32 characters). Verify tokens using jsonwebtoken.verify() and handle TokenExpiredError and JsonWebTokenError exceptions. Validate email format using regex: /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/. Validate password strength: minimum 8 characters, at least one uppercase letter, one lowercase letter, one number, one special character (!@#$%^&*). Validate name: 2-100 characters, alphanumeric and spaces only. Check email uniqueness before creating user. Throw appropriate errors with specific error codes for validation failures. Hash passwords asynchronously to avoid blocking event loop.",
      "complexity": 45
    },
    {
      "component_name": "TaskService",
      "semantic_unit_id": "SU-002",
      "responsibility": "Implements core task management business logic including CRUD operations, filtering, sorting, pagination, and status transition validation. Enforces business rules and data integrity.",
      "interfaces": [
        {
          "method": "createTask",
          "parameters": {
            "userId": "string",
            "data": "CreateTaskDTO"
          },
          "returns": "Promise<Task>",
          "description": "Creates a new task for the specified user with provided data. Validates input and sets default values for optional fields."
        },
        {
          "method": "getTaskById",
          "parameters": {
            "userId": "string",
            "taskId": "string"
          },
          "returns": "Promise<Task>",
          "description": "Retrieves a single task by ID. Verifies task belongs to specified user."
        },
        {
          "method": "getTasks",
          "parameters": {
            "userId": "string",
            "filters": "TaskFilters",
            "pagination": "PaginationParams"
          },
          "returns": "Promise<{tasks: Task[], pagination: PaginationMeta}>",
          "description": "Retrieves paginated list of tasks for user with optional filtering and sorting."
        },
        {
          "method": "updateTask",
          "parameters": {
            "userId": "string",
            "taskId": "string",
            "data": "UpdateTaskDTO"
          },
          "returns": "Promise<Task>",
          "description": "Updates existing task with provided data. Implements optimistic locking using version field."
        },
        {
          "method": "deleteTask",
          "parameters": {
            "userId": "string",
            "taskId": "string"
          },
          "returns": "Promise<void>",
          "description": "Deletes task by ID. Verifies task belongs to specified user."
        },
        {
          "method": "validateTaskData",
          "parameters": {
            "data": "Partial<Task>"
          },
          "returns": "void",
          "description": "Validates task data against business rules and constraints."
        }
      ],
      "dependencies": [
        "TaskRepository",
        "AuditLogRepository"
      ],
      "implementation_notes": "Use Zod schemas for input validation. Define CreateTaskDTO with required title field and optional description, status, priority, dueDate fields. Define UpdateTaskDTO with all optional fields plus required version field. Validate title length: 1-200 characters. Validate description length: max 2000 characters. Validate status enum: TODO, IN_PROGRESS, DONE. Validate priority enum: LOW, MEDIUM, HIGH. Validate dueDate is valid ISO 8601 date and future date for creation. Set default status to TODO if not provided. Set default priority to MEDIUM if not provided. For getTasks, build dynamic WHERE clause based on filters. Support filtering by status (exact match), priority (exact match), dueDateFrom (>=), dueDateTo (<=). Support sorting by createdAt, updatedAt, dueDate, priority with asc/desc order. Implement pagination with offset/limit. Calculate totalPages as Math.ceil(total / limit). For updateTask, implement optimistic locking by checking version field matches database version before update. Increment version by 1 on successful update. Throw VERSION_CONFLICT error if version mismatch. For all operations, verify userId matches task.userId to enforce ownership. Create audit log entries for all create, update, delete operations with old and new data. Use database transactions for update and delete operations to ensure atomicity with audit logs. Throw TASK_NOT_FOUND error if task doesn't exist or doesn't belong to user. Sanitize input to prevent SQL injection (use parameterized queries via Prisma).",
      "complexity": 67
    },
    {
      "component_name": "AuthenticationMiddleware",
      "semantic_unit_id": "SU-003",
      "responsibility": "Express middleware that validates JWT tokens from Authorization header and attaches authenticated user information to request object. Protects routes requiring authentication.",
      "interfaces": [
        {
          "method": "authenticate",
          "parameters": {
            "req": "Request",
            "res": "Response",
            "next": "NextFunction"
          },
          "returns": "Promise<void>",
          "description": "Middleware function that extracts and validates JWT token from Authorization header. Attaches user information to request object on success."
        },
        {
          "method": "extractToken",
          "parameters": {
            "authHeader": "string"
          },
          "returns": "string | null",
          "description": "Extracts JWT token from Authorization header with Bearer scheme."
        }
      ],
      "dependencies": [
        "AuthenticationService"
      ],
      "implementation_notes": "Extract Authorization header from request using req.headers.authorization. Validate header format is 'Bearer <token>'. Extract token by splitting on space and taking second element. Call AuthenticationService.verifyToken() to validate and decode token. On success, attach decoded user information to req.user object with userId and email fields. Call next() to proceed to next middleware/route handler. On failure (missing header, invalid format, invalid token, expired token), return 401 UNAUTHORIZED error with appropriate error code. Use try-catch to handle token verification errors. For TokenExpiredError, return error code TOKEN_EXPIRED. For JsonWebTokenError, return error code INVALID_TOKEN. For missing Authorization header, return error code MISSING_TOKEN. Do not expose token verification details in error messages. Log authentication failures with Winston logger for security monitoring.",
      "complexity": 28
    },
    {
      "component_name": "TaskController",
      "semantic_unit_id": "SU-004",
      "responsibility": "Express route handlers for task-related endpoints. Handles HTTP request/response processing, input validation, and delegates business logic to TaskService.",
      "interfaces": [
        {
          "method": "createTask",
          "parameters": {
            "req": "Request",
            "res": "Response",
            "next": "NextFunction"
          },
          "returns": "Promise<void>",
          "description": "Handles POST /api/tasks endpoint. Validates request body and creates new task."
        },
        {
          "method": "getTaskById",
          "parameters": {
            "req": "Request",
            "res": "Response",
            "next": "NextFunction"
          },
          "returns": "Promise<void>",
          "description": "Handles GET /api/tasks/:id endpoint. Retrieves single task by ID."
        },
        {
          "method": "getTasks",
          "parameters": {
            "req": "Request",
            "res": "Response",
            "next": "NextFunction"
          },
          "returns": "Promise<void>",
          "description": "Handles GET /api/tasks endpoint. Retrieves paginated list of tasks with filters."
        },
        {
          "method": "updateTask",
          "parameters": {
            "req": "Request",
            "res": "Response",
            "next": "NextFunction"
          },
          "returns": "Promise<void>",
          "description": "Handles PUT /api/tasks/:id endpoint. Updates existing task."
        },
        {
          "method": "deleteTask",
          "parameters": {
            "req": "Request",
            "res": "Response",
            "next": "NextFunction"
          },
          "returns": "Promise<void>",
          "description": "Handles DELETE /api/tasks/:id endpoint. Deletes task by ID."
        }
      ],
      "dependencies": [
        "TaskService",
        "Zod validation schemas"
      ],
      "implementation_notes": "Use Zod schemas to validate request body and query parameters. Define schemas for CreateTaskDTO, UpdateTaskDTO, TaskFilters, and PaginationParams. Parse and validate request data using schema.parse() which throws ZodError on validation failure. Extract authenticated user ID from req.user.userId (set by AuthenticationMiddleware). Extract task ID from req.params.id and validate UUID format. For createTask, validate request body against CreateTaskDTO schema, call TaskService.createTask(), return 201 Created with task object. For getTaskById, validate task ID format, call TaskService.getTaskById(), return 200 OK with task object. For getTasks, parse and validate query parameters (page, limit, status, priority, dueDateFrom, dueDateTo, sortBy, sortOrder), call TaskService.getTasks(), return 200 OK with tasks array and pagination metadata. For updateTask, validate task ID and request body against UpdateTaskDTO schema, call TaskService.updateTask(), return 200 OK with updated task object. For deleteTask, validate task ID, call TaskService.deleteTask(), return 204 No Content with empty body. Wrap all async operations in try-catch and call next(error) to pass errors to error handling middleware. Do not handle errors directly in controllers - delegate to centralized error handler. Use Winston logger to log all requests with method, path, userId, and response status.",
      "complexity": 52
    },
    {
      "component_name": "AuthController",
      "semantic_unit_id": "SU-005",
      "responsibility": "Express route handlers for authentication endpoints. Handles user registration and login requests, validates input, and delegates to AuthenticationService.",
      "interfaces": [
        {
          "method": "register",
          "parameters": {
            "req": "Request",
            "res": "Response",
            "next": "NextFunction"
          },
          "returns": "Promise<void>",
          "description": "Handles POST /api/auth/register endpoint. Validates registration data and creates new user account."
        },
        {
          "method": "login",
          "parameters": {
            "req": "Request",
            "res": "Response",
            "next": "NextFunction"
          },
          "returns": "Promise<void>",
          "description": "Handles POST /api/auth/login endpoint. Validates credentials and authenticates user."
        }
      ],
      "dependencies": [
        "AuthenticationService",
        "Zod validation schemas"
      ],
      "implementation_notes": "Use Zod schemas to validate request body. Define RegisterDTO schema with email (string, email format, max 255 chars), password (string, min 8 chars, max 128 chars, regex for strength), name (string, min 2 chars, max 100 chars, alphanumeric and spaces). Define LoginDTO schema with email (string, email format) and password (string). For register endpoint, parse and validate request body against RegisterDTO schema, call AuthenticationService.register(), return 201 Created with user object (excluding password_hash) and JWT token. For login endpoint, parse and validate request body against LoginDTO schema, call AuthenticationService.login(), return 200 OK with user object (excluding password_hash) and JWT token. Wrap all async operations in try-catch and call next(error) to pass errors to error handling middleware. Never include password_hash in response objects - explicitly exclude it when serializing user data. Use Winston logger to log authentication events (registration, login success/failure) with email and timestamp for security auditing. Do not log passwords or tokens.",
      "complexity": 35
    },
    {
      "component_name": "ErrorHandlingMiddleware",
      "semantic_unit_id": "SU-006",
      "responsibility": "Centralized Express error handling middleware that catches all errors, formats error responses consistently, and logs errors appropriately. Handles different error types with appropriate HTTP status codes.",
      "interfaces": [
        {
          "method": "handleError",
          "parameters": {
            "err": "Error",
            "req": "Request",
            "res": "Response",
            "next": "NextFunction"
          },
          "returns": "void",
          "description": "Express error handling middleware that processes all errors and sends formatted JSON error responses."
        },
        {
          "method": "mapErrorToResponse",
          "parameters": {
            "err": "Error"
          },
          "returns": "{statusCode: number, errorCode: string, message: string}",
          "description": "Maps application errors to HTTP status codes and error response format."
        }
      ],
      "dependencies": [
        "Winston logger"
      ],
      "implementation_notes": "Register as Express error handling middleware using app.use(errorHandler) after all routes. Check error type and map to appropriate HTTP status code and error code. Handle ZodError (from validation) as 400 Bad Request with error code VALIDATION_ERROR and detailed validation messages. Handle custom application errors (AuthenticationError, NotFoundError, ConflictError, VersionConflictError) with appropriate status codes (401, 404, 409, 409). Handle JsonWebTokenError and TokenExpiredError as 401 Unauthorized. Handle Prisma errors (PrismaClientKnownRequestError) and map to appropriate status codes (P2002 unique constraint = 409 Conflict, P2025 record not found = 404 Not Found). For unknown errors, return 500 Internal Server Error with generic message. Never expose stack traces or internal error details in production. Log all errors with Winston logger including error message, stack trace, request method, path, userId (if authenticated), and timestamp. Use logger.error() for 5xx errors and logger.warn() for 4xx errors. Format error response as JSON with structure: {errorCode: string, message: string}. For ZodError, include validation details in message. Set appropriate HTTP status code using res.status(). Send JSON response using res.json(). Ensure error handler is registered last in middleware chain to catch all errors.",
      "complexity": 38
    },
    {
      "component_name": "HealthCheckController",
      "semantic_unit_id": "SU-007",
      "responsibility": "Handles health check endpoint to verify API service and database connectivity status. Provides monitoring and alerting capabilities.",
      "interfaces": [
        {
          "method": "healthCheck",
          "parameters": {
            "req": "Request",
            "res": "Response",
            "next": "NextFunction"
          },
          "returns": "Promise<void>",
          "description": "Handles GET /api/health endpoint. Checks database connectivity and returns service status."
        },
        {
          "method": "checkDatabaseConnection",
          "parameters": {},
          "returns": "Promise<boolean>",
          "description": "Tests database connectivity by executing simple query."
        }
      ],
      "dependencies": [
        "Prisma client"
      ],
      "implementation_notes": "For healthCheck endpoint, call checkDatabaseConnection() to verify database connectivity. Return 200 OK with JSON response containing status='healthy', timestamp (ISO 8601 format using new Date().toISOString()), and database='connected'. If database check fails, return 503 Service Unavailable with status='unhealthy' and database='disconnected'. For checkDatabaseConnection, use Prisma client to execute simple query like prisma.$queryRaw`SELECT 1`. Wrap in try-catch and return true on success, false on error. Set timeout of 5 seconds for database check to avoid hanging. Use Winston logger to log health check failures. This endpoint does not require authentication - it should be publicly accessible for monitoring tools. Keep health check logic lightweight to avoid impacting performance.",
      "complexity": 22
    },
    {
      "component_name": "UserRepository",
      "semantic_unit_id": "SU-008",
      "responsibility": "Data access layer for user-related database operations. Provides abstraction over Prisma ORM for user CRUD operations.",
      "interfaces": [
        {
          "method": "createUser",
          "parameters": {
            "data": "{email: string",
            "passwordHash": "string",
            "name": "string}"
          },
          "returns": "Promise<User>",
          "description": "Creates new user record in database."
        },
        {
          "method": "findUserByEmail",
          "parameters": {
            "email": "string"
          },
          "returns": "Promise<User | null>",
          "description": "Finds user by email address."
        },
        {
          "method": "findUserById",
          "parameters": {
            "id": "string"
          },
          "returns": "Promise<User | null>",
          "description": "Finds user by ID."
        }
      ],
      "dependencies": [
        "Prisma client"
      ],
      "implementation_notes": "Use Prisma client for all database operations. For createUser, use prisma.user.create() with data object containing email, password_hash (map passwordHash to password_hash column), and name. Return created user object. For findUserByEmail, use prisma.user.findUnique() with where clause {email}. Return user or null. For findUserById, use prisma.user.findUnique() with where clause {id}. Return user or null. All methods should use async/await. Handle Prisma errors and let them propagate to error handling middleware. Use Prisma's type safety to ensure correct data types. Do not expose password_hash in return types - define User type without password_hash field for application use.",
      "complexity": 25
    },
    {
      "component_name": "TaskRepository",
      "semantic_unit_id": "SU-009",
      "responsibility": "Data access layer for task-related database operations. Provides abstraction over Prisma ORM for task CRUD operations with filtering, sorting, and pagination.",
      "interfaces": [
        {
          "method": "createTask",
          "parameters": {
            "data": "{userId: string",
            "title": "string",
            "description?": "string",
            "status": "string",
            "priority": "string",
            "dueDate?": "Date}"
          },
          "returns": "Promise<Task>",
          "description": "Creates new task record in database."
        },
        {
          "method": "findTaskById",
          "parameters": {
            "id": "string"
          },
          "returns": "Promise<Task | null>",
          "description": "Finds task by ID."
        },
        {
          "method": "findTasks",
          "parameters": {
            "userId": "string",
            "filters": "TaskFilters",
            "pagination": "PaginationParams"
          },
          "returns": "Promise<{tasks: Task[], total: number}>",
          "description": "Finds tasks for user with filtering, sorting, and pagination."
        },
        {
          "method": "updateTask",
          "parameters": {
            "id": "string",
            "version": "number",
            "data": "Partial<Task>"
          },
          "returns": "Promise<Task>",
          "description": "Updates task with optimistic locking. Throws error if version mismatch."
        },
        {
          "method": "deleteTask",
          "parameters": {
            "id": "string"
          },
          "returns": "Promise<void>",
          "description": "Deletes task by ID."
        }
      ],
      "dependencies": [
        "Prisma client"
      ],
      "implementation_notes": "Use Prisma client for all database operations. For createTask, use prisma.task.create() with data object. Set version to 1 for new tasks. For findTaskById, use prisma.task.findUnique() with where clause {id}. For findTasks, build dynamic where clause based on filters. Use prisma.task.findMany() with where, orderBy, skip, and take parameters. Calculate skip as (page - 1) * limit. Use prisma.task.count() with same where clause to get total count. For status filter, use exact match {status}. For priority filter, use exact match {priority}. For dueDateFrom, use {dueDate: {gte: dueDateFrom}}. For dueDateTo, use {dueDate: {lte: dueDateTo}}. Combine multiple filters with AND. For sorting, map sortBy to Prisma orderBy object. Support sorting by createdAt, updatedAt, dueDate, priority. Map sortOrder to 'asc' or 'desc'. For updateTask, use prisma.task.updateMany() with where clause {id, version} to implement optimistic locking. Check if update affected 0 rows and throw VERSION_CONFLICT error. Increment version by 1 in update data. Use prisma.task.findUnique() to fetch and return updated task. For deleteTask, use prisma.task.delete() with where clause {id}. Handle Prisma P2025 error (record not found) and throw TASK_NOT_FOUND error. All methods should use async/await. Use Prisma transactions for operations requiring atomicity.",
      "complexity": 58
    },
    {
      "component_name": "AuditLogRepository",
      "semantic_unit_id": "SU-010",
      "responsibility": "Data access layer for audit log operations. Records all task operations for compliance and debugging.",
      "interfaces": [
        {
          "method": "createAuditLog",
          "parameters": {
            "data": "{taskId: string",
            "userId": "string",
            "operation": "string",
            "oldData?": "object",
            "newData?": "object}"
          },
          "returns": "Promise<void>",
          "description": "Creates audit log entry for task operation."
        }
      ],
      "dependencies": [
        "Prisma client"
      ],
      "implementation_notes": "Use Prisma client for database operations. For createAuditLog, use prisma.auditLog.create() with data object containing task_id (map taskId), user_id (map userId), operation, old_data (map oldData as JSONB), new_data (map newData as JSONB). Operation should be one of: CREATE, UPDATE, DELETE. For CREATE operations, oldData is null and newData contains created task. For UPDATE operations, oldData contains task before update and newData contains task after update. For DELETE operations, oldData contains deleted task and newData is null. Serialize task objects to JSON for storage in JSONB columns. Use async/await. This operation should not fail the main operation - wrap in try-catch and log errors but don't throw. Use Winston logger to log audit log creation failures.",
      "complexity": 20
    }
  ],
  "design_review_checklist": [
    {
      "category": "Security",
      "description": "Password storage and authentication",
      "validation_criteria": "Verify all passwords are hashed using bcrypt with cost factor 12 before storage. Verify password_hash is never included in API responses. Verify JWT tokens use strong secret (minimum 32 characters) and have appropriate expiration (24 hours). Verify authentication middleware properly validates tokens and handles expired/invalid tokens.",
      "severity": "Critical"
    },
    {
      "category": "Security",
      "description": "SQL injection prevention",
      "validation_criteria": "Verify all database queries use Prisma ORM with parameterized queries. Verify no raw SQL queries with string concatenation. Verify user input is validated before database operations. Verify Zod schemas validate all input data types and formats.",
      "severity": "Critical"
    },
    {
      "category": "Data Integrity",
      "description": "Optimistic locking implementation",
      "validation_criteria": "Verify updateTask operations check version field before updating. Verify version is incremented on successful update. Verify VERSION_CONFLICT error is thrown when version mismatch occurs. Verify version field is included in update request body validation.",
      "severity": "High"
    },
    {
      "category": "Architecture",
      "description": "Separation of concerns and layering",
      "validation_criteria": "Verify controllers only handle HTTP request/response and delegate to services. Verify services contain business logic and delegate to repositories. Verify repositories only handle database operations. Verify no business logic in repositories or controllers. Verify no database operations in controllers or services.",
      "severity": "High"
    },
    {
      "category": "API Design",
      "description": "Error response consistency",
      "validation_criteria": "Verify all error responses follow consistent format with errorCode and message fields. Verify appropriate HTTP status codes are used (400 for validation, 401 for auth, 404 for not found, 409 for conflicts, 500 for server errors). Verify error messages are descriptive but don't expose sensitive information. Verify all endpoints document error responses.",
      "severity": "High"
    },
    {
      "category": "Performance",
      "description": "Database query optimization",
      "validation_criteria": "Verify appropriate indexes exist on frequently queried columns (user_id, status, priority, due_date, created_at, updated_at). Verify composite index exists for user_id + status combination. Verify pagination uses offset/limit to avoid loading all records. Verify N+1 query problems are avoided.",
      "severity": "Medium"
    },
    {
      "category": "Data Integrity",
      "description": "Foreign key constraints and cascading deletes",
      "validation_criteria": "Verify tasks table has foreign key to users table with ON DELETE CASCADE. Verify audit_logs table has foreign key to users table with ON DELETE CASCADE. Verify deleting a user cascades to delete all their tasks and audit logs. Verify orphaned records cannot exist.",
      "severity": "Medium"
    },
    {
      "category": "Maintainability",
      "description": "Input validation and type safety",
      "validation_criteria": "Verify all API endpoints use Zod schemas for request validation. Verify TypeScript types are defined for all data structures. Verify Prisma schema matches database schema. Verify no 'any' types are used. Verify validation errors provide clear messages about what failed.",
      "severity": "Medium"
    },
    {
      "category": "Error Handling",
      "description": "Comprehensive error handling",
      "validation_criteria": "Verify all async operations are wrapped in try-catch blocks. Verify errors are passed to error handling middleware using next(error). Verify error handling middleware handles all error types (Zod, Prisma, JWT, custom errors). Verify errors are logged with appropriate severity levels. Verify 5xx errors don't expose internal details.",
      "severity": "High"
    },
    {
      "category": "Security",
      "description": "Authorization and ownership verification",
      "validation_criteria": "Verify all task operations verify userId matches task.userId. Verify users cannot access or modify tasks belonging to other users. Verify authentication middleware properly extracts and validates user from JWT token. Verify req.user is populated before reaching controllers.",
      "severity": "Critical"
    }
  ],
  "architecture_overview": "Multi-tier web application architecture implementing a task management system with RESTful API design. The system consists of three primary layers: (1) Presentation Layer - RESTful API endpoints built with Express.js handling HTTP requests/responses, input validation, and authentication middleware, (2) Business Logic Layer - Service components implementing core task management operations including CRUD operations, task filtering, status transitions, and business rule enforcement, (3) Data Persistence Layer - PostgreSQL relational database with normalized schema for tasks, users, and audit logs. Authentication uses JWT tokens with bcrypt password hashing. The application follows MVC pattern with clear separation of concerns. Request flow: Client -> Express Router -> Authentication Middleware -> Controller -> Service Layer -> Repository Layer -> PostgreSQL Database. Response flow reverses this path with appropriate error handling at each layer. All components communicate through well-defined interfaces enabling independent testing and future scalability.",
  "technology_stack": {
    "language": "Node.js 20.x with TypeScript 5.3",
    "framework": "Express.js 4.18",
    "database": "PostgreSQL 16.1",
    "orm": "Prisma 5.7",
    "authentication": "JWT (jsonwebtoken 9.0) with bcrypt 5.1 for password hashing",
    "validation": "Zod 3.22 for request validation",
    "testing": "Jest 29.7 with Supertest 6.3",
    "logging": "Winston 3.11",
    "environment": "dotenv 16.3 for configuration management"
  },
  "assumptions": [
    "PostgreSQL database is accessible and properly configured with connection pooling",
    "JWT secret key is stored securely in environment variables and rotated periodically",
    "All timestamps are stored in UTC timezone in the database",
    "API clients can handle JSON request/response format",
    "Maximum task title length is 200 characters, description is 2000 characters",
    "Task status transitions follow defined workflow: TODO -> IN_PROGRESS -> DONE",
    "Users must be authenticated for all task operations except health check",
    "Concurrent task updates are handled with optimistic locking using version field",
    "API rate limiting is handled at infrastructure level (reverse proxy/API gateway)",
    "HTTPS/TLS termination is handled by reverse proxy or load balancer"
  ],
  "timestamp": "2025-01-20T10:30:00Z"
}