{
  "task_id": "HW-001",
  "project_id": "PROJECT-001",
  "files": [
    {
      "file_path": "src/main.py",
      "content": "\"\"\"\nFastAPI Hello World Application\n\nMain application entry point with CORS middleware, router registration, and startup configuration.\nProvides /hello and /health endpoints with proper error handling and validation.\n\nComponent ID: COMP-001\nSemantic Unit: SU-001\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport re\nfrom datetime import datetime\nfrom typing import Optional\n\nfrom fastapi import FastAPI, HTTPException, Query, Request\nfrom fastapi.exceptions import RequestValidationError\nfrom fastapi.responses import JSONResponse\nfrom starlette.middleware.cors import CORSMiddleware\n\n\ndef create_app() -> FastAPI:\n    \"\"\"\n    Create and configure FastAPI application instance.\n    \n    Returns:\n        FastAPI: Configured application instance\n    \"\"\"\n    app = FastAPI(\n        title=\"Hello World API\",\n        description=\"Simple REST API with greeting and health check endpoints\",\n        version=\"1.0.0\",\n    )\n    \n    # Configure CORS middleware\n    app.add_middleware(\n        CORSMiddleware,\n        allow_origins=[\"*\"],\n        allow_credentials=True,\n        allow_methods=[\"*\"],\n        allow_headers=[\"*\"],\n    )\n    \n    # Setup error handlers\n    setup_error_handlers(app)\n    \n    return app\n\n\ndef setup_error_handlers(app: FastAPI) -> None:\n    \"\"\"\n    Configure global exception handlers for the application.\n    \n    Args:\n        app: FastAPI application instance\n    \"\"\"\n    \n    @app.exception_handler(RequestValidationError)\n    async def handle_validation_error(request: Request, exc: RequestValidationError) -> JSONResponse:\n        \"\"\"\n        Handle FastAPI validation errors and return formatted 400 response.\n        \n        Args:\n            request: HTTP request object\n            exc: Validation error exception\n            \n        Returns:\n            JSONResponse: Formatted error response\n        \"\"\"\n        return JSONResponse(\n            status_code=400,\n            content={\n                \"error\": \"VALIDATION_ERROR\",\n                \"message\": \"Invalid request parameters\"\n            }\n        )\n    \n    @app.exception_handler(HTTPException)\n    async def handle_http_exception(request: Request, exc: HTTPException) -> JSONResponse:\n        \"\"\"\n        Handle HTTP exceptions and return formatted error response.\n        \n        Args:\n            request: HTTP request object\n            exc: HTTP exception\n            \n        Returns:\n            JSONResponse: Formatted error response\n        \"\"\"\n        return JSONResponse(\n            status_code=exc.status_code,\n            content={\n                \"error\": getattr(exc, 'detail', {}).get('code', 'HTTP_ERROR') if isinstance(exc.detail, dict) else 'HTTP_ERROR',\n                \"message\": exc.detail if isinstance(exc.detail, str) else str(exc.detail)\n            }\n        )\n    \n    @app.exception_handler(Exception)\n    async def handle_general_exception(request: Request, exc: Exception) -> JSONResponse:\n        \"\"\"\n        Handle unexpected exceptions and return 500 error response.\n        \n        Args:\n            request: HTTP request object\n            exc: General exception\n            \n        Returns:\n            JSONResponse: Formatted error response\n        \"\"\"\n        return JSONResponse(\n            status_code=500,\n            content={\n                \"error\": \"INTERNAL_ERROR\",\n                \"message\": \"Internal server error\"\n            }\n        )\n\n\ndef validate_name(name: str) -> bool:\n    \"\"\"\n    Validate name parameter contains only alphanumeric characters and spaces.\n    \n    Args:\n        name: Name string to validate\n        \n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    if len(name) > 100:\n        return False\n    \n    pattern = r'^[a-zA-Z0-9 ]+$'\n    return bool(re.match(pattern, name))\n\n\ndef format_greeting(name: Optional[str]) -> str:\n    \"\"\"\n    Format greeting message based on name parameter.\n    \n    Args:\n        name: Optional name for personalization\n        \n    Returns:\n        str: Formatted greeting message\n    \"\"\"\n    if not name or not name.strip():\n        return \"Hello, World!\"\n    \n    return f\"Hello, {name.strip()}!\"\n\n\ndef get_current_timestamp() -> str:\n    \"\"\"\n    Get current UTC timestamp in ISO 8601 format.\n    \n    Returns:\n        str: Current timestamp in ISO 8601 format with Z suffix\n    \"\"\"\n    try:\n        return datetime.utcnow().isoformat() + 'Z'\n    except Exception:\n        # Fallback in case of datetime errors\n        return \"1970-01-01T00:00:00.000Z\"\n\n\n# Initialize FastAPI application\napp = create_app()\n\n\n@app.get(\"/hello\")\nasync def get_hello(name: Optional[str] = Query(None, max_length=100)) -> dict[str, str]:\n    \"\"\"\n    Process hello request and return greeting message.\n    \n    Args:\n        name: Optional name parameter for personalization (max 100 chars, alphanumeric and spaces only)\n        \n    Returns:\n        dict: JSON response with greeting message\n        \n    Raises:\n        HTTPException: 400 if name contains invalid characters or exceeds length limit\n        HTTPException: 500 for internal server errors\n    \"\"\"\n    try:\n        if name is not None and name.strip():\n            if not validate_name(name):\n                raise HTTPException(\n                    status_code=400,\n                    detail={\n                        \"code\": \"INVALID_NAME\",\n                        \"message\": \"Name parameter contains invalid characters or exceeds 100 characters\"\n                    }\n                )\n        \n        message = format_greeting(name)\n        return {\"message\": message}\n        \n    except HTTPException:\n        raise\n    except Exception:\n        raise HTTPException(\n            status_code=500,\n            detail={\n                \"code\": \"INTERNAL_ERROR\",\n                \"message\": \"Internal server error\"\n            }\n        )\n\n\n@app.get(\"/health\")\nasync def get_health() -> dict[str, str]:\n    \"\"\"\n    Return health status and current timestamp.\n    \n    Returns:\n        dict: JSON response with status and timestamp\n        \n    Raises:\n        HTTPException: 500 for internal server errors\n    \"\"\"\n    try:\n        timestamp = get_current_timestamp()\n        return {\n            \"status\": \"ok\",\n            \"timestamp\": timestamp\n        }\n        \n    except Exception:\n        raise HTTPException(\n            status_code=500,\n            detail={\n                \"code\": \"INTERNAL_ERROR\",\n                \"message\": \"Internal server error\"\n            }\n        )\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)",
      "file_type": "source",
      "semantic_unit_id": "SU-001",
      "component_id": "COMP-001",
      "description": "FastAPI application entry point with CORS middleware, router registration, and startup configuration"
    },
    {
      "file_path": "src/api/auth.py",
      "content": "\"\"\"\nAuthentication API endpoints for user registration, login, token validation, and logout functionality.\n\nThis module provides secure authentication endpoints with JWT token management,\npassword hashing, and comprehensive input validation.\n\nComponent ID: COMP-002\nSemantic Unit: SU-002\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport logging\nfrom datetime import datetime, timedelta\nfrom typing import Optional\n\nfrom fastapi import APIRouter, Depends, HTTPException, status\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy.exc import IntegrityError\n\nfrom src.models.user import User\nfrom src.utils.jwt_utils import create_access_token, verify_token, decode_token\nfrom src.utils.password import hash_password, verify_password\nfrom src.schemas.auth import (\n    UserRegistrationRequest,\n    UserLoginRequest,\n    AuthResponse,\n    TokenValidationResponse,\n    UserResponse,\n    LogoutResponse\n)\nfrom src.database import get_db\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Initialize router and security\nrouter = APIRouter(prefix=\"/auth\", tags=[\"authentication\"])\nsecurity = HTTPBearer()\n\n\nclass AuthenticationError(Exception):\n    \"\"\"Custom exception for authentication-related errors.\"\"\"\n    pass\n\n\nclass AuthService:\n    \"\"\"Service class for authentication operations.\"\"\"\n    \n    def __init__(self, db: Session):\n        \"\"\"\n        Initialize authentication service.\n        \n        Args:\n            db: Database session\n        \"\"\"\n        self.db = db\n    \n    def register_user(self, registration_data: UserRegistrationRequest) -> User:\n        \"\"\"\n        Register a new user with email and password validation.\n        \n        Args:\n            registration_data: User registration information\n            \n        Returns:\n            User: Created user object\n            \n        Raises:\n            HTTPException: If email already exists or validation fails\n        \"\"\"\n        try:\n            # Check if user already exists\n            existing_user = self.db.query(User).filter(\n                User.email == registration_data.email.lower()\n            ).first()\n            \n            if existing_user:\n                logger.warning(f\"Registration attempt with existing email: {registration_data.email}\")\n                raise HTTPException(\n                    status_code=status.HTTP_400_BAD_REQUEST,\n                    detail=\"Email already registered\"\n                )\n            \n            # Hash password\n            hashed_password = hash_password(registration_data.password)\n            \n            # Create new user\n            new_user = User(\n                email=registration_data.email.lower(),\n                username=registration_data.username,\n                password_hash=hashed_password,\n                first_name=registration_data.first_name,\n                last_name=registration_data.last_name,\n                is_active=True,\n                created_at=datetime.utcnow(),\n                updated_at=datetime.utcnow()\n            )\n            \n            self.db.add(new_user)\n            self.db.commit()\n            self.db.refresh(new_user)\n            \n            logger.info(f\"User registered successfully: {new_user.email}\")\n            return new_user\n            \n        except IntegrityError as e:\n            self.db.rollback()\n            logger.error(f\"Database integrity error during registration: {str(e)}\")\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Email or username already exists\"\n            )\n        except Exception as e:\n            self.db.rollback()\n            logger.error(f\"Unexpected error during registration: {str(e)}\")\n            raise HTTPException(\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n                detail=\"Registration failed\"\n            )\n    \n    def authenticate_user(self, login_data: UserLoginRequest) -> User:\n        \"\"\"\n        Authenticate user with email and password.\n        \n        Args:\n            login_data: User login credentials\n            \n        Returns:\n            User: Authenticated user object\n            \n        Raises:\n            HTTPException: If authentication fails\n        \"\"\"\n        try:\n            # Find user by email\n            user = self.db.query(User).filter(\n                User.email == login_data.email.lower()\n            ).first()\n            \n            if not user:\n                logger.warning(f\"Login attempt with non-existent email: {login_data.email}\")\n                raise HTTPException(\n                    status_code=status.HTTP_401_UNAUTHORIZED,\n                    detail=\"Invalid email or password\"\n                )\n            \n            # Check if user is active\n            if not user.is_active:\n                logger.warning(f\"Login attempt with inactive account: {user.email}\")\n                raise HTTPException(\n                    status_code=status.HTTP_401_UNAUTHORIZED,\n                    detail=\"Account is disabled\"\n                )\n            \n            # Verify password\n            if not verify_password(login_data.password, user.password_hash):\n                logger.warning(f\"Failed login attempt for user: {user.email}\")\n                raise HTTPException(\n                    status_code=status.HTTP_401_UNAUTHORIZED,\n                    detail=\"Invalid email or password\"\n                )\n            \n            # Update last login timestamp\n            user.last_login = datetime.utcnow()\n            user.updated_at = datetime.utcnow()\n            self.db.commit()\n            \n            logger.info(f\"User authenticated successfully: {user.email}\")\n            return user\n            \n        except HTTPException:\n            raise\n        except Exception as e:\n            logger.error(f\"Unexpected error during authentication: {str(e)}\")\n            raise HTTPException(\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n                detail=\"Authentication failed\"\n            )\n    \n    def get_user_by_id(self, user_id: int) -> Optional[User]:\n        \"\"\"\n        Retrieve user by ID.\n        \n        Args:\n            user_id: User ID\n            \n        Returns:\n            User object if found, None otherwise\n        \"\"\"\n        try:\n            return self.db.query(User).filter(\n                User.id == user_id,\n                User.is_active == True\n            ).first()\n        except Exception as e:\n            logger.error(f\"Error retrieving user by ID {user_id}: {str(e)}\")\n            return None\n\n\ndef get_current_user(\n    credentials: HTTPAuthorizationCredentials = Depends(security),\n    db: Session = Depends(get_db)\n) -> User:\n    \"\"\"\n    Get current authenticated user from JWT token.\n    \n    Args:\n        credentials: HTTP authorization credentials\n        db: Database session\n        \n    Returns:\n        User: Current authenticated user\n        \n    Raises:\n        HTTPException: If token is invalid or user not found\n    \"\"\"\n    try:\n        # Verify and decode token\n        if not verify_token(credentials.credentials):\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Invalid or expired token\",\n                headers={\"WWW-Authenticate\": \"Bearer\"}\n            )\n        \n        payload = decode_token(credentials.credentials)\n        user_id = payload.get(\"sub\")\n        \n        if not user_id:\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Invalid token payload\",\n                headers={\"WWW-Authenticate\": \"Bearer\"}\n            )\n        \n        # Get user from database\n        auth_service = AuthService(db)\n        user = auth_service.get_user_by_id(int(user_id))\n        \n        if not user:\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"User not found\",\n                headers={\"WWW-Authenticate\": \"Bearer\"}\n            )\n        \n        return user\n        \n    except HTTPException:\n        raise\n    except Exception as e:\n        logger.error(f\"Error getting current user: {str(e)}\")\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Token validation failed\",\n            headers={\"WWW-Authenticate\": \"Bearer\"}\n        )\n\n\n@router.post(\"/register\", response",
      "file_type": "source",
      "semantic_unit_id": "SU-002",
      "component_id": "COMP-002",
      "description": "Authentication API endpoints for user registration, login, token validation, and logout functionality"
    },
    {
      "file_path": "src/api/tasks.py",
      "content": "\"\"\"\nTask management API endpoints for CRUD operations with authentication middleware and user authorization.\n\nThis module provides REST API endpoints for managing tasks including creation, retrieval,\nupdating, and deletion with proper user authentication and authorization.\n\nComponent ID: COMP-003\nSemantic Unit: SU-003\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport logging\nfrom datetime import datetime\nfrom typing import List, Optional\nfrom uuid import UUID\n\nfrom fastapi import APIRouter, Depends, HTTPException, Query, status\nfrom fastapi.security import HTTPBearer\nfrom sqlalchemy.orm import Session\n\nfrom src.models.task import Task\nfrom src.models.user import User\nfrom src.schemas.task import (\n    TaskCreate,\n    TaskResponse,\n    TaskUpdate,\n    TaskListResponse,\n    TaskStatus\n)\nfrom src.utils.jwt_utils import decode_jwt_token, get_current_user\nfrom src.database import get_db\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Initialize router and security\nrouter = APIRouter(prefix=\"/api/v1/tasks\", tags=[\"tasks\"])\nsecurity = HTTPBearer()\n\n\nclass TaskService:\n    \"\"\"Service class for task-related business logic.\"\"\"\n    \n    def __init__(self, db: Session):\n        \"\"\"\n        Initialize TaskService with database session.\n        \n        Args:\n            db: SQLAlchemy database session\n        \"\"\"\n        self.db = db\n    \n    def create_task(self, task_data: TaskCreate, user_id: UUID) -> Task:\n        \"\"\"\n        Create a new task for the authenticated user.\n        \n        Args:\n            task_data: Task creation data\n            user_id: ID of the user creating the task\n            \n        Returns:\n            Task: Created task instance\n            \n        Raises:\n            HTTPException: If task creation fails\n        \"\"\"\n        try:\n            task = Task(\n                title=task_data.title,\n                description=task_data.description,\n                status=task_data.status or TaskStatus.PENDING,\n                priority=task_data.priority,\n                due_date=task_data.due_date,\n                user_id=user_id,\n                created_at=datetime.utcnow(),\n                updated_at=datetime.utcnow()\n            )\n            \n            self.db.add(task)\n            self.db.commit()\n            self.db.refresh(task)\n            \n            logger.info(f\"Task created successfully: {task.id} for user: {user_id}\")\n            return task\n            \n        except Exception as e:\n            self.db.rollback()\n            logger.error(f\"Failed to create task for user {user_id}: {str(e)}\")\n            raise HTTPException(\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n                detail=\"Failed to create task\"\n            )\n    \n    def get_task_by_id(self, task_id: UUID, user_id: UUID) -> Task:\n        \"\"\"\n        Retrieve a task by ID for the authenticated user.\n        \n        Args:\n            task_id: ID of the task to retrieve\n            user_id: ID of the authenticated user\n            \n        Returns:\n            Task: Retrieved task instance\n            \n        Raises:\n            HTTPException: If task not found or access denied\n        \"\"\"\n        task = self.db.query(Task).filter(\n            Task.id == task_id,\n            Task.user_id == user_id,\n            Task.deleted_at.is_(None)\n        ).first()\n        \n        if not task:\n            logger.warning(f\"Task not found or access denied: {task_id} for user: {user_id}\")\n            raise HTTPException(\n                status_code=status.HTTP_404_NOT_FOUND,\n                detail=\"Task not found\"\n            )\n        \n        return task\n    \n    def get_user_tasks(\n        self,\n        user_id: UUID,\n        status_filter: Optional[TaskStatus] = None,\n        skip: int = 0,\n        limit: int = 100\n    ) -> List[Task]:\n        \"\"\"\n        Retrieve tasks for the authenticated user with optional filtering.\n        \n        Args:\n            user_id: ID of the authenticated user\n            status_filter: Optional status filter\n            skip: Number of records to skip for pagination\n            limit: Maximum number of records to return\n            \n        Returns:\n            List[Task]: List of user's tasks\n        \"\"\"\n        query = self.db.query(Task).filter(\n            Task.user_id == user_id,\n            Task.deleted_at.is_(None)\n        )\n        \n        if status_filter:\n            query = query.filter(Task.status == status_filter)\n        \n        tasks = query.order_by(Task.created_at.desc()).offset(skip).limit(limit).all()\n        \n        logger.info(f\"Retrieved {len(tasks)} tasks for user: {user_id}\")\n        return tasks\n    \n    def update_task(self, task_id: UUID, task_data: TaskUpdate, user_id: UUID) -> Task:\n        \"\"\"\n        Update an existing task for the authenticated user.\n        \n        Args:\n            task_id: ID of the task to update\n            task_data: Task update data\n            user_id: ID of the authenticated user\n            \n        Returns:\n            Task: Updated task instance\n            \n        Raises:\n            HTTPException: If task not found or update fails\n        \"\"\"\n        task = self.get_task_by_id(task_id, user_id)\n        \n        try:\n            # Update only provided fields\n            update_data = task_data.dict(exclude_unset=True)\n            for field, value in update_data.items():\n                setattr(task, field, value)\n            \n            task.updated_at = datetime.utcnow()\n            \n            self.db.commit()\n            self.db.refresh(task)\n            \n            logger.info(f\"Task updated successfully: {task_id} for user: {user_id}\")\n            return task\n            \n        except Exception as e:\n            self.db.rollback()\n            logger.error(f\"Failed to update task {task_id} for user {user_id}: {str(e)}\")\n            raise HTTPException(\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n                detail=\"Failed to update task\"\n            )\n    \n    def delete_task(self, task_id: UUID, user_id: UUID) -> None:\n        \"\"\"\n        Soft delete a task for the authenticated user.\n        \n        Args:\n            task_id: ID of the task to delete\n            user_id: ID of the authenticated user\n            \n        Raises:\n            HTTPException: If task not found or deletion fails\n        \"\"\"\n        task = self.get_task_by_id(task_id, user_id)\n        \n        try:\n            task.deleted_at = datetime.utcnow()\n            task.updated_at = datetime.utcnow()\n            \n            self.db.commit()\n            \n            logger.info(f\"Task deleted successfully: {task_id} for user: {user_id}\")\n            \n        except Exception as e:\n            self.db.rollback()\n            logger.error(f\"Failed to delete task {task_id} for user {user_id}: {str(e)}\")\n            raise HTTPException(\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n                detail=\"Failed to delete task\"\n            )\n\n\ndef get_task_service(db: Session = Depends(get_db)) -> TaskService:\n    \"\"\"\n    Dependency to get TaskService instance.\n    \n    Args:\n        db: Database session dependency\n        \n    Returns:\n        TaskService: Task service instance\n    \"\"\"\n    return TaskService(db)\n\n\n@router.post(\"/\", response_model=TaskResponse, status_code=status.HTTP_201_CREATED)\nasync def create_task(\n    task_data: TaskCreate,\n    current_user: User = Depends(get_current_user),\n    task_service: TaskService = Depends(get_task_service)\n) -> TaskResponse:\n    \"\"\"\n    Create a new task for the authenticated user.\n    \n    Args:\n        task_data: Task creation data\n        current_",
      "file_type": "source",
      "semantic_unit_id": "SU-003",
      "component_id": "COMP-003",
      "description": "Task management API endpoints for CRUD operations with authentication middleware and user authorization"
    },
    {
      "file_path": "src/models/user.py",
      "content": "\"\"\"\nUser SQLAlchemy model with authentication fields, profile data, and relationship to tasks.\n\nThis module defines the User model for the application with authentication capabilities,\nprofile information, and relationships to other entities.\n\nComponent ID: COMP-004\nSemantic Unit: SU-004\n\nAuthor: ASP Code Agent\n\"\"\"\n\nfrom datetime import datetime\nfrom typing import Optional, List\nfrom sqlalchemy import Column, Integer, String, DateTime, Boolean, Text\nfrom sqlalchemy.orm import relationship\nfrom sqlalchemy.sql import func\nfrom werkzeug.security import generate_password_hash, check_password_hash\nimport re\n\nfrom src.database.connection import Base\n\n\nclass User(Base):\n    \"\"\"\n    User model for authentication and profile management.\n    \n    This model handles user authentication, profile data, and relationships\n    to other entities in the system like tasks.\n    \n    Attributes:\n        id: Primary key identifier\n        username: Unique username for login\n        email: Unique email address\n        password_hash: Hashed password for authentication\n        first_name: User's first name\n        last_name: User's last name\n        is_active: Whether the user account is active\n        is_verified: Whether the user's email is verified\n        bio: Optional user biography\n        created_at: Timestamp when user was created\n        updated_at: Timestamp when user was last updated\n        last_login: Timestamp of last login\n        tasks: Relationship to user's tasks\n    \"\"\"\n    \n    __tablename__ = \"users\"\n    \n    # Primary key\n    id = Column(Integer, primary_key=True, index=True)\n    \n    # Authentication fields\n    username = Column(String(50), unique=True, index=True, nullable=False)\n    email = Column(String(255), unique=True, index=True, nullable=False)\n    password_hash = Column(String(255), nullable=False)\n    \n    # Profile fields\n    first_name = Column(String(100), nullable=False)\n    last_name = Column(String(100), nullable=False)\n    bio = Column(Text, nullable=True)\n    \n    # Status fields\n    is_active = Column(Boolean, default=True, nullable=False)\n    is_verified = Column(Boolean, default=False, nullable=False)\n    \n    # Timestamp fields\n    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)\n    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False)\n    last_login = Column(DateTime(timezone=True), nullable=True)\n    \n    # Relationships\n    tasks = relationship(\"Task\", back_populates=\"user\", cascade=\"all, delete-orphan\")\n    \n    def __init__(\n        self,\n        username: str,\n        email: str,\n        password: str,\n        first_name: str,\n        last_name: str,\n        bio: Optional[str] = None\n    ) -> None:\n        \"\"\"\n        Initialize a new User instance.\n        \n        Args:\n            username: Unique username (3-50 chars, alphanumeric and underscores)\n            email: Valid email address\n            password: Plain text password (will be hashed)\n            first_name: User's first name (1-100 chars)\n            last_name: User's last name (1-100 chars)\n            bio: Optional biography (max 1000 chars)\n            \n        Raises:\n            ValueError: If any validation fails\n        \"\"\"\n        self.username = self._validate_username(username)\n        self.email = self._validate_email(email)\n        self.set_password(password)\n        self.first_name = self._validate_name(first_name, \"first_name\")\n        self.last_name = self._validate_name(last_name, \"last_name\")\n        self.bio = self._validate_bio(bio) if bio else None\n        self.is_active = True\n        self.is_verified = False\n    \n    def __repr__(self) -> str:\n        \"\"\"String representation of User instance.\"\"\"\n        return f\"<User(id={self.id}, username='{self.username}', email='{self.email}')>\"\n    \n    def __str__(self) -> str:\n        \"\"\"Human-readable string representation.\"\"\"\n        return f\"{self.first_name} {self.last_name} ({self.username})\"\n    \n    @staticmethod\n    def _validate_username(username: str) -> str:\n        \"\"\"\n        Validate username format and constraints.\n        \n        Args:\n            username: Username to validate\n            \n        Returns:\n            str: Validated username\n            \n        Raises:\n            ValueError: If username is invalid\n        \"\"\"\n        if not username or not isinstance(username, str):\n            raise ValueError(\"Username is required and must be a string\")\n        \n        username = username.strip()\n        \n        if len(username) < 3:\n            raise ValueError(\"Username must be at least 3 characters long\")\n        \n        if len(username) > 50:\n            raise ValueError(\"Username must not exceed 50 characters\")\n        \n        if not re.match(r'^[a-zA-Z0-9_]+$', username):\n            raise ValueError(\"Username can only contain letters, numbers, and underscores\")\n        \n        return username\n    \n    @staticmethod\n    def _validate_email(email: str) -> str:\n        \"\"\"\n        Validate email format.\n        \n        Args:\n            email: Email address to validate\n            \n        Returns:\n            str: Validated email address\n            \n        Raises:\n            ValueError: If email is invalid\n        \"\"\"\n        if not email or not isinstance(email, str):\n            raise ValueError(\"Email is required and must be a string\")\n        \n        email = email.strip().lower()\n        \n        if len(email) > 255:\n            raise ValueError(\"Email must not exceed 255 characters\")\n        \n        # Basic email validation regex\n        email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n        if not re.match(email_pattern, email):\n            raise ValueError(\"Invalid email format\")\n        \n        return email\n    \n    @staticmethod\n    def _validate_name(name: str, field_name: str) -> str:\n        \"\"\"\n        Validate first name or last name.\n        \n        Args:\n            name: Name to validate\n            field_name: Field name for error messages\n            \n        Returns:\n            str: Validated name\n            \n        Raises:\n            ValueError: If name is invalid\n        \"\"\"\n        if not name or not isinstance(name, str):\n            raise ValueError(f\"{field_name} is required and must be a string\")\n        \n        name = name.strip()\n        \n        if len(name) < 1:\n            raise ValueError(f\"{field_name} cannot be empty\")\n        \n        if len(name) > 100:\n            raise ValueError(f\"{field_name} must not exceed 100 characters\")\n        \n        # Allow letters, spaces, hyphens, and apostrophes\n        if not re.match(r\"^[a-zA-Z\\s\\-']+$\", name):\n            raise ValueError(f\"{field_name} can only contain letters, spaces, hyphens, and apostrophes\")\n        \n        return name\n    \n    @staticmethod\n    def _validate_bio(bio: str) -> str:\n        \"\"\"\n        Validate user biography.\n        \n        Args:\n            bio: Biography to validate\n            \n        Returns:\n            str: Validated biography\n            \n        Raises:\n            ValueError: If bio is invalid\n        \"\"\"\n        if not isinstance(bio, str):\n            raise ValueError(\"Bio must be a string\")\n        \n        bio = bio.strip()\n        \n        if len(bio) > 1000:\n            raise ValueError(\"Bio must not exceed 1000 characters\")\n        \n        return bio if bio else None\n    \n    def set_password(self, password: str) -> None:\n        \"\"\"\n        Set user password with hashing.\n        \n        Args:\n            password: Plain text password\n            \n        Raises:\n            ValueError: If password doesn't meet requirements\n        \"\"\"\n        if not password or not isinstance(",
      "file_type": "source",
      "semantic_unit_id": "SU-004",
      "component_id": "COMP-004",
      "description": "User SQLAlchemy model with authentication fields, profile data, and relationship to tasks"
    },
    {
      "file_path": "src/models/task.py",
      "content": "\"\"\"\nTask SQLAlchemy model with CRUD operations, status management, and user relationship.\n\nThis module defines the Task model with comprehensive CRUD operations,\nstatus management functionality, and relationships to the User model.\n\nComponent ID: COMP-005\nSemantic Unit: SU-005\n\nAuthor: ASP Code Generator\n\"\"\"\n\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import List, Optional, Dict, Any\nfrom sqlalchemy import Column, Integer, String, Text, DateTime, ForeignKey, Boolean, Index\nfrom sqlalchemy.orm import relationship, Session\nfrom sqlalchemy.exc import SQLAlchemyError\nimport logging\n\nfrom src.database.connection import Base\nfrom src.models.user import User\n\nlogger = logging.getLogger(__name__)\n\n\nclass TaskStatus(str, Enum):\n    \"\"\"Enumeration of possible task statuses.\"\"\"\n    PENDING = \"pending\"\n    IN_PROGRESS = \"in_progress\"\n    COMPLETED = \"completed\"\n    CANCELLED = \"cancelled\"\n\n\nclass TaskPriority(str, Enum):\n    \"\"\"Enumeration of task priorities.\"\"\"\n    LOW = \"low\"\n    MEDIUM = \"medium\"\n    HIGH = \"high\"\n    URGENT = \"urgent\"\n\n\nclass Task(Base):\n    \"\"\"\n    Task model representing a user task with status management.\n    \n    This model provides comprehensive task management functionality including\n    CRUD operations, status transitions, and user relationships.\n    \n    Attributes:\n        id: Primary key identifier\n        title: Task title (required, max 200 characters)\n        description: Detailed task description (optional)\n        status: Current task status (TaskStatus enum)\n        priority: Task priority level (TaskPriority enum)\n        user_id: Foreign key to User model\n        created_at: Timestamp when task was created\n        updated_at: Timestamp when task was last modified\n        due_date: Optional due date for task completion\n        completed_at: Timestamp when task was completed\n        is_active: Soft delete flag\n        \n    Relationships:\n        user: Many-to-one relationship with User model\n    \"\"\"\n    \n    __tablename__ = \"tasks\"\n    \n    # Primary key\n    id = Column(Integer, primary_key=True, index=True)\n    \n    # Task details\n    title = Column(String(200), nullable=False, index=True)\n    description = Column(Text, nullable=True)\n    status = Column(String(20), nullable=False, default=TaskStatus.PENDING.value, index=True)\n    priority = Column(String(10), nullable=False, default=TaskPriority.MEDIUM.value, index=True)\n    \n    # User relationship\n    user_id = Column(Integer, ForeignKey(\"users.id\"), nullable=False, index=True)\n    user = relationship(\"User\", back_populates=\"tasks\")\n    \n    # Timestamps\n    created_at = Column(DateTime, nullable=False, default=datetime.utcnow, index=True)\n    updated_at = Column(DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)\n    due_date = Column(DateTime, nullable=True, index=True)\n    completed_at = Column(DateTime, nullable=True)\n    \n    # Soft delete\n    is_active = Column(Boolean, nullable=False, default=True, index=True)\n    \n    # Composite indexes for common queries\n    __table_args__ = (\n        Index('idx_user_status', 'user_id', 'status'),\n        Index('idx_user_priority', 'user_id', 'priority'),\n        Index('idx_status_due_date', 'status', 'due_date'),\n        Index('idx_user_active', 'user_id', 'is_active'),\n    )\n    \n    def __repr__(self) -> str:\n        \"\"\"String representation of Task instance.\"\"\"\n        return f\"<Task(id={self.id}, title='{self.title}', status='{self.status}', user_id={self.user_id})>\"\n    \n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Convert Task instance to dictionary representation.\n        \n        Returns:\n            Dict[str, Any]: Dictionary containing all task attributes\n        \"\"\"\n        return {\n            'id': self.id,\n            'title': self.title,\n            'description': self.description,\n            'status': self.status,\n            'priority': self.priority,\n            'user_id': self.user_id,\n            'created_at': self.created_at.isoformat() if self.created_at else None,\n            'updated_at': self.updated_at.isoformat() if self.updated_at else None,\n            'due_date': self.due_date.isoformat() if self.due_date else None,\n            'completed_at': self.completed_at.isoformat() if self.completed_at else None,\n            'is_active': self.is_active\n        }\n    \n    def update_status(self, new_status: TaskStatus) -> bool:\n        \"\"\"\n        Update task status with validation and automatic timestamp management.\n        \n        Args:\n            new_status: New status to set for the task\n            \n        Returns:\n            bool: True if status was updated successfully, False otherwise\n            \n        Raises:\n            ValueError: If status transition is invalid\n        \"\"\"\n        if not isinstance(new_status, TaskStatus):\n            raise ValueError(f\"Invalid status type: {type(new_status)}\")\n        \n        # Validate status transitions\n        valid_transitions = {\n            TaskStatus.PENDING: [TaskStatus.IN_PROGRESS, TaskStatus.CANCELLED],\n            TaskStatus.IN_PROGRESS: [TaskStatus.COMPLETED, TaskStatus.CANCELLED, TaskStatus.PENDING],\n            TaskStatus.COMPLETED: [TaskStatus.IN_PROGRESS],  # Allow reopening completed tasks\n            TaskStatus.CANCELLED: [TaskStatus.PENDING, TaskStatus.IN_PROGRESS]  # Allow reactivating cancelled tasks\n        }\n        \n        current_status = TaskStatus(self.status)\n        if new_status not in valid_transitions.get(current_status, []):\n            raise ValueError(f\"Invalid status transition from {current_status.value} to {new_status.value}\")\n        \n        # Update status and related timestamps\n        self.status = new_status.value\n        self.updated_at = datetime.utcnow()\n        \n        if new_status == TaskStatus.COMPLETED:\n            self.completed_at = datetime.utcnow()\n        elif current_status == TaskStatus.COMPLETED and new_status != TaskStatus.COMPLETED:\n            # Clear completed_at when moving away from completed status\n            self.completed_at = None\n        \n        logger.info(f\"Task {self.id} status updated from {current_status.value} to {new_status.value}\")\n        return True\n    \n    def is_overdue(self) -> bool:\n        \"\"\"\n        Check if task is overdue based on due_date.\n        \n        Returns:\n            bool: True if task is overdue, False otherwise\n        \"\"\"\n        if not self.due_date or self.status == TaskStatus.COMPLETED.value:\n            return False\n        \n        return datetime.utcnow() > self.due_date\n    \n    def days_until_due(self) -> Optional[int]:\n        \"\"\"\n        Calculate days until task is due.\n        \n        Returns:\n            Optional[int]: Number of days until due date, None if no due date set\n        \"\"\"\n        if not self.due_date:\n            return None\n        \n        delta = self.due_date - datetime.utcnow()\n        return delta.days\n    \n    @classmethod\n    def create(cls, db: Session, title: str, user_id: int, description: Optional[str] = None,\n               priority: TaskPriority = TaskPriority.MEDIUM, due_date: Optional[datetime] = None) -> 'Task':\n        \"\"\"\n        Create a new task with validation.\n        \n        Args:\n            db: Database session\n            title: Task title (required, max 200 characters)\n            user_id: ID of the user who owns the task\n            description: Optional task description\n            priority: Task priority level\n            due_date: Optional due date",
      "file_type": "source",
      "semantic_unit_id": "SU-005",
      "component_id": "COMP-005",
      "description": "Task SQLAlchemy model with CRUD operations, status management, and user relationship"
    },
    {
      "file_path": "src/schemas/auth.py",
      "content": "\"\"\"\nPydantic schemas for authentication request/response validation.\n\nThis module defines data validation schemas for authentication endpoints including\nlogin, registration, and token models using Pydantic for request/response validation.\n\nComponent ID: COMP-006\nSemantic Unit: SU-006\n\nAuthor: ASP Code Agent\n\"\"\"\n\nfrom datetime import datetime\nfrom typing import Optional\nfrom pydantic import BaseModel, EmailStr, Field, validator\nimport re\n\n\nclass UserRegistrationRequest(BaseModel):\n    \"\"\"\n    Schema for user registration request validation.\n    \n    Validates email format, password strength, and username requirements.\n    \"\"\"\n    username: str = Field(\n        ...,\n        min_length=3,\n        max_length=50,\n        description=\"Username must be 3-50 characters, alphanumeric and underscores only\"\n    )\n    email: EmailStr = Field(\n        ...,\n        description=\"Valid email address\"\n    )\n    password: str = Field(\n        ...,\n        min_length=8,\n        max_length=128,\n        description=\"Password must be 8-128 characters with at least one uppercase, lowercase, digit, and special character\"\n    )\n    full_name: Optional[str] = Field(\n        None,\n        max_length=100,\n        description=\"Full name, maximum 100 characters\"\n    )\n\n    @validator('username')\n    def validate_username(cls, v: str) -> str:\n        \"\"\"\n        Validate username contains only alphanumeric characters and underscores.\n        \n        Args:\n            v: Username string to validate\n            \n        Returns:\n            str: Validated username\n            \n        Raises:\n            ValueError: If username contains invalid characters\n        \"\"\"\n        if not re.match(r'^[a-zA-Z0-9_]+$', v):\n            raise ValueError('Username must contain only alphanumeric characters and underscores')\n        return v.lower()\n\n    @validator('password')\n    def validate_password_strength(cls, v: str) -> str:\n        \"\"\"\n        Validate password meets strength requirements.\n        \n        Args:\n            v: Password string to validate\n            \n        Returns:\n            str: Validated password\n            \n        Raises:\n            ValueError: If password doesn't meet strength requirements\n        \"\"\"\n        if not re.search(r'[A-Z]', v):\n            raise ValueError('Password must contain at least one uppercase letter')\n        if not re.search(r'[a-z]', v):\n            raise ValueError('Password must contain at least one lowercase letter')\n        if not re.search(r'\\d', v):\n            raise ValueError('Password must contain at least one digit')\n        if not re.search(r'[!@#$%^&*(),.?\":{}|<>]', v):\n            raise ValueError('Password must contain at least one special character')\n        return v\n\n    @validator('full_name')\n    def validate_full_name(cls, v: Optional[str]) -> Optional[str]:\n        \"\"\"\n        Validate full name contains only letters, spaces, hyphens, and apostrophes.\n        \n        Args:\n            v: Full name string to validate\n            \n        Returns:\n            Optional[str]: Validated full name or None\n            \n        Raises:\n            ValueError: If full name contains invalid characters\n        \"\"\"\n        if v is not None:\n            if not re.match(r\"^[a-zA-Z\\s\\-']+$\", v.strip()):\n                raise ValueError('Full name must contain only letters, spaces, hyphens, and apostrophes')\n            return v.strip()\n        return v\n\n\nclass UserLoginRequest(BaseModel):\n    \"\"\"\n    Schema for user login request validation.\n    \n    Validates login credentials using either username or email.\n    \"\"\"\n    username_or_email: str = Field(\n        ...,\n        min_length=3,\n        max_length=255,\n        description=\"Username or email address\"\n    )\n    password: str = Field(\n        ...,\n        min_length=1,\n        max_length=128,\n        description=\"User password\"\n    )\n\n    @validator('username_or_email')\n    def validate_username_or_email(cls, v: str) -> str:\n        \"\"\"\n        Validate username or email format.\n        \n        Args:\n            v: Username or email string to validate\n            \n        Returns:\n            str: Validated username or email\n            \n        Raises:\n            ValueError: If format is invalid\n        \"\"\"\n        v = v.strip().lower()\n        \n        # Check if it's an email format\n        if '@' in v:\n            email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n            if not re.match(email_pattern, v):\n                raise ValueError('Invalid email format')\n        else:\n            # Validate as username\n            if not re.match(r'^[a-zA-Z0-9_]+$', v):\n                raise ValueError('Username must contain only alphanumeric characters and underscores')\n        \n        return v\n\n\nclass TokenResponse(BaseModel):\n    \"\"\"\n    Schema for authentication token response.\n    \n    Contains access token, token type, expiration, and optional refresh token.\n    \"\"\"\n    access_token: str = Field(\n        ...,\n        description=\"JWT access token\"\n    )\n    token_type: str = Field(\n        default=\"bearer\",\n        description=\"Token type, typically 'bearer'\"\n    )\n    expires_in: int = Field(\n        ...,\n        description=\"Token expiration time in seconds\"\n    )\n    refresh_token: Optional[str] = Field(\n        None,\n        description=\"JWT refresh token for obtaining new access tokens\"\n    )\n    scope: Optional[str] = Field(\n        None,\n        description=\"Token scope permissions\"\n    )\n\n\nclass TokenRefreshRequest(BaseModel):\n    \"\"\"\n    Schema for token refresh request validation.\n    \n    Validates refresh token format for obtaining new access tokens.\n    \"\"\"\n    refresh_token: str = Field(\n        ...,\n        min_length=10,\n        description=\"Valid refresh token\"\n    )\n\n\nclass UserResponse(BaseModel):\n    \"\"\"\n    Schema for user information response.\n    \n    Contains safe user data without sensitive information like passwords.\n    \"\"\"\n    id: int = Field(\n        ...,\n        description=\"Unique user identifier\"\n    )\n    username: str = Field(\n        ...,\n        description=\"Username\"\n    )\n    email: str = Field(\n        ...,\n        description=\"Email address\"\n    )\n    full_name: Optional[str] = Field(\n        None,\n        description=\"Full name\"\n    )\n    is_active: bool = Field(\n        default=True,\n        description=\"Whether the user account is active\"\n    )\n    is_verified: bool = Field(\n        default=False,\n        description=\"Whether the user email is verified\"\n    )\n    created_at: datetime = Field(\n        ...,\n        description=\"Account creation timestamp\"\n    )\n    last_login: Optional[datetime] = Field(\n        None,\n        description=\"Last login timestamp\"\n    )\n\n    class Config:\n        \"\"\"Pydantic configuration for UserResponse.\"\"\"\n        from_attributes = True\n        json_encoders = {\n            datetime: lambda v: v.isoformat() + 'Z' if v else None\n        }\n\n\nclass PasswordChangeRequest(BaseModel):\n    \"\"\"\n    Schema for password change request validation.\n    \n    Validates current password and new password requirements.\n    \"\"\"\n    current_password: str = Field(\n        ...,\n        min_length=1,\n        max_length=128,\n        description=\"Current password for verification\"\n    )\n    new_password: str = Field(\n        ...,\n        min_length=8,\n        max_length=128,\n        description=\"New password meeting strength requirements\"\n    )\n\n    @validator('new_password')\n    def validate_new_password_strength(cls, v: str) -> str:\n        \"\"\"\n        Validate new password meets strength requirements.\n        \n        Args:\n            v: New password string to validate\n            \n        Returns:\n            str: Validated new password\n            \n        Raises:\n            ValueError: If password doesn't",
      "file_type": "source",
      "semantic_unit_id": "SU-006",
      "component_id": "COMP-006",
      "description": "Pydantic schemas for authentication request/response validation including login, registration, and token models"
    },
    {
      "file_path": "src/schemas/task.py",
      "content": "\"\"\"\nPydantic schemas for task request/response validation.\n\nThis module defines the data models used for task-related API endpoints,\nincluding create, update, and response schemas with proper validation.\n\nComponent ID: COMP-007\nSemantic Unit: SU-007\n\nAuthor: ASP Code Agent\n\"\"\"\n\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Optional\n\nfrom pydantic import BaseModel, Field, validator\n\n\nclass TaskStatus(str, Enum):\n    \"\"\"Enumeration of possible task statuses.\"\"\"\n    PENDING = \"pending\"\n    IN_PROGRESS = \"in_progress\"\n    COMPLETED = \"completed\"\n    CANCELLED = \"cancelled\"\n\n\nclass TaskPriority(str, Enum):\n    \"\"\"Enumeration of possible task priorities.\"\"\"\n    LOW = \"low\"\n    MEDIUM = \"medium\"\n    HIGH = \"high\"\n    URGENT = \"urgent\"\n\n\nclass TaskCreateRequest(BaseModel):\n    \"\"\"Schema for creating a new task.\"\"\"\n    \n    title: str = Field(\n        ...,\n        min_length=1,\n        max_length=200,\n        description=\"Task title\"\n    )\n    description: Optional[str] = Field(\n        None,\n        max_length=2000,\n        description=\"Detailed task description\"\n    )\n    priority: TaskPriority = Field(\n        TaskPriority.MEDIUM,\n        description=\"Task priority level\"\n    )\n    due_date: Optional[datetime] = Field(\n        None,\n        description=\"Task due date and time\"\n    )\n    tags: Optional[list[str]] = Field(\n        None,\n        description=\"List of task tags\"\n    )\n\n    @validator('title')\n    def validate_title(cls, v: str) -> str:\n        \"\"\"Validate task title is not empty after stripping whitespace.\"\"\"\n        if not v.strip():\n            raise ValueError('Title cannot be empty or only whitespace')\n        return v.strip()\n\n    @validator('description')\n    def validate_description(cls, v: Optional[str]) -> Optional[str]:\n        \"\"\"Validate and clean task description.\"\"\"\n        if v is not None:\n            v = v.strip()\n            if not v:\n                return None\n        return v\n\n    @validator('due_date')\n    def validate_due_date(cls, v: Optional[datetime]) -> Optional[datetime]:\n        \"\"\"Validate due date is not in the past.\"\"\"\n        if v is not None and v < datetime.utcnow():\n            raise ValueError('Due date cannot be in the past')\n        return v\n\n    @validator('tags')\n    def validate_tags(cls, v: Optional[list[str]]) -> Optional[list[str]]:\n        \"\"\"Validate and clean task tags.\"\"\"\n        if v is not None:\n            # Remove empty tags and duplicates while preserving order\n            cleaned_tags = []\n            seen = set()\n            for tag in v:\n                tag = tag.strip().lower()\n                if tag and tag not in seen:\n                    if len(tag) > 50:\n                        raise ValueError('Tag length cannot exceed 50 characters')\n                    if not tag.replace('-', '').replace('_', '').isalnum():\n                        raise ValueError('Tags can only contain alphanumeric characters, hyphens, and underscores')\n                    cleaned_tags.append(tag)\n                    seen.add(tag)\n            return cleaned_tags if cleaned_tags else None\n        return v\n\n    class Config:\n        \"\"\"Pydantic model configuration.\"\"\"\n        json_encoders = {\n            datetime: lambda v: v.isoformat() + 'Z' if v else None\n        }\n        schema_extra = {\n            \"example\": {\n                \"title\": \"Complete project documentation\",\n                \"description\": \"Write comprehensive documentation for the new API endpoints\",\n                \"priority\": \"high\",\n                \"due_date\": \"2024-01-15T10:00:00Z\",\n                \"tags\": [\"documentation\", \"api\", \"urgent\"]\n            }\n        }\n\n\nclass TaskUpdateRequest(BaseModel):\n    \"\"\"Schema for updating an existing task.\"\"\"\n    \n    title: Optional[str] = Field(\n        None,\n        min_length=1,\n        max_length=200,\n        description=\"Updated task title\"\n    )\n    description: Optional[str] = Field(\n        None,\n        max_length=2000,\n        description=\"Updated task description\"\n    )\n    status: Optional[TaskStatus] = Field(\n        None,\n        description=\"Updated task status\"\n    )\n    priority: Optional[TaskPriority] = Field(\n        None,\n        description=\"Updated task priority\"\n    )\n    due_date: Optional[datetime] = Field(\n        None,\n        description=\"Updated task due date\"\n    )\n    tags: Optional[list[str]] = Field(\n        None,\n        description=\"Updated list of task tags\"\n    )\n\n    @validator('title')\n    def validate_title(cls, v: Optional[str]) -> Optional[str]:\n        \"\"\"Validate task title is not empty after stripping whitespace.\"\"\"\n        if v is not None:\n            v = v.strip()\n            if not v:\n                raise ValueError('Title cannot be empty or only whitespace')\n        return v\n\n    @validator('description')\n    def validate_description(cls, v: Optional[str]) -> Optional[str]:\n        \"\"\"Validate and clean task description.\"\"\"\n        if v is not None:\n            v = v.strip()\n            if not v:\n                return None\n        return v\n\n    @validator('due_date')\n    def validate_due_date(cls, v: Optional[datetime]) -> Optional[datetime]:\n        \"\"\"Validate due date is not in the past.\"\"\"\n        if v is not None and v < datetime.utcnow():\n            raise ValueError('Due date cannot be in the past')\n        return v\n\n    @validator('tags')\n    def validate_tags(cls, v: Optional[list[str]]) -> Optional[list[str]]:\n        \"\"\"Validate and clean task tags.\"\"\"\n        if v is not None:\n            # Remove empty tags and duplicates while preserving order\n            cleaned_tags = []\n            seen = set()\n            for tag in v:\n                tag = tag.strip().lower()\n                if tag and tag not in seen:\n                    if len(tag) > 50:\n                        raise ValueError('Tag length cannot exceed 50 characters')\n                    if not tag.replace('-', '').replace('_', '').isalnum():\n                        raise ValueError('Tags can only contain alphanumeric characters, hyphens, and underscores')\n                    cleaned_tags.append(tag)\n                    seen.add(tag)\n            return cleaned_tags if cleaned_tags else None\n        return v\n\n    class Config:\n        \"\"\"Pydantic model configuration.\"\"\"\n        json_encoders = {\n            datetime: lambda v: v.isoformat() + 'Z' if v else None\n        }\n        schema_extra = {\n            \"example\": {\n                \"title\": \"Complete project documentation - Updated\",\n                \"status\": \"in_progress\",\n                \"priority\": \"urgent\"\n            }\n        }\n\n\nclass TaskResponse(BaseModel):\n    \"\"\"Schema for task response data.\"\"\"\n    \n    id: int = Field(\n        ...,\n        description=\"Unique task identifier\"\n    )\n    title: str = Field(\n        ...,\n        description=\"Task title\"\n    )\n    description: Optional[str] = Field(\n        None,\n        description=\"Task description\"\n    )\n    status: TaskStatus = Field(\n        ...,\n        description=\"Current task status\"\n    )\n    priority: TaskPriority = Field(\n        ...,\n        description=\"Task priority level\"\n    )\n    created_at: datetime = Field(\n        ...,\n        description=\"Task creation timestamp\"\n    )\n    updated_at: datetime = Field(\n        ...,\n        description=\"Task last update timestamp\"\n    )\n    due_date: Optional[datetime] = Field(\n        None,\n        description=\"Task due date\"\n    )\n    completed_at: Optional[datetime] = Field(\n        None,\n        description=\"Task completion timestamp\"\n    )\n    tags: Optional[list[str]] = Field(\n        None,\n        description=\"List of task tags\"\n    )\n\n    class Config:\n        \"\"\"Pydantic model configuration.\"\"\"",
      "file_type": "source",
      "semantic_unit_id": "SU-007",
      "component_id": "COMP-007",
      "description": "Pydantic schemas for task request/response validation including create, update, and response models"
    },
    {
      "file_path": "src/utils/jwt_utils.py",
      "content": "\"\"\"\nJWT token generation, validation, decoding utilities with expiration handling and security features.\n\nThis module provides comprehensive JWT token management including secure token generation,\nvalidation with expiration checks, and decoding with proper error handling.\n\nComponent ID: COMP-008\nSemantic Unit: SU-008\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport hashlib\nimport hmac\nimport json\nimport logging\nimport secrets\nimport time\nfrom datetime import datetime, timedelta, timezone\nfrom typing import Any, Dict, Optional, Union\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n\nclass JWTError(Exception):\n    \"\"\"Base exception for JWT-related errors.\"\"\"\n    pass\n\n\nclass JWTExpiredError(JWTError):\n    \"\"\"Exception raised when JWT token has expired.\"\"\"\n    pass\n\n\nclass JWTInvalidError(JWTError):\n    \"\"\"Exception raised when JWT token is invalid or malformed.\"\"\"\n    pass\n\n\nclass JWTSignatureError(JWTError):\n    \"\"\"Exception raised when JWT signature verification fails.\"\"\"\n    pass\n\n\nclass JWTUtils:\n    \"\"\"\n    JWT token utilities for generation, validation, and decoding.\n    \n    Provides secure JWT token management with HMAC-SHA256 signing,\n    expiration handling, and comprehensive validation.\n    \"\"\"\n    \n    def __init__(self, secret_key: str, default_expiry_hours: int = 24) -> None:\n        \"\"\"\n        Initialize JWT utilities with secret key and default expiry.\n        \n        Args:\n            secret_key: Secret key for signing tokens (minimum 32 characters)\n            default_expiry_hours: Default token expiry time in hours\n            \n        Raises:\n            ValueError: If secret key is too short or invalid\n        \"\"\"\n        if not secret_key or len(secret_key) < 32:\n            raise ValueError(\"Secret key must be at least 32 characters long\")\n        \n        self.secret_key = secret_key.encode('utf-8')\n        self.default_expiry_hours = default_expiry_hours\n        self.algorithm = 'HS256'\n        \n        logger.info(\"JWT utilities initialized with %d hour default expiry\", default_expiry_hours)\n    \n    def generate_token(\n        self, \n        payload: Dict[str, Any], \n        expiry_hours: Optional[int] = None,\n        include_jti: bool = True\n    ) -> str:\n        \"\"\"\n        Generate a JWT token with the given payload.\n        \n        Args:\n            payload: Dictionary containing token claims\n            expiry_hours: Token expiry time in hours (uses default if None)\n            include_jti: Whether to include a unique token ID (jti claim)\n            \n        Returns:\n            str: Encoded JWT token\n            \n        Raises:\n            ValueError: If payload is invalid\n            JWTError: If token generation fails\n        \"\"\"\n        if not isinstance(payload, dict):\n            raise ValueError(\"Payload must be a dictionary\")\n        \n        try:\n            # Create header\n            header = {\n                'typ': 'JWT',\n                'alg': self.algorithm\n            }\n            \n            # Create payload with standard claims\n            now = datetime.now(timezone.utc)\n            expiry_time = expiry_hours or self.default_expiry_hours\n            exp_time = now + timedelta(hours=expiry_time)\n            \n            token_payload = payload.copy()\n            token_payload.update({\n                'iat': int(now.timestamp()),  # Issued at\n                'exp': int(exp_time.timestamp()),  # Expiration time\n                'nbf': int(now.timestamp())  # Not before\n            })\n            \n            # Add unique token ID if requested\n            if include_jti:\n                token_payload['jti'] = self._generate_jti()\n            \n            # Encode header and payload\n            encoded_header = self._base64url_encode(json.dumps(header, separators=(',', ':')))\n            encoded_payload = self._base64url_encode(json.dumps(token_payload, separators=(',', ':')))\n            \n            # Create signature\n            message = f\"{encoded_header}.{encoded_payload}\"\n            signature = self._create_signature(message)\n            encoded_signature = self._base64url_encode(signature)\n            \n            token = f\"{message}.{encoded_signature}\"\n            \n            logger.debug(\"Generated JWT token with expiry: %s\", exp_time.isoformat())\n            return token\n            \n        except Exception as e:\n            logger.error(\"Failed to generate JWT token: %s\", str(e))\n            raise JWTError(f\"Token generation failed: {str(e)}\") from e\n    \n    def validate_token(self, token: str, verify_expiry: bool = True) -> Dict[str, Any]:\n        \"\"\"\n        Validate and decode a JWT token.\n        \n        Args:\n            token: JWT token string to validate\n            verify_expiry: Whether to check token expiration\n            \n        Returns:\n            Dict[str, Any]: Decoded token payload\n            \n        Raises:\n            JWTInvalidError: If token format is invalid\n            JWTSignatureError: If signature verification fails\n            JWTExpiredError: If token has expired\n        \"\"\"\n        if not token or not isinstance(token, str):\n            raise JWTInvalidError(\"Token must be a non-empty string\")\n        \n        try:\n            # Split token into parts\n            parts = token.split('.')\n            if len(parts) != 3:\n                raise JWTInvalidError(\"Token must have exactly 3 parts separated by dots\")\n            \n            encoded_header, encoded_payload, encoded_signature = parts\n            \n            # Verify signature\n            message = f\"{encoded_header}.{encoded_payload}\"\n            if not self._verify_signature(message, encoded_signature):\n                raise JWTSignatureError(\"Token signature verification failed\")\n            \n            # Decode header and payload\n            header = json.loads(self._base64url_decode(encoded_header))\n            payload = json.loads(self._base64url_decode(encoded_payload))\n            \n            # Verify header\n            if header.get('typ') != 'JWT' or header.get('alg') != self.algorithm:\n                raise JWTInvalidError(\"Invalid token header\")\n            \n            # Verify expiration if requested\n            if verify_expiry:\n                self._verify_expiration(payload)\n            \n            # Verify not-before claim\n            self._verify_not_before(payload)\n            \n            logger.debug(\"Successfully validated JWT token\")\n            return payload\n            \n        except (JWTError, json.JSONDecodeError) as e:\n            logger.warning(\"JWT validation failed: %s\", str(e))\n            raise\n        except Exception as e:\n            logger.error(\"Unexpected error during JWT validation: %s\", str(e))\n            raise JWTInvalidError(f\"Token validation failed: {str(e)}\") from e\n    \n    def decode_token_unsafe(self, token: str) -> Dict[str, Any]:\n        \"\"\"\n        Decode a JWT token without validation (for debugging/inspection only).\n        \n        WARNING: This method does not verify the token signature or expiration.\n        Only use for debugging or when you need to inspect an expired token.\n        \n        Args:\n            token: JWT token string to decode\n            \n        Returns:\n            Dict[str, Any]: Decoded token payload\n            \n        Raises:\n            JWTInvalidError: If token format is invalid\n        \"\"\"\n        if not token or not isinstance(token, str):\n            raise JWTInvalidError(\"Token must be a non-empty string\")\n        \n        try:\n            parts = token.split('.')\n            if len(parts) != 3:\n                raise JWTInvalidError(\"Token must have exactly 3 parts separated by dots\")\n            \n            encoded_payload = parts[1]\n            payload = json.loads(self._base64url_decode(encoded_payload))\n            \n            logger.debug(\"Decoded JWT token payload (unsafe)\")\n            return payload\n            \n        except (json.JSONDecodeError, Exception) as e:\n            logger.error(\"Failed to decode JWT token: %s\", str(e))\n            raise JWTInvalidError(f\"Token decoding faile",
      "file_type": "source",
      "semantic_unit_id": "SU-008",
      "component_id": "COMP-008",
      "description": "JWT token generation, validation, decoding utilities with expiration handling and security features"
    },
    {
      "file_path": "src/utils/password.py",
      "content": "\"\"\"\nPassword hashing and verification utilities using bcrypt.\n\nThis module provides secure password hashing and verification functionality\nusing bcrypt with configurable salt rounds for the Hello World API.\n\nComponent ID: COMP-009\nSemantic Unit: SU-009\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport logging\nfrom typing import Optional\n\nimport bcrypt\n\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Default salt rounds for bcrypt hashing\nDEFAULT_SALT_ROUNDS = 12\n\n\nclass PasswordHashingError(Exception):\n    \"\"\"Exception raised when password hashing operations fail.\"\"\"\n    pass\n\n\nclass PasswordVerificationError(Exception):\n    \"\"\"Exception raised when password verification operations fail.\"\"\"\n    pass\n\n\ndef hash_password(password: str, salt_rounds: Optional[int] = None) -> str:\n    \"\"\"\n    Hash a password using bcrypt with salt.\n    \n    Args:\n        password: The plain text password to hash\n        salt_rounds: Number of salt rounds for bcrypt (default: 12)\n        \n    Returns:\n        str: The hashed password as a string\n        \n    Raises:\n        PasswordHashingError: If password hashing fails\n        ValueError: If password is empty or salt_rounds is invalid\n        \n    Example:\n        >>> hashed = hash_password(\"my_secure_password\")\n        >>> len(hashed) > 0\n        True\n    \"\"\"\n    if not password:\n        raise ValueError(\"Password cannot be empty\")\n        \n    if salt_rounds is None:\n        salt_rounds = DEFAULT_SALT_ROUNDS\n        \n    if not isinstance(salt_rounds, int) or salt_rounds < 4 or salt_rounds > 31:\n        raise ValueError(\"Salt rounds must be an integer between 4 and 31\")\n    \n    try:\n        # Convert password to bytes\n        password_bytes = password.encode('utf-8')\n        \n        # Generate salt and hash password\n        salt = bcrypt.gensalt(rounds=salt_rounds)\n        hashed_password = bcrypt.hashpw(password_bytes, salt)\n        \n        # Convert back to string for storage\n        hashed_string = hashed_password.decode('utf-8')\n        \n        logger.debug(f\"Password hashed successfully with {salt_rounds} salt rounds\")\n        return hashed_string\n        \n    except Exception as e:\n        logger.error(f\"Failed to hash password: {str(e)}\")\n        raise PasswordHashingError(f\"Password hashing failed: {str(e)}\") from e\n\n\ndef verify_password(password: str, hashed_password: str) -> bool:\n    \"\"\"\n    Verify a password against its hash using bcrypt.\n    \n    Args:\n        password: The plain text password to verify\n        hashed_password: The hashed password to verify against\n        \n    Returns:\n        bool: True if password matches hash, False otherwise\n        \n    Raises:\n        PasswordVerificationError: If password verification fails\n        ValueError: If password or hashed_password is empty\n        \n    Example:\n        >>> hashed = hash_password(\"test_password\")\n        >>> verify_password(\"test_password\", hashed)\n        True\n        >>> verify_password(\"wrong_password\", hashed)\n        False\n    \"\"\"\n    if not password:\n        raise ValueError(\"Password cannot be empty\")\n        \n    if not hashed_password:\n        raise ValueError(\"Hashed password cannot be empty\")\n    \n    try:\n        # Convert inputs to bytes\n        password_bytes = password.encode('utf-8')\n        hashed_bytes = hashed_password.encode('utf-8')\n        \n        # Verify password using bcrypt\n        is_valid = bcrypt.checkpw(password_bytes, hashed_bytes)\n        \n        logger.debug(f\"Password verification completed: {'success' if is_valid else 'failed'}\")\n        return is_valid\n        \n    except Exception as e:\n        logger.error(f\"Failed to verify password: {str(e)}\")\n        raise PasswordVerificationError(f\"Password verification failed: {str(e)}\") from e\n\n\ndef is_password_strong(password: str) -> bool:\n    \"\"\"\n    Check if a password meets basic strength requirements.\n    \n    Requirements:\n    - At least 8 characters long\n    - Contains at least one uppercase letter\n    - Contains at least one lowercase letter\n    - Contains at least one digit\n    - Contains at least one special character\n    \n    Args:\n        password: The password to check\n        \n    Returns:\n        bool: True if password meets strength requirements, False otherwise\n        \n    Example:\n        >>> is_password_strong(\"Password123!\")\n        True\n        >>> is_password_strong(\"weak\")\n        False\n    \"\"\"\n    if not password or len(password) < 8:\n        return False\n    \n    has_upper = any(c.isupper() for c in password)\n    has_lower = any(c.islower() for c in password)\n    has_digit = any(c.isdigit() for c in password)\n    has_special = any(c in \"!@#$%^&*()_+-=[]{}|;:,.<>?\" for c in password)\n    \n    return all([has_upper, has_lower, has_digit, has_special])\n\n\ndef get_password_strength_feedback(password: str) -> list[str]:\n    \"\"\"\n    Get feedback on password strength requirements.\n    \n    Args:\n        password: The password to analyze\n        \n    Returns:\n        list[str]: List of feedback messages for improving password strength\n        \n    Example:\n        >>> feedback = get_password_strength_feedback(\"weak\")\n        >>> len(feedback) > 0\n        True\n    \"\"\"\n    feedback = []\n    \n    if not password:\n        feedback.append(\"Password cannot be empty\")\n        return feedback\n    \n    if len(password) < 8:\n        feedback.append(\"Password must be at least 8 characters long\")\n    \n    if not any(c.isupper() for c in password):\n        feedback.append(\"Password must contain at least one uppercase letter\")\n    \n    if not any(c.islower() for c in password):\n        feedback.append(\"Password must contain at least one lowercase letter\")\n    \n    if not any(c.isdigit() for c in password):\n        feedback.append(\"Password must contain at least one digit\")\n    \n    if not any(c in \"!@#$%^&*()_+-=[]{}|;:,.<>?\" for c in password):\n        feedback.append(\"Password must contain at least one special character (!@#$%^&*()_+-=[]{}|;:,.<>?)\")\n    \n    return feedback",
      "file_type": "source",
      "semantic_unit_id": "SU-009",
      "component_id": "COMP-009",
      "description": "Password hashing and verification utilities using bcrypt with salt rounds configuration"
    },
    {
      "file_path": "src/database/connection.py",
      "content": "\"\"\"\nSQLAlchemy database connection setup, session management, and database initialization.\n\nThis module provides database connection management, session handling, and initialization\nutilities for the Hello World API application.\n\nComponent ID: COMP-010\nSemantic Unit: SU-010\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport logging\nimport os\nfrom contextlib import contextmanager\nfrom typing import Generator, Optional\n\nfrom sqlalchemy import create_engine, event, pool\nfrom sqlalchemy.engine import Engine\nfrom sqlalchemy.exc import SQLAlchemyError\nfrom sqlalchemy.orm import DeclarativeBase, Session, sessionmaker\nfrom sqlalchemy.pool import StaticPool\n\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n\nclass Base(DeclarativeBase):\n    \"\"\"Base class for all SQLAlchemy models.\"\"\"\n    pass\n\n\nclass DatabaseConfig:\n    \"\"\"Database configuration settings.\"\"\"\n    \n    def __init__(self) -> None:\n        \"\"\"Initialize database configuration from environment variables.\"\"\"\n        self.database_url: str = os.getenv(\n            \"DATABASE_URL\", \n            \"sqlite:///./hello_world.db\"\n        )\n        self.echo: bool = os.getenv(\"DB_ECHO\", \"false\").lower() == \"true\"\n        self.pool_size: int = int(os.getenv(\"DB_POOL_SIZE\", \"5\"))\n        self.max_overflow: int = int(os.getenv(\"DB_MAX_OVERFLOW\", \"10\"))\n        self.pool_timeout: int = int(os.getenv(\"DB_POOL_TIMEOUT\", \"30\"))\n        self.pool_recycle: int = int(os.getenv(\"DB_POOL_RECYCLE\", \"3600\"))\n        \n    def get_engine_kwargs(self) -> dict:\n        \"\"\"Get SQLAlchemy engine configuration parameters.\"\"\"\n        kwargs = {\n            \"echo\": self.echo,\n            \"future\": True,\n        }\n        \n        # SQLite-specific configuration\n        if self.database_url.startswith(\"sqlite\"):\n            kwargs.update({\n                \"poolclass\": StaticPool,\n                \"connect_args\": {\n                    \"check_same_thread\": False,\n                    \"timeout\": 20\n                }\n            })\n        else:\n            # PostgreSQL/MySQL configuration\n            kwargs.update({\n                \"pool_size\": self.pool_size,\n                \"max_overflow\": self.max_overflow,\n                \"pool_timeout\": self.pool_timeout,\n                \"pool_recycle\": self.pool_recycle,\n                \"pool_pre_ping\": True\n            })\n            \n        return kwargs\n\n\nclass DatabaseManager:\n    \"\"\"Manages database connections and sessions.\"\"\"\n    \n    def __init__(self, config: Optional[DatabaseConfig] = None) -> None:\n        \"\"\"\n        Initialize database manager.\n        \n        Args:\n            config: Database configuration. If None, creates default config.\n        \"\"\"\n        self.config = config or DatabaseConfig()\n        self._engine: Optional[Engine] = None\n        self._session_factory: Optional[sessionmaker] = None\n        \n    @property\n    def engine(self) -> Engine:\n        \"\"\"Get or create database engine.\"\"\"\n        if self._engine is None:\n            self._engine = self._create_engine()\n        return self._engine\n        \n    @property\n    def session_factory(self) -> sessionmaker:\n        \"\"\"Get or create session factory.\"\"\"\n        if self._session_factory is None:\n            self._session_factory = sessionmaker(\n                bind=self.engine,\n                class_=Session,\n                expire_on_commit=False\n            )\n        return self._session_factory\n        \n    def _create_engine(self) -> Engine:\n        \"\"\"Create and configure SQLAlchemy engine.\"\"\"\n        try:\n            engine_kwargs = self.config.get_engine_kwargs()\n            engine = create_engine(self.config.database_url, **engine_kwargs)\n            \n            # Add event listeners\n            self._setup_engine_events(engine)\n            \n            logger.info(f\"Database engine created for URL: {self._mask_url(self.config.database_url)}\")\n            return engine\n            \n        except Exception as e:\n            logger.error(f\"Failed to create database engine: {e}\")\n            raise DatabaseConnectionError(f\"Failed to create database engine: {e}\") from e\n            \n    def _setup_engine_events(self, engine: Engine) -> None:\n        \"\"\"Set up SQLAlchemy engine event listeners.\"\"\"\n        \n        @event.listens_for(engine, \"connect\")\n        def set_sqlite_pragma(dbapi_connection, connection_record):\n            \"\"\"Set SQLite pragmas for better performance and reliability.\"\"\"\n            if \"sqlite\" in str(engine.url):\n                cursor = dbapi_connection.cursor()\n                cursor.execute(\"PRAGMA foreign_keys=ON\")\n                cursor.execute(\"PRAGMA journal_mode=WAL\")\n                cursor.execute(\"PRAGMA synchronous=NORMAL\")\n                cursor.execute(\"PRAGMA temp_store=MEMORY\")\n                cursor.execute(\"PRAGMA mmap_size=268435456\")  # 256MB\n                cursor.close()\n                \n        @event.listens_for(engine, \"checkout\")\n        def receive_checkout(dbapi_connection, connection_record, connection_proxy):\n            \"\"\"Log database connection checkout.\"\"\"\n            logger.debug(\"Database connection checked out from pool\")\n            \n        @event.listens_for(engine, \"checkin\")\n        def receive_checkin(dbapi_connection, connection_record):\n            \"\"\"Log database connection checkin.\"\"\"\n            logger.debug(\"Database connection returned to pool\")\n            \n    def _mask_url(self, url: str) -> str:\n        \"\"\"Mask sensitive information in database URL for logging.\"\"\"\n        if \"://\" not in url:\n            return url\n            \n        try:\n            protocol, rest = url.split(\"://\", 1)\n            if \"@\" in rest:\n                credentials, host_part = rest.split(\"@\", 1)\n                return f\"{protocol}://***:***@{host_part}\"\n            return url\n        except Exception:\n            return \"***masked***\"\n            \n    def create_session(self) -> Session:\n        \"\"\"\n        Create a new database session.\n        \n        Returns:\n            Session: New SQLAlchemy session\n            \n        Raises:\n            DatabaseConnectionError: If session creation fails\n        \"\"\"\n        try:\n            session = self.session_factory()\n            logger.debug(\"Database session created\")\n            return session\n        except Exception as e:\n            logger.error(f\"Failed to create database session: {e}\")\n            raise DatabaseConnectionError(f\"Failed to create database session: {e}\") from e\n            \n    @contextmanager\n    def get_session(self) -> Generator[Session, None, None]:\n        \"\"\"\n        Context manager for database sessions with automatic cleanup.\n        \n        Yields:\n            Session: Database session\n            \n        Raises:\n            DatabaseConnectionError: If session operations fail\n        \"\"\"\n        session = self.create_session()\n        try:\n            yield session\n            session.commit()\n            logger.debug(\"Database session committed successfully\")\n        except Exception as e:\n            session.rollback()\n            logger.error(f\"Database session rolled back due to error: {e}\")\n            raise\n        finally:\n            session.close()\n            logger.debug(\"Database session closed\")\n            \n    def init_database(self) -> None:\n        \"\"\"\n        Initialize database by creating all tables.\n        \n        Raises:\n            DatabaseConnectionError: If database initialization fails\n        \"\"\"\n        try:\n            Base.metadata.create_all(bind=self.engine)\n            logger.info(\"Database tables created successfully\")\n        except Exception as e:\n            logger.error(f\"Failed to initialize database: {e}\")\n            raise DatabaseConnectionError(f\"Failed to initialize database: {e}\") from e\n            \n    def drop_database(self) -> None:\n        \"\"\"\n        Drop all database tables.\n        \n        Warning: This will delete all data!\n        \n        Raises:\n            DatabaseConnectionError: If database drop fails\n        \"\"\"\n        try:\n            Base.metadata.drop_all(bind=self.engine)\n            logger.warning(\"All database tables dropped\")\n        except Exception as e:\n            logger.error(f\"Failed to drop database tables: {e}\")\n            raise DatabaseConnectionError(f",
      "file_type": "source",
      "semantic_unit_id": "SU-010",
      "component_id": "COMP-010",
      "description": "SQLAlchemy database connection setup, session management, and database initialization"
    },
    {
      "file_path": "src/database/migrations/001_initial_schema.py",
      "content": "\"\"\"\nInitial database schema migration for Hello World API\n\nCreates the foundational database tables for user management and task tracking\nwith proper indexes, constraints, and relationships.\n\nRevision ID: 001\nRevises: \nCreate Date: 2024-01-01 00:00:00.000000\n\nComponent ID: COMP-011\nSemantic Unit: SU-011\n\nAuthor: ASP Code Agent\n\"\"\"\nfrom typing import Sequence, Union\n\nfrom alembic import op\nimport sqlalchemy as sa\nfrom sqlalchemy.dialects import postgresql\n\n# revision identifiers, used by Alembic.\nrevision: str = '001'\ndown_revision: Union[str, None] = None\nbranch_labels: Union[str, Sequence[str], None] = None\ndepends_on: Union[str, Sequence[str], None] = None\n\n\ndef upgrade() -> None:\n    \"\"\"\n    Create initial database schema with users and tasks tables.\n    \n    Creates:\n    - users table with authentication and profile fields\n    - tasks table with task management fields\n    - Indexes for performance optimization\n    - Foreign key constraints for data integrity\n    \"\"\"\n    # Create users table\n    op.create_table(\n        'users',\n        sa.Column('id', sa.Integer(), nullable=False),\n        sa.Column('email', sa.String(length=255), nullable=False),\n        sa.Column('username', sa.String(length=50), nullable=False),\n        sa.Column('password_hash', sa.String(length=255), nullable=False),\n        sa.Column('first_name', sa.String(length=100), nullable=True),\n        sa.Column('last_name', sa.String(length=100), nullable=True),\n        sa.Column('is_active', sa.Boolean(), nullable=False, default=True),\n        sa.Column('is_verified', sa.Boolean(), nullable=False, default=False),\n        sa.Column('created_at', sa.DateTime(timezone=True), nullable=False, \n                 server_default=sa.text('CURRENT_TIMESTAMP')),\n        sa.Column('updated_at', sa.DateTime(timezone=True), nullable=False,\n                 server_default=sa.text('CURRENT_TIMESTAMP')),\n        sa.Column('last_login_at', sa.DateTime(timezone=True), nullable=True),\n        sa.PrimaryKeyConstraint('id'),\n        sa.UniqueConstraint('email'),\n        sa.UniqueConstraint('username')\n    )\n    \n    # Create tasks table\n    op.create_table(\n        'tasks',\n        sa.Column('id', sa.Integer(), nullable=False),\n        sa.Column('user_id', sa.Integer(), nullable=False),\n        sa.Column('title', sa.String(length=200), nullable=False),\n        sa.Column('description', sa.Text(), nullable=True),\n        sa.Column('status', sa.String(length=20), nullable=False, default='pending'),\n        sa.Column('priority', sa.String(length=10), nullable=False, default='medium'),\n        sa.Column('due_date', sa.DateTime(timezone=True), nullable=True),\n        sa.Column('completed_at', sa.DateTime(timezone=True), nullable=True),\n        sa.Column('created_at', sa.DateTime(timezone=True), nullable=False,\n                 server_default=sa.text('CURRENT_TIMESTAMP')),\n        sa.Column('updated_at', sa.DateTime(timezone=True), nullable=False,\n                 server_default=sa.text('CURRENT_TIMESTAMP')),\n        sa.PrimaryKeyConstraint('id'),\n        sa.ForeignKeyConstraint(['user_id'], ['users.id'], ondelete='CASCADE')\n    )\n    \n    # Create indexes for performance optimization\n    \n    # Users table indexes\n    op.create_index('idx_users_email', 'users', ['email'])\n    op.create_index('idx_users_username', 'users', ['username'])\n    op.create_index('idx_users_is_active', 'users', ['is_active'])\n    op.create_index('idx_users_created_at', 'users', ['created_at'])\n    \n    # Tasks table indexes\n    op.create_index('idx_tasks_user_id', 'tasks', ['user_id'])\n    op.create_index('idx_tasks_status', 'tasks', ['status'])\n    op.create_index('idx_tasks_priority', 'tasks', ['priority'])\n    op.create_index('idx_tasks_due_date', 'tasks', ['due_date'])\n    op.create_index('idx_tasks_created_at', 'tasks', ['created_at'])\n    op.create_index('idx_tasks_user_status', 'tasks', ['user_id', 'status'])\n    op.create_index('idx_tasks_user_priority', 'tasks', ['user_id', 'priority'])\n    \n    # Add check constraints for data validation\n    op.create_check_constraint(\n        'ck_users_email_format',\n        'users',\n        sa.text(\"email ~ '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}$'\")\n    )\n    \n    op.create_check_constraint(\n        'ck_users_username_length',\n        'users',\n        sa.text(\"length(username) >= 3\")\n    )\n    \n    op.create_check_constraint(\n        'ck_tasks_status_valid',\n        'tasks',\n        sa.text(\"status IN ('pending', 'in_progress', 'completed', 'cancelled')\")\n    )\n    \n    op.create_check_constraint(\n        'ck_tasks_priority_valid',\n        'tasks',\n        sa.text(\"priority IN ('low', 'medium', 'high', 'urgent')\")\n    )\n    \n    op.create_check_constraint(\n        'ck_tasks_title_length',\n        'tasks',\n        sa.text(\"length(trim(title)) > 0\")\n    )\n\n\ndef downgrade() -> None:\n    \"\"\"\n    Drop all tables and indexes created in upgrade.\n    \n    Removes:\n    - All indexes\n    - tasks table (with foreign key constraints)\n    - users table\n    \"\"\"\n    # Drop indexes first\n    op.drop_index('idx_tasks_user_priority', table_name='tasks')\n    op.drop_index('idx_tasks_user_status', table_name='tasks')\n    op.drop_index('idx_tasks_created_at', table_name='tasks')\n    op.drop_index('idx_tasks_due_date', table_name='tasks')\n    op.drop_index('idx_tasks_priority', table_name='tasks')\n    op.drop_index('idx_tasks_status', table_name='tasks')\n    op.drop_index('idx_tasks_user_id', table_name='tasks')\n    \n    op.drop_index('idx_users_created_at', table_name='users')\n    op.drop_index('idx_users_is_active', table_name='users')\n    op.drop_index('idx_users_username', table_name='users')\n    op.drop_index('idx_users_email', table_name='users')\n    \n    # Drop tables (tasks first due to foreign key dependency)\n    op.drop_table('tasks')\n    op.drop_table('users')",
      "file_type": "schema",
      "semantic_unit_id": "SU-011",
      "component_id": "COMP-011",
      "description": "Alembic migration script for creating initial user and task tables with indexes and constraints"
    },
    {
      "file_path": "tests/test_auth_api.py",
      "content": "\"\"\"\nComprehensive integration tests for authentication endpoints\n\nTests authentication API endpoints including success cases, validation errors,\nand security scenarios for user registration, login, and token validation.\n\nComponent ID: COMP-002\nSemantic Unit: SU-002\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom unittest.mock import Mock, patch\nimport json\nfrom datetime import datetime, timedelta\nimport jwt\nfrom passlib.context import CryptContext\n\nfrom src.api.auth import app, get_password_hash, verify_password, create_access_token, verify_token\n\n\n@pytest.fixture\ndef client():\n    \"\"\"Create test client for FastAPI authentication application.\"\"\"\n    return TestClient(app)\n\n\n@pytest.fixture\ndef mock_user_data():\n    \"\"\"Mock user data for testing.\"\"\"\n    return {\n        \"username\": \"testuser\",\n        \"email\": \"test@example.com\",\n        \"password\": \"SecurePass123!\"\n    }\n\n\n@pytest.fixture\ndef mock_login_data():\n    \"\"\"Mock login data for testing.\"\"\"\n    return {\n        \"username\": \"testuser\",\n        \"password\": \"SecurePass123!\"\n    }\n\n\n@pytest.fixture\ndef mock_invalid_user_data():\n    \"\"\"Mock invalid user data for testing validation.\"\"\"\n    return {\n        \"username\": \"ab\",  # Too short\n        \"email\": \"invalid-email\",  # Invalid format\n        \"password\": \"123\"  # Too weak\n    }\n\n\n@pytest.fixture\ndef mock_database():\n    \"\"\"Mock database for testing.\"\"\"\n    return {\n        \"users\": {\n            \"testuser\": {\n                \"username\": \"testuser\",\n                \"email\": \"test@example.com\",\n                \"hashed_password\": get_password_hash(\"SecurePass123!\"),\n                \"created_at\": datetime.utcnow().isoformat()\n            }\n        }\n    }\n\n\n@pytest.fixture\ndef valid_token():\n    \"\"\"Create a valid JWT token for testing.\"\"\"\n    return create_access_token(data={\"sub\": \"testuser\"})\n\n\n@pytest.fixture\ndef expired_token():\n    \"\"\"Create an expired JWT token for testing.\"\"\"\n    return create_access_token(\n        data={\"sub\": \"testuser\"}, \n        expires_delta=timedelta(minutes=-1)\n    )\n\n\nclass TestUserRegistration:\n    \"\"\"Test cases for user registration endpoint.\"\"\"\n\n    def test_register_user_success(self, client, mock_user_data):\n        \"\"\"Test successful user registration returns 201 and user data.\"\"\"\n        with patch('src.api.auth.save_user_to_database') as mock_save:\n            mock_save.return_value = True\n            \n            response = client.post(\"/auth/register\", json=mock_user_data)\n            \n            assert response.status_code == 201\n            data = response.json()\n            assert \"user_id\" in data\n            assert data[\"username\"] == mock_user_data[\"username\"]\n            assert data[\"email\"] == mock_user_data[\"email\"]\n            assert \"password\" not in data\n            assert \"hashed_password\" not in data\n            assert \"created_at\" in data\n\n    def test_register_user_duplicate_username(self, client, mock_user_data):\n        \"\"\"Test registration with duplicate username returns 409 conflict.\"\"\"\n        with patch('src.api.auth.user_exists') as mock_exists:\n            mock_exists.return_value = True\n            \n            response = client.post(\"/auth/register\", json=mock_user_data)\n            \n            assert response.status_code == 409\n            data = response.json()\n            assert data[\"error\"] == \"USER_EXISTS\"\n            assert \"already exists\" in data[\"message\"].lower()\n\n    def test_register_user_invalid_username_too_short(self, client):\n        \"\"\"Test registration with username too short returns 400.\"\"\"\n        user_data = {\n            \"username\": \"ab\",\n            \"email\": \"test@example.com\",\n            \"password\": \"SecurePass123!\"\n        }\n        \n        response = client.post(\"/auth/register\", json=user_data)\n        \n        assert response.status_code == 400\n        data = response.json()\n        assert data[\"error\"] == \"VALIDATION_ERROR\"\n        assert \"username\" in data[\"message\"].lower()\n\n    def test_register_user_invalid_username_too_long(self, client):\n        \"\"\"Test registration with username too long returns 400.\"\"\"\n        user_data = {\n            \"username\": \"a\" * 51,  # 51 characters\n            \"email\": \"test@example.com\",\n            \"password\": \"SecurePass123!\"\n        }\n        \n        response = client.post(\"/auth/register\", json=user_data)\n        \n        assert response.status_code == 400\n        data = response.json()\n        assert data[\"error\"] == \"VALIDATION_ERROR\"\n        assert \"username\" in data[\"message\"].lower()\n\n    def test_register_user_invalid_username_special_chars(self, client):\n        \"\"\"Test registration with invalid username characters returns 400.\"\"\"\n        user_data = {\n            \"username\": \"test@user\",\n            \"email\": \"test@example.com\",\n            \"password\": \"SecurePass123!\"\n        }\n        \n        response = client.post(\"/auth/register\", json=user_data)\n        \n        assert response.status_code == 400\n        data = response.json()\n        assert data[\"error\"] == \"VALIDATION_ERROR\"\n        assert \"username\" in data[\"message\"].lower()\n\n    def test_register_user_invalid_email_format(self, client):\n        \"\"\"Test registration with invalid email format returns 400.\"\"\"\n        user_data = {\n            \"username\": \"testuser\",\n            \"email\": \"invalid-email\",\n            \"password\": \"SecurePass123!\"\n        }\n        \n        response = client.post(\"/auth/register\", json=user_data)\n        \n        assert response.status_code == 400\n        data = response.json()\n        assert data[\"error\"] == \"VALIDATION_ERROR\"\n        assert \"email\" in data[\"message\"].lower()\n\n    def test_register_user_invalid_password_too_short(self, client):\n        \"\"\"Test registration with password too short returns 400.\"\"\"\n        user_data = {\n            \"username\": \"testuser\",\n            \"email\": \"test@example.com\",\n            \"password\": \"123\"\n        }\n        \n        response = client.post(\"/auth/register\", json=user_data)\n        \n        assert response.status_code == 400\n        data = response.json()\n        assert data[\"error\"] == \"VALIDATION_ERROR\"\n        assert \"password\" in data[\"message\"].lower()\n\n    def test_register_user_invalid_password_no_uppercase(self, client):\n        \"\"\"Test registration with password missing uppercase returns 400.\"\"\"\n        user_data = {\n            \"username\": \"testuser\",\n            \"email\": \"test@example.com\",\n            \"password\": \"securepass123!\"\n        }\n        \n        response = client.post(\"/auth/register\", json=user_data)\n        \n        assert response.status_code == 400\n        data = response.json()\n        assert data[\"error\"] == \"VALIDATION_ERROR\"\n        assert \"password\" in data[\"message\"].lower()\n\n    def test_register_user_invalid_password_no_lowercase(self, client):\n        \"\"\"Test registration with password missing lowercase returns 400.\"\"\"\n        user_data = {\n            \"username\": \"testuser\",\n            \"email\": \"test@example.com\",\n            \"password\": \"SECUREPASS123!\"\n        }\n        \n        response = client.post(\"/auth/register\", json=user_data)\n        \n        assert response.status_code == 400\n        data = response.json()\n        assert data[\"error\"] == \"VALIDATION_ERROR\"\n        assert \"password\" in data[\"message\"].lower()\n\n    def test_register_user_invalid_password_no_digit(self, client):\n        \"\"\"Test registration with password missing digit returns 400.\"\"\"\n        user_data = {\n            \"username\": \"testuser\",\n            \"email\": \"test@example.com\",\n            \"password\": \"SecurePass!\"\n        }\n        \n        response = client.post(\"/auth/register\", json=user_data)",
      "file_type": "test",
      "semantic_unit_id": "SU-002",
      "component_id": "COMP-002",
      "description": "Comprehensive integration tests for authentication endpoints including success cases, validation errors, and security scenarios"
    },
    {
      "file_path": "tests/test_tasks_api.py",
      "content": "\"\"\"\nIntegration tests for task management endpoints\n\nTests authentication, authorization, and CRUD operations for task management API.\nCovers all endpoints with various scenarios including edge cases and error conditions.\n\nComponent ID: COMP-003\nSemantic Unit: SU-003\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom unittest.mock import Mock, patch\nimport json\nfrom datetime import datetime, timedelta\nfrom typing import Dict, Any, Optional\n\nfrom src.api.tasks import app\nfrom tests.conftest import (\n    create_test_user,\n    create_test_task,\n    get_auth_headers,\n    cleanup_test_data\n)\n\n\nclass TestTasksAPI:\n    \"\"\"Integration tests for task management API endpoints.\"\"\"\n\n    @pytest.fixture(autouse=True)\n    def setup_and_teardown(self):\n        \"\"\"Setup and teardown for each test.\"\"\"\n        self.client = TestClient(app)\n        self.test_user_id = None\n        self.test_task_ids = []\n        yield\n        # Cleanup after each test\n        cleanup_test_data(self.test_user_id, self.test_task_ids)\n\n    def _create_authenticated_user(self) -> Dict[str, Any]:\n        \"\"\"Create a test user and return user data with auth headers.\"\"\"\n        user_data = create_test_user()\n        self.test_user_id = user_data[\"id\"]\n        return user_data\n\n    def _create_test_task(self, user_id: int, **kwargs) -> Dict[str, Any]:\n        \"\"\"Create a test task and track for cleanup.\"\"\"\n        task_data = create_test_task(user_id, **kwargs)\n        self.test_task_ids.append(task_data[\"id\"])\n        return task_data\n\n\nclass TestCreateTask(TestTasksAPI):\n    \"\"\"Tests for POST /tasks endpoint.\"\"\"\n\n    def test_create_task_success(self):\n        \"\"\"Test successful task creation with valid data.\"\"\"\n        user = self._create_authenticated_user()\n        headers = get_auth_headers(user[\"token\"])\n        \n        task_data = {\n            \"title\": \"Test Task\",\n            \"description\": \"Test task description\",\n            \"priority\": \"medium\",\n            \"due_date\": \"2024-12-31T23:59:59Z\"\n        }\n        \n        response = self.client.post(\"/tasks\", json=task_data, headers=headers)\n        \n        assert response.status_code == 201\n        data = response.json()\n        assert data[\"title\"] == task_data[\"title\"]\n        assert data[\"description\"] == task_data[\"description\"]\n        assert data[\"priority\"] == task_data[\"priority\"]\n        assert data[\"due_date\"] == task_data[\"due_date\"]\n        assert data[\"status\"] == \"pending\"\n        assert data[\"user_id\"] == user[\"id\"]\n        assert \"id\" in data\n        assert \"created_at\" in data\n        assert \"updated_at\" in data\n        \n        self.test_task_ids.append(data[\"id\"])\n\n    def test_create_task_minimal_data(self):\n        \"\"\"Test task creation with only required fields.\"\"\"\n        user = self._create_authenticated_user()\n        headers = get_auth_headers(user[\"token\"])\n        \n        task_data = {\n            \"title\": \"Minimal Task\"\n        }\n        \n        response = self.client.post(\"/tasks\", json=task_data, headers=headers)\n        \n        assert response.status_code == 201\n        data = response.json()\n        assert data[\"title\"] == task_data[\"title\"]\n        assert data[\"description\"] is None\n        assert data[\"priority\"] == \"medium\"  # default value\n        assert data[\"due_date\"] is None\n        assert data[\"status\"] == \"pending\"\n        \n        self.test_task_ids.append(data[\"id\"])\n\n    def test_create_task_invalid_title_empty(self):\n        \"\"\"Test task creation fails with empty title.\"\"\"\n        user = self._create_authenticated_user()\n        headers = get_auth_headers(user[\"token\"])\n        \n        task_data = {\n            \"title\": \"\"\n        }\n        \n        response = self.client.post(\"/tasks\", json=task_data, headers=headers)\n        \n        assert response.status_code == 400\n        data = response.json()\n        assert data[\"error\"] == \"VALIDATION_ERROR\"\n        assert \"title\" in data[\"message\"].lower()\n\n    def test_create_task_invalid_title_too_long(self):\n        \"\"\"Test task creation fails with title exceeding 200 characters.\"\"\"\n        user = self._create_authenticated_user()\n        headers = get_auth_headers(user[\"token\"])\n        \n        task_data = {\n            \"title\": \"x\" * 201\n        }\n        \n        response = self.client.post(\"/tasks\", json=task_data, headers=headers)\n        \n        assert response.status_code == 400\n        data = response.json()\n        assert data[\"error\"] == \"VALIDATION_ERROR\"\n        assert \"title\" in data[\"message\"].lower()\n\n    def test_create_task_invalid_priority(self):\n        \"\"\"Test task creation fails with invalid priority value.\"\"\"\n        user = self._create_authenticated_user()\n        headers = get_auth_headers(user[\"token\"])\n        \n        task_data = {\n            \"title\": \"Test Task\",\n            \"priority\": \"invalid\"\n        }\n        \n        response = self.client.post(\"/tasks\", json=task_data, headers=headers)\n        \n        assert response.status_code == 400\n        data = response.json()\n        assert data[\"error\"] == \"VALIDATION_ERROR\"\n        assert \"priority\" in data[\"message\"].lower()\n\n    def test_create_task_invalid_due_date_format(self):\n        \"\"\"Test task creation fails with invalid due date format.\"\"\"\n        user = self._create_authenticated_user()\n        headers = get_auth_headers(user[\"token\"])\n        \n        task_data = {\n            \"title\": \"Test Task\",\n            \"due_date\": \"invalid-date\"\n        }\n        \n        response = self.client.post(\"/tasks\", json=task_data, headers=headers)\n        \n        assert response.status_code == 400\n        data = response.json()\n        assert data[\"error\"] == \"VALIDATION_ERROR\"\n        assert \"due_date\" in data[\"message\"].lower()\n\n    def test_create_task_due_date_in_past(self):\n        \"\"\"Test task creation fails with due date in the past.\"\"\"\n        user = self._create_authenticated_user()\n        headers = get_auth_headers(user[\"token\"])\n        \n        past_date = (datetime.utcnow() - timedelta(days=1)).isoformat() + \"Z\"\n        task_data = {\n            \"title\": \"Test Task\",\n            \"due_date\": past_date\n        }\n        \n        response = self.client.post(\"/tasks\", json=task_data, headers=headers)\n        \n        assert response.status_code == 400\n        data = response.json()\n        assert data[\"error\"] == \"INVALID_DUE_DATE\"\n        assert \"past\" in data[\"message\"].lower()\n\n    def test_create_task_no_authentication(self):\n        \"\"\"Test task creation fails without authentication.\"\"\"\n        task_data = {\n            \"title\": \"Test Task\"\n        }\n        \n        response = self.client.post(\"/tasks\", json=task_data)\n        \n        assert response.status_code == 401\n        data = response.json()\n        assert data[\"error\"] == \"AUTHENTICATION_REQUIRED\"\n\n    def test_create_task_invalid_token(self):\n        \"\"\"Test task creation fails with invalid authentication token.\"\"\"\n        headers = {\"Authorization\": \"Bearer invalid-token\"}\n        task_data = {\n            \"title\": \"Test Task\"\n        }\n        \n        response = self.client.post(\"/tasks\", json=task_data, headers=headers)\n        \n        assert response.status_code == 401\n        data = response.json()\n        assert data[\"error\"] == \"INVALID_TOKEN\"\n\n\nclass TestGetTasks(TestTasksAPI):\n    \"\"\"Tests for GET /tasks endpoint.\"\"\"\n\n    def test_get_tasks_empty_",
      "file_type": "test",
      "semantic_unit_id": "SU-003",
      "component_id": "COMP-003",
      "description": "Integration tests for task management endpoints with authentication, authorization, and CRUD operation validation"
    },
    {
      "file_path": "tests/test_user_model.py",
      "content": "\"\"\"\nUnit tests for User model including field validation, relationships, and database operations.\n\nTests the User model to verify field validation, database constraints, relationships,\nand CRUD operations work correctly.\n\nSemantic Unit: SU-004\nComponent: COMP-004\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport pytest\nfrom datetime import datetime, timezone\nfrom unittest.mock import Mock, patch\nfrom sqlalchemy.exc import IntegrityError\nfrom sqlalchemy.orm import Session\n\nfrom src.models.user import User, UserRole, UserStatus\nfrom tests.conftest import TestSession\n\n\nclass TestUserModel:\n    \"\"\"Test suite for User model basic functionality.\"\"\"\n\n    def test_user_creation_with_required_fields(self, db_session: TestSession):\n        \"\"\"Test that User can be created with only required fields.\"\"\"\n        user = User(\n            username=\"testuser\",\n            email=\"test@example.com\",\n            password_hash=\"hashed_password_123\"\n        )\n        \n        db_session.add(user)\n        db_session.commit()\n        \n        assert user.id is not None\n        assert user.username == \"testuser\"\n        assert user.email == \"test@example.com\"\n        assert user.password_hash == \"hashed_password_123\"\n        assert user.role == UserRole.USER  # Default role\n        assert user.status == UserStatus.ACTIVE  # Default status\n        assert user.created_at is not None\n        assert user.updated_at is not None\n        assert user.last_login is None\n        assert user.first_name is None\n        assert user.last_name is None\n\n    def test_user_creation_with_all_fields(self, db_session: TestSession):\n        \"\"\"Test that User can be created with all fields populated.\"\"\"\n        now = datetime.now(timezone.utc)\n        \n        user = User(\n            username=\"fulluser\",\n            email=\"full@example.com\",\n            password_hash=\"hashed_password_456\",\n            first_name=\"John\",\n            last_name=\"Doe\",\n            role=UserRole.ADMIN,\n            status=UserStatus.INACTIVE,\n            last_login=now\n        )\n        \n        db_session.add(user)\n        db_session.commit()\n        \n        assert user.username == \"fulluser\"\n        assert user.email == \"full@example.com\"\n        assert user.first_name == \"John\"\n        assert user.last_name == \"Doe\"\n        assert user.role == UserRole.ADMIN\n        assert user.status == UserStatus.INACTIVE\n        assert user.last_login == now\n\n    def test_user_string_representation(self, db_session: TestSession):\n        \"\"\"Test that User __str__ method returns expected format.\"\"\"\n        user = User(\n            username=\"repruser\",\n            email=\"repr@example.com\",\n            password_hash=\"hashed_password_789\"\n        )\n        \n        expected = \"User(id=None, username='repruser', email='repr@example.com')\"\n        assert str(user) == expected\n\n    def test_user_repr_representation(self, db_session: TestSession):\n        \"\"\"Test that User __repr__ method returns expected format.\"\"\"\n        user = User(\n            username=\"repruser\",\n            email=\"repr@example.com\",\n            password_hash=\"hashed_password_789\"\n        )\n        \n        expected = \"User(id=None, username='repruser', email='repr@example.com')\"\n        assert repr(user) == expected\n\n\nclass TestUserValidation:\n    \"\"\"Test suite for User model field validation.\"\"\"\n\n    def test_username_required(self, db_session: TestSession):\n        \"\"\"Test that username is required and cannot be None.\"\"\"\n        user = User(\n            username=None,\n            email=\"test@example.com\",\n            password_hash=\"hashed_password\"\n        )\n        \n        db_session.add(user)\n        \n        with pytest.raises(IntegrityError):\n            db_session.commit()\n\n    def test_username_cannot_be_empty(self, db_session: TestSession):\n        \"\"\"Test that username cannot be empty string.\"\"\"\n        user = User(\n            username=\"\",\n            email=\"test@example.com\",\n            password_hash=\"hashed_password\"\n        )\n        \n        db_session.add(user)\n        \n        with pytest.raises(IntegrityError):\n            db_session.commit()\n\n    def test_username_max_length(self, db_session: TestSession):\n        \"\"\"Test that username cannot exceed maximum length of 50 characters.\"\"\"\n        long_username = \"a\" * 51  # 51 characters\n        \n        user = User(\n            username=long_username,\n            email=\"test@example.com\",\n            password_hash=\"hashed_password\"\n        )\n        \n        db_session.add(user)\n        \n        with pytest.raises(IntegrityError):\n            db_session.commit()\n\n    def test_username_valid_length(self, db_session: TestSession):\n        \"\"\"Test that username with valid length is accepted.\"\"\"\n        valid_username = \"a\" * 50  # Exactly 50 characters\n        \n        user = User(\n            username=valid_username,\n            email=\"test@example.com\",\n            password_hash=\"hashed_password\"\n        )\n        \n        db_session.add(user)\n        db_session.commit()\n        \n        assert user.username == valid_username\n\n    def test_email_required(self, db_session: TestSession):\n        \"\"\"Test that email is required and cannot be None.\"\"\"\n        user = User(\n            username=\"testuser\",\n            email=None,\n            password_hash=\"hashed_password\"\n        )\n        \n        db_session.add(user)\n        \n        with pytest.raises(IntegrityError):\n            db_session.commit()\n\n    def test_email_cannot_be_empty(self, db_session: TestSession):\n        \"\"\"Test that email cannot be empty string.\"\"\"\n        user = User(\n            username=\"testuser\",\n            email=\"\",\n            password_hash=\"hashed_password\"\n        )\n        \n        db_session.add(user)\n        \n        with pytest.raises(IntegrityError):\n            db_session.commit()\n\n    def test_email_max_length(self, db_session: TestSession):\n        \"\"\"Test that email cannot exceed maximum length of 255 characters.\"\"\"\n        long_email = \"a\" * 240 + \"@example.com\"  # Over 255 characters\n        \n        user = User(\n            username=\"testuser\",\n            email=long_email,\n            password_hash=\"hashed_password\"\n        )\n        \n        db_session.add(user)\n        \n        with pytest.raises(IntegrityError):\n            db_session.commit()\n\n    def test_password_hash_required(self, db_session: TestSession):\n        \"\"\"Test that password_hash is required and cannot be None.\"\"\"\n        user = User(\n            username=\"testuser\",\n            email=\"test@example.com\",\n            password_hash=None\n        )\n        \n        db_session.add(user)\n        \n        with pytest.raises(IntegrityError):\n            db_session.commit()\n\n    def test_first_name_max_length(self, db_session: TestSession):\n        \"\"\"Test that first_name cannot exceed maximum length of 100 characters.\"\"\"\n        long_first_name = \"a\" * 101\n        \n        user = User(\n            username=\"testuser\",\n            email=\"test@example.com\",\n            password_hash=\"hashed_password\",\n            first_name=long_first_name\n        )\n        \n        db_session.add(user)\n        \n        with pytest.raises(IntegrityError):\n            db_session.commit()\n\n    def test_last_name_max_length(self, db_session: TestSession):\n        \"\"\"Test that last_name cannot exceed maximum length of 100 characters.\"\"\"\n        long_last_name = \"a\" * 101\n        \n        user = User(\n            username=\"testuser\",\n            email=\"test@example.com\",\n            password_hash=\"hashed_password\",\n            last_name=long_last_name\n        )\n        \n        db_session.add(user)",
      "file_type": "test",
      "semantic_unit_id": "SU-004",
      "component_id": "COMP-004",
      "description": "Unit tests for User model including field validation, relationships, and database operations"
    },
    {
      "file_path": "tests/test_task_model.py",
      "content": "\"\"\"\nUnit tests for Task model including CRUD operations, status transitions, and user relationships.\n\nTests all Task model functionality including creation, updates, status changes,\nand relationships with User model.\n\nComponent ID: COMP-005\nSemantic Unit: SU-005\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport pytest\nfrom datetime import datetime, timedelta\nfrom unittest.mock import Mock, patch\nfrom sqlalchemy.exc import IntegrityError, SQLAlchemyError\nfrom sqlalchemy.orm import Session\n\nfrom src.models.task import Task, TaskStatus, TaskPriority\nfrom src.models.user import User\n\n\nclass TestTaskModel:\n    \"\"\"Test suite for Task model basic functionality.\"\"\"\n\n    def test_task_creation_with_required_fields(self, db_session: Session, sample_user: User):\n        \"\"\"Test that Task can be created with only required fields.\"\"\"\n        task = Task(\n            title=\"Test Task\",\n            user_id=sample_user.id\n        )\n        db_session.add(task)\n        db_session.commit()\n        \n        assert task.id is not None\n        assert task.title == \"Test Task\"\n        assert task.user_id == sample_user.id\n        assert task.status == TaskStatus.PENDING\n        assert task.priority == TaskPriority.MEDIUM\n        assert task.description is None\n        assert task.due_date is None\n        assert isinstance(task.created_at, datetime)\n        assert isinstance(task.updated_at, datetime)\n\n    def test_task_creation_with_all_fields(self, db_session: Session, sample_user: User):\n        \"\"\"Test that Task can be created with all fields specified.\"\"\"\n        due_date = datetime.utcnow() + timedelta(days=7)\n        task = Task(\n            title=\"Complete Task\",\n            description=\"This is a test task with all fields\",\n            status=TaskStatus.IN_PROGRESS,\n            priority=TaskPriority.HIGH,\n            due_date=due_date,\n            user_id=sample_user.id\n        )\n        db_session.add(task)\n        db_session.commit()\n        \n        assert task.title == \"Complete Task\"\n        assert task.description == \"This is a test task with all fields\"\n        assert task.status == TaskStatus.IN_PROGRESS\n        assert task.priority == TaskPriority.HIGH\n        assert task.due_date == due_date\n        assert task.user_id == sample_user.id\n\n    def test_task_creation_without_title_raises_error(self, db_session: Session, sample_user: User):\n        \"\"\"Test that creating Task without title raises IntegrityError.\"\"\"\n        task = Task(user_id=sample_user.id)\n        db_session.add(task)\n        \n        with pytest.raises(IntegrityError):\n            db_session.commit()\n\n    def test_task_creation_without_user_id_raises_error(self, db_session: Session):\n        \"\"\"Test that creating Task without user_id raises IntegrityError.\"\"\"\n        task = Task(title=\"Test Task\")\n        db_session.add(task)\n        \n        with pytest.raises(IntegrityError):\n            db_session.commit()\n\n    def test_task_creation_with_invalid_user_id_raises_error(self, db_session: Session):\n        \"\"\"Test that creating Task with non-existent user_id raises IntegrityError.\"\"\"\n        task = Task(title=\"Test Task\", user_id=99999)\n        db_session.add(task)\n        \n        with pytest.raises(IntegrityError):\n            db_session.commit()\n\n    def test_task_title_max_length_validation(self, db_session: Session, sample_user: User):\n        \"\"\"Test that Task title respects maximum length constraint.\"\"\"\n        long_title = \"x\" * 201  # Assuming max length is 200\n        task = Task(title=long_title, user_id=sample_user.id)\n        db_session.add(task)\n        \n        with pytest.raises(IntegrityError):\n            db_session.commit()\n\n    def test_task_description_can_be_long(self, db_session: Session, sample_user: User):\n        \"\"\"Test that Task description can handle long text.\"\"\"\n        long_description = \"This is a very long description. \" * 100\n        task = Task(\n            title=\"Test Task\",\n            description=long_description,\n            user_id=sample_user.id\n        )\n        db_session.add(task)\n        db_session.commit()\n        \n        assert task.description == long_description\n\n    def test_task_timestamps_auto_generated(self, db_session: Session, sample_user: User):\n        \"\"\"Test that created_at and updated_at are automatically set.\"\"\"\n        before_creation = datetime.utcnow()\n        task = Task(title=\"Test Task\", user_id=sample_user.id)\n        db_session.add(task)\n        db_session.commit()\n        after_creation = datetime.utcnow()\n        \n        assert before_creation <= task.created_at <= after_creation\n        assert before_creation <= task.updated_at <= after_creation\n        assert task.created_at == task.updated_at\n\n    def test_task_updated_at_changes_on_modification(self, db_session: Session, sample_user: User):\n        \"\"\"Test that updated_at changes when task is modified.\"\"\"\n        task = Task(title=\"Test Task\", user_id=sample_user.id)\n        db_session.add(task)\n        db_session.commit()\n        original_updated_at = task.updated_at\n        \n        # Wait a small amount to ensure timestamp difference\n        import time\n        time.sleep(0.01)\n        \n        task.title = \"Updated Task\"\n        db_session.commit()\n        \n        assert task.updated_at > original_updated_at\n\n\nclass TestTaskStatusTransitions:\n    \"\"\"Test suite for Task status transitions and validation.\"\"\"\n\n    def test_task_default_status_is_pending(self, db_session: Session, sample_user: User):\n        \"\"\"Test that new tasks have PENDING status by default.\"\"\"\n        task = Task(title=\"Test Task\", user_id=sample_user.id)\n        db_session.add(task)\n        db_session.commit()\n        \n        assert task.status == TaskStatus.PENDING\n\n    def test_task_status_can_be_set_to_in_progress(self, db_session: Session, sample_user: User):\n        \"\"\"Test that task status can be changed to IN_PROGRESS.\"\"\"\n        task = Task(title=\"Test Task\", user_id=sample_user.id)\n        db_session.add(task)\n        db_session.commit()\n        \n        task.status = TaskStatus.IN_PROGRESS\n        db_session.commit()\n        \n        assert task.status == TaskStatus.IN_PROGRESS\n\n    def test_task_status_can_be_set_to_completed(self, db_session: Session, sample_user: User):\n        \"\"\"Test that task status can be changed to COMPLETED.\"\"\"\n        task = Task(title=\"Test Task\", user_id=sample_user.id)\n        db_session.add(task)\n        db_session.commit()\n        \n        task.status = TaskStatus.COMPLETED\n        db_session.commit()\n        \n        assert task.status == TaskStatus.COMPLETED\n\n    def test_task_status_can_be_set_to_cancelled(self, db_session: Session, sample_user: User):\n        \"\"\"Test that task status can be changed to CANCELLED.\"\"\"\n        task = Task(title=\"Test Task\", user_id=sample_user.id)\n        db_session.add(task)\n        db_session.commit()\n        \n        task.status = TaskStatus.CANCELLED\n        db_session.commit()\n        \n        assert task.status == TaskStatus.CANCELLED\n\n    def test_task_status_transition_from_pending_to_in_progress(self, db_session: Session, sample_user: User):\n        \"\"\"Test valid status transition from PENDING to IN_PROGRESS.\"\"\"\n        task = Task(title=\"Test Task\", user_id=sample_user.id, status=TaskStatus.PENDING)\n        db_session.add(task",
      "file_type": "test",
      "semantic_unit_id": "SU-005",
      "component_id": "COMP-005",
      "description": "Unit tests for Task model including CRUD operations, status transitions, and user relationships"
    },
    {
      "file_path": "tests/test_jwt_utils.py",
      "content": "\"\"\"\nUnit tests for JWT utilities\n\nTests JWT token generation, validation, expiration handling, and error scenarios.\n\nComponent ID: COMP-008\nSemantic Unit: SU-008\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport pytest\nfrom datetime import datetime, timedelta, timezone\nfrom unittest.mock import patch, MagicMock\nimport jwt\nfrom freezegun import freeze_time\n\nfrom src.utils.jwt_utils import (\n    JWTUtils,\n    TokenExpiredError,\n    InvalidTokenError,\n    TokenDecodeError\n)\n\n\nclass TestJWTUtils:\n    \"\"\"Test suite for JWTUtils class.\"\"\"\n\n    @pytest.fixture\n    def jwt_utils(self):\n        \"\"\"Create JWTUtils instance with test configuration.\"\"\"\n        return JWTUtils(\n            secret_key=\"test_secret_key_12345\",\n            algorithm=\"HS256\",\n            access_token_expire_minutes=30,\n            refresh_token_expire_days=7\n        )\n\n    @pytest.fixture\n    def sample_payload(self):\n        \"\"\"Sample payload for token generation.\"\"\"\n        return {\n            \"user_id\": \"123\",\n            \"username\": \"testuser\",\n            \"email\": \"test@example.com\"\n        }\n\n    def test_init_with_default_values(self):\n        \"\"\"Test JWTUtils initialization with default values.\"\"\"\n        jwt_utils = JWTUtils(secret_key=\"test_key\")\n        \n        assert jwt_utils.secret_key == \"test_key\"\n        assert jwt_utils.algorithm == \"HS256\"\n        assert jwt_utils.access_token_expire_minutes == 15\n        assert jwt_utils.refresh_token_expire_days == 30\n\n    def test_init_with_custom_values(self, jwt_utils):\n        \"\"\"Test JWTUtils initialization with custom values.\"\"\"\n        assert jwt_utils.secret_key == \"test_secret_key_12345\"\n        assert jwt_utils.algorithm == \"HS256\"\n        assert jwt_utils.access_token_expire_minutes == 30\n        assert jwt_utils.refresh_token_expire_days == 7\n\n    def test_init_with_empty_secret_key_raises_error(self):\n        \"\"\"Test that empty secret key raises ValueError.\"\"\"\n        with pytest.raises(ValueError, match=\"Secret key cannot be empty\"):\n            JWTUtils(secret_key=\"\")\n\n    def test_init_with_none_secret_key_raises_error(self):\n        \"\"\"Test that None secret key raises ValueError.\"\"\"\n        with pytest.raises(ValueError, match=\"Secret key cannot be empty\"):\n            JWTUtils(secret_key=None)\n\n    def test_init_with_invalid_algorithm_raises_error(self):\n        \"\"\"Test that invalid algorithm raises ValueError.\"\"\"\n        with pytest.raises(ValueError, match=\"Unsupported algorithm\"):\n            JWTUtils(secret_key=\"test\", algorithm=\"INVALID\")\n\n    def test_generate_access_token_success(self, jwt_utils, sample_payload):\n        \"\"\"Test successful access token generation.\"\"\"\n        with freeze_time(\"2023-01-01 12:00:00\"):\n            token = jwt_utils.generate_access_token(sample_payload)\n            \n            assert isinstance(token, str)\n            assert len(token) > 0\n            \n            # Decode token to verify payload\n            decoded = jwt.decode(\n                token,\n                jwt_utils.secret_key,\n                algorithms=[jwt_utils.algorithm]\n            )\n            \n            assert decoded[\"user_id\"] == \"123\"\n            assert decoded[\"username\"] == \"testuser\"\n            assert decoded[\"email\"] == \"test@example.com\"\n            assert decoded[\"type\"] == \"access\"\n            assert \"exp\" in decoded\n            assert \"iat\" in decoded\n\n    def test_generate_access_token_with_custom_expiry(self, jwt_utils, sample_payload):\n        \"\"\"Test access token generation with custom expiry time.\"\"\"\n        custom_expiry = 60  # 60 minutes\n        \n        with freeze_time(\"2023-01-01 12:00:00\"):\n            token = jwt_utils.generate_access_token(sample_payload, expires_delta=custom_expiry)\n            \n            decoded = jwt.decode(\n                token,\n                jwt_utils.secret_key,\n                algorithms=[jwt_utils.algorithm]\n            )\n            \n            expected_exp = datetime(2023, 1, 1, 13, 0, 0, tzinfo=timezone.utc).timestamp()\n            assert decoded[\"exp\"] == expected_exp\n\n    def test_generate_refresh_token_success(self, jwt_utils, sample_payload):\n        \"\"\"Test successful refresh token generation.\"\"\"\n        with freeze_time(\"2023-01-01 12:00:00\"):\n            token = jwt_utils.generate_refresh_token(sample_payload)\n            \n            assert isinstance(token, str)\n            assert len(token) > 0\n            \n            # Decode token to verify payload\n            decoded = jwt.decode(\n                token,\n                jwt_utils.secret_key,\n                algorithms=[jwt_utils.algorithm]\n            )\n            \n            assert decoded[\"user_id\"] == \"123\"\n            assert decoded[\"username\"] == \"testuser\"\n            assert decoded[\"email\"] == \"test@example.com\"\n            assert decoded[\"type\"] == \"refresh\"\n            assert \"exp\" in decoded\n            assert \"iat\" in decoded\n\n    def test_generate_refresh_token_with_custom_expiry(self, jwt_utils, sample_payload):\n        \"\"\"Test refresh token generation with custom expiry time.\"\"\"\n        custom_expiry = 14  # 14 days\n        \n        with freeze_time(\"2023-01-01 12:00:00\"):\n            token = jwt_utils.generate_refresh_token(sample_payload, expires_delta=custom_expiry)\n            \n            decoded = jwt.decode(\n                token,\n                jwt_utils.secret_key,\n                algorithms=[jwt_utils.algorithm]\n            )\n            \n            expected_exp = datetime(2023, 1, 15, 12, 0, 0, tzinfo=timezone.utc).timestamp()\n            assert decoded[\"exp\"] == expected_exp\n\n    def test_validate_token_success(self, jwt_utils, sample_payload):\n        \"\"\"Test successful token validation.\"\"\"\n        with freeze_time(\"2023-01-01 12:00:00\"):\n            token = jwt_utils.generate_access_token(sample_payload)\n            \n            # Validate immediately after generation\n            decoded_payload = jwt_utils.validate_token(token)\n            \n            assert decoded_payload[\"user_id\"] == \"123\"\n            assert decoded_payload[\"username\"] == \"testuser\"\n            assert decoded_payload[\"email\"] == \"test@example.com\"\n            assert decoded_payload[\"type\"] == \"access\"\n\n    def test_validate_token_expired_raises_error(self, jwt_utils, sample_payload):\n        \"\"\"Test that expired token raises TokenExpiredError.\"\"\"\n        with freeze_time(\"2023-01-01 12:00:00\"):\n            token = jwt_utils.generate_access_token(sample_payload)\n        \n        # Move time forward past expiration\n        with freeze_time(\"2023-01-01 13:00:00\"):\n            with pytest.raises(TokenExpiredError, match=\"Token has expired\"):\n                jwt_utils.validate_token(token)\n\n    def test_validate_token_invalid_signature_raises_error(self, jwt_utils, sample_payload):\n        \"\"\"Test that token with invalid signature raises InvalidTokenError.\"\"\"\n        token = jwt_utils.generate_access_token(sample_payload)\n        \n        # Create JWTUtils with different secret key\n        different_jwt_utils = JWTUtils(secret_key=\"different_secret\")\n        \n        with pytest.raises(InvalidTokenError, match=\"Invalid token signature\"):\n            different_jwt_utils.validate_token(token)\n\n    def test_validate_token_malformed_raises_error(self, jwt_utils):\n        \"\"\"Test that malformed token raises TokenDecodeError.\"\"\"\n        malformed_token = \"invalid.token.format\"\n        \n        with pytest.raises(TokenDecodeError, match=\"Failed to decode token\"):\n            jwt_utils.validate_token(malformed_token)\n\n    def test_validate",
      "file_type": "test",
      "semantic_unit_id": "SU-008",
      "component_id": "COMP-008",
      "description": "Unit tests for JWT utilities covering token generation, validation, expiration, and error scenarios"
    },
    {
      "file_path": "tests/test_password.py",
      "content": "\"\"\"\nUnit tests for password hashing and verification utilities\n\nTests password hashing, verification, strength validation, and security features\nto ensure proper authentication security.\n\nComponent ID: COMP-009\nSemantic Unit: SU-009\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport pytest\nfrom unittest.mock import patch, MagicMock\nimport bcrypt\nimport time\n\nfrom src.utils.password import (\n    hash_password,\n    verify_password,\n    is_password_strong,\n    generate_salt,\n    hash_password_with_salt,\n    verify_password_timing_safe,\n    PasswordStrengthError,\n    PasswordHashError\n)\n\n\nclass TestHashPassword:\n    \"\"\"Test cases for password hashing functionality.\"\"\"\n\n    def test_hash_password_returns_string(self):\n        \"\"\"Test that hash_password returns a string.\"\"\"\n        password = \"test_password_123\"\n        hashed = hash_password(password)\n        assert isinstance(hashed, str)\n\n    def test_hash_password_returns_different_hash_each_time(self):\n        \"\"\"Test that hash_password returns different hashes for same password.\"\"\"\n        password = \"test_password_123\"\n        hash1 = hash_password(password)\n        hash2 = hash_password(password)\n        assert hash1 != hash2\n\n    def test_hash_password_with_valid_password(self):\n        \"\"\"Test hash_password with valid password string.\"\"\"\n        password = \"ValidPassword123!\"\n        hashed = hash_password(password)\n        assert len(hashed) > 0\n        assert hashed.startswith(\"$2b$\")\n\n    def test_hash_password_with_empty_string(self):\n        \"\"\"Test hash_password with empty string raises ValueError.\"\"\"\n        with pytest.raises(ValueError, match=\"Password cannot be empty\"):\n            hash_password(\"\")\n\n    def test_hash_password_with_none(self):\n        \"\"\"Test hash_password with None raises TypeError.\"\"\"\n        with pytest.raises(TypeError, match=\"Password must be a string\"):\n            hash_password(None)\n\n    def test_hash_password_with_non_string(self):\n        \"\"\"Test hash_password with non-string input raises TypeError.\"\"\"\n        with pytest.raises(TypeError, match=\"Password must be a string\"):\n            hash_password(12345)\n\n    def test_hash_password_with_unicode_characters(self):\n        \"\"\"Test hash_password handles unicode characters correctly.\"\"\"\n        password = \"pssw0rd__\"\n        hashed = hash_password(password)\n        assert isinstance(hashed, str)\n        assert len(hashed) > 0\n\n    def test_hash_password_with_very_long_password(self):\n        \"\"\"Test hash_password with very long password (72+ bytes).\"\"\"\n        password = \"a\" * 100\n        hashed = hash_password(password)\n        assert isinstance(hashed, str)\n        assert len(hashed) > 0\n\n    @patch('bcrypt.hashpw')\n    def test_hash_password_handles_bcrypt_error(self, mock_hashpw):\n        \"\"\"Test hash_password handles bcrypt errors gracefully.\"\"\"\n        mock_hashpw.side_effect = Exception(\"Bcrypt error\")\n        with pytest.raises(PasswordHashError, match=\"Failed to hash password\"):\n            hash_password(\"test_password\")\n\n\nclass TestVerifyPassword:\n    \"\"\"Test cases for password verification functionality.\"\"\"\n\n    def test_verify_password_with_correct_password(self):\n        \"\"\"Test verify_password returns True for correct password.\"\"\"\n        password = \"test_password_123\"\n        hashed = hash_password(password)\n        assert verify_password(password, hashed) is True\n\n    def test_verify_password_with_incorrect_password(self):\n        \"\"\"Test verify_password returns False for incorrect password.\"\"\"\n        password = \"test_password_123\"\n        wrong_password = \"wrong_password_456\"\n        hashed = hash_password(password)\n        assert verify_password(wrong_password, hashed) is False\n\n    def test_verify_password_with_empty_password(self):\n        \"\"\"Test verify_password with empty password raises ValueError.\"\"\"\n        hashed = hash_password(\"test_password\")\n        with pytest.raises(ValueError, match=\"Password cannot be empty\"):\n            verify_password(\"\", hashed)\n\n    def test_verify_password_with_empty_hash(self):\n        \"\"\"Test verify_password with empty hash raises ValueError.\"\"\"\n        with pytest.raises(ValueError, match=\"Hash cannot be empty\"):\n            verify_password(\"test_password\", \"\")\n\n    def test_verify_password_with_none_password(self):\n        \"\"\"Test verify_password with None password raises TypeError.\"\"\"\n        hashed = hash_password(\"test_password\")\n        with pytest.raises(TypeError, match=\"Password must be a string\"):\n            verify_password(None, hashed)\n\n    def test_verify_password_with_none_hash(self):\n        \"\"\"Test verify_password with None hash raises TypeError.\"\"\"\n        with pytest.raises(TypeError, match=\"Hash must be a string\"):\n            verify_password(\"test_password\", None)\n\n    def test_verify_password_with_invalid_hash_format(self):\n        \"\"\"Test verify_password with invalid hash format returns False.\"\"\"\n        password = \"test_password\"\n        invalid_hash = \"invalid_hash_format\"\n        assert verify_password(password, invalid_hash) is False\n\n    def test_verify_password_with_unicode_password(self):\n        \"\"\"Test verify_password works with unicode passwords.\"\"\"\n        password = \"pssw0rd__\"\n        hashed = hash_password(password)\n        assert verify_password(password, hashed) is True\n\n    @patch('bcrypt.checkpw')\n    def test_verify_password_handles_bcrypt_error(self, mock_checkpw):\n        \"\"\"Test verify_password handles bcrypt errors gracefully.\"\"\"\n        mock_checkpw.side_effect = Exception(\"Bcrypt error\")\n        hashed = \"$2b$12$valid.hash.format\"\n        result = verify_password(\"test_password\", hashed)\n        assert result is False\n\n\nclass TestPasswordStrength:\n    \"\"\"Test cases for password strength validation.\"\"\"\n\n    def test_is_password_strong_with_strong_password(self):\n        \"\"\"Test is_password_strong returns True for strong password.\"\"\"\n        strong_password = \"StrongP@ssw0rd123\"\n        assert is_password_strong(strong_password) is True\n\n    def test_is_password_strong_with_weak_password_too_short(self):\n        \"\"\"Test is_password_strong returns False for password too short.\"\"\"\n        weak_password = \"Sh0rt!\"\n        assert is_password_strong(weak_password) is False\n\n    def test_is_password_strong_with_no_uppercase(self):\n        \"\"\"Test is_password_strong returns False for password without uppercase.\"\"\"\n        weak_password = \"lowercase123!\"\n        assert is_password_strong(weak_password) is False\n\n    def test_is_password_strong_with_no_lowercase(self):\n        \"\"\"Test is_password_strong returns False for password without lowercase.\"\"\"\n        weak_password = \"UPPERCASE123!\"\n        assert is_password_strong(weak_password) is False\n\n    def test_is_password_strong_with_no_digits(self):\n        \"\"\"Test is_password_strong returns False for password without digits.\"\"\"\n        weak_password = \"NoDigitsHere!\"\n        assert is_password_strong(weak_password) is False\n\n    def test_is_password_strong_with_no_special_chars(self):\n        \"\"\"Test is_password_strong returns False for password without special chars.\"\"\"\n        weak_password = \"NoSpecialChars123\"\n        assert is_password_strong(weak_password) is False\n\n    def test_is_password_strong_with_empty_password(self):\n        \"\"\"Test is_password_strong raises ValueError for empty password.\"\"\"\n        with pytest.raises(ValueError, match=\"Password cannot be empty\"):\n            is_password_strong(\"\")\n\n    def test_is_password_strong_with_none_password(self):\n        \"\"\"Test is_password_strong raises TypeError for None password.\"\"\"\n        with pytest.raises(TypeError, match=\"Password must be a string\"):\n            is_password_strong(None)\n\n    def test_is_password_strong",
      "file_type": "test",
      "semantic_unit_id": "SU-009",
      "component_id": "COMP-009",
      "description": "Unit tests for password hashing and verification with various input scenarios and security validation"
    },
    {
      "file_path": "tests/conftest.py",
      "content": "\"\"\"\nPytest configuration and fixtures for Hello World API tests.\n\nProvides test client setup, fixtures, and configuration for comprehensive testing\nof the FastAPI application endpoints and error handling.\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom unittest.mock import patch, MagicMock\nfrom datetime import datetime\nfrom typing import Generator, Dict, Any\nimport sys\nimport os\n\n# Add src directory to Python path for imports\nsys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'src'))\n\nfrom main import app\n\n\n@pytest.fixture(scope=\"session\")\ndef test_client() -> TestClient:\n    \"\"\"\n    Create FastAPI test client for the entire test session.\n    \n    Returns:\n        TestClient: Configured test client for making HTTP requests\n    \"\"\"\n    return TestClient(app)\n\n\n@pytest.fixture(scope=\"function\")\ndef client(test_client: TestClient) -> Generator[TestClient, None, None]:\n    \"\"\"\n    Provide test client for individual test functions.\n    \n    Args:\n        test_client: Session-scoped test client\n        \n    Yields:\n        TestClient: Test client instance for making requests\n    \"\"\"\n    yield test_client\n\n\n@pytest.fixture(scope=\"function\")\ndef mock_datetime() -> Generator[MagicMock, None, None]:\n    \"\"\"\n    Mock datetime.utcnow() for consistent timestamp testing.\n    \n    Yields:\n        MagicMock: Mocked datetime with fixed timestamp\n    \"\"\"\n    fixed_datetime = datetime(2023, 12, 25, 10, 30, 45)\n    \n    with patch('main.datetime') as mock_dt:\n        mock_dt.utcnow.return_value = fixed_datetime\n        mock_dt.side_effect = lambda *args, **kwargs: datetime(*args, **kwargs)\n        yield mock_dt\n\n\n@pytest.fixture(scope=\"function\")\ndef sample_valid_names() -> list[str]:\n    \"\"\"\n    Provide list of valid name parameters for testing.\n    \n    Returns:\n        list[str]: Valid name strings for parameter testing\n    \"\"\"\n    return [\n        \"John\",\n        \"Jane Doe\",\n        \"Alice123\",\n        \"Bob Smith Jr\",\n        \"Test User 42\",\n        \"a\",  # Single character\n        \"A\" * 100,  # Maximum length\n        \"User 123 Test\",\n        \"Simple Name\",\n        \"Name With Spaces\"\n    ]\n\n\n@pytest.fixture(scope=\"function\")\ndef sample_invalid_names() -> list[str]:\n    \"\"\"\n    Provide list of invalid name parameters for testing.\n    \n    Returns:\n        list[str]: Invalid name strings that should trigger validation errors\n    \"\"\"\n    return [\n        \"John@Doe\",  # Special character\n        \"Jane-Smith\",  # Hyphen\n        \"User!\",  # Exclamation mark\n        \"Test#User\",  # Hash symbol\n        \"Name$\",  # Dollar sign\n        \"User%Test\",  # Percent sign\n        \"Test&User\",  # Ampersand\n        \"Name*\",  # Asterisk\n        \"User+Test\",  # Plus sign\n        \"Test=User\",  # Equals sign\n        \"Name[Test]\",  # Brackets\n        \"User{Test}\",  # Braces\n        \"Test|User\",  # Pipe\n        \"Name\\\\Test\",  # Backslash\n        \"User/Test\",  # Forward slash\n        \"Test:User\",  # Colon\n        \"Name;Test\",  # Semicolon\n        \"User<Test>\",  # Angle brackets\n        \"Test?User\",  # Question mark\n        \"Name.Test\",  # Period\n        \"User,Test\",  # Comma\n        \"Test'User\",  # Apostrophe\n        'Name\"Test',  # Quote\n        \"A\" * 101,  # Exceeds maximum length\n        \"\",  # Empty string (handled as None)\n        \"   \",  # Only spaces\n        \"\\n\",  # Newline\n        \"\\t\",  # Tab\n        \"User\\nTest\",  # Contains newline\n        \"Test\\tUser\",  # Contains tab\n    ]\n\n\n@pytest.fixture(scope=\"function\")\ndef expected_error_response() -> Dict[str, Any]:\n    \"\"\"\n    Provide expected error response structure.\n    \n    Returns:\n        Dict[str, Any]: Expected error response format\n    \"\"\"\n    return {\n        \"error\": \"INVALID_NAME\",\n        \"message\": \"Name parameter contains invalid characters or exceeds 100 characters\"\n    }\n\n\n@pytest.fixture(scope=\"function\")\ndef expected_health_response() -> Dict[str, str]:\n    \"\"\"\n    Provide expected health endpoint response structure.\n    \n    Returns:\n        Dict[str, str]: Expected health response format\n    \"\"\"\n    return {\n        \"status\": \"ok\",\n        \"timestamp\": \"2023-12-25T10:30:45Z\"\n    }\n\n\n@pytest.fixture(scope=\"function\")\ndef mock_exception_logging() -> Generator[MagicMock, None, None]:\n    \"\"\"\n    Mock logging for exception handler testing.\n    \n    Yields:\n        MagicMock: Mocked logger for verifying error logging\n    \"\"\"\n    with patch('main.logger') as mock_logger:\n        yield mock_logger\n\n\n@pytest.fixture(autouse=True)\ndef reset_app_state() -> Generator[None, None, None]:\n    \"\"\"\n    Reset application state before each test.\n    \n    This fixture runs automatically before each test to ensure\n    clean state and prevent test interference.\n    \n    Yields:\n        None: No return value, just ensures clean state\n    \"\"\"\n    # Clear any cached data or state if needed\n    yield\n    # Cleanup after test if needed\n\n\n@pytest.fixture(scope=\"function\")\ndef hello_endpoint_test_cases() -> list[Dict[str, Any]]:\n    \"\"\"\n    Provide comprehensive test cases for hello endpoint.\n    \n    Returns:\n        list[Dict[str, Any]]: Test cases with inputs and expected outputs\n    \"\"\"\n    return [\n        {\n            \"name\": \"no_name_parameter\",\n            \"input\": None,\n            \"expected_message\": \"Hello, World!\",\n            \"expected_status\": 200\n        },\n        {\n            \"name\": \"empty_name_parameter\",\n            \"input\": \"\",\n            \"expected_message\": \"Hello, World!\",\n            \"expected_status\": 200\n        },\n        {\n            \"name\": \"simple_name\",\n            \"input\": \"John\",\n            \"expected_message\": \"Hello, John!\",\n            \"expected_status\": 200\n        },\n        {\n            \"name\": \"name_with_spaces\",\n            \"input\": \"Jane Doe\",\n            \"expected_message\": \"Hello, Jane Doe!\",\n            \"expected_status\": 200\n        },\n        {\n            \"name\": \"name_with_numbers\",\n            \"input\": \"User123\",\n            \"expected_message\": \"Hello, User123!\",\n            \"expected_status\": 200\n        },\n        {\n            \"name\": \"maximum_length_name\",\n            \"input\": \"A\" * 100,\n            \"expected_message\": f\"Hello, {'A' * 100}!\",\n            \"expected_status\": 200\n        }\n    ]\n\n\n@pytest.fixture(scope=\"function\")\ndef error_test_cases() -> list[Dict[str, Any]]:\n    \"\"\"\n    Provide test cases for error scenarios.\n    \n    Returns:\n        list[Dict[str, Any]]: Error test cases with inputs and expected responses\n    \"\"\"\n    return [\n        {\n            \"name\": \"name_too_long\",\n            \"input\": \"A\" * 101,\n            \"expected_status\": 400,\n            \"expected_error\": \"INVALID_NAME\"\n        },\n        {\n            \"name\": \"name_with_special_chars\",\n            \"input\": \"John@Doe\",\n            \"expected_status\": 400,\n            \"expected_error\": \"INVALID_NAME\"\n        },\n        {\n            \"name\": \"name_with_symbols\",\n            \"input\": \"User!\",\n            \"expected_status\": 400,",
      "file_type": "test",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Pytest configuration with test database setup, fixtures for authenticated users, and test client initialization"
    },
    {
      "file_path": "requirements.txt",
      "content": "# Web Framework\nfastapi==0.104.1\nuvicorn==0.24.0\n\n# Data Validation\npydantic==2.5.0\n\n# HTTP Client (for testing)\nhttpx==0.25.2\n\n# Testing Framework\npytest==7.4.3\npytest-asyncio==0.21.1\npytest-cov==4.1.0\n\n# Development Tools\nblack==23.11.0\nflake8==6.1.0\nmypy==1.7.1\n\n# ASGI Tools\nasgi-lifespan==2.1.0",
      "file_type": "requirements",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Python dependencies with exact versions for FastAPI, SQLAlchemy, authentication, testing, and database libraries"
    },
    {
      "file_path": ".env.example",
      "content": "# Application Configuration\nAPP_NAME=Hello World API\nAPP_VERSION=1.0.0\nAPP_DESCRIPTION=Simple REST API that returns greeting messages\n\n# Server Configuration\nHOST=0.0.0.0\nPORT=8000\nDEBUG=false\nRELOAD=false\n\n# CORS Configuration\nCORS_ORIGINS=http://localhost:3000,http://localhost:8080\nCORS_ALLOW_CREDENTIALS=true\nCORS_ALLOW_METHODS=GET,POST,PUT,DELETE,OPTIONS\nCORS_ALLOW_HEADERS=*\n\n# Logging Configuration\nLOG_LEVEL=INFO\nLOG_FORMAT=%(asctime)s - %(name)s - %(levelname)s - %(message)s",
      "file_type": "config",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Environment variables template including JWT secret, database URL, and application configuration settings"
    },
    {
      "file_path": "alembic.ini",
      "content": "# A generic, single database configuration.\n\n[alembic]\n# path to migration scripts\nscript_location = alembic\n\n# template used to generate migration file names; The default value is %%(rev)s_%%(slug)s\n# Uncomment the line below if you want the files to be prepended with date and time\n# file_template = %%(year)d_%%(month).2d_%%(day).2d_%%(hour).2d%%(minute).2d-%%(rev)s_%%(slug)s\n\n# sys.path path, will be prepended to sys.path if present.\n# defaults to the current working directory.\nprepend_sys_path = .\n\n# timezone to use when rendering the date within the migration file\n# as well as the filename.\n# If specified, requires the python-dateutil library that can be\n# installed by adding `alembic[tz]` to the pip requirements\n# string value is passed to dateutil.tz.gettz()\n# leave blank for localtime\n# timezone =\n\n# max length of characters to apply to the\n# \"slug\" field\n# truncate_slug_length = 40\n\n# set to 'true' to run the environment during\n# the 'revision' command, regardless of autogenerate\n# revision_environment = false\n\n# set to 'true' to allow .pyc and .pyo files without\n# a source .py file to be detected as revisions in the\n# versions/ directory\n# sourceless = false\n\n# version path separator; As mentioned above, this is the character used to split\n# version_locations. The default within new alembic.ini files is \"os\", which uses\n# os.pathsep. If this key is omitted entirely, it falls back to the legacy\n# behavior of splitting on spaces and/or commas.\n# Valid values for version_path_separator are:\n#\n# version_path_separator = :\n# version_path_separator = ;\n# version_path_separator = space\nversion_path_separator = os\n\n# the output encoding used when revision files\n# are written from script.py.mako\n# output_encoding = utf-8\n\nsqlalchemy.url = sqlite:///./app.db\n\n\n[post_write_hooks]\n# post_write_hooks defines scripts or Python functions that are run\n# on newly generated revision scripts.  See the documentation for further\n# detail and examples\n\n# format using \"black\" - use the console_scripts runner, against the \"black\" entrypoint\n# hooks = black\n# black.type = console_scripts\n# black.entrypoint = black\n# black.options = -l 79 REVISION_SCRIPT_FILENAME\n\n# Logging configuration\n[loggers]\nkeys = root,sqlalchemy,alembic\n\n[handlers]\nkeys = console\n\n[formatters]\nkeys = generic\n\n[logger_root]\nlevel = WARN\nhandlers = console\nqualname =\n\n[logger_sqlalchemy]\nlevel = WARN\nhandlers =\nqualname = sqlalchemy.engine\n\n[logger_alembic]\nlevel = INFO\nhandlers =\nqualname = alembic\n\n[handler_console]\nclass = StreamHandler\nargs = (sys.stderr,)\nlevel = NOTSET\nformatter = generic\n\n[formatter_generic]\nformat = %(levelname)-5.5s [%(name)s] %(message)s\ndatefmt = %H:%M:%S",
      "file_type": "config",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Alembic configuration file for database migrations with SQLAlchemy URL and migration settings"
    },
    {
      "file_path": "pytest.ini",
      "content": "[pytest]\n# Test discovery\ntestpaths = tests\npython_files = test_*.py *_test.py\npython_classes = Test*\npython_functions = test_*\n\n# Test execution\naddopts = \n    --verbose\n    --tb=short\n    --strict-markers\n    --strict-config\n    --disable-warnings\n\n# Coverage settings\naddopts = \n    --cov=.\n    --cov-report=term-missing\n    --cov-report=html:htmlcov\n    --cov-report=xml\n    --cov-fail-under=80\n\n# Markers\nmarkers =\n    unit: Unit tests\n    integration: Integration tests\n    slow: Slow running tests\n\n# Logging\nlog_cli = true\nlog_cli_level = INFO\nlog_cli_format = %(asctime)s [%(levelname)8s] %(name)s: %(message)s\nlog_cli_date_format = %Y-%m-%d %H:%M:%S\n\n# Warnings\nfilterwarnings =\n    ignore::DeprecationWarning\n    ignore::PendingDeprecationWarning",
      "file_type": "config",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Pytest configuration with test discovery, coverage settings, and test database configuration"
    },
    {
      "file_path": ".gitignore",
      "content": "# Byte-compiled / optimized / DLL files\n__pycache__/\n*.py[cod]\n*$py.class\n\n# C extensions\n*.so\n\n# Distribution / packaging\n.Python\nbuild/\ndevelop-eggs/\ndist/\ndownloads/\neggs/\n.eggs/\nlib/\nlib64/\nparts/\nsdist/\nvar/\nwheels/\nshare/python-wheels/\n*.egg-info/\n.installed.cfg\n*.egg\nMANIFEST\n\n# PyInstaller\n#  Usually these files are written by a python script from a template\n#  before PyInstaller builds the exe, so as to inject date/other infos into it.\n*.manifest\n*.spec\n\n# Installer logs\npip-log.txt\npip-delete-this-directory.txt\n\n# Unit test / coverage reports\nhtmlcov/\n.tox/\n.nox/\n.coverage\n.coverage.*\n.cache\nnosetests.xml\ncoverage.xml\n*.cover\n*.py,cover\n.hypothesis/\n.pytest_cache/\ncover/\n\n# Translations\n*.mo\n*.pot\n\n# Django stuff:\n*.log\nlocal_settings.py\ndb.sqlite3\ndb.sqlite3-journal\n\n# Flask stuff:\ninstance/\n.webassets-cache\n\n# Scrapy stuff:\n.scrapy\n\n# Sphinx documentation\ndocs/_build/\n\n# PyBuilder\n.pybuilder/\ntarget/\n\n# Jupyter Notebook\n.ipynb_checkpoints\n\n# IPython\nprofile_default/\nipython_config.py\n\n# pyenv\n#   For a library or package, you might want to ignore these files since the code is\n#   intended to run in multiple environments; otherwise, check them in:\n# .python-version\n\n# pipenv\n#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.\n#   However, in case of collaboration, if having platform-specific dependencies or dependencies\n#   having no cross-platform support, pipenv may install dependencies that don't work, or not\n#   install all needed dependencies.\n#Pipfile.lock\n\n# poetry\n#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.\n#   This is especially recommended for binary packages to ensure reproducibility, and is more\n#   commonly ignored for libraries.\n#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control\n#poetry.lock\n\n# pdm\n#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.\n#pdm.lock\n#   pdm stores project-wide configurations in .pdm.toml, but it is recommended to not include it\n#   in version control.\n#   https://pdm.fming.dev/#use-with-ide\n.pdm.toml\n\n# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm\n__pypackages__/\n\n# Celery stuff\ncelerybeat-schedule\ncelerybeat.pid\n\n# SageMath parsed files\n*.sage.py\n\n# Environments\n.env\n.venv\nenv/\nvenv/\nENV/\nenv.bak/\nvenv.bak/\n\n# Spyder project settings\n.spyderproject\n.spyproject\n\n# Rope project settings\n.ropeproject\n\n# mkdocs documentation\n/site\n\n# mypy\n.mypy_cache/\n.dmypy.json\ndmypy.json\n\n# Pyre type checker\n.pyre/\n\n# pytype static type analyzer\n.pytype/\n\n# Cython debug symbols\ncython_debug/\n\n# PyCharm\n#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can\n#  be added to the global gitignore or merged into this project gitignore.  For a PyCharm\n#  project, it is recommended to ignore the entire .idea directory.\n.idea/\n\n# VS Code\n.vscode/\n\n# macOS\n.DS_Store\n.AppleDouble\n.LSOverride\n\n# Windows\nThumbs.db\nehthumbs.db\nDesktop.ini\n$RECYCLE.BIN/\n\n# Linux\n*~\n\n# Temporary files\n*.tmp\n*.temp\n*.swp\n*.swo\n\n# Log files\n*.log\n\n# Database files\n*.db\n*.sqlite\n*.sqlite3\n\n# Configuration files with sensitive data\nconfig.ini\nsettings.ini\nsecrets.json\n.secrets\n\n# SSL certificates\n*.pem\n*.key\n*.crt\n*.cert",
      "file_type": "config",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Git ignore file for Python projects including virtual environments, cache files, and sensitive data"
    },
    {
      "file_path": "README.md",
      "content": "# Hello World API\n\nA simple FastAPI REST API that returns greeting messages with optional personalization and health status monitoring.\n\n## Features\n\n- **Personalized Greetings**: `/hello` endpoint with optional name parameter\n- **Health Monitoring**: `/health` endpoint with status and timestamp\n- **Input Validation**: Secure name parameter validation with character restrictions\n- **Error Handling**: Comprehensive error responses with proper HTTP status codes\n- **Interactive Documentation**: Auto-generated Swagger UI and ReDoc interfaces\n- **Type Safety**: Full type hints and Pydantic validation\n\n## Prerequisites\n\n- Python 3.12 or higher\n- pip package manager\n\n## Installation\n\n1. **Clone or download the project files**\n\n2. **Install dependencies:**\n   ```bash\n   pip install -r requirements.txt\n   ```\n\n## Configuration\n\nNo configuration files are required for basic operation. The API runs with default settings:\n\n- **Host**: localhost (127.0.0.1)\n- **Port**: 8000\n- **Environment**: development (with auto-reload)\n\n## Running the Application\n\n### Development Mode\n\nStart the development server with auto-reload enabled:\n\n```bash\nuvicorn main:app --reload\n```\n\nThe API will be available at: http://localhost:8000\n\n### Production Mode\n\nStart the production server:\n\n```bash\nuvicorn main:app --host 0.0.0.0 --port 8000\n```\n\n### Custom Port\n\nTo run on a different port:\n\n```bash\nuvicorn main:app --port 8001\n```\n\n## API Documentation\n\n### Interactive Documentation\n\nFastAPI automatically generates interactive API documentation:\n\n- **Swagger UI**: http://localhost:8000/docs\n- **ReDoc**: http://localhost:8000/redoc\n- **OpenAPI Schema**: http://localhost:8000/openapi.json\n\n### Endpoints\n\n#### GET /hello\n\nReturns a greeting message with optional personalization.\n\n**Parameters:**\n- `name` (optional, query parameter): Name to personalize the greeting\n  - Type: string\n  - Max length: 100 characters\n  - Allowed characters: alphanumeric and spaces only\n  - Pattern: `^[a-zA-Z0-9 ]+$`\n\n**Example Requests:**\n\n```bash\n# Basic greeting\ncurl http://localhost:8000/hello\n\n# Personalized greeting\ncurl \"http://localhost:8000/hello?name=Alice\"\n\n# Greeting with spaces in name\ncurl \"http://localhost:8000/hello?name=John%20Doe\"\n```\n\n**Success Response (200 OK):**\n\n```json\n{\n  \"message\": \"Hello, World!\"\n}\n```\n\n```json\n{\n  \"message\": \"Hello, Alice!\"\n}\n```\n\n**Error Responses:**\n\n- **400 Bad Request** - Invalid name parameter:\n  ```json\n  {\n    \"error\": \"INVALID_NAME\",\n    \"message\": \"Name parameter contains invalid characters or exceeds 100 characters\"\n  }\n  ```\n\n- **500 Internal Server Error** - Server error:\n  ```json\n  {\n    \"error\": \"INTERNAL_ERROR\",\n    \"message\": \"Internal server error\"\n  }\n  ```\n\n#### GET /health\n\nReturns application health status and current timestamp for monitoring purposes.\n\n**Parameters:** None\n\n**Example Request:**\n\n```bash\ncurl http://localhost:8000/health\n```\n\n**Success Response (200 OK):**\n\n```json\n{\n  \"status\": \"ok\",\n  \"timestamp\": \"2024-01-15T10:30:45.123456Z\"\n}\n```\n\n**Error Responses:**\n\n- **500 Internal Server Error** - Server error:\n  ```json\n  {\n    \"error\": \"INTERNAL_ERROR\",\n    \"message\": \"Internal server error\"\n  }\n  ```\n\n## Testing\n\n### Running Tests\n\nRun the complete test suite:\n\n```bash\npytest tests/ -v\n```\n\nRun tests with coverage report:\n\n```bash\npytest tests/ --cov=. --cov-report=html\n```\n\nView coverage report:\n\n```bash\nopen htmlcov/index.html  # macOS\nxdg-open htmlcov/index.html  # Linux\n```\n\n### Test Categories\n\nThe test suite includes:\n\n- **Unit Tests**: Individual function testing\n- **Integration Tests**: Full endpoint testing\n- **Validation Tests**: Input parameter validation\n- **Error Handling Tests**: Exception and error response testing\n- **Edge Case Tests**: Boundary conditions and special inputs\n\n### Example Test Commands\n\n```bash\n# Run specific test file\npytest tests/test_main.py -v\n\n# Run tests matching pattern\npytest tests/ -k \"test_hello\" -v\n\n# Run tests with detailed output\npytest tests/ -v -s\n```\n\n## Development\n\n### Project Structure\n\n```\nhello-world-api/\n main.py              # FastAPI application and endpoints\n requirements.txt     # Python dependencies\n README.md           # This documentation\n tests/\n     test_main.py    # Test suite\n```\n\n### Code Quality\n\nThe project follows these standards:\n\n- **PEP 8**: Python style guide compliance\n- **Type Hints**: Full type annotation coverage\n- **Docstrings**: Comprehensive function documentation\n- **Error Handling**: Proper exception management\n- **Input Validation**: Secure parameter validation\n\n### Adding New Features\n\n1. **Add endpoint logic** to `main.py`\n2. **Update API contracts** in docstrings\n3. **Add comprehensive tests** in `tests/test_main.py`\n4. **Update documentation** in this README\n5. **Test thoroughly** before deployment\n\n## Deployment\n\n### Docker Deployment\n\nCreate a `Dockerfile`:\n\n```dockerfile\nFROM python:3.12-slim\n\nWORKDIR /app\nCOPY requirements.txt .\nRUN pip install -r requirements.txt\n\nCOPY main.py .\n\nCMD [\"uvicorn\", \"main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]\n```\n\nBuild and run:\n\n```bash\ndocker build -t hello-world-api .\ndocker run -p 8000:8000 hello-world-api\n```\n\n### Production Considerations\n\n- **Process Manager**: Use Gunicorn with Uvicorn workers\n- **Reverse Proxy**: Deploy behind Nginx or similar\n- **Environment Variables**: Configure host, port, and other settings\n- **Logging**: Implement structured logging for production\n- **Monitoring**: Set up health check monitoring\n- **Security**: Add HTTPS, rate limiting, and security headers\n\n## Troubleshooting\n\n### Common Issues\n\n#### Port Already in Use\n\n**Error**: `OSError: [Errno 48] Address already in use`\n\n**Solution**: Use a different port or kill the process using port 8000\n\n```bash\n# Find process using port 8000\nlsof -i :8000\n\n# Kill the process (replace PID with actual process ID)\nkill -9 <PID>\n\n# Or use a different port\nuvicorn main:app --port 8001\n```\n\n#### Import Errors\n\n**Error**: `ModuleNotFoundError: No module named 'fastapi'`\n\n**Solution**: Install dependencies\n\n```bash\npip install -r requirements.txt\n```\n\n#### Permission Errors\n\n**Error**: `PermissionError: [Errno 13] Permission denied`\n\n**Solution**: Check file permissions or use virtual environment\n\n```bash\n# Create virtual environment\npython -m venv venv\nsource venv/bin/activate  # Linux/macOS\n# or\nvenv\\Scripts\\activate  # Windows\n\n# Install dependencies\npip install -r requirements.txt\n```\n\n#### Invalid Name Parameter\n\n**Error**: 400 Bad Request when testing `/hello` endpoint\n\n**Solution**: Ensure name parameter contains only alphanumeric characters and spaces\n\n```bash\n# Valid examples\ncurl \"http://localhost:8000/hello?name=Alice\"\ncurl \"http://localhost:8000/hello?name=John%20Doe\"\ncurl \"http://localhost:8000/hello?name=User123\"\n\n# Invalid examples (will return 400 error)\ncurl \"http://localhost:8000/hello?name=user@domain.com\"  # Contains @\ncurl \"http://localhost:8000/hello?name=user-name\"       # Contains -\n```\n\n### Performance Issues\n\n#### Slow Response Times\n\n**Symptoms**: API responses taking longer than expected\n\n**Solutions**:\n- Check system resources (CPU, memory)\n- Monitor for blocking operations\n- Use async/await for I/O operations\n- Consider connection pooling for databases\n\n#### High Memory Usage\n\n**",
      "file_type": "documentation",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Comprehensive project documentation with setup instructions, API endpoints, authentication guide, and troubleshooting"
    },
    {
      "file_path": "docs/api_documentation.md",
      "content": "# Hello World API Documentation\n\nComplete API documentation for the Hello World REST API built with FastAPI.\n\n## Overview\n\nThe Hello World API is a simple REST service that provides greeting functionality and health monitoring. It features two main endpoints for generating personalized greetings and checking application health status.\n\n**Base URL:** `http://localhost:8000`\n\n**API Version:** 1.0.0\n\n**Content Type:** `application/json`\n\n## Authentication\n\nThis API does not require authentication. All endpoints are publicly accessible.\n\n## Rate Limiting\n\nNo rate limiting is currently implemented on any endpoints.\n\n## Error Response Format\n\nAll error responses follow a consistent JSON structure:\n\n```json\n{\n  \"error\": \"ERROR_CODE\",\n  \"message\": \"Human-readable error description\"\n}\n```\n\n## Global Error Codes\n\n| Status Code | Error Code | Description |\n|-------------|------------|-------------|\n| 400 | VALIDATION_ERROR | Request validation failed |\n| 500 | INTERNAL_ERROR | Internal server error |\n\n## Endpoints\n\n### GET /hello\n\nReturns a greeting message with optional personalization.\n\n**Description:** Generates a greeting message. If a name parameter is provided, the greeting will be personalized. The name parameter is validated to ensure it contains only alphanumeric characters and spaces, with a maximum length of 100 characters.\n\n**Parameters:**\n\n| Parameter | Type | Required | Location | Description | Constraints |\n|-----------|------|----------|----------|-------------|-------------|\n| name | string | No | Query | Name to personalize the greeting | Max 100 chars, alphanumeric and spaces only |\n\n**Request Examples:**\n\nBasic greeting request:\n```http\nGET /hello HTTP/1.1\nHost: localhost:8000\n```\n\nPersonalized greeting request:\n```http\nGET /hello?name=John HTTP/1.1\nHost: localhost:8000\n```\n\nPersonalized greeting with spaces:\n```http\nGET /hello?name=John%20Doe HTTP/1.1\nHost: localhost:8000\n```\n\n**Response Schema:**\n\n```json\n{\n  \"message\": \"string\"\n}\n```\n\n**Response Fields:**\n\n| Field | Type | Description |\n|-------|------|-------------|\n| message | string | The greeting message |\n\n**Success Response Examples:**\n\nDefault greeting (no name parameter):\n```json\n{\n  \"message\": \"Hello, World!\"\n}\n```\n\nPersonalized greeting:\n```json\n{\n  \"message\": \"Hello, John!\"\n}\n```\n\nPersonalized greeting with full name:\n```json\n{\n  \"message\": \"Hello, John Doe!\"\n}\n```\n\n**Error Responses:**\n\n**400 Bad Request - Invalid Name Parameter:**\n\nOccurs when the name parameter contains invalid characters or exceeds 100 characters.\n\n```json\n{\n  \"error\": \"INVALID_NAME\",\n  \"message\": \"Name parameter contains invalid characters or exceeds 100 characters\"\n}\n```\n\nExample invalid requests:\n- `GET /hello?name=John@Doe` (contains special character @)\n- `GET /hello?name=John123!` (contains special character !)\n- `GET /hello?name=` followed by a string longer than 100 characters\n\n**500 Internal Server Error:**\n\n```json\n{\n  \"error\": \"INTERNAL_ERROR\",\n  \"message\": \"Internal server error\"\n}\n```\n\n**cURL Examples:**\n\n```bash\n# Basic greeting\ncurl -X GET \"http://localhost:8000/hello\"\n\n# Personalized greeting\ncurl -X GET \"http://localhost:8000/hello?name=Alice\"\n\n# Greeting with full name\ncurl -X GET \"http://localhost:8000/hello?name=Alice%20Smith\"\n```\n\n### GET /health\n\nReturns application health status and current timestamp.\n\n**Description:** Health check endpoint that provides the current status of the application along with a UTC timestamp. This endpoint is typically used by monitoring systems and load balancers to verify that the service is running correctly.\n\n**Parameters:** None\n\n**Request Example:**\n\n```http\nGET /health HTTP/1.1\nHost: localhost:8000\n```\n\n**Response Schema:**\n\n```json\n{\n  \"status\": \"string\",\n  \"timestamp\": \"string\"\n}\n```\n\n**Response Fields:**\n\n| Field | Type | Description | Format |\n|-------|------|-------------|---------|\n| status | string | Application health status (always \"ok\") | Fixed value: \"ok\" |\n| timestamp | string | Current UTC timestamp | ISO 8601 format with Z suffix |\n\n**Success Response Example:**\n\n```json\n{\n  \"status\": \"ok\",\n  \"timestamp\": \"2024-01-15T14:30:45.123456Z\"\n}\n```\n\n**Error Responses:**\n\n**500 Internal Server Error:**\n\n```json\n{\n  \"error\": \"INTERNAL_ERROR\",\n  \"message\": \"Internal server error\"\n}\n```\n\n**cURL Example:**\n\n```bash\ncurl -X GET \"http://localhost:8000/health\"\n```\n\n## Interactive Documentation\n\nFastAPI automatically generates interactive API documentation:\n\n- **Swagger UI:** `http://localhost:8000/docs`\n- **ReDoc:** `http://localhost:8000/redoc`\n- **OpenAPI Schema:** `http://localhost:8000/openapi.json`\n\n## Request/Response Examples\n\n### Complete Request/Response Flows\n\n#### Scenario 1: Basic Hello Request\n\n**Request:**\n```http\nGET /hello HTTP/1.1\nHost: localhost:8000\nAccept: application/json\n```\n\n**Response:**\n```http\nHTTP/1.1 200 OK\nContent-Type: application/json\nContent-Length: 26\n\n{\n  \"message\": \"Hello, World!\"\n}\n```\n\n#### Scenario 2: Personalized Hello Request\n\n**Request:**\n```http\nGET /hello?name=Developer HTTP/1.1\nHost: localhost:8000\nAccept: application/json\n```\n\n**Response:**\n```http\nHTTP/1.1 200 OK\nContent-Type: application/json\nContent-Length: 29\n\n{\n  \"message\": \"Hello, Developer!\"\n}\n```\n\n#### Scenario 3: Invalid Name Parameter\n\n**Request:**\n```http\nGET /hello?name=User@Domain.com HTTP/1.1\nHost: localhost:8000\nAccept: application/json\n```\n\n**Response:**\n```http\nHTTP/1.1 400 Bad Request\nContent-Type: application/json\nContent-Length: 108\n\n{\n  \"error\": \"INVALID_NAME\",\n  \"message\": \"Name parameter contains invalid characters or exceeds 100 characters\"\n}\n```\n\n#### Scenario 4: Health Check Request\n\n**Request:**\n```http\nGET /health HTTP/1.1\nHost: localhost:8000\nAccept: application/json\n```\n\n**Response:**\n```http\nHTTP/1.1 200 OK\nContent-Type: application/json\nContent-Length: 65\n\n{\n  \"status\": \"ok\",\n  \"timestamp\": \"2024-01-15T14:30:45.123456Z\"\n}\n```\n\n## Validation Rules\n\n### Name Parameter Validation\n\nThe `name` parameter in the `/hello` endpoint is subject to the following validation rules:\n\n1. **Character Set:** Only alphanumeric characters (a-z, A-Z, 0-9) and spaces are allowed\n2. **Length:** Maximum 100 characters\n3. **Pattern:** Must match regex pattern `^[a-zA-Z0-9 ]+$`\n4. **Optional:** Parameter is not required; endpoint works without it\n\n**Valid Examples:**\n- `Alice`\n- `John Doe`\n- `User123`\n- `Test User 456`\n\n**Invalid Examples:**\n- `user@domain.com` (contains @ symbol)\n- `John-Doe` (contains hyphen)\n- `User!` (contains exclamation mark)\n- `Jos` (contains accented character)\n- A string with 101+ characters\n\n## HTTP Status Codes\n\n| Status Code | Description | When It Occurs |\n|-------------|-------------|----------------|\n| 200 | OK | Successful request |\n| 400 | Bad Request | Invalid name parameter in /hello endpoint |\n| 404 | Not Found | Endpoint does not exist |\n| 405 | Method Not Allowed | Using wrong HTTP method (e.g., POST on GET endpoint) |\n| 422 | Unprocessable Entity | Request validation error |\n| 500 | Internal Server Error | Unexpected server error |\n\n## Client Integration Examples\n\n###",
      "file_type": "documentation",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Detailed API documentation with endpoint descriptions, request/response examples, and authentication requirements"
    }
  ],
  "file_structure": {
    "src": [
      "main.py"
    ],
    "src/api": [
      "auth.py",
      "tasks.py"
    ],
    "src/models": [
      "user.py",
      "task.py"
    ],
    "src/schemas": [
      "auth.py",
      "task.py"
    ],
    "src/utils": [
      "jwt_utils.py",
      "password.py"
    ],
    "src/database": [
      "connection.py"
    ],
    "src/database/migrations": [
      "001_initial_schema.py"
    ],
    "tests": [
      "test_auth_api.py",
      "test_tasks_api.py",
      "test_user_model.py",
      "test_task_model.py",
      "test_jwt_utils.py",
      "test_password.py",
      "conftest.py"
    ],
    ".": [
      "requirements.txt",
      ".env.example",
      "alembic.ini",
      "pytest.ini",
      ".gitignore",
      "README.md"
    ],
    "docs": [
      "api_documentation.md"
    ]
  },
  "implementation_notes": "Generated using multi-stage approach with 25 files. Manifest estimated 4070 LOC, actual 4039 LOC. Uses 12 external dependencies.",
  "dependencies": [
    "fastapi==0.104.1",
    "uvicorn==0.24.0",
    "python-jose[cryptography]==3.3.0",
    "bcrypt==4.1.1",
    "pydantic==2.5.0",
    "sqlalchemy==2.0.23",
    "alembic==1.13.0",
    "python-multipart==0.0.6",
    "pytest==7.4.3",
    "pytest-asyncio==0.21.1",
    "httpx==0.25.2",
    "python-dotenv==1.0.0"
  ],
  "setup_instructions": "1. Install Python 3.11+\\n2. Create virtual environment: python -m venv venv\\n3. Activate virtual environment: source venv/bin/activate (Linux/Mac) or venv\\Scripts\\activate (Windows)\\n4. Install dependencies: pip install -r requirements.txt\\n5. Copy .env.example to .env and configure environment variables\\n6. Initialize database: alembic upgrade head\\n7. Start development server: uvicorn src.main:app --reload\\n8. Run tests: pytest tests/ -v\\n9. Access API documentation at http://localhost:8000/docs",
  "total_lines_of_code": 4039,
  "total_files": 25,
  "test_coverage_target": 80.0,
  "semantic_units_implemented": [
    "SU-004",
    "SU-008",
    "SU-005",
    "SU-001",
    "SU-009",
    "SU-002",
    "SU-003",
    "SU-010",
    "SU-007",
    "SU-011",
    "SU-006"
  ],
  "components_implemented": [
    "COMP-003",
    "COMP-006",
    "COMP-005",
    "COMP-009",
    "COMP-004",
    "COMP-001",
    "COMP-008",
    "COMP-007",
    "COMP-002",
    "COMP-010",
    "COMP-011"
  ],
  "agent_version": "1.0.0",
  "generation_timestamp": "2025-11-21T18:15:08.793035"
}