{
  "task_id": "HW-001",
  "project_id": "PROJECT-001",
  "files": [
    {
      "file_path": "src/main.py",
      "content": "\"\"\"\nFastAPI Hello World Application\n\nMain application entry point with CORS middleware, router registration, and startup configuration.\nProvides /hello and /health endpoints with proper error handling and validation.\n\nComponent ID: COMP-001\nSemantic Unit: SU-001\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport re\nfrom datetime import datetime\nfrom typing import Optional, Any\nimport logging\n\nfrom fastapi import FastAPI, Query, HTTPException, Request\nfrom fastapi.exceptions import RequestValidationError\nfrom fastapi.responses import JSONResponse\nfrom fastapi.middleware.cors import CORSMiddleware\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\nclass FastAPIApplication:\n    \"\"\"\n    FastAPI application factory and configuration manager.\n    \n    Handles application initialization, middleware setup, and error handler registration.\n    \"\"\"\n    \n    @staticmethod\n    def create_app() -> FastAPI:\n        \"\"\"\n        Create and configure FastAPI application instance.\n        \n        Returns:\n            FastAPI: Configured application instance\n        \"\"\"\n        app = FastAPI(\n            title=\"Hello World API\",\n            description=\"Simple REST API that returns greeting messages\",\n            version=\"1.0.0\"\n        )\n        \n        # Add CORS middleware\n        app.add_middleware(\n            CORSMiddleware,\n            allow_origins=[\"*\"],\n            allow_credentials=True,\n            allow_methods=[\"*\"],\n            allow_headers=[\"*\"],\n        )\n        \n        # Setup error handlers\n        FastAPIApplication.setup_error_handlers(app)\n        \n        return app\n    \n    @staticmethod\n    def setup_error_handlers(app: FastAPI) -> None:\n        \"\"\"\n        Configure global exception handlers for the application.\n        \n        Args:\n            app: FastAPI application instance\n        \"\"\"\n        error_handler = ErrorHandler()\n        \n        app.add_exception_handler(RequestValidationError, error_handler.handle_validation_error)\n        app.add_exception_handler(HTTPException, error_handler.handle_http_exception)\n        app.add_exception_handler(Exception, error_handler.handle_general_exception)\n\n\nclass HelloEndpoint:\n    \"\"\"\n    Handler for the /hello endpoint with name parameter validation.\n    \n    Provides greeting functionality with optional personalization.\n    \"\"\"\n    \n    NAME_PATTERN = re.compile(r'^[a-zA-Z0-9 ]+$')\n    MAX_NAME_LENGTH = 100\n    \n    @staticmethod\n    def get_hello(name: Optional[str] = None) -> dict[str, str]:\n        \"\"\"\n        Process hello request and return greeting message.\n        \n        Args:\n            name: Optional name parameter for personalization\n            \n        Returns:\n            dict: Response containing greeting message\n            \n        Raises:\n            HTTPException: If name parameter is invalid\n        \"\"\"\n        if name is not None:\n            if not HelloEndpoint.validate_name(name):\n                raise HTTPException(\n                    status_code=400,\n                    detail={\n                        \"error\": {\n                            \"code\": \"INVALID_NAME\",\n                            \"message\": \"Name parameter contains invalid characters or exceeds 100 characters\"\n                        }\n                    }\n                )\n        \n        message = HelloEndpoint.format_greeting(name)\n        return {\"message\": message}\n    \n    @staticmethod\n    def validate_name(name: str) -> bool:\n        \"\"\"\n        Validate name parameter contains only alphanumeric characters and spaces.\n        \n        Args:\n            name: Name string to validate\n            \n        Returns:\n            bool: True if name is valid, False otherwise\n        \"\"\"\n        if not name or len(name.strip()) == 0:\n            return False\n        \n        if len(name) > HelloEndpoint.MAX_NAME_LENGTH:\n            return False\n        \n        return bool(HelloEndpoint.NAME_PATTERN.match(name))\n    \n    @staticmethod\n    def format_greeting(name: Optional[str]) -> str:\n        \"\"\"\n        Format greeting message based on name parameter.\n        \n        Args:\n            name: Optional name for personalization\n            \n        Returns:\n            str: Formatted greeting message\n        \"\"\"\n        if name is None or len(name.strip()) == 0:\n            return \"Hello, World!\"\n        \n        return f\"Hello, {name.strip()}!\"\n\n\nclass HealthEndpoint:\n    \"\"\"\n    Handler for the /health endpoint providing application status.\n    \n    Returns health status and current timestamp information.\n    \"\"\"\n    \n    @staticmethod\n    def get_health() -> dict[str, str]:\n        \"\"\"\n        Return health status and current timestamp.\n        \n        Returns:\n            dict: Health status and timestamp information\n        \"\"\"\n        timestamp = HealthEndpoint.get_current_timestamp()\n        return {\n            \"status\": \"ok\",\n            \"timestamp\": timestamp\n        }\n    \n    @staticmethod\n    def get_current_timestamp() -> str:\n        \"\"\"\n        Get current UTC timestamp in ISO 8601 format.\n        \n        Returns:\n            str: Current UTC timestamp with 'Z' suffix\n        \"\"\"\n        try:\n            return datetime.utcnow().isoformat() + 'Z'\n        except Exception as e:\n            logger.error(f\"Error generating timestamp: {e}\")\n            # Fallback to basic format if isoformat fails\n            return datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%S.%fZ')\n\n\nclass ErrorHandler:\n    \"\"\"\n    Centralized error handling and HTTP status code management.\n    \n    Provides consistent error response formatting across all endpoints.\n    \"\"\"\n    \n    async def handle_validation_error(self, request: Request, exc: RequestValidationError) -> JSONResponse:\n        \"\"\"\n        Handle FastAPI validation errors and return formatted 400 response.\n        \n        Args:\n            request: FastAPI request object\n            exc: Validation error exception\n            \n        Returns:\n            JSONResponse: Formatted error response\n        \"\"\"\n        logger.warning(f\"Validation error on {request.url}: {exc}\")\n        \n        error_response = self.format_error_response(\n            status_code=400,\n            error_code=\"VALIDATION_ERROR\",\n            message=\"Invalid request parameters\"\n        )\n        \n        return JSONResponse(\n            status_code=400,\n            content=error_response\n        )\n    \n    async def handle_http_exception(self, request: Request, exc: HTTPException) -> JSONResponse:\n        \"\"\"\n        Handle HTTPException and return formatted error response.\n        \n        Args:\n            request: FastAPI request object\n            exc: HTTP exception\n            \n        Returns:\n            JSONResponse: Formatted error response\n        \"\"\"\n        logger.warning(f\"HTTP exception on {request.url}: {exc.status_code} - {exc.detail}\")\n        \n        # If detail is already formatted as our error structure, use it\n        if isinstance(exc.detail, dict) and \"error\" in exc.detail:\n            return JSONResponse(\n                status_code=exc.status_code,\n                content=exc.detail\n            )\n        \n        # Otherwise format it\n        error_response = self.format_error_response(\n            status_code=exc.status_code,\n            error_code=\"HTTP_ERROR\",\n            message=str(exc.detail) if exc.detail else \"HTTP error occurred\"\n        )\n        \n        return JSONResponse(\n            status_code=exc.status_code,\n            content=error_response\n        )\n    \n    async def handle_general_exception(self, request: Request, exc: Exception) -> JSONResponse:\n        \"\"\"\n        Handle unexpected exceptions and return 500 error response.\n        \n        Args:\n            request: FastAPI request object\n            exc: General exception\n            \n        Returns:\n            JSONResponse: Formatted 500 error response\n        \"\"\"\n        logger.error(f\"Unhandled exception on {request.url}: {type(exc).__name__}: {exc}\")\n        \n        error_response = self.format_error_response(\n            status_code=500,\n            error_code=\"INTERNAL_ERROR\",\n            message=\"Internal server error\"\n        )\n        \n        return JSONResponse(\n            status_code=500,\n            content=error_response\n        )\n    \n    @staticmethod\n    def format_",
      "file_type": "source",
      "semantic_unit_id": "SU-001",
      "component_id": "COMP-001",
      "description": "FastAPI application entry point with CORS middleware, router registration, and startup configuration"
    },
    {
      "file_path": "src/api/auth.py",
      "content": "\"\"\"\nAuthentication API endpoints for user registration, login, token validation, and logout functionality.\n\nThis module provides secure authentication endpoints with JWT token management,\npassword hashing, and comprehensive input validation.\n\nComponent ID: COMP-002\nSemantic Unit: SU-002\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport logging\nfrom datetime import datetime, timedelta\nfrom typing import Optional\n\nfrom fastapi import APIRouter, Depends, HTTPException, status\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy.exc import IntegrityError\n\nfrom src.models.user import User\nfrom src.utils.jwt_utils import create_access_token, verify_token, decode_token\nfrom src.utils.password import hash_password, verify_password\nfrom src.schemas.auth import (\n    UserRegistrationRequest,\n    UserLoginRequest,\n    AuthResponse,\n    TokenValidationResponse,\n    UserResponse,\n    LogoutResponse\n)\nfrom src.database import get_db\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Initialize router and security\nrouter = APIRouter(prefix=\"/auth\", tags=[\"authentication\"])\nsecurity = HTTPBearer()\n\n\nclass AuthenticationError(Exception):\n    \"\"\"Custom exception for authentication-related errors.\"\"\"\n    pass\n\n\nclass AuthService:\n    \"\"\"Service class handling authentication business logic.\"\"\"\n    \n    def __init__(self, db: Session):\n        \"\"\"\n        Initialize authentication service.\n        \n        Args:\n            db: Database session for user operations\n        \"\"\"\n        self.db = db\n    \n    def register_user(self, registration_data: UserRegistrationRequest) -> User:\n        \"\"\"\n        Register a new user with validated input data.\n        \n        Args:\n            registration_data: User registration information\n            \n        Returns:\n            User: Created user instance\n            \n        Raises:\n            HTTPException: If email already exists or validation fails\n        \"\"\"\n        # Check if user already exists\n        existing_user = self.db.query(User).filter(\n            User.email == registration_data.email.lower()\n        ).first()\n        \n        if existing_user:\n            logger.warning(f\"Registration attempt with existing email: {registration_data.email}\")\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail={\n                    \"error\": {\n                        \"code\": \"EMAIL_ALREADY_EXISTS\",\n                        \"message\": \"A user with this email address already exists\"\n                    }\n                }\n            )\n        \n        # Validate password strength\n        if not self._validate_password_strength(registration_data.password):\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail={\n                    \"error\": {\n                        \"code\": \"WEAK_PASSWORD\",\n                        \"message\": \"Password must be at least 8 characters long and contain uppercase, lowercase, number, and special character\"\n                    }\n                }\n            )\n        \n        # Hash password and create user\n        hashed_password = hash_password(registration_data.password)\n        \n        new_user = User(\n            email=registration_data.email.lower(),\n            username=registration_data.username,\n            full_name=registration_data.full_name,\n            hashed_password=hashed_password,\n            is_active=True,\n            created_at=datetime.utcnow()\n        )\n        \n        try:\n            self.db.add(new_user)\n            self.db.commit()\n            self.db.refresh(new_user)\n            logger.info(f\"User registered successfully: {new_user.email}\")\n            return new_user\n        except IntegrityError as e:\n            self.db.rollback()\n            logger.error(f\"Database error during user registration: {str(e)}\")\n            raise HTTPException(\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n                detail={\n                    \"error\": {\n                        \"code\": \"REGISTRATION_FAILED\",\n                        \"message\": \"Failed to create user account\"\n                    }\n                }\n            )\n    \n    def authenticate_user(self, login_data: UserLoginRequest) -> User:\n        \"\"\"\n        Authenticate user with email and password.\n        \n        Args:\n            login_data: User login credentials\n            \n        Returns:\n            User: Authenticated user instance\n            \n        Raises:\n            HTTPException: If credentials are invalid\n        \"\"\"\n        user = self.db.query(User).filter(\n            User.email == login_data.email.lower()\n        ).first()\n        \n        if not user or not verify_password(login_data.password, user.hashed_password):\n            logger.warning(f\"Failed login attempt for email: {login_data.email}\")\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail={\n                    \"error\": {\n                        \"code\": \"INVALID_CREDENTIALS\",\n                        \"message\": \"Invalid email or password\"\n                    }\n                }\n            )\n        \n        if not user.is_active:\n            logger.warning(f\"Login attempt for inactive user: {login_data.email}\")\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail={\n                    \"error\": {\n                        \"code\": \"ACCOUNT_DISABLED\",\n                        \"message\": \"User account is disabled\"\n                    }\n                }\n            )\n        \n        # Update last login timestamp\n        user.last_login = datetime.utcnow()\n        self.db.commit()\n        \n        logger.info(f\"User authenticated successfully: {user.email}\")\n        return user\n    \n    def validate_token(self, token: str) -> User:\n        \"\"\"\n        Validate JWT token and return associated user.\n        \n        Args:\n            token: JWT token string\n            \n        Returns:\n            User: User associated with the token\n            \n        Raises:\n            HTTPException: If token is invalid or expired\n        \"\"\"\n        try:\n            if not verify_token(token):\n                raise AuthenticationError(\"Invalid token\")\n            \n            payload = decode_token(token)\n            user_id = payload.get(\"sub\")\n            \n            if not user_id:\n                raise AuthenticationError(\"Token missing user ID\")\n            \n            user = self.db.query(User).filter(User.id == int(user_id)).first()\n            \n            if not user or not user.is_active:\n                raise AuthenticationError(\"User not found or inactive\")\n            \n            return user\n            \n        except AuthenticationError as e:\n            logger.warning(f\"Token validation failed: {str(e)}\")\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail={\n                    \"error\": {\n                        \"code\": \"INVALID_TOKEN\",\n                        \"message\": \"Invalid or expired token\"\n                    }\n                }\n            )\n        except Exception as e:\n            logger.error(f\"Unexpected error during token validation: {str(e)}\")\n            raise HTTPException(\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n                detail={\n                    \"error\": {\n                        \"code\": \"TOKEN_VALIDATION_ERROR\",\n                        \"message\": \"Failed to validate token\"\n                    }\n                }\n            )\n    \n    def _validate_password_strength(self, password: str) -> bool:\n        \"\"\"\n        Validate password meets security requirements.\n        \n        Args:\n            password: Password to validate\n            \n        Returns:\n            bool: True if password meets requirements\n        \"\"\"\n        if len(password) < 8:\n            return False\n        \n        has_upper = any(c.isupper() for c in password)\n        has_lower = any(c.islower() for c in password)\n        has_digit = any(c.isdigit() for c in password)\n        has_special = any(c in \"!@#$%^&*()_+-=[]{}|;:,.<>?\" for c in password)\n        \n        return has_upper and has_lower and has_digit and has_special\n\n\ndef get_current_user(\n    credentials: HTTPAuthorizationCredentials = Depends(",
      "file_type": "source",
      "semantic_unit_id": "SU-002",
      "component_id": "COMP-002",
      "description": "Authentication API endpoints for user registration, login, token validation, and logout functionality"
    },
    {
      "file_path": "src/api/tasks.py",
      "content": "\"\"\"\nTask management API endpoints for CRUD operations with authentication middleware and user authorization.\n\nThis module provides REST API endpoints for managing tasks including creation, retrieval,\nupdating, and deletion with proper user authentication and authorization.\n\nComponent ID: COMP-003\nSemantic Unit: SU-003\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport logging\nfrom datetime import datetime\nfrom typing import List, Optional\nfrom uuid import UUID\n\nfrom fastapi import APIRouter, Depends, HTTPException, Query, status\nfrom fastapi.security import HTTPBearer\nfrom sqlalchemy.orm import Session\n\nfrom src.models.task import Task\nfrom src.models.user import User\nfrom src.schemas.task import (\n    TaskCreate,\n    TaskResponse,\n    TaskUpdate,\n    TaskListResponse,\n    TaskStatus,\n    TaskPriority\n)\nfrom src.utils.jwt_utils import decode_jwt_token, get_current_user\nfrom src.database import get_db\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Initialize router and security\nrouter = APIRouter(prefix=\"/api/v1/tasks\", tags=[\"tasks\"])\nsecurity = HTTPBearer()\n\n\nclass TaskService:\n    \"\"\"Service class for task-related business logic.\"\"\"\n    \n    def __init__(self, db: Session):\n        \"\"\"\n        Initialize TaskService with database session.\n        \n        Args:\n            db: SQLAlchemy database session\n        \"\"\"\n        self.db = db\n    \n    def create_task(self, task_data: TaskCreate, user_id: UUID) -> Task:\n        \"\"\"\n        Create a new task for the authenticated user.\n        \n        Args:\n            task_data: Task creation data\n            user_id: ID of the user creating the task\n            \n        Returns:\n            Task: Created task instance\n            \n        Raises:\n            HTTPException: If task creation fails\n        \"\"\"\n        try:\n            task = Task(\n                title=task_data.title,\n                description=task_data.description,\n                status=task_data.status or TaskStatus.TODO,\n                priority=task_data.priority or TaskPriority.MEDIUM,\n                due_date=task_data.due_date,\n                user_id=user_id,\n                created_at=datetime.utcnow(),\n                updated_at=datetime.utcnow()\n            )\n            \n            self.db.add(task)\n            self.db.commit()\n            self.db.refresh(task)\n            \n            logger.info(f\"Task created successfully: {task.id} for user: {user_id}\")\n            return task\n            \n        except Exception as e:\n            logger.error(f\"Failed to create task for user {user_id}: {str(e)}\")\n            self.db.rollback()\n            raise HTTPException(\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n                detail=\"Failed to create task\"\n            )\n    \n    def get_task_by_id(self, task_id: UUID, user_id: UUID) -> Task:\n        \"\"\"\n        Retrieve a task by ID for the authenticated user.\n        \n        Args:\n            task_id: ID of the task to retrieve\n            user_id: ID of the authenticated user\n            \n        Returns:\n            Task: Retrieved task instance\n            \n        Raises:\n            HTTPException: If task not found or access denied\n        \"\"\"\n        task = self.db.query(Task).filter(\n            Task.id == task_id,\n            Task.user_id == user_id,\n            Task.deleted_at.is_(None)\n        ).first()\n        \n        if not task:\n            logger.warning(f\"Task not found or access denied: {task_id} for user: {user_id}\")\n            raise HTTPException(\n                status_code=status.HTTP_404_NOT_FOUND,\n                detail=\"Task not found\"\n            )\n        \n        return task\n    \n    def get_user_tasks(\n        self,\n        user_id: UUID,\n        status_filter: Optional[TaskStatus] = None,\n        priority_filter: Optional[TaskPriority] = None,\n        skip: int = 0,\n        limit: int = 100\n    ) -> List[Task]:\n        \"\"\"\n        Retrieve tasks for the authenticated user with optional filtering.\n        \n        Args:\n            user_id: ID of the authenticated user\n            status_filter: Optional status filter\n            priority_filter: Optional priority filter\n            skip: Number of records to skip for pagination\n            limit: Maximum number of records to return\n            \n        Returns:\n            List[Task]: List of user's tasks\n        \"\"\"\n        query = self.db.query(Task).filter(\n            Task.user_id == user_id,\n            Task.deleted_at.is_(None)\n        )\n        \n        if status_filter:\n            query = query.filter(Task.status == status_filter)\n        \n        if priority_filter:\n            query = query.filter(Task.priority == priority_filter)\n        \n        tasks = query.order_by(Task.created_at.desc()).offset(skip).limit(limit).all()\n        \n        logger.info(f\"Retrieved {len(tasks)} tasks for user: {user_id}\")\n        return tasks\n    \n    def update_task(self, task_id: UUID, task_data: TaskUpdate, user_id: UUID) -> Task:\n        \"\"\"\n        Update an existing task for the authenticated user.\n        \n        Args:\n            task_id: ID of the task to update\n            task_data: Task update data\n            user_id: ID of the authenticated user\n            \n        Returns:\n            Task: Updated task instance\n            \n        Raises:\n            HTTPException: If task not found or update fails\n        \"\"\"\n        task = self.get_task_by_id(task_id, user_id)\n        \n        try:\n            # Update only provided fields\n            update_data = task_data.dict(exclude_unset=True)\n            for field, value in update_data.items():\n                setattr(task, field, value)\n            \n            task.updated_at = datetime.utcnow()\n            \n            self.db.commit()\n            self.db.refresh(task)\n            \n            logger.info(f\"Task updated successfully: {task_id} for user: {user_id}\")\n            return task\n            \n        except Exception as e:\n            logger.error(f\"Failed to update task {task_id} for user {user_id}: {str(e)}\")\n            self.db.rollback()\n            raise HTTPException(\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n                detail=\"Failed to update task\"\n            )\n    \n    def delete_task(self, task_id: UUID, user_id: UUID) -> None:\n        \"\"\"\n        Soft delete a task for the authenticated user.\n        \n        Args:\n            task_id: ID of the task to delete\n            user_id: ID of the authenticated user\n            \n        Raises:\n            HTTPException: If task not found or deletion fails\n        \"\"\"\n        task = self.get_task_by_id(task_id, user_id)\n        \n        try:\n            task.deleted_at = datetime.utcnow()\n            task.updated_at = datetime.utcnow()\n            \n            self.db.commit()\n            \n            logger.info(f\"Task deleted successfully: {task_id} for user: {user_id}\")\n            \n        except Exception as e:\n            logger.error(f\"Failed to delete task {task_id} for user {user_id}: {str(e)}\")\n            self.db.rollback()\n            raise HTTPException(\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n                detail=\"Failed to delete task\"\n            )\n\n\ndef get_task_service(db: Session = Depends(get_db)) -> TaskService:\n    \"\"\"\n    Dependency to get TaskService instance.\n    \n    Args:\n        db: Database session dependency\n        \n    Returns:\n        TaskService: Task service instance\n    \"\"\"\n    return TaskService(db)\n\n\ndef validate_task_data(task_data: TaskCreate) -> None:\n    \"\"\"\n    Validate task creation data.\n    \n    Args:\n        task_data: Task data to validate\n        \n    Raises:",
      "file_type": "source",
      "semantic_unit_id": "SU-003",
      "component_id": "COMP-003",
      "description": "Task management API endpoints for CRUD operations with authentication middleware and user authorization"
    },
    {
      "file_path": "src/models/user.py",
      "content": "\"\"\"\nUser SQLAlchemy model with authentication fields, profile data, and relationship to tasks.\n\nThis module defines the User model for the application with authentication capabilities,\nprofile information, and relationships to other entities.\n\nComponent ID: COMP-004\nSemantic Unit: SU-004\n\nAuthor: ASP Code Agent\n\"\"\"\n\nfrom datetime import datetime\nfrom typing import Optional, List\nfrom sqlalchemy import Column, Integer, String, DateTime, Boolean, Text\nfrom sqlalchemy.orm import relationship\nfrom sqlalchemy.sql import func\nfrom werkzeug.security import generate_password_hash, check_password_hash\nimport re\n\nfrom src.database.connection import Base\n\n\nclass User(Base):\n    \"\"\"\n    User model for authentication and profile management.\n    \n    This model handles user authentication, profile data, and relationships\n    to other entities in the system like tasks.\n    \n    Attributes:\n        id: Primary key identifier\n        username: Unique username for login\n        email: Unique email address\n        password_hash: Hashed password for authentication\n        first_name: User's first name\n        last_name: User's last name\n        is_active: Whether the user account is active\n        is_verified: Whether the user's email is verified\n        bio: Optional user biography\n        created_at: Timestamp when user was created\n        updated_at: Timestamp when user was last updated\n        last_login: Timestamp of last login\n        tasks: Relationship to user's tasks\n    \"\"\"\n    \n    __tablename__ = \"users\"\n    \n    # Primary key\n    id = Column(Integer, primary_key=True, index=True)\n    \n    # Authentication fields\n    username = Column(String(50), unique=True, index=True, nullable=False)\n    email = Column(String(255), unique=True, index=True, nullable=False)\n    password_hash = Column(String(255), nullable=False)\n    \n    # Profile fields\n    first_name = Column(String(100), nullable=False)\n    last_name = Column(String(100), nullable=False)\n    bio = Column(Text, nullable=True)\n    \n    # Status fields\n    is_active = Column(Boolean, default=True, nullable=False)\n    is_verified = Column(Boolean, default=False, nullable=False)\n    \n    # Timestamp fields\n    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)\n    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False)\n    last_login = Column(DateTime(timezone=True), nullable=True)\n    \n    # Relationships\n    tasks = relationship(\"Task\", back_populates=\"user\", cascade=\"all, delete-orphan\")\n    \n    def __init__(\n        self,\n        username: str,\n        email: str,\n        password: str,\n        first_name: str,\n        last_name: str,\n        bio: Optional[str] = None\n    ) -> None:\n        \"\"\"\n        Initialize a new User instance.\n        \n        Args:\n            username: Unique username for the user\n            email: User's email address\n            password: Plain text password (will be hashed)\n            first_name: User's first name\n            last_name: User's last name\n            bio: Optional biography text\n            \n        Raises:\n            ValueError: If any validation fails\n        \"\"\"\n        self.username = self._validate_username(username)\n        self.email = self._validate_email(email)\n        self.set_password(password)\n        self.first_name = self._validate_name(first_name, \"first_name\")\n        self.last_name = self._validate_name(last_name, \"last_name\")\n        self.bio = self._validate_bio(bio) if bio else None\n        self.is_active = True\n        self.is_verified = False\n    \n    def set_password(self, password: str) -> None:\n        \"\"\"\n        Set the user's password by hashing it.\n        \n        Args:\n            password: Plain text password to hash and store\n            \n        Raises:\n            ValueError: If password doesn't meet requirements\n        \"\"\"\n        validated_password = self._validate_password(password)\n        self.password_hash = generate_password_hash(validated_password)\n    \n    def check_password(self, password: str) -> bool:\n        \"\"\"\n        Check if the provided password matches the stored hash.\n        \n        Args:\n            password: Plain text password to verify\n            \n        Returns:\n            bool: True if password matches, False otherwise\n        \"\"\"\n        if not password or not self.password_hash:\n            return False\n        return check_password_hash(self.password_hash, password)\n    \n    def update_last_login(self) -> None:\n        \"\"\"Update the last_login timestamp to current time.\"\"\"\n        self.last_login = datetime.utcnow()\n    \n    def deactivate(self) -> None:\n        \"\"\"Deactivate the user account.\"\"\"\n        self.is_active = False\n    \n    def activate(self) -> None:\n        \"\"\"Activate the user account.\"\"\"\n        self.is_active = True\n    \n    def verify_email(self) -> None:\n        \"\"\"Mark the user's email as verified.\"\"\"\n        self.is_verified = True\n    \n    def update_profile(\n        self,\n        first_name: Optional[str] = None,\n        last_name: Optional[str] = None,\n        bio: Optional[str] = None\n    ) -> None:\n        \"\"\"\n        Update user profile information.\n        \n        Args:\n            first_name: New first name (optional)\n            last_name: New last name (optional)\n            bio: New biography (optional)\n            \n        Raises:\n            ValueError: If any validation fails\n        \"\"\"\n        if first_name is not None:\n            self.first_name = self._validate_name(first_name, \"first_name\")\n        if last_name is not None:\n            self.last_name = self._validate_name(last_name, \"last_name\")\n        if bio is not None:\n            self.bio = self._validate_bio(bio) if bio.strip() else None\n    \n    @property\n    def full_name(self) -> str:\n        \"\"\"\n        Get the user's full name.\n        \n        Returns:\n            str: Concatenated first and last name\n        \"\"\"\n        return f\"{self.first_name} {self.last_name}\"\n    \n    @property\n    def display_name(self) -> str:\n        \"\"\"\n        Get the user's display name (full name or username).\n        \n        Returns:\n            str: Full name if available, otherwise username\n        \"\"\"\n        if self.first_name and self.last_name:\n            return self.full_name\n        return self.username\n    \n    def to_dict(self, include_sensitive: bool = False) -> dict:\n        \"\"\"\n        Convert user instance to dictionary.\n        \n        Args:\n            include_sensitive: Whether to include sensitive fields like password_hash\n            \n        Returns:\n            dict: User data as dictionary\n        \"\"\"\n        data = {\n            \"id\": self.id,\n            \"username\": self.username,\n            \"email\": self.email,\n            \"first_name\": self.first_name,\n            \"last_name\": self.last_name,\n            \"full_name\": self.full_name,\n            \"bio\": self.bio,\n            \"is_active\": self.is_active,\n            \"is_verified\": self.is_verified,\n            \"created_at\": self.created_at.isoformat() if self.created_at else None,\n            \"updated_at\": self.updated_at.isoformat() if self.updated_at else None,\n            \"last_login\": self.last_login.isoformat() if self.last_login else None,\n        }\n        \n        if include_sensitive:\n            data[\"password_hash\"] = self.password_hash\n            \n        return data\n    \n    def _validate_username(self, username: str) -> str:\n        \"\"\"\n        Validate username format and length.\n        \n        Args:\n            username: Username to validate\n            \n        Returns:\n            str: Validated username\n            \n        Raises:\n            ValueError: If username is invalid",
      "file_type": "source",
      "semantic_unit_id": "SU-004",
      "component_id": "COMP-004",
      "description": "User SQLAlchemy model with authentication fields, profile data, and relationship to tasks"
    },
    {
      "file_path": "src/models/task.py",
      "content": "\"\"\"\nTask SQLAlchemy model with CRUD operations, status management, and user relationship.\n\nThis module defines the Task model with comprehensive CRUD operations,\nstatus management functionality, and relationships to the User model.\n\nComponent ID: COMP-005\nSemantic Unit: SU-005\n\nAuthor: ASP Code Agent\n\"\"\"\n\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import List, Optional, Dict, Any\nfrom sqlalchemy import Column, Integer, String, Text, DateTime, ForeignKey, Boolean, Index\nfrom sqlalchemy.orm import relationship, Session\nfrom sqlalchemy.exc import SQLAlchemyError\nimport logging\n\nfrom src.database.connection import Base\nfrom src.models.user import User\n\nlogger = logging.getLogger(__name__)\n\n\nclass TaskStatus(str, Enum):\n    \"\"\"Enumeration of possible task statuses.\"\"\"\n    PENDING = \"pending\"\n    IN_PROGRESS = \"in_progress\"\n    COMPLETED = \"completed\"\n    CANCELLED = \"cancelled\"\n\n\nclass TaskPriority(str, Enum):\n    \"\"\"Enumeration of task priorities.\"\"\"\n    LOW = \"low\"\n    MEDIUM = \"medium\"\n    HIGH = \"high\"\n    URGENT = \"urgent\"\n\n\nclass Task(Base):\n    \"\"\"\n    Task model representing a user task with status management.\n    \n    This model provides comprehensive task management functionality including\n    CRUD operations, status transitions, and user relationships.\n    \n    Attributes:\n        id: Primary key identifier\n        title: Task title (required, max 200 chars)\n        description: Detailed task description (optional)\n        status: Current task status (TaskStatus enum)\n        priority: Task priority level (TaskPriority enum)\n        user_id: Foreign key to User model\n        created_at: Timestamp when task was created\n        updated_at: Timestamp when task was last modified\n        due_date: Optional due date for task completion\n        completed_at: Timestamp when task was completed\n        is_active: Soft delete flag\n        \n    Relationships:\n        user: Many-to-one relationship with User model\n    \"\"\"\n    \n    __tablename__ = \"tasks\"\n    \n    # Primary key\n    id = Column(Integer, primary_key=True, index=True)\n    \n    # Task details\n    title = Column(String(200), nullable=False, index=True)\n    description = Column(Text, nullable=True)\n    status = Column(String(20), nullable=False, default=TaskStatus.PENDING.value, index=True)\n    priority = Column(String(10), nullable=False, default=TaskPriority.MEDIUM.value, index=True)\n    \n    # User relationship\n    user_id = Column(Integer, ForeignKey(\"users.id\"), nullable=False, index=True)\n    user = relationship(\"User\", back_populates=\"tasks\")\n    \n    # Timestamps\n    created_at = Column(DateTime, nullable=False, default=datetime.utcnow, index=True)\n    updated_at = Column(DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)\n    due_date = Column(DateTime, nullable=True, index=True)\n    completed_at = Column(DateTime, nullable=True)\n    \n    # Soft delete\n    is_active = Column(Boolean, nullable=False, default=True, index=True)\n    \n    # Composite indexes for common queries\n    __table_args__ = (\n        Index('idx_user_status', 'user_id', 'status'),\n        Index('idx_user_priority', 'user_id', 'priority'),\n        Index('idx_status_due_date', 'status', 'due_date'),\n        Index('idx_user_active', 'user_id', 'is_active'),\n    )\n    \n    def __repr__(self) -> str:\n        \"\"\"String representation of Task instance.\"\"\"\n        return f\"<Task(id={self.id}, title='{self.title}', status='{self.status}', user_id={self.user_id})>\"\n    \n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Convert Task instance to dictionary representation.\n        \n        Returns:\n            Dict[str, Any]: Dictionary containing all task attributes\n        \"\"\"\n        return {\n            'id': self.id,\n            'title': self.title,\n            'description': self.description,\n            'status': self.status,\n            'priority': self.priority,\n            'user_id': self.user_id,\n            'created_at': self.created_at.isoformat() if self.created_at else None,\n            'updated_at': self.updated_at.isoformat() if self.updated_at else None,\n            'due_date': self.due_date.isoformat() if self.due_date else None,\n            'completed_at': self.completed_at.isoformat() if self.completed_at else None,\n            'is_active': self.is_active\n        }\n    \n    def update_status(self, new_status: TaskStatus) -> bool:\n        \"\"\"\n        Update task status with validation and automatic timestamp handling.\n        \n        Args:\n            new_status: New status to set for the task\n            \n        Returns:\n            bool: True if status was updated successfully, False otherwise\n            \n        Raises:\n            ValueError: If status transition is invalid\n        \"\"\"\n        if not isinstance(new_status, TaskStatus):\n            raise ValueError(f\"Invalid status type: {type(new_status)}\")\n        \n        # Validate status transitions\n        valid_transitions = {\n            TaskStatus.PENDING: [TaskStatus.IN_PROGRESS, TaskStatus.CANCELLED],\n            TaskStatus.IN_PROGRESS: [TaskStatus.COMPLETED, TaskStatus.CANCELLED, TaskStatus.PENDING],\n            TaskStatus.COMPLETED: [TaskStatus.IN_PROGRESS],  # Allow reopening completed tasks\n            TaskStatus.CANCELLED: [TaskStatus.PENDING, TaskStatus.IN_PROGRESS]  # Allow reactivating cancelled tasks\n        }\n        \n        current_status = TaskStatus(self.status)\n        if new_status not in valid_transitions.get(current_status, []):\n            raise ValueError(f\"Invalid status transition from {current_status.value} to {new_status.value}\")\n        \n        # Update status and related timestamps\n        self.status = new_status.value\n        self.updated_at = datetime.utcnow()\n        \n        if new_status == TaskStatus.COMPLETED:\n            self.completed_at = datetime.utcnow()\n        elif current_status == TaskStatus.COMPLETED and new_status != TaskStatus.COMPLETED:\n            # Clear completed_at when moving away from completed status\n            self.completed_at = None\n        \n        logger.info(f\"Task {self.id} status updated from {current_status.value} to {new_status.value}\")\n        return True\n    \n    def is_overdue(self) -> bool:\n        \"\"\"\n        Check if task is overdue based on due_date.\n        \n        Returns:\n            bool: True if task is overdue, False otherwise\n        \"\"\"\n        if not self.due_date or self.status == TaskStatus.COMPLETED.value:\n            return False\n        \n        return datetime.utcnow() > self.due_date\n    \n    def days_until_due(self) -> Optional[int]:\n        \"\"\"\n        Calculate days until task is due.\n        \n        Returns:\n            Optional[int]: Number of days until due date, None if no due date set\n        \"\"\"\n        if not self.due_date:\n            return None\n        \n        delta = self.due_date - datetime.utcnow()\n        return delta.days\n    \n    @classmethod\n    def create(cls, db: Session, title: str, user_id: int, description: Optional[str] = None,\n               priority: TaskPriority = TaskPriority.MEDIUM, due_date: Optional[datetime] = None) -> 'Task':\n        \"\"\"\n        Create a new task with validation.\n        \n        Args:\n            db: Database session\n            title: Task title (required, max 200 chars)\n            user_id: ID of the user who owns the task\n            description: Optional task description\n            priority: Task priority level\n            due_date: Optional due date",
      "file_type": "source",
      "semantic_unit_id": "SU-005",
      "component_id": "COMP-005",
      "description": "Task SQLAlchemy model with CRUD operations, status management, and user relationship"
    },
    {
      "file_path": "src/schemas/auth.py",
      "content": "\"\"\"\nPydantic schemas for authentication request/response validation.\n\nThis module defines data validation schemas for authentication endpoints including\nlogin, registration, token management, and user profile operations.\n\nComponent ID: COMP-006\nSemantic Unit: SU-006\n\nAuthor: ASP Code Agent\n\"\"\"\n\nfrom datetime import datetime\nfrom typing import Optional\nfrom pydantic import BaseModel, EmailStr, Field, validator\nimport re\n\n\nclass UserRegistrationRequest(BaseModel):\n    \"\"\"Schema for user registration request validation.\"\"\"\n    \n    email: EmailStr = Field(\n        ...,\n        description=\"User email address\",\n        example=\"user@example.com\"\n    )\n    password: str = Field(\n        ...,\n        min_length=8,\n        max_length=128,\n        description=\"User password (8-128 characters)\",\n        example=\"SecurePassword123!\"\n    )\n    full_name: str = Field(\n        ...,\n        min_length=1,\n        max_length=100,\n        description=\"User full name\",\n        example=\"John Doe\"\n    )\n    \n    @validator('password')\n    def validate_password_strength(cls, v: str) -> str:\n        \"\"\"\n        Validate password meets security requirements.\n        \n        Args:\n            v: Password string to validate\n            \n        Returns:\n            str: Validated password\n            \n        Raises:\n            ValueError: If password doesn't meet requirements\n        \"\"\"\n        if not re.search(r'[A-Z]', v):\n            raise ValueError('Password must contain at least one uppercase letter')\n        if not re.search(r'[a-z]', v):\n            raise ValueError('Password must contain at least one lowercase letter')\n        if not re.search(r'\\d', v):\n            raise ValueError('Password must contain at least one digit')\n        if not re.search(r'[!@#$%^&*(),.?\":{}|<>]', v):\n            raise ValueError('Password must contain at least one special character')\n        return v\n    \n    @validator('full_name')\n    def validate_full_name(cls, v: str) -> str:\n        \"\"\"\n        Validate full name contains only allowed characters.\n        \n        Args:\n            v: Full name string to validate\n            \n        Returns:\n            str: Validated and cleaned full name\n            \n        Raises:\n            ValueError: If name contains invalid characters\n        \"\"\"\n        # Allow letters, spaces, hyphens, and apostrophes\n        if not re.match(r\"^[a-zA-Z\\s\\-']+$\", v.strip()):\n            raise ValueError('Full name can only contain letters, spaces, hyphens, and apostrophes')\n        return v.strip()\n\n\nclass UserLoginRequest(BaseModel):\n    \"\"\"Schema for user login request validation.\"\"\"\n    \n    email: EmailStr = Field(\n        ...,\n        description=\"User email address\",\n        example=\"user@example.com\"\n    )\n    password: str = Field(\n        ...,\n        min_length=1,\n        max_length=128,\n        description=\"User password\",\n        example=\"SecurePassword123!\"\n    )\n\n\nclass TokenResponse(BaseModel):\n    \"\"\"Schema for authentication token response.\"\"\"\n    \n    access_token: str = Field(\n        ...,\n        description=\"JWT access token\",\n        example=\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\"\n    )\n    refresh_token: str = Field(\n        ...,\n        description=\"JWT refresh token\",\n        example=\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\"\n    )\n    token_type: str = Field(\n        default=\"bearer\",\n        description=\"Token type\",\n        example=\"bearer\"\n    )\n    expires_in: int = Field(\n        ...,\n        description=\"Access token expiration time in seconds\",\n        example=3600\n    )\n\n\nclass TokenRefreshRequest(BaseModel):\n    \"\"\"Schema for token refresh request validation.\"\"\"\n    \n    refresh_token: str = Field(\n        ...,\n        description=\"Valid refresh token\",\n        example=\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\"\n    )\n\n\nclass UserProfileResponse(BaseModel):\n    \"\"\"Schema for user profile response.\"\"\"\n    \n    id: int = Field(\n        ...,\n        description=\"User unique identifier\",\n        example=1\n    )\n    email: EmailStr = Field(\n        ...,\n        description=\"User email address\",\n        example=\"user@example.com\"\n    )\n    full_name: str = Field(\n        ...,\n        description=\"User full name\",\n        example=\"John Doe\"\n    )\n    is_active: bool = Field(\n        ...,\n        description=\"User account status\",\n        example=True\n    )\n    created_at: datetime = Field(\n        ...,\n        description=\"Account creation timestamp\",\n        example=\"2023-01-01T00:00:00Z\"\n    )\n    last_login: Optional[datetime] = Field(\n        None,\n        description=\"Last login timestamp\",\n        example=\"2023-01-01T12:00:00Z\"\n    )\n\n\nclass UserProfileUpdateRequest(BaseModel):\n    \"\"\"Schema for user profile update request validation.\"\"\"\n    \n    full_name: Optional[str] = Field(\n        None,\n        min_length=1,\n        max_length=100,\n        description=\"Updated full name\",\n        example=\"John Smith\"\n    )\n    \n    @validator('full_name')\n    def validate_full_name(cls, v: Optional[str]) -> Optional[str]:\n        \"\"\"\n        Validate full name contains only allowed characters.\n        \n        Args:\n            v: Full name string to validate\n            \n        Returns:\n            Optional[str]: Validated and cleaned full name\n            \n        Raises:\n            ValueError: If name contains invalid characters\n        \"\"\"\n        if v is None:\n            return v\n        \n        # Allow letters, spaces, hyphens, and apostrophes\n        if not re.match(r\"^[a-zA-Z\\s\\-']+$\", v.strip()):\n            raise ValueError('Full name can only contain letters, spaces, hyphens, and apostrophes')\n        return v.strip()\n\n\nclass PasswordChangeRequest(BaseModel):\n    \"\"\"Schema for password change request validation.\"\"\"\n    \n    current_password: str = Field(\n        ...,\n        min_length=1,\n        max_length=128,\n        description=\"Current password\",\n        example=\"OldPassword123!\"\n    )\n    new_password: str = Field(\n        ...,\n        min_length=8,\n        max_length=128,\n        description=\"New password (8-128 characters)\",\n        example=\"NewSecurePassword123!\"\n    )\n    \n    @validator('new_password')\n    def validate_new_password_strength(cls, v: str) -> str:\n        \"\"\"\n        Validate new password meets security requirements.\n        \n        Args:\n            v: New password string to validate\n            \n        Returns:\n            str: Validated password\n            \n        Raises:\n            ValueError: If password doesn't meet requirements\n        \"\"\"\n        if not re.search(r'[A-Z]', v):\n            raise ValueError('New password must contain at least one uppercase letter')\n        if not re.search(r'[a-z]', v):\n            raise ValueError('New password must contain at least one lowercase letter')\n        if not re.search(r'\\d', v):\n            raise ValueError('New password must contain at least one digit')\n        if not re.search(r'[!@#$%^&*(),.?\":{}|<>]', v):\n            raise ValueError('New password must contain at least one special character')\n        return v\n\n\nclass PasswordResetRequest(BaseModel):\n    \"\"\"Schema for password reset request validation.\"\"\"\n    \n    email: EmailStr = Field(\n        ...,\n        description=\"User email address for password reset\",\n        example=\"user@example.com\"\n    )\n\n\nclass PasswordResetConfirmRequest(BaseModel):\n    \"\"\"Schema for password reset confirmation request validation.\"\"\"\n    \n    token: str = Field(\n        ...,\n        min_length",
      "file_type": "source",
      "semantic_unit_id": "SU-006",
      "component_id": "COMP-006",
      "description": "Pydantic schemas for authentication request/response validation including login, registration, and token models"
    },
    {
      "file_path": "src/schemas/task.py",
      "content": "\"\"\"\nPydantic schemas for task request/response validation.\n\nThis module defines the data models used for task-related API endpoints,\nincluding create, update, and response schemas with proper validation.\n\nComponent ID: COMP-007\nSemantic Unit: SU-007\n\nAuthor: ASP Code Agent\n\"\"\"\n\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Optional\nfrom uuid import UUID\n\nfrom pydantic import BaseModel, Field, validator\n\n\nclass TaskStatus(str, Enum):\n    \"\"\"Enumeration of possible task statuses.\"\"\"\n    PENDING = \"pending\"\n    IN_PROGRESS = \"in_progress\"\n    COMPLETED = \"completed\"\n    CANCELLED = \"cancelled\"\n\n\nclass TaskPriority(str, Enum):\n    \"\"\"Enumeration of task priority levels.\"\"\"\n    LOW = \"low\"\n    MEDIUM = \"medium\"\n    HIGH = \"high\"\n    URGENT = \"urgent\"\n\n\nclass TaskCreateRequest(BaseModel):\n    \"\"\"Schema for creating a new task.\"\"\"\n    \n    title: str = Field(\n        ...,\n        min_length=1,\n        max_length=200,\n        description=\"Task title\"\n    )\n    description: Optional[str] = Field(\n        None,\n        max_length=2000,\n        description=\"Detailed task description\"\n    )\n    priority: TaskPriority = Field(\n        TaskPriority.MEDIUM,\n        description=\"Task priority level\"\n    )\n    due_date: Optional[datetime] = Field(\n        None,\n        description=\"Task due date and time\"\n    )\n    tags: Optional[list[str]] = Field(\n        None,\n        description=\"List of task tags\"\n    )\n    \n    @validator('title')\n    def validate_title(cls, v: str) -> str:\n        \"\"\"Validate task title is not empty after stripping whitespace.\"\"\"\n        if not v.strip():\n            raise ValueError('Title cannot be empty or only whitespace')\n        return v.strip()\n    \n    @validator('description')\n    def validate_description(cls, v: Optional[str]) -> Optional[str]:\n        \"\"\"Validate and clean task description.\"\"\"\n        if v is not None:\n            v = v.strip()\n            if not v:\n                return None\n        return v\n    \n    @validator('due_date')\n    def validate_due_date(cls, v: Optional[datetime]) -> Optional[datetime]:\n        \"\"\"Validate due date is not in the past.\"\"\"\n        if v is not None and v < datetime.utcnow():\n            raise ValueError('Due date cannot be in the past')\n        return v\n    \n    @validator('tags')\n    def validate_tags(cls, v: Optional[list[str]]) -> Optional[list[str]]:\n        \"\"\"Validate and clean task tags.\"\"\"\n        if v is not None:\n            # Remove empty tags and duplicates while preserving order\n            cleaned_tags = []\n            seen = set()\n            for tag in v:\n                tag = tag.strip().lower()\n                if tag and tag not in seen:\n                    if len(tag) > 50:\n                        raise ValueError('Tag length cannot exceed 50 characters')\n                    cleaned_tags.append(tag)\n                    seen.add(tag)\n            return cleaned_tags if cleaned_tags else None\n        return v\n\n    class Config:\n        \"\"\"Pydantic model configuration.\"\"\"\n        json_encoders = {\n            datetime: lambda v: v.isoformat() + 'Z' if v else None\n        }\n\n\nclass TaskUpdateRequest(BaseModel):\n    \"\"\"Schema for updating an existing task.\"\"\"\n    \n    title: Optional[str] = Field(\n        None,\n        min_length=1,\n        max_length=200,\n        description=\"Updated task title\"\n    )\n    description: Optional[str] = Field(\n        None,\n        max_length=2000,\n        description=\"Updated task description\"\n    )\n    status: Optional[TaskStatus] = Field(\n        None,\n        description=\"Updated task status\"\n    )\n    priority: Optional[TaskPriority] = Field(\n        None,\n        description=\"Updated task priority\"\n    )\n    due_date: Optional[datetime] = Field(\n        None,\n        description=\"Updated task due date\"\n    )\n    tags: Optional[list[str]] = Field(\n        None,\n        description=\"Updated list of task tags\"\n    )\n    \n    @validator('title')\n    def validate_title(cls, v: Optional[str]) -> Optional[str]:\n        \"\"\"Validate task title is not empty after stripping whitespace.\"\"\"\n        if v is not None:\n            v = v.strip()\n            if not v:\n                raise ValueError('Title cannot be empty or only whitespace')\n        return v\n    \n    @validator('description')\n    def validate_description(cls, v: Optional[str]) -> Optional[str]:\n        \"\"\"Validate and clean task description.\"\"\"\n        if v is not None:\n            v = v.strip()\n            if not v:\n                return None\n        return v\n    \n    @validator('due_date')\n    def validate_due_date(cls, v: Optional[datetime]) -> Optional[datetime]:\n        \"\"\"Validate due date is not in the past.\"\"\"\n        if v is not None and v < datetime.utcnow():\n            raise ValueError('Due date cannot be in the past')\n        return v\n    \n    @validator('tags')\n    def validate_tags(cls, v: Optional[list[str]]) -> Optional[list[str]]:\n        \"\"\"Validate and clean task tags.\"\"\"\n        if v is not None:\n            # Remove empty tags and duplicates while preserving order\n            cleaned_tags = []\n            seen = set()\n            for tag in v:\n                tag = tag.strip().lower()\n                if tag and tag not in seen:\n                    if len(tag) > 50:\n                        raise ValueError('Tag length cannot exceed 50 characters')\n                    cleaned_tags.append(tag)\n                    seen.add(tag)\n            return cleaned_tags if cleaned_tags else None\n        return v\n\n    class Config:\n        \"\"\"Pydantic model configuration.\"\"\"\n        json_encoders = {\n            datetime: lambda v: v.isoformat() + 'Z' if v else None\n        }\n\n\nclass TaskResponse(BaseModel):\n    \"\"\"Schema for task response data.\"\"\"\n    \n    id: UUID = Field(\n        ...,\n        description=\"Unique task identifier\"\n    )\n    title: str = Field(\n        ...,\n        description=\"Task title\"\n    )\n    description: Optional[str] = Field(\n        None,\n        description=\"Task description\"\n    )\n    status: TaskStatus = Field(\n        ...,\n        description=\"Current task status\"\n    )\n    priority: TaskPriority = Field(\n        ...,\n        description=\"Task priority level\"\n    )\n    created_at: datetime = Field(\n        ...,\n        description=\"Task creation timestamp\"\n    )\n    updated_at: datetime = Field(\n        ...,\n        description=\"Task last update timestamp\"\n    )\n    due_date: Optional[datetime] = Field(\n        None,\n        description=\"Task due date\"\n    )\n    completed_at: Optional[datetime] = Field(\n        None,\n        description=\"Task completion timestamp\"\n    )\n    tags: Optional[list[str]] = Field(\n        None,\n        description=\"List of task tags\"\n    )\n\n    class Config:\n        \"\"\"Pydantic model configuration.\"\"\"\n        json_encoders = {\n            datetime: lambda v: v.isoformat() + 'Z' if v else None\n        }\n\n\nclass TaskListResponse(BaseModel):\n    \"\"\"Schema for paginated task list response.\"\"\"\n    \n    tasks: list[TaskResponse] = Field(\n        ...,\n        description=\"List of tasks\"\n    )\n    total: int = Field(\n        ...,\n        ge=0,\n        description=\"Total number of tasks\"\n    )\n    page: int = Field(\n        ...,\n        ge=1,\n        description=\"Current page number\"\n    )\n    page_size: int = Field(\n        ...,\n        ge=1,\n        le=100,\n        description=\"Number of tasks per page\"\n    )\n    total_pages: int = Field(\n        ...,\n        ge=0,\n        description=\"Total number of pages\"",
      "file_type": "source",
      "semantic_unit_id": "SU-007",
      "component_id": "COMP-007",
      "description": "Pydantic schemas for task request/response validation including create, update, and response models"
    },
    {
      "file_path": "src/utils/jwt_utils.py",
      "content": "\"\"\"\nJWT token generation, validation, decoding utilities with expiration handling and security features.\n\nThis module provides comprehensive JWT token management including secure token generation,\nvalidation with expiration checking, and decoding with proper error handling.\n\nComponent ID: COMP-008\nSemantic Unit: SU-008\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport hashlib\nimport hmac\nimport json\nimport logging\nimport secrets\nimport time\nfrom base64 import urlsafe_b64decode, urlsafe_b64encode\nfrom datetime import datetime, timedelta, timezone\nfrom typing import Any, Dict, Optional, Union\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n\nclass JWTError(Exception):\n    \"\"\"Base exception for JWT-related errors.\"\"\"\n    pass\n\n\nclass JWTExpiredError(JWTError):\n    \"\"\"Exception raised when JWT token has expired.\"\"\"\n    pass\n\n\nclass JWTInvalidError(JWTError):\n    \"\"\"Exception raised when JWT token is invalid or malformed.\"\"\"\n    pass\n\n\nclass JWTSignatureError(JWTError):\n    \"\"\"Exception raised when JWT signature verification fails.\"\"\"\n    pass\n\n\nclass JWTUtils:\n    \"\"\"\n    JWT token utilities for generation, validation, and decoding.\n    \n    Provides secure JWT token management with HMAC-SHA256 signing,\n    expiration handling, and comprehensive validation.\n    \"\"\"\n    \n    def __init__(self, secret_key: str, default_expiry_hours: int = 24) -> None:\n        \"\"\"\n        Initialize JWT utilities with secret key and default expiry.\n        \n        Args:\n            secret_key: Secret key for signing tokens (minimum 32 characters)\n            default_expiry_hours: Default token expiry in hours\n            \n        Raises:\n            ValueError: If secret key is too short or invalid\n        \"\"\"\n        if not secret_key or len(secret_key) < 32:\n            raise ValueError(\"Secret key must be at least 32 characters long\")\n        \n        self.secret_key = secret_key.encode('utf-8')\n        self.default_expiry_hours = default_expiry_hours\n        self.algorithm = 'HS256'\n        \n        logger.info(\"JWT utilities initialized with %d hour default expiry\", default_expiry_hours)\n    \n    def generate_token(\n        self,\n        payload: Dict[str, Any],\n        expiry_hours: Optional[int] = None,\n        include_jti: bool = True\n    ) -> str:\n        \"\"\"\n        Generate a JWT token with the given payload.\n        \n        Args:\n            payload: Token payload data\n            expiry_hours: Token expiry in hours (uses default if None)\n            include_jti: Whether to include unique token ID (jti claim)\n            \n        Returns:\n            str: Encoded JWT token\n            \n        Raises:\n            ValueError: If payload is invalid\n            JWTError: If token generation fails\n        \"\"\"\n        if not isinstance(payload, dict):\n            raise ValueError(\"Payload must be a dictionary\")\n        \n        try:\n            # Create header\n            header = {\n                'typ': 'JWT',\n                'alg': self.algorithm\n            }\n            \n            # Create payload with standard claims\n            now = datetime.now(timezone.utc)\n            expiry_time = now + timedelta(hours=expiry_hours or self.default_expiry_hours)\n            \n            token_payload = payload.copy()\n            token_payload.update({\n                'iat': int(now.timestamp()),  # Issued at\n                'exp': int(expiry_time.timestamp()),  # Expiration time\n                'nbf': int(now.timestamp())  # Not before\n            })\n            \n            # Add unique token ID if requested\n            if include_jti:\n                token_payload['jti'] = self._generate_jti()\n            \n            # Encode header and payload\n            encoded_header = self._base64url_encode(json.dumps(header, separators=(',', ':')))\n            encoded_payload = self._base64url_encode(json.dumps(token_payload, separators=(',', ':')))\n            \n            # Create signature\n            message = f\"{encoded_header}.{encoded_payload}\"\n            signature = self._create_signature(message)\n            \n            # Combine all parts\n            token = f\"{message}.{signature}\"\n            \n            logger.debug(\"Generated JWT token with expiry: %s\", expiry_time.isoformat())\n            return token\n            \n        except Exception as e:\n            logger.error(\"Failed to generate JWT token: %s\", str(e))\n            raise JWTError(f\"Token generation failed: {str(e)}\") from e\n    \n    def validate_token(self, token: str, verify_expiry: bool = True) -> bool:\n        \"\"\"\n        Validate a JWT token without decoding the payload.\n        \n        Args:\n            token: JWT token to validate\n            verify_expiry: Whether to check token expiration\n            \n        Returns:\n            bool: True if token is valid, False otherwise\n        \"\"\"\n        try:\n            self.decode_token(token, verify_expiry=verify_expiry)\n            return True\n        except JWTError:\n            return False\n    \n    def decode_token(\n        self,\n        token: str,\n        verify_expiry: bool = True,\n        verify_signature: bool = True\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Decode and validate a JWT token.\n        \n        Args:\n            token: JWT token to decode\n            verify_expiry: Whether to check token expiration\n            verify_signature: Whether to verify token signature\n            \n        Returns:\n            dict: Decoded token payload\n            \n        Raises:\n            JWTInvalidError: If token format is invalid\n            JWTSignatureError: If signature verification fails\n            JWTExpiredError: If token has expired\n        \"\"\"\n        if not token or not isinstance(token, str):\n            raise JWTInvalidError(\"Token must be a non-empty string\")\n        \n        try:\n            # Split token into parts\n            parts = token.split('.')\n            if len(parts) != 3:\n                raise JWTInvalidError(\"Token must have exactly 3 parts separated by dots\")\n            \n            encoded_header, encoded_payload, encoded_signature = parts\n            \n            # Decode header\n            header = self._decode_json_part(encoded_header, \"header\")\n            \n            # Validate header\n            if header.get('typ') != 'JWT':\n                raise JWTInvalidError(\"Invalid token type in header\")\n            \n            if header.get('alg') != self.algorithm:\n                raise JWTInvalidError(f\"Unsupported algorithm: {header.get('alg')}\")\n            \n            # Verify signature if requested\n            if verify_signature:\n                message = f\"{encoded_header}.{encoded_payload}\"\n                expected_signature = self._create_signature(message)\n                \n                if not self._constant_time_compare(encoded_signature, expected_signature):\n                    raise JWTSignatureError(\"Token signature verification failed\")\n            \n            # Decode payload\n            payload = self._decode_json_part(encoded_payload, \"payload\")\n            \n            # Verify expiration if requested\n            if verify_expiry:\n                self._verify_token_expiry(payload)\n            \n            # Verify not-before claim\n            self._verify_not_before(payload)\n            \n            logger.debug(\"Successfully decoded JWT token\")\n            return payload\n            \n        except JWTError:\n            raise\n        except Exception as e:\n            logger.error(\"Failed to decode JWT token: %s\", str(e))\n            raise JWTInvalidError(f\"Token decoding failed: {str(e)}\") from e\n    \n    def refresh_token(self, token: str, new_expiry_hours: Optional[int] = None) -> str:\n        \"\"\"\n        Refresh a JWT token with new expiration time.\n        \n        Args:\n            token: Original JWT token\n            new_expiry_hours: New expiry in hours (uses default if None)\n            \n        Returns:\n            str: New JWT token with updated expiration\n            \n        Raises:\n            JWTError: If original token is invalid or refresh fails\n        \"\"\"\n        try:",
      "file_type": "source",
      "semantic_unit_id": "SU-008",
      "component_id": "COMP-008",
      "description": "JWT token generation, validation, decoding utilities with expiration handling and security features"
    },
    {
      "file_path": "src/utils/password.py",
      "content": "\"\"\"\nPassword hashing and verification utilities using bcrypt.\n\nThis module provides secure password hashing and verification functionality\nusing the bcrypt algorithm with configurable salt rounds.\n\nComponent ID: COMP-009\nSemantic Unit: SU-009\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport logging\nfrom typing import Optional\n\nimport bcrypt\n\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Default salt rounds for bcrypt hashing\nDEFAULT_SALT_ROUNDS = 12\n\n\nclass PasswordHasher:\n    \"\"\"\n    Password hashing and verification utility class using bcrypt.\n    \n    This class provides methods to securely hash passwords and verify\n    password attempts against stored hashes using the bcrypt algorithm.\n    \"\"\"\n    \n    def __init__(self, salt_rounds: int = DEFAULT_SALT_ROUNDS) -> None:\n        \"\"\"\n        Initialize the password hasher with specified salt rounds.\n        \n        Args:\n            salt_rounds: Number of salt rounds for bcrypt (default: 12)\n            \n        Raises:\n            ValueError: If salt_rounds is not between 4 and 31\n        \"\"\"\n        if not isinstance(salt_rounds, int):\n            raise ValueError(\"Salt rounds must be an integer\")\n        \n        if salt_rounds < 4 or salt_rounds > 31:\n            raise ValueError(\"Salt rounds must be between 4 and 31\")\n        \n        self.salt_rounds = salt_rounds\n        logger.debug(f\"PasswordHasher initialized with {salt_rounds} salt rounds\")\n    \n    def hash_password(self, password: str) -> str:\n        \"\"\"\n        Hash a password using bcrypt with the configured salt rounds.\n        \n        Args:\n            password: Plain text password to hash\n            \n        Returns:\n            str: Base64-encoded bcrypt hash of the password\n            \n        Raises:\n            ValueError: If password is empty or None\n            RuntimeError: If hashing fails due to bcrypt error\n        \"\"\"\n        if not password:\n            raise ValueError(\"Password cannot be empty or None\")\n        \n        if not isinstance(password, str):\n            raise ValueError(\"Password must be a string\")\n        \n        try:\n            # Convert password to bytes\n            password_bytes = password.encode('utf-8')\n            \n            # Generate salt and hash password\n            salt = bcrypt.gensalt(rounds=self.salt_rounds)\n            hashed = bcrypt.hashpw(password_bytes, salt)\n            \n            # Return hash as string\n            hash_str = hashed.decode('utf-8')\n            logger.debug(\"Password hashed successfully\")\n            return hash_str\n            \n        except Exception as e:\n            logger.error(f\"Failed to hash password: {str(e)}\")\n            raise RuntimeError(f\"Password hashing failed: {str(e)}\") from e\n    \n    def verify_password(self, password: str, hashed_password: str) -> bool:\n        \"\"\"\n        Verify a password against a stored bcrypt hash.\n        \n        Args:\n            password: Plain text password to verify\n            hashed_password: Stored bcrypt hash to verify against\n            \n        Returns:\n            bool: True if password matches hash, False otherwise\n            \n        Raises:\n            ValueError: If password or hashed_password is empty or None\n            RuntimeError: If verification fails due to bcrypt error\n        \"\"\"\n        if not password:\n            raise ValueError(\"Password cannot be empty or None\")\n        \n        if not hashed_password:\n            raise ValueError(\"Hashed password cannot be empty or None\")\n        \n        if not isinstance(password, str):\n            raise ValueError(\"Password must be a string\")\n        \n        if not isinstance(hashed_password, str):\n            raise ValueError(\"Hashed password must be a string\")\n        \n        try:\n            # Convert inputs to bytes\n            password_bytes = password.encode('utf-8')\n            hash_bytes = hashed_password.encode('utf-8')\n            \n            # Verify password against hash\n            is_valid = bcrypt.checkpw(password_bytes, hash_bytes)\n            \n            logger.debug(f\"Password verification result: {is_valid}\")\n            return is_valid\n            \n        except Exception as e:\n            logger.error(f\"Failed to verify password: {str(e)}\")\n            raise RuntimeError(f\"Password verification failed: {str(e)}\") from e\n\n\n# Module-level convenience functions\n_default_hasher: Optional[PasswordHasher] = None\n\n\ndef get_default_hasher() -> PasswordHasher:\n    \"\"\"\n    Get the default password hasher instance.\n    \n    Returns:\n        PasswordHasher: Default hasher with standard salt rounds\n    \"\"\"\n    global _default_hasher\n    if _default_hasher is None:\n        _default_hasher = PasswordHasher()\n    return _default_hasher\n\n\ndef hash_password(password: str, salt_rounds: int = DEFAULT_SALT_ROUNDS) -> str:\n    \"\"\"\n    Hash a password using bcrypt (convenience function).\n    \n    Args:\n        password: Plain text password to hash\n        salt_rounds: Number of salt rounds for bcrypt (default: 12)\n        \n    Returns:\n        str: Base64-encoded bcrypt hash of the password\n        \n    Raises:\n        ValueError: If password is invalid or salt_rounds out of range\n        RuntimeError: If hashing fails\n    \"\"\"\n    hasher = PasswordHasher(salt_rounds)\n    return hasher.hash_password(password)\n\n\ndef verify_password(password: str, hashed_password: str) -> bool:\n    \"\"\"\n    Verify a password against a stored bcrypt hash (convenience function).\n    \n    Args:\n        password: Plain text password to verify\n        hashed_password: Stored bcrypt hash to verify against\n        \n    Returns:\n        bool: True if password matches hash, False otherwise\n        \n    Raises:\n        ValueError: If inputs are invalid\n        RuntimeError: If verification fails\n    \"\"\"\n    hasher = get_default_hasher()\n    return hasher.verify_password(password, hashed_password)\n\n\ndef is_password_strong(password: str, min_length: int = 8) -> bool:\n    \"\"\"\n    Check if a password meets basic strength requirements.\n    \n    Args:\n        password: Password to check\n        min_length: Minimum required length (default: 8)\n        \n    Returns:\n        bool: True if password meets strength requirements\n        \n    Raises:\n        ValueError: If password is None or min_length is invalid\n    \"\"\"\n    if password is None:\n        raise ValueError(\"Password cannot be None\")\n    \n    if not isinstance(password, str):\n        raise ValueError(\"Password must be a string\")\n    \n    if min_length < 1:\n        raise ValueError(\"Minimum length must be at least 1\")\n    \n    # Check minimum length\n    if len(password) < min_length:\n        return False\n    \n    # Check for at least one uppercase letter\n    has_upper = any(c.isupper() for c in password)\n    \n    # Check for at least one lowercase letter\n    has_lower = any(c.islower() for c in password)\n    \n    # Check for at least one digit\n    has_digit = any(c.isdigit() for c in password)\n    \n    # Check for at least one special character\n    special_chars = \"!@#$%^&*()_+-=[]{}|;:,.<>?\"\n    has_special = any(c in special_chars for c in password)\n    \n    # Password is strong if it has at least 3 of the 4 character types\n    criteria_met = sum([has_upper, has_lower, has_digit, has_special])\n    \n    return criteria_met >= 3",
      "file_type": "source",
      "semantic_unit_id": "SU-009",
      "component_id": "COMP-009",
      "description": "Password hashing and verification utilities using bcrypt with salt rounds configuration"
    },
    {
      "file_path": "src/database/connection.py",
      "content": "\"\"\"\nSQLAlchemy database connection setup, session management, and database initialization.\n\nThis module provides database connection management, session handling, and initialization\nutilities for the Hello World API application.\n\nComponent ID: COMP-010\nSemantic Unit: SU-010\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport logging\nimport os\nfrom contextlib import contextmanager\nfrom typing import Generator, Optional\n\nfrom sqlalchemy import create_engine, event, text\nfrom sqlalchemy.engine import Engine\nfrom sqlalchemy.exc import SQLAlchemyError\nfrom sqlalchemy.orm import DeclarativeBase, Session, sessionmaker\nfrom sqlalchemy.pool import StaticPool\n\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n\nclass Base(DeclarativeBase):\n    \"\"\"Base class for all SQLAlchemy models.\"\"\"\n    pass\n\n\nclass DatabaseConfig:\n    \"\"\"Database configuration management.\"\"\"\n    \n    def __init__(self) -> None:\n        \"\"\"Initialize database configuration from environment variables.\"\"\"\n        self.database_url: str = os.getenv(\n            \"DATABASE_URL\", \n            \"sqlite:///./hello_world.db\"\n        )\n        self.echo_sql: bool = os.getenv(\"DATABASE_ECHO\", \"false\").lower() == \"true\"\n        self.pool_size: int = int(os.getenv(\"DATABASE_POOL_SIZE\", \"5\"))\n        self.max_overflow: int = int(os.getenv(\"DATABASE_MAX_OVERFLOW\", \"10\"))\n        self.pool_timeout: int = int(os.getenv(\"DATABASE_POOL_TIMEOUT\", \"30\"))\n        self.pool_recycle: int = int(os.getenv(\"DATABASE_POOL_RECYCLE\", \"3600\"))\n    \n    def get_engine_kwargs(self) -> dict:\n        \"\"\"\n        Get SQLAlchemy engine configuration parameters.\n        \n        Returns:\n            dict: Engine configuration parameters\n        \"\"\"\n        kwargs = {\n            \"echo\": self.echo_sql,\n            \"future\": True,\n        }\n        \n        # SQLite-specific configuration\n        if self.database_url.startswith(\"sqlite\"):\n            kwargs.update({\n                \"poolclass\": StaticPool,\n                \"connect_args\": {\n                    \"check_same_thread\": False,\n                    \"timeout\": 20\n                }\n            })\n        else:\n            # PostgreSQL/MySQL configuration\n            kwargs.update({\n                \"pool_size\": self.pool_size,\n                \"max_overflow\": self.max_overflow,\n                \"pool_timeout\": self.pool_timeout,\n                \"pool_recycle\": self.pool_recycle,\n                \"pool_pre_ping\": True\n            })\n        \n        return kwargs\n\n\nclass DatabaseConnection:\n    \"\"\"Database connection and session management.\"\"\"\n    \n    def __init__(self, config: Optional[DatabaseConfig] = None) -> None:\n        \"\"\"\n        Initialize database connection.\n        \n        Args:\n            config: Database configuration instance\n        \"\"\"\n        self.config = config or DatabaseConfig()\n        self._engine: Optional[Engine] = None\n        self._session_factory: Optional[sessionmaker] = None\n    \n    @property\n    def engine(self) -> Engine:\n        \"\"\"\n        Get SQLAlchemy engine instance.\n        \n        Returns:\n            Engine: SQLAlchemy engine\n            \n        Raises:\n            RuntimeError: If engine is not initialized\n        \"\"\"\n        if self._engine is None:\n            raise RuntimeError(\"Database engine not initialized. Call initialize() first.\")\n        return self._engine\n    \n    @property\n    def session_factory(self) -> sessionmaker:\n        \"\"\"\n        Get SQLAlchemy session factory.\n        \n        Returns:\n            sessionmaker: Session factory instance\n            \n        Raises:\n            RuntimeError: If session factory is not initialized\n        \"\"\"\n        if self._session_factory is None:\n            raise RuntimeError(\"Session factory not initialized. Call initialize() first.\")\n        return self._session_factory\n    \n    def initialize(self) -> None:\n        \"\"\"\n        Initialize database engine and session factory.\n        \n        Raises:\n            SQLAlchemyError: If database initialization fails\n        \"\"\"\n        try:\n            logger.info(f\"Initializing database connection to {self.config.database_url}\")\n            \n            # Create engine\n            engine_kwargs = self.config.get_engine_kwargs()\n            self._engine = create_engine(self.config.database_url, **engine_kwargs)\n            \n            # Set up event listeners\n            self._setup_event_listeners()\n            \n            # Create session factory\n            self._session_factory = sessionmaker(\n                bind=self._engine,\n                autocommit=False,\n                autoflush=False,\n                expire_on_commit=False\n            )\n            \n            # Test connection\n            self._test_connection()\n            \n            logger.info(\"Database connection initialized successfully\")\n            \n        except Exception as e:\n            logger.error(f\"Failed to initialize database connection: {e}\")\n            raise SQLAlchemyError(f\"Database initialization failed: {e}\") from e\n    \n    def _setup_event_listeners(self) -> None:\n        \"\"\"Set up SQLAlchemy event listeners for connection management.\"\"\"\n        if self._engine is None:\n            return\n        \n        @event.listens_for(self._engine, \"connect\")\n        def set_sqlite_pragma(dbapi_connection, connection_record):\n            \"\"\"Set SQLite pragmas for better performance and reliability.\"\"\"\n            if self.config.database_url.startswith(\"sqlite\"):\n                cursor = dbapi_connection.cursor()\n                cursor.execute(\"PRAGMA foreign_keys=ON\")\n                cursor.execute(\"PRAGMA journal_mode=WAL\")\n                cursor.execute(\"PRAGMA synchronous=NORMAL\")\n                cursor.execute(\"PRAGMA temp_store=MEMORY\")\n                cursor.execute(\"PRAGMA mmap_size=268435456\")  # 256MB\n                cursor.close()\n        \n        @event.listens_for(self._engine, \"engine_connect\")\n        def log_connection(conn, branch):\n            \"\"\"Log database connections.\"\"\"\n            logger.debug(\"Database connection established\")\n    \n    def _test_connection(self) -> None:\n        \"\"\"\n        Test database connection.\n        \n        Raises:\n            SQLAlchemyError: If connection test fails\n        \"\"\"\n        try:\n            with self.get_session() as session:\n                session.execute(text(\"SELECT 1\"))\n            logger.debug(\"Database connection test successful\")\n        except Exception as e:\n            logger.error(f\"Database connection test failed: {e}\")\n            raise SQLAlchemyError(f\"Connection test failed: {e}\") from e\n    \n    def create_tables(self) -> None:\n        \"\"\"\n        Create all database tables defined in models.\n        \n        Raises:\n            SQLAlchemyError: If table creation fails\n        \"\"\"\n        try:\n            logger.info(\"Creating database tables\")\n            Base.metadata.create_all(bind=self.engine)\n            logger.info(\"Database tables created successfully\")\n        except Exception as e:\n            logger.error(f\"Failed to create database tables: {e}\")\n            raise SQLAlchemyError(f\"Table creation failed: {e}\") from e\n    \n    def drop_tables(self) -> None:\n        \"\"\"\n        Drop all database tables.\n        \n        Raises:\n            SQLAlchemyError: If table dropping fails\n        \"\"\"\n        try:\n            logger.warning(\"Dropping all database tables\")\n            Base.metadata.drop_all(bind=self.engine)\n            logger.info(\"Database tables dropped successfully\")\n        except Exception as e:\n            logger.error(f\"Failed to drop database tables: {e}\")\n            raise SQLAlchemyError(f\"Table dropping failed: {e}\") from e\n    \n    @contextmanager\n    def get_session(self) -> Generator[Session, None, None]:\n        \"\"\"\n        Get database session with automatic cleanup.\n        \n        Yields:\n            Session: SQLAlchemy session instance\n            \n        Raises:\n            SQLAlchemyError: If session creation or operation fails\n        \"\"\"\n        session = self.session_factory()\n        try:\n            yield session\n            session.commit()\n        except Exception as e:\n            session.rollback()\n            logger.error(f\"Database session error: {e}\")\n            raise SQLAlchemyError(f\"Session",
      "file_type": "source",
      "semantic_unit_id": "SU-010",
      "component_id": "COMP-010",
      "description": "SQLAlchemy database connection setup, session management, and database initialization"
    },
    {
      "file_path": "src/database/migrations/001_initial_schema.py",
      "content": "\"\"\"\nInitial database schema migration for Hello World API\n\nCreates the foundational database tables, indexes, and constraints.\nThis migration establishes the core data structure for the application.\n\nRevision ID: 001\nRevises: \nCreate Date: 2024-01-01 00:00:00.000000\n\nComponent ID: COMP-011\nSemantic Unit: SU-011\n\nAuthor: ASP Code Agent\n\"\"\"\nfrom typing import Sequence, Union\n\nfrom alembic import op\nimport sqlalchemy as sa\nfrom sqlalchemy.dialects import postgresql\n\n# revision identifiers, used by Alembic.\nrevision: str = '001'\ndown_revision: Union[str, None] = None\nbranch_labels: Union[str, Sequence[str], None] = None\ndepends_on: Union[str, Sequence[str], None] = None\n\n\ndef upgrade() -> None:\n    \"\"\"\n    Create initial database schema with users and tasks tables.\n    \n    This migration creates:\n    - users table with authentication and profile information\n    - tasks table with task management functionality\n    - Appropriate indexes for query performance\n    - Foreign key constraints for data integrity\n    - Check constraints for data validation\n    \"\"\"\n    # Create users table\n    op.create_table(\n        'users',\n        sa.Column('id', sa.Integer(), nullable=False, primary_key=True),\n        sa.Column('username', sa.String(length=50), nullable=False),\n        sa.Column('email', sa.String(length=255), nullable=False),\n        sa.Column('password_hash', sa.String(length=255), nullable=False),\n        sa.Column('first_name', sa.String(length=100), nullable=True),\n        sa.Column('last_name', sa.String(length=100), nullable=True),\n        sa.Column('is_active', sa.Boolean(), nullable=False, default=True),\n        sa.Column('is_verified', sa.Boolean(), nullable=False, default=False),\n        sa.Column('created_at', sa.DateTime(timezone=True), nullable=False, \n                 server_default=sa.text('CURRENT_TIMESTAMP')),\n        sa.Column('updated_at', sa.DateTime(timezone=True), nullable=False,\n                 server_default=sa.text('CURRENT_TIMESTAMP')),\n        sa.Column('last_login_at', sa.DateTime(timezone=True), nullable=True),\n        sa.PrimaryKeyConstraint('id'),\n        sa.UniqueConstraint('username', name='uq_users_username'),\n        sa.UniqueConstraint('email', name='uq_users_email'),\n        sa.CheckConstraint('length(username) >= 3', name='ck_users_username_length'),\n        sa.CheckConstraint('length(email) >= 5', name='ck_users_email_length'),\n        sa.CheckConstraint('email LIKE \\'%@%\\'', name='ck_users_email_format')\n    )\n    \n    # Create tasks table\n    op.create_table(\n        'tasks',\n        sa.Column('id', sa.Integer(), nullable=False, primary_key=True),\n        sa.Column('user_id', sa.Integer(), nullable=False),\n        sa.Column('title', sa.String(length=200), nullable=False),\n        sa.Column('description', sa.Text(), nullable=True),\n        sa.Column('status', sa.String(length=20), nullable=False, default='pending'),\n        sa.Column('priority', sa.String(length=10), nullable=False, default='medium'),\n        sa.Column('due_date', sa.DateTime(timezone=True), nullable=True),\n        sa.Column('completed_at', sa.DateTime(timezone=True), nullable=True),\n        sa.Column('created_at', sa.DateTime(timezone=True), nullable=False,\n                 server_default=sa.text('CURRENT_TIMESTAMP')),\n        sa.Column('updated_at', sa.DateTime(timezone=True), nullable=False,\n                 server_default=sa.text('CURRENT_TIMESTAMP')),\n        sa.PrimaryKeyConstraint('id'),\n        sa.ForeignKeyConstraint(['user_id'], ['users.id'], \n                               name='fk_tasks_user_id', ondelete='CASCADE'),\n        sa.CheckConstraint('length(title) >= 1', name='ck_tasks_title_length'),\n        sa.CheckConstraint('status IN (\\'pending\\', \\'in_progress\\', \\'completed\\', \\'cancelled\\')', \n                          name='ck_tasks_status_values'),\n        sa.CheckConstraint('priority IN (\\'low\\', \\'medium\\', \\'high\\', \\'urgent\\')', \n                          name='ck_tasks_priority_values'),\n        sa.CheckConstraint('(status = \\'completed\\' AND completed_at IS NOT NULL) OR '\n                          '(status != \\'completed\\' AND completed_at IS NULL)',\n                          name='ck_tasks_completed_consistency')\n    )\n    \n    # Create indexes for users table\n    op.create_index('ix_users_username', 'users', ['username'])\n    op.create_index('ix_users_email', 'users', ['email'])\n    op.create_index('ix_users_created_at', 'users', ['created_at'])\n    op.create_index('ix_users_is_active', 'users', ['is_active'])\n    op.create_index('ix_users_last_login_at', 'users', ['last_login_at'])\n    \n    # Create indexes for tasks table\n    op.create_index('ix_tasks_user_id', 'tasks', ['user_id'])\n    op.create_index('ix_tasks_status', 'tasks', ['status'])\n    op.create_index('ix_tasks_priority', 'tasks', ['priority'])\n    op.create_index('ix_tasks_due_date', 'tasks', ['due_date'])\n    op.create_index('ix_tasks_created_at', 'tasks', ['created_at'])\n    op.create_index('ix_tasks_completed_at', 'tasks', ['completed_at'])\n    \n    # Create composite indexes for common query patterns\n    op.create_index('ix_tasks_user_status', 'tasks', ['user_id', 'status'])\n    op.create_index('ix_tasks_user_priority', 'tasks', ['user_id', 'priority'])\n    op.create_index('ix_tasks_status_due_date', 'tasks', ['status', 'due_date'])\n    op.create_index('ix_users_active_created', 'users', ['is_active', 'created_at'])\n\n\ndef downgrade() -> None:\n    \"\"\"\n    Drop all tables and indexes created in the upgrade.\n    \n    This will completely remove the initial schema, including:\n    - All indexes (dropped automatically with tables)\n    - tasks table (with foreign key constraints)\n    - users table\n    \n    Warning: This will permanently delete all data in these tables.\n    \"\"\"\n    # Drop composite indexes first (if they exist independently)\n    op.drop_index('ix_users_active_created', table_name='users')\n    op.drop_index('ix_tasks_status_due_date', table_name='tasks')\n    op.drop_index('ix_tasks_user_priority', table_name='tasks')\n    op.drop_index('ix_tasks_user_status', table_name='tasks')\n    \n    # Drop tasks table indexes\n    op.drop_index('ix_tasks_completed_at', table_name='tasks')\n    op.drop_index('ix_tasks_created_at', table_name='tasks')\n    op.drop_index('ix_tasks_due_date', table_name='tasks')\n    op.drop_index('ix_tasks_priority', table_name='tasks')\n    op.drop_index('ix_tasks_status', table_name='tasks')\n    op.drop_index('ix_tasks_user_id', table_name='tasks')\n    \n    # Drop users table indexes\n    op.drop_index('ix_users_last_login_at', table_name='users')\n    op.drop_index('ix_users_is_active', table_name='",
      "file_type": "schema",
      "semantic_unit_id": "SU-011",
      "component_id": "COMP-011",
      "description": "Alembic migration script for creating initial user and task tables with indexes and constraints"
    },
    {
      "file_path": "tests/test_auth_api.py",
      "content": "\"\"\"\nComprehensive integration tests for authentication endpoints\n\nTests all authentication endpoints including edge cases, error scenarios,\nand security validation for the Hello World API.\n\nComponent ID: COMP-002\nSemantic Unit: SU-002\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom unittest.mock import patch, MagicMock\nimport json\nfrom datetime import datetime\nimport re\n\nfrom src.api.auth import app\n\n\n@pytest.fixture\ndef client():\n    \"\"\"Create test client for FastAPI application.\"\"\"\n    return TestClient(app)\n\n\nclass TestHelloEndpoint:\n    \"\"\"Test suite for GET /hello endpoint.\"\"\"\n\n    def test_hello_endpoint_returns_200_without_name(self, client):\n        \"\"\"Test that /hello endpoint returns 200 OK status without name parameter.\"\"\"\n        response = client.get(\"/hello\")\n        assert response.status_code == 200\n\n    def test_hello_endpoint_returns_json_content_type(self, client):\n        \"\"\"Test that /hello endpoint returns JSON content type.\"\"\"\n        response = client.get(\"/hello\")\n        assert \"application/json\" in response.headers[\"content-type\"]\n\n    def test_hello_endpoint_default_message(self, client):\n        \"\"\"Test that /hello endpoint returns default message without name parameter.\"\"\"\n        response = client.get(\"/hello\")\n        data = response.json()\n        assert data[\"message\"] == \"Hello, World!\"\n\n    def test_hello_endpoint_with_valid_name(self, client):\n        \"\"\"Test that /hello endpoint returns personalized message with valid name.\"\"\"\n        response = client.get(\"/hello?name=John\")\n        data = response.json()\n        assert data[\"message\"] == \"Hello, John!\"\n\n    def test_hello_endpoint_with_name_containing_spaces(self, client):\n        \"\"\"Test that /hello endpoint accepts names with spaces.\"\"\"\n        response = client.get(\"/hello?name=John Doe\")\n        data = response.json()\n        assert response.status_code == 200\n        assert data[\"message\"] == \"Hello, John Doe!\"\n\n    def test_hello_endpoint_with_name_containing_numbers(self, client):\n        \"\"\"Test that /hello endpoint accepts names with numbers.\"\"\"\n        response = client.get(\"/hello?name=User123\")\n        data = response.json()\n        assert response.status_code == 200\n        assert data[\"message\"] == \"Hello, User123!\"\n\n    def test_hello_endpoint_with_mixed_alphanumeric_name(self, client):\n        \"\"\"Test that /hello endpoint accepts mixed alphanumeric names with spaces.\"\"\"\n        response = client.get(\"/hello?name=John Doe 123\")\n        data = response.json()\n        assert response.status_code == 200\n        assert data[\"message\"] == \"Hello, John Doe 123!\"\n\n    def test_hello_endpoint_with_empty_name(self, client):\n        \"\"\"Test that /hello endpoint returns default message with empty name.\"\"\"\n        response = client.get(\"/hello?name=\")\n        data = response.json()\n        assert response.status_code == 200\n        assert data[\"message\"] == \"Hello, World!\"\n\n    def test_hello_endpoint_with_whitespace_only_name(self, client):\n        \"\"\"Test that /hello endpoint handles whitespace-only name.\"\"\"\n        response = client.get(\"/hello?name=   \")\n        data = response.json()\n        assert response.status_code == 200\n        assert data[\"message\"] == \"Hello,    !\"\n\n    def test_hello_endpoint_name_max_length_valid(self, client):\n        \"\"\"Test that /hello endpoint accepts name at maximum length (100 chars).\"\"\"\n        name = \"a\" * 100\n        response = client.get(f\"/hello?name={name}\")\n        data = response.json()\n        assert response.status_code == 200\n        assert data[\"message\"] == f\"Hello, {name}!\"\n\n    def test_hello_endpoint_name_exceeds_max_length(self, client):\n        \"\"\"Test that /hello endpoint returns 400 for name exceeding 100 characters.\"\"\"\n        name = \"a\" * 101\n        response = client.get(f\"/hello?name={name}\")\n        assert response.status_code == 400\n        data = response.json()\n        assert data[\"error\"][\"code\"] == \"INVALID_NAME\"\n        assert \"exceeds 100 characters\" in data[\"error\"][\"message\"]\n\n    def test_hello_endpoint_name_with_special_characters(self, client):\n        \"\"\"Test that /hello endpoint returns 400 for name with special characters.\"\"\"\n        response = client.get(\"/hello?name=John@Doe\")\n        assert response.status_code == 400\n        data = response.json()\n        assert data[\"error\"][\"code\"] == \"INVALID_NAME\"\n        assert \"invalid characters\" in data[\"error\"][\"message\"]\n\n    def test_hello_endpoint_name_with_symbols(self, client):\n        \"\"\"Test that /hello endpoint returns 400 for name with symbols.\"\"\"\n        response = client.get(\"/hello?name=John#Doe$\")\n        assert response.status_code == 400\n        data = response.json()\n        assert data[\"error\"][\"code\"] == \"INVALID_NAME\"\n\n    def test_hello_endpoint_name_with_punctuation(self, client):\n        \"\"\"Test that /hello endpoint returns 400 for name with punctuation.\"\"\"\n        response = client.get(\"/hello?name=John.Doe\")\n        assert response.status_code == 400\n        data = response.json()\n        assert data[\"error\"][\"code\"] == \"INVALID_NAME\"\n\n    def test_hello_endpoint_name_with_newlines(self, client):\n        \"\"\"Test that /hello endpoint returns 400 for name with newlines.\"\"\"\n        response = client.get(\"/hello?name=John\\nDoe\")\n        assert response.status_code == 400\n        data = response.json()\n        assert data[\"error\"][\"code\"] == \"INVALID_NAME\"\n\n    def test_hello_endpoint_name_with_tabs(self, client):\n        \"\"\"Test that /hello endpoint returns 400 for name with tabs.\"\"\"\n        response = client.get(\"/hello?name=John\\tDoe\")\n        assert response.status_code == 400\n        data = response.json()\n        assert data[\"error\"][\"code\"] == \"INVALID_NAME\"\n\n    def test_hello_endpoint_name_with_unicode_characters(self, client):\n        \"\"\"Test that /hello endpoint returns 400 for name with unicode characters.\"\"\"\n        response = client.get(\"/hello?name=Jhn\")\n        assert response.status_code == 400\n        data = response.json()\n        assert data[\"error\"][\"code\"] == \"INVALID_NAME\"\n\n    def test_hello_endpoint_response_schema_structure(self, client):\n        \"\"\"Test that /hello endpoint response has correct schema structure.\"\"\"\n        response = client.get(\"/hello\")\n        data = response.json()\n        assert isinstance(data, dict)\n        assert \"message\" in data\n        assert isinstance(data[\"message\"], str)\n        assert len(data) == 1\n\n    def test_hello_endpoint_response_schema_with_name(self, client):\n        \"\"\"Test that /hello endpoint response schema is correct with name parameter.\"\"\"\n        response = client.get(\"/hello?name=Test\")\n        data = response.json()\n        assert isinstance(data, dict)\n        assert \"message\" in data\n        assert isinstance(data[\"message\"], str)\n        assert len(data) == 1\n\n    def test_hello_endpoint_error_response_schema(self, client):\n        \"\"\"Test that /hello endpoint error response has correct schema structure.\"\"\"\n        response = client.get(\"/hello?name=Invalid@Name\")\n        data = response.json()\n        assert isinstance(data, dict)\n        assert \"error\" in data\n        assert isinstance(data[\"error\"], dict)\n        assert \"code\" in data[\"error\"]\n        assert \"message\" in data[\"error\"]\n        assert isinstance(data[\"error\"][\"code\"], str)\n        assert isinstance(data[\"error\"][\"message\"], str)\n\n    def test_hello_endpoint_case_sensitivity(self, client):\n        \"\"\"Test that /hello endpoint preserves case in name parameter.\"\"\"\n        response = client.get(\"/hello?name=JoHn DoE\")\n        data = response.json()\n        assert response.status_code == 200",
      "file_type": "test",
      "semantic_unit_id": "SU-002",
      "component_id": "COMP-002",
      "description": "Comprehensive integration tests for authentication endpoints including edge cases, error scenarios, and security validation"
    },
    {
      "file_path": "tests/test_tasks_api.py",
      "content": "\"\"\"\nIntegration tests for task management endpoints\n\nTests authentication, authorization, and CRUD operations for task management API.\nCovers all endpoints with various scenarios including edge cases and error conditions.\n\nComponent ID: COMP-003\nSemantic Unit: SU-003\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom unittest.mock import Mock, patch\nimport json\nfrom datetime import datetime, timedelta\nfrom typing import Dict, Any, List\n\nfrom src.api.tasks import app\nfrom tests.conftest import (\n    create_test_user,\n    create_test_task,\n    get_auth_headers,\n    cleanup_test_data\n)\n\n\nclass TestTasksAPI:\n    \"\"\"Integration tests for task management API endpoints.\"\"\"\n\n    @pytest.fixture(autouse=True)\n    def setup_and_teardown(self):\n        \"\"\"Setup and teardown for each test.\"\"\"\n        self.client = TestClient(app)\n        self.test_users = []\n        self.test_tasks = []\n        yield\n        # Cleanup after each test\n        cleanup_test_data(self.test_users, self.test_tasks)\n\n    def test_create_task_success(self):\n        \"\"\"Test successful task creation with valid data.\"\"\"\n        user = create_test_user(\"testuser\", \"test@example.com\")\n        self.test_users.append(user)\n        headers = get_auth_headers(user[\"id\"])\n        \n        task_data = {\n            \"title\": \"Test Task\",\n            \"description\": \"This is a test task\",\n            \"priority\": \"medium\",\n            \"due_date\": \"2024-12-31T23:59:59Z\"\n        }\n        \n        response = self.client.post(\"/tasks\", json=task_data, headers=headers)\n        \n        assert response.status_code == 201\n        data = response.json()\n        assert \"id\" in data\n        assert data[\"title\"] == task_data[\"title\"]\n        assert data[\"description\"] == task_data[\"description\"]\n        assert data[\"priority\"] == task_data[\"priority\"]\n        assert data[\"status\"] == \"pending\"\n        assert data[\"user_id\"] == user[\"id\"]\n        assert \"created_at\" in data\n        assert \"updated_at\" in data\n        \n        self.test_tasks.append(data)\n\n    def test_create_task_missing_title(self):\n        \"\"\"Test task creation fails with missing title.\"\"\"\n        user = create_test_user(\"testuser\", \"test@example.com\")\n        self.test_users.append(user)\n        headers = get_auth_headers(user[\"id\"])\n        \n        task_data = {\n            \"description\": \"This is a test task\",\n            \"priority\": \"medium\"\n        }\n        \n        response = self.client.post(\"/tasks\", json=task_data, headers=headers)\n        \n        assert response.status_code == 422\n        data = response.json()\n        assert \"error\" in data\n        assert \"title\" in data[\"error\"][\"message\"].lower()\n\n    def test_create_task_invalid_priority(self):\n        \"\"\"Test task creation fails with invalid priority.\"\"\"\n        user = create_test_user(\"testuser\", \"test@example.com\")\n        self.test_users.append(user)\n        headers = get_auth_headers(user[\"id\"])\n        \n        task_data = {\n            \"title\": \"Test Task\",\n            \"description\": \"This is a test task\",\n            \"priority\": \"invalid_priority\"\n        }\n        \n        response = self.client.post(\"/tasks\", json=task_data, headers=headers)\n        \n        assert response.status_code == 422\n        data = response.json()\n        assert \"error\" in data\n        assert \"priority\" in data[\"error\"][\"message\"].lower()\n\n    def test_create_task_invalid_due_date(self):\n        \"\"\"Test task creation fails with invalid due date format.\"\"\"\n        user = create_test_user(\"testuser\", \"test@example.com\")\n        self.test_users.append(user)\n        headers = get_auth_headers(user[\"id\"])\n        \n        task_data = {\n            \"title\": \"Test Task\",\n            \"description\": \"This is a test task\",\n            \"priority\": \"medium\",\n            \"due_date\": \"invalid-date-format\"\n        }\n        \n        response = self.client.post(\"/tasks\", json=task_data, headers=headers)\n        \n        assert response.status_code == 422\n        data = response.json()\n        assert \"error\" in data\n        assert \"due_date\" in data[\"error\"][\"message\"].lower()\n\n    def test_create_task_unauthorized(self):\n        \"\"\"Test task creation fails without authentication.\"\"\"\n        task_data = {\n            \"title\": \"Test Task\",\n            \"description\": \"This is a test task\",\n            \"priority\": \"medium\"\n        }\n        \n        response = self.client.post(\"/tasks\", json=task_data)\n        \n        assert response.status_code == 401\n        data = response.json()\n        assert \"error\" in data\n        assert data[\"error\"][\"code\"] == \"UNAUTHORIZED\"\n\n    def test_create_task_invalid_token(self):\n        \"\"\"Test task creation fails with invalid authentication token.\"\"\"\n        headers = {\"Authorization\": \"Bearer invalid_token\"}\n        \n        task_data = {\n            \"title\": \"Test Task\",\n            \"description\": \"This is a test task\",\n            \"priority\": \"medium\"\n        }\n        \n        response = self.client.post(\"/tasks\", json=task_data, headers=headers)\n        \n        assert response.status_code == 401\n        data = response.json()\n        assert \"error\" in data\n        assert data[\"error\"][\"code\"] == \"INVALID_TOKEN\"\n\n    def test_get_tasks_success(self):\n        \"\"\"Test successful retrieval of user's tasks.\"\"\"\n        user = create_test_user(\"testuser\", \"test@example.com\")\n        self.test_users.append(user)\n        headers = get_auth_headers(user[\"id\"])\n        \n        # Create test tasks\n        task1 = create_test_task(user[\"id\"], \"Task 1\", \"high\")\n        task2 = create_test_task(user[\"id\"], \"Task 2\", \"low\")\n        self.test_tasks.extend([task1, task2])\n        \n        response = self.client.get(\"/tasks\", headers=headers)\n        \n        assert response.status_code == 200\n        data = response.json()\n        assert \"tasks\" in data\n        assert \"total\" in data\n        assert \"page\" in data\n        assert \"per_page\" in data\n        assert len(data[\"tasks\"]) == 2\n        assert data[\"total\"] == 2\n        \n        # Verify task data\n        task_titles = [task[\"title\"] for task in data[\"tasks\"]]\n        assert \"Task 1\" in task_titles\n        assert \"Task 2\" in task_titles\n\n    def test_get_tasks_with_pagination(self):\n        \"\"\"Test task retrieval with pagination parameters.\"\"\"\n        user = create_test_user(\"testuser\", \"test@example.com\")\n        self.test_users.append(user)\n        headers = get_auth_headers(user[\"id\"])\n        \n        # Create multiple test tasks\n        for i in range(5):\n            task = create_test_task(user[\"id\"], f\"Task {i+1}\", \"medium\")\n            self.test_tasks.append(task)\n        \n        response = self.client.get(\"/tasks?page=1&per_page=3\", headers=headers)\n        \n        assert response.status_code == 200\n        data = response.json()\n        assert len(data[\"tasks\"]) == 3\n        assert data[\"total\"] == 5\n        assert data[\"page\"] == 1\n        assert data[\"per_page\"] == 3\n\n    def test_get_tasks_with_status_filter(self):\n        \"\"\"Test task retrieval with status filter.\"\"\"\n        user = create_test_user(\"testuser\", \"test@example.com\")\n        self.test_users.append(user)\n        headers = get_auth_headers(user[\"id\"])\n        \n        # Create tasks with different statuses\n        task1 = create_test_task(user[\"i",
      "file_type": "test",
      "semantic_unit_id": "SU-003",
      "component_id": "COMP-003",
      "description": "Integration tests for task management endpoints with authentication, authorization, and CRUD operation validation"
    },
    {
      "file_path": "tests/test_user_model.py",
      "content": "\"\"\"\nUnit tests for User model including validation, relationships, and database operations.\n\nTests the User model to verify field validation, password hashing, database operations,\nand relationships with other models.\n\nSemantic Unit ID: SU-004\nComponent ID: COMP-004\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport pytest\nfrom datetime import datetime, timezone\nfrom unittest.mock import Mock, patch\nfrom sqlalchemy.exc import IntegrityError\nfrom sqlalchemy.orm import Session\n\nfrom src.models.user import User\nfrom tests.conftest import TestSession\n\n\nclass TestUserModel:\n    \"\"\"Test suite for User model basic functionality.\"\"\"\n\n    def test_user_creation_with_valid_data(self, db_session: TestSession):\n        \"\"\"Test that User can be created with valid data.\"\"\"\n        user = User(\n            username=\"testuser\",\n            email=\"test@example.com\",\n            password_hash=\"hashed_password_123\"\n        )\n        \n        assert user.username == \"testuser\"\n        assert user.email == \"test@example.com\"\n        assert user.password_hash == \"hashed_password_123\"\n        assert user.is_active is True  # Default value\n        assert user.created_at is not None\n        assert user.updated_at is not None\n\n    def test_user_creation_sets_timestamps(self, db_session: TestSession):\n        \"\"\"Test that User creation automatically sets created_at and updated_at.\"\"\"\n        before_creation = datetime.now(timezone.utc)\n        \n        user = User(\n            username=\"testuser\",\n            email=\"test@example.com\",\n            password_hash=\"hashed_password_123\"\n        )\n        \n        after_creation = datetime.now(timezone.utc)\n        \n        assert before_creation <= user.created_at <= after_creation\n        assert before_creation <= user.updated_at <= after_creation\n        assert user.created_at == user.updated_at\n\n    def test_user_str_representation(self, db_session: TestSession):\n        \"\"\"Test that User string representation returns username.\"\"\"\n        user = User(\n            username=\"testuser\",\n            email=\"test@example.com\",\n            password_hash=\"hashed_password_123\"\n        )\n        \n        assert str(user) == \"testuser\"\n\n    def test_user_repr_representation(self, db_session: TestSession):\n        \"\"\"Test that User repr representation includes id and username.\"\"\"\n        user = User(\n            id=123,\n            username=\"testuser\",\n            email=\"test@example.com\",\n            password_hash=\"hashed_password_123\"\n        )\n        \n        assert repr(user) == \"<User(id=123, username='testuser')>\"\n\n\nclass TestUserValidation:\n    \"\"\"Test suite for User model field validation.\"\"\"\n\n    def test_username_required(self, db_session: TestSession):\n        \"\"\"Test that username is required.\"\"\"\n        with pytest.raises(ValueError, match=\"Username is required\"):\n            User(\n                username=None,\n                email=\"test@example.com\",\n                password_hash=\"hashed_password_123\"\n            )\n\n    def test_username_empty_string_invalid(self, db_session: TestSession):\n        \"\"\"Test that empty username string is invalid.\"\"\"\n        with pytest.raises(ValueError, match=\"Username cannot be empty\"):\n            User(\n                username=\"\",\n                email=\"test@example.com\",\n                password_hash=\"hashed_password_123\"\n            )\n\n    def test_username_whitespace_only_invalid(self, db_session: TestSession):\n        \"\"\"Test that whitespace-only username is invalid.\"\"\"\n        with pytest.raises(ValueError, match=\"Username cannot be empty\"):\n            User(\n                username=\"   \",\n                email=\"test@example.com\",\n                password_hash=\"hashed_password_123\"\n            )\n\n    def test_username_too_long_invalid(self, db_session: TestSession):\n        \"\"\"Test that username longer than 50 characters is invalid.\"\"\"\n        long_username = \"a\" * 51\n        \n        with pytest.raises(ValueError, match=\"Username must be 50 characters or less\"):\n            User(\n                username=long_username,\n                email=\"test@example.com\",\n                password_hash=\"hashed_password_123\"\n            )\n\n    def test_username_max_length_valid(self, db_session: TestSession):\n        \"\"\"Test that username with exactly 50 characters is valid.\"\"\"\n        max_username = \"a\" * 50\n        \n        user = User(\n            username=max_username,\n            email=\"test@example.com\",\n            password_hash=\"hashed_password_123\"\n        )\n        \n        assert user.username == max_username\n\n    def test_email_required(self, db_session: TestSession):\n        \"\"\"Test that email is required.\"\"\"\n        with pytest.raises(ValueError, match=\"Email is required\"):\n            User(\n                username=\"testuser\",\n                email=None,\n                password_hash=\"hashed_password_123\"\n            )\n\n    def test_email_empty_string_invalid(self, db_session: TestSession):\n        \"\"\"Test that empty email string is invalid.\"\"\"\n        with pytest.raises(ValueError, match=\"Email cannot be empty\"):\n            User(\n                username=\"testuser\",\n                email=\"\",\n                password_hash=\"hashed_password_123\"\n            )\n\n    def test_email_invalid_format(self, db_session: TestSession):\n        \"\"\"Test that invalid email format raises ValueError.\"\"\"\n        invalid_emails = [\n            \"invalid_email\",\n            \"@example.com\",\n            \"test@\",\n            \"test.example.com\",\n            \"test@.com\",\n            \"test@example.\",\n            \"test space@example.com\"\n        ]\n        \n        for invalid_email in invalid_emails:\n            with pytest.raises(ValueError, match=\"Invalid email format\"):\n                User(\n                    username=\"testuser\",\n                    email=invalid_email,\n                    password_hash=\"hashed_password_123\"\n                )\n\n    def test_email_valid_formats(self, db_session: TestSession):\n        \"\"\"Test that valid email formats are accepted.\"\"\"\n        valid_emails = [\n            \"test@example.com\",\n            \"user.name@example.com\",\n            \"user+tag@example.co.uk\",\n            \"123@example.org\",\n            \"test@sub.example.com\"\n        ]\n        \n        for valid_email in valid_emails:\n            user = User(\n                username=f\"user_{valid_email.replace('@', '_').replace('.', '_')}\",\n                email=valid_email,\n                password_hash=\"hashed_password_123\"\n            )\n            assert user.email == valid_email\n\n    def test_email_too_long_invalid(self, db_session: TestSession):\n        \"\"\"Test that email longer than 255 characters is invalid.\"\"\"\n        long_email = \"a\" * 240 + \"@example.com\"  # 252 chars total\n        \n        user = User(\n            username=\"testuser\",\n            email=long_email,\n            password_hash=\"hashed_password_123\"\n        )\n        assert user.email == long_email\n        \n        # Test email that's too long\n        too_long_email = \"a\" * 250 + \"@example.com\"  # 262 chars total\n        with pytest.raises(ValueError, match=\"Email must be 255 characters or less\"):\n            User(\n                username=\"testuser\",\n                email=too_long_email,\n                password_hash=\"hashed_password_123\"\n            )\n\n    def test_password_hash_required(self, db_session: TestSession):\n        \"\"\"Test that password_hash is required.\"\"\"\n        with pytest.raises(ValueError, match=\"Password hash is required\"):\n            User(\n                username=\"testuser\",\n                email=\"test@example.com\",\n                password_hash=None\n            )\n\n    def test_password_hash_empty_string_invalid(self, db_session: TestSession):\n        \"\"\"Test that empty password_hash string is invalid.\"\"\"\n        with pytest.raises(ValueError, match=\"Password hash cannot be empty\"):\n            User(\n                username=\"testuser\",\n                email=\"test@example.com\",\n                password_hash=\"\"\n            )\n\n\nclass TestUserDatabaseOperations:\n    \"\"\"Test suite for User model database operations",
      "file_type": "test",
      "semantic_unit_id": "SU-004",
      "component_id": "COMP-004",
      "description": "Unit tests for User model including validation, relationships, and database operations"
    },
    {
      "file_path": "tests/test_task_model.py",
      "content": "\"\"\"\nUnit tests for Task model including CRUD operations, status transitions, and user relationships.\n\nTests all Task model functionality including creation, updates, status changes,\nand relationships with User model.\n\nComponent ID: COMP-005\nSemantic Unit: SU-005\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport pytest\nfrom datetime import datetime, timedelta\nfrom unittest.mock import Mock, patch\nfrom sqlalchemy.exc import IntegrityError, SQLAlchemyError\nfrom sqlalchemy.orm import Session\n\nfrom src.models.task import Task, TaskStatus, TaskPriority\nfrom src.models.user import User\n\n\nclass TestTaskModel:\n    \"\"\"Test suite for Task model basic functionality.\"\"\"\n\n    def test_task_creation_with_required_fields(self, db_session: Session, sample_user: User):\n        \"\"\"Test that Task can be created with only required fields.\"\"\"\n        task = Task(\n            title=\"Test Task\",\n            user_id=sample_user.id\n        )\n        db_session.add(task)\n        db_session.commit()\n        \n        assert task.id is not None\n        assert task.title == \"Test Task\"\n        assert task.user_id == sample_user.id\n        assert task.status == TaskStatus.PENDING\n        assert task.priority == TaskPriority.MEDIUM\n        assert task.description is None\n        assert task.due_date is None\n        assert isinstance(task.created_at, datetime)\n        assert isinstance(task.updated_at, datetime)\n\n    def test_task_creation_with_all_fields(self, db_session: Session, sample_user: User):\n        \"\"\"Test that Task can be created with all fields populated.\"\"\"\n        due_date = datetime.utcnow() + timedelta(days=7)\n        task = Task(\n            title=\"Complete Task\",\n            description=\"This is a test task with full details\",\n            status=TaskStatus.IN_PROGRESS,\n            priority=TaskPriority.HIGH,\n            due_date=due_date,\n            user_id=sample_user.id\n        )\n        db_session.add(task)\n        db_session.commit()\n        \n        assert task.title == \"Complete Task\"\n        assert task.description == \"This is a test task with full details\"\n        assert task.status == TaskStatus.IN_PROGRESS\n        assert task.priority == TaskPriority.HIGH\n        assert task.due_date == due_date\n        assert task.user_id == sample_user.id\n\n    def test_task_creation_without_title_raises_error(self, db_session: Session, sample_user: User):\n        \"\"\"Test that creating Task without title raises IntegrityError.\"\"\"\n        task = Task(user_id=sample_user.id)\n        db_session.add(task)\n        \n        with pytest.raises(IntegrityError):\n            db_session.commit()\n\n    def test_task_creation_without_user_id_raises_error(self, db_session: Session):\n        \"\"\"Test that creating Task without user_id raises IntegrityError.\"\"\"\n        task = Task(title=\"Test Task\")\n        db_session.add(task)\n        \n        with pytest.raises(IntegrityError):\n            db_session.commit()\n\n    def test_task_creation_with_invalid_user_id_raises_error(self, db_session: Session):\n        \"\"\"Test that creating Task with non-existent user_id raises IntegrityError.\"\"\"\n        task = Task(title=\"Test Task\", user_id=99999)\n        db_session.add(task)\n        \n        with pytest.raises(IntegrityError):\n            db_session.commit()\n\n    def test_task_title_max_length_validation(self, db_session: Session, sample_user: User):\n        \"\"\"Test that Task title respects maximum length constraint.\"\"\"\n        long_title = \"x\" * 201  # Assuming max length is 200\n        task = Task(title=long_title, user_id=sample_user.id)\n        db_session.add(task)\n        \n        with pytest.raises(IntegrityError):\n            db_session.commit()\n\n    def test_task_description_can_be_long(self, db_session: Session, sample_user: User):\n        \"\"\"Test that Task description can handle long text.\"\"\"\n        long_description = \"This is a very long description. \" * 100\n        task = Task(\n            title=\"Test Task\",\n            description=long_description,\n            user_id=sample_user.id\n        )\n        db_session.add(task)\n        db_session.commit()\n        \n        assert task.description == long_description\n\n\nclass TestTaskStatusTransitions:\n    \"\"\"Test suite for Task status transitions and validation.\"\"\"\n\n    def test_task_default_status_is_pending(self, db_session: Session, sample_user: User):\n        \"\"\"Test that new Task has default status of PENDING.\"\"\"\n        task = Task(title=\"Test Task\", user_id=sample_user.id)\n        assert task.status == TaskStatus.PENDING\n\n    def test_task_status_can_be_updated_to_in_progress(self, db_session: Session, sample_task: Task):\n        \"\"\"Test that Task status can be changed from PENDING to IN_PROGRESS.\"\"\"\n        assert sample_task.status == TaskStatus.PENDING\n        \n        sample_task.status = TaskStatus.IN_PROGRESS\n        db_session.commit()\n        \n        assert sample_task.status == TaskStatus.IN_PROGRESS\n\n    def test_task_status_can_be_updated_to_completed(self, db_session: Session, sample_task: Task):\n        \"\"\"Test that Task status can be changed to COMPLETED.\"\"\"\n        sample_task.status = TaskStatus.COMPLETED\n        db_session.commit()\n        \n        assert sample_task.status == TaskStatus.COMPLETED\n\n    def test_task_status_can_be_updated_to_cancelled(self, db_session: Session, sample_task: Task):\n        \"\"\"Test that Task status can be changed to CANCELLED.\"\"\"\n        sample_task.status = TaskStatus.CANCELLED\n        db_session.commit()\n        \n        assert sample_task.status == TaskStatus.CANCELLED\n\n    def test_task_completed_at_set_when_status_completed(self, db_session: Session, sample_task: Task):\n        \"\"\"Test that completed_at timestamp is set when status changes to COMPLETED.\"\"\"\n        assert sample_task.completed_at is None\n        \n        sample_task.status = TaskStatus.COMPLETED\n        sample_task.completed_at = datetime.utcnow()\n        db_session.commit()\n        \n        assert sample_task.completed_at is not None\n        assert isinstance(sample_task.completed_at, datetime)\n\n    def test_task_updated_at_changes_on_status_update(self, db_session: Session, sample_task: Task):\n        \"\"\"Test that updated_at timestamp changes when status is updated.\"\"\"\n        original_updated_at = sample_task.updated_at\n        \n        # Wait a small amount to ensure timestamp difference\n        import time\n        time.sleep(0.01)\n        \n        sample_task.status = TaskStatus.IN_PROGRESS\n        sample_task.updated_at = datetime.utcnow()\n        db_session.commit()\n        \n        assert sample_task.updated_at > original_updated_at\n\n\nclass TestTaskPriority:\n    \"\"\"Test suite for Task priority functionality.\"\"\"\n\n    def test_task_default_priority_is_medium(self, db_session: Session, sample_user: User):\n        \"\"\"Test that new Task has default priority of MEDIUM.\"\"\"\n        task = Task(title=\"Test Task\", user_id=sample_user.id)\n        assert task.priority == TaskPriority.MEDIUM\n\n    def test_task_priority_can_be_set_to_low(self, db_session: Session, sample_user: User):\n        \"\"\"Test that Task priority can be set to LOW.\"\"\"\n        task = Task(title=\"Test Task\", priority=TaskPriority.LOW, user_id=sample_user.id)\n        db_session.add(task)\n        db_session.commit()\n        \n        assert task.priority == TaskPriority.LOW\n\n    def test_task_priority_can_be_set_to_high(self, db_session: Session, sample_",
      "file_type": "test",
      "semantic_unit_id": "SU-005",
      "component_id": "COMP-005",
      "description": "Unit tests for Task model including CRUD operations, status transitions, and user relationships"
    },
    {
      "file_path": "tests/test_jwt_utils.py",
      "content": "\"\"\"\nUnit tests for JWT utilities\n\nTests JWT token generation, validation, expiration handling, and security edge cases.\n\nComponent ID: COMP-008\nSemantic Unit: SU-008\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport pytest\nfrom datetime import datetime, timedelta, timezone\nfrom unittest.mock import patch, MagicMock\nimport jwt\nfrom freezegun import freeze_time\n\nfrom src.utils.jwt_utils import (\n    JWTUtils,\n    TokenExpiredError,\n    InvalidTokenError,\n    InvalidSignatureError,\n    MissingClaimError\n)\n\n\nclass TestJWTUtils:\n    \"\"\"Test suite for JWT utilities.\"\"\"\n\n    @pytest.fixture\n    def jwt_utils(self):\n        \"\"\"Create JWTUtils instance with test configuration.\"\"\"\n        return JWTUtils(\n            secret_key=\"test_secret_key_12345\",\n            algorithm=\"HS256\",\n            access_token_expire_minutes=30,\n            refresh_token_expire_days=7\n        )\n\n    @pytest.fixture\n    def sample_payload(self):\n        \"\"\"Sample JWT payload for testing.\"\"\"\n        return {\n            \"user_id\": \"123\",\n            \"username\": \"testuser\",\n            \"email\": \"test@example.com\",\n            \"role\": \"user\"\n        }\n\n    def test_init_with_default_values(self):\n        \"\"\"Test JWTUtils initialization with default values.\"\"\"\n        jwt_utils = JWTUtils(secret_key=\"test_key\")\n        \n        assert jwt_utils.secret_key == \"test_key\"\n        assert jwt_utils.algorithm == \"HS256\"\n        assert jwt_utils.access_token_expire_minutes == 15\n        assert jwt_utils.refresh_token_expire_days == 30\n\n    def test_init_with_custom_values(self):\n        \"\"\"Test JWTUtils initialization with custom values.\"\"\"\n        jwt_utils = JWTUtils(\n            secret_key=\"custom_key\",\n            algorithm=\"HS512\",\n            access_token_expire_minutes=60,\n            refresh_token_expire_days=14\n        )\n        \n        assert jwt_utils.secret_key == \"custom_key\"\n        assert jwt_utils.algorithm == \"HS512\"\n        assert jwt_utils.access_token_expire_minutes == 60\n        assert jwt_utils.refresh_token_expire_days == 14\n\n    def test_init_with_empty_secret_key_raises_error(self):\n        \"\"\"Test that empty secret key raises ValueError.\"\"\"\n        with pytest.raises(ValueError, match=\"Secret key cannot be empty\"):\n            JWTUtils(secret_key=\"\")\n\n    def test_init_with_none_secret_key_raises_error(self):\n        \"\"\"Test that None secret key raises ValueError.\"\"\"\n        with pytest.raises(ValueError, match=\"Secret key cannot be empty\"):\n            JWTUtils(secret_key=None)\n\n    def test_init_with_invalid_algorithm_raises_error(self):\n        \"\"\"Test that invalid algorithm raises ValueError.\"\"\"\n        with pytest.raises(ValueError, match=\"Unsupported algorithm\"):\n            JWTUtils(secret_key=\"test_key\", algorithm=\"INVALID\")\n\n    def test_generate_access_token_success(self, jwt_utils, sample_payload):\n        \"\"\"Test successful access token generation.\"\"\"\n        token = jwt_utils.generate_access_token(sample_payload)\n        \n        assert isinstance(token, str)\n        assert len(token) > 0\n        assert token.count('.') == 2  # JWT has 3 parts separated by dots\n\n    def test_generate_access_token_with_custom_expiry(self, jwt_utils, sample_payload):\n        \"\"\"Test access token generation with custom expiry.\"\"\"\n        custom_expiry = datetime.now(timezone.utc) + timedelta(hours=2)\n        token = jwt_utils.generate_access_token(sample_payload, expires_at=custom_expiry)\n        \n        decoded = jwt.decode(token, jwt_utils.secret_key, algorithms=[jwt_utils.algorithm])\n        assert decoded['exp'] == int(custom_expiry.timestamp())\n\n    def test_generate_access_token_adds_standard_claims(self, jwt_utils, sample_payload):\n        \"\"\"Test that access token includes standard JWT claims.\"\"\"\n        with freeze_time(\"2023-01-01 12:00:00\"):\n            token = jwt_utils.generate_access_token(sample_payload)\n            \n            decoded = jwt.decode(token, jwt_utils.secret_key, algorithms=[jwt_utils.algorithm])\n            \n            assert 'iat' in decoded  # issued at\n            assert 'exp' in decoded  # expiration\n            assert 'type' in decoded  # token type\n            assert decoded['type'] == 'access'\n\n    def test_generate_refresh_token_success(self, jwt_utils, sample_payload):\n        \"\"\"Test successful refresh token generation.\"\"\"\n        token = jwt_utils.generate_refresh_token(sample_payload)\n        \n        assert isinstance(token, str)\n        assert len(token) > 0\n        assert token.count('.') == 2\n\n    def test_generate_refresh_token_with_custom_expiry(self, jwt_utils, sample_payload):\n        \"\"\"Test refresh token generation with custom expiry.\"\"\"\n        custom_expiry = datetime.now(timezone.utc) + timedelta(days=14)\n        token = jwt_utils.generate_refresh_token(sample_payload, expires_at=custom_expiry)\n        \n        decoded = jwt.decode(token, jwt_utils.secret_key, algorithms=[jwt_utils.algorithm])\n        assert decoded['exp'] == int(custom_expiry.timestamp())\n\n    def test_generate_refresh_token_adds_standard_claims(self, jwt_utils, sample_payload):\n        \"\"\"Test that refresh token includes standard JWT claims.\"\"\"\n        with freeze_time(\"2023-01-01 12:00:00\"):\n            token = jwt_utils.generate_refresh_token(sample_payload)\n            \n            decoded = jwt.decode(token, jwt_utils.secret_key, algorithms=[jwt_utils.algorithm])\n            \n            assert 'iat' in decoded\n            assert 'exp' in decoded\n            assert 'type' in decoded\n            assert decoded['type'] == 'refresh'\n\n    def test_generate_token_with_empty_payload(self, jwt_utils):\n        \"\"\"Test token generation with empty payload.\"\"\"\n        token = jwt_utils.generate_access_token({})\n        \n        decoded = jwt.decode(token, jwt_utils.secret_key, algorithms=[jwt_utils.algorithm])\n        assert 'iat' in decoded\n        assert 'exp' in decoded\n        assert 'type' in decoded\n\n    def test_validate_token_success(self, jwt_utils, sample_payload):\n        \"\"\"Test successful token validation.\"\"\"\n        token = jwt_utils.generate_access_token(sample_payload)\n        decoded_payload = jwt_utils.validate_token(token)\n        \n        assert decoded_payload['user_id'] == sample_payload['user_id']\n        assert decoded_payload['username'] == sample_payload['username']\n        assert decoded_payload['email'] == sample_payload['email']\n        assert decoded_payload['role'] == sample_payload['role']\n        assert decoded_payload['type'] == 'access'\n\n    def test_validate_token_with_expired_token_raises_error(self, jwt_utils, sample_payload):\n        \"\"\"Test that expired token raises TokenExpiredError.\"\"\"\n        past_time = datetime.now(timezone.utc) - timedelta(hours=1)\n        token = jwt_utils.generate_access_token(sample_payload, expires_at=past_time)\n        \n        with pytest.raises(TokenExpiredError, match=\"Token has expired\"):\n            jwt_utils.validate_token(token)\n\n    def test_validate_token_with_invalid_signature_raises_error(self, jwt_utils, sample_payload):\n        \"\"\"Test that token with invalid signature raises InvalidSignatureError.\"\"\"\n        token = jwt_utils.generate_access_token(sample_payload)\n        # Tamper with the token\n        tampered_token = token[:-10] + \"tampered123\"\n        \n        with pytest.raises(InvalidSignatureError, match=\"Invalid token signature\"):\n            jwt_utils.validate",
      "file_type": "test",
      "semantic_unit_id": "SU-008",
      "component_id": "COMP-008",
      "description": "Unit tests for JWT utilities covering token generation, validation, expiration, and security edge cases"
    },
    {
      "file_path": "tests/test_password.py",
      "content": "\"\"\"\nUnit tests for password hashing and verification utilities.\n\nTests password hashing, verification, strength validation, and security features\nto ensure proper authentication security.\n\nComponent ID: COMP-009\nSemantic Unit: SU-009\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport pytest\nfrom unittest.mock import patch, MagicMock\nimport bcrypt\nimport time\nfrom typing import Any\n\nfrom src.utils.password import (\n    hash_password,\n    verify_password,\n    validate_password_strength,\n    generate_salt,\n    is_password_compromised,\n    PasswordStrengthError,\n    PasswordHashError\n)\n\n\nclass TestHashPassword:\n    \"\"\"Test cases for password hashing functionality.\"\"\"\n\n    def test_hash_password_returns_string(self):\n        \"\"\"Test that hash_password returns a string.\"\"\"\n        password = \"test_password_123\"\n        hashed = hash_password(password)\n        assert isinstance(hashed, str)\n\n    def test_hash_password_returns_bcrypt_hash(self):\n        \"\"\"Test that hash_password returns a valid bcrypt hash.\"\"\"\n        password = \"test_password_123\"\n        hashed = hash_password(password)\n        assert hashed.startswith(\"$2b$\")\n        assert len(hashed) == 60  # Standard bcrypt hash length\n\n    def test_hash_password_different_passwords_different_hashes(self):\n        \"\"\"Test that different passwords produce different hashes.\"\"\"\n        password1 = \"password123\"\n        password2 = \"password456\"\n        hash1 = hash_password(password1)\n        hash2 = hash_password(password2)\n        assert hash1 != hash2\n\n    def test_hash_password_same_password_different_hashes(self):\n        \"\"\"Test that same password produces different hashes due to salt.\"\"\"\n        password = \"test_password_123\"\n        hash1 = hash_password(password)\n        hash2 = hash_password(password)\n        assert hash1 != hash2\n\n    def test_hash_password_empty_string(self):\n        \"\"\"Test that empty password can be hashed.\"\"\"\n        password = \"\"\n        hashed = hash_password(password)\n        assert isinstance(hashed, str)\n        assert hashed.startswith(\"$2b$\")\n\n    def test_hash_password_unicode_characters(self):\n        \"\"\"Test that passwords with unicode characters are handled correctly.\"\"\"\n        password = \"pssw0rd__\"\n        hashed = hash_password(password)\n        assert isinstance(hashed, str)\n        assert hashed.startswith(\"$2b$\")\n\n    def test_hash_password_very_long_password(self):\n        \"\"\"Test that very long passwords are handled correctly.\"\"\"\n        password = \"a\" * 1000\n        hashed = hash_password(password)\n        assert isinstance(hashed, str)\n        assert hashed.startswith(\"$2b$\")\n\n    def test_hash_password_with_custom_rounds(self):\n        \"\"\"Test that custom rounds parameter works correctly.\"\"\"\n        password = \"test_password_123\"\n        hashed = hash_password(password, rounds=10)\n        assert hashed.startswith(\"$2b$10$\")\n\n    @patch('bcrypt.hashpw')\n    def test_hash_password_bcrypt_exception(self, mock_hashpw):\n        \"\"\"Test that bcrypt exceptions are handled properly.\"\"\"\n        mock_hashpw.side_effect = Exception(\"Bcrypt error\")\n        password = \"test_password_123\"\n        \n        with pytest.raises(PasswordHashError) as exc_info:\n            hash_password(password)\n        \n        assert \"Failed to hash password\" in str(exc_info.value)\n\n    def test_hash_password_none_input(self):\n        \"\"\"Test that None input raises appropriate error.\"\"\"\n        with pytest.raises(TypeError):\n            hash_password(None)\n\n\nclass TestVerifyPassword:\n    \"\"\"Test cases for password verification functionality.\"\"\"\n\n    def test_verify_password_correct_password(self):\n        \"\"\"Test that correct password verification returns True.\"\"\"\n        password = \"test_password_123\"\n        hashed = hash_password(password)\n        assert verify_password(password, hashed) is True\n\n    def test_verify_password_incorrect_password(self):\n        \"\"\"Test that incorrect password verification returns False.\"\"\"\n        password = \"test_password_123\"\n        wrong_password = \"wrong_password_456\"\n        hashed = hash_password(password)\n        assert verify_password(wrong_password, hashed) is False\n\n    def test_verify_password_empty_password(self):\n        \"\"\"Test verification with empty password.\"\"\"\n        password = \"\"\n        hashed = hash_password(password)\n        assert verify_password(\"\", hashed) is True\n        assert verify_password(\"not_empty\", hashed) is False\n\n    def test_verify_password_unicode_characters(self):\n        \"\"\"Test verification with unicode characters.\"\"\"\n        password = \"pssw0rd__\"\n        hashed = hash_password(password)\n        assert verify_password(password, hashed) is True\n        assert verify_password(\"different_unicode_\", hashed) is False\n\n    def test_verify_password_case_sensitive(self):\n        \"\"\"Test that password verification is case sensitive.\"\"\"\n        password = \"TestPassword123\"\n        hashed = hash_password(password)\n        assert verify_password(\"testpassword123\", hashed) is False\n        assert verify_password(\"TESTPASSWORD123\", hashed) is False\n\n    def test_verify_password_invalid_hash_format(self):\n        \"\"\"Test verification with invalid hash format.\"\"\"\n        password = \"test_password_123\"\n        invalid_hash = \"not_a_valid_hash\"\n        assert verify_password(password, invalid_hash) is False\n\n    def test_verify_password_empty_hash(self):\n        \"\"\"Test verification with empty hash.\"\"\"\n        password = \"test_password_123\"\n        assert verify_password(password, \"\") is False\n\n    @patch('bcrypt.checkpw')\n    def test_verify_password_bcrypt_exception(self, mock_checkpw):\n        \"\"\"Test that bcrypt exceptions during verification are handled.\"\"\"\n        mock_checkpw.side_effect = Exception(\"Bcrypt verification error\")\n        password = \"test_password_123\"\n        hashed = hash_password(password)\n        \n        # Should return False on exception, not raise\n        assert verify_password(password, hashed) is False\n\n    def test_verify_password_none_inputs(self):\n        \"\"\"Test verification with None inputs.\"\"\"\n        password = \"test_password_123\"\n        hashed = hash_password(password)\n        \n        with pytest.raises(TypeError):\n            verify_password(None, hashed)\n        \n        with pytest.raises(TypeError):\n            verify_password(password, None)\n\n\nclass TestValidatePasswordStrength:\n    \"\"\"Test cases for password strength validation.\"\"\"\n\n    def test_validate_strong_password(self):\n        \"\"\"Test that strong password passes validation.\"\"\"\n        strong_password = \"StrongP@ssw0rd123\"\n        assert validate_password_strength(strong_password) is True\n\n    def test_validate_password_too_short(self):\n        \"\"\"Test that password shorter than minimum length fails.\"\"\"\n        short_password = \"Sh0rt!\"\n        with pytest.raises(PasswordStrengthError) as exc_info:\n            validate_password_strength(short_password)\n        assert \"at least 8 characters\" in str(exc_info.value)\n\n    def test_validate_password_no_uppercase(self):\n        \"\"\"Test that password without uppercase fails.\"\"\"\n        no_upper = \"lowercase123!\"\n        with pytest.raises(PasswordStrengthError) as exc_info:\n            validate_password_strength(no_upper)\n        assert \"uppercase letter\" in str(exc_info.value)\n\n    def test_validate_password_no_lowercase(self):\n        \"\"\"Test that password without lowercase fails.\"\"\"\n        no_lower = \"UPPERCASE123!\"\n        with pytest.raises(PasswordStrengthError) as exc_info:\n            validate_password_strength(no_lower)\n        assert \"lowercase letter\" in str(exc_info.value)\n\n    def test_validate_password_no_digit(self):\n        \"\"\"Test that password without digit",
      "file_type": "test",
      "semantic_unit_id": "SU-009",
      "component_id": "COMP-009",
      "description": "Unit tests for password hashing and verification with various input scenarios and security validation"
    },
    {
      "file_path": "tests/conftest.py",
      "content": "\"\"\"\nPytest configuration and fixtures for Hello World API tests.\n\nProvides test client setup, fixtures, and configuration for comprehensive testing\nof the FastAPI application endpoints and error handling.\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom unittest.mock import Mock, patch\nfrom datetime import datetime\nfrom typing import Generator, Dict, Any\nimport logging\nimport sys\nimport os\n\n# Add src directory to Python path for imports\nsys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'src'))\n\nfrom main import app\n\n\n# Configure logging for tests\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\n@pytest.fixture(scope=\"session\")\ndef test_client() -> TestClient:\n    \"\"\"\n    Create FastAPI test client for the entire test session.\n    \n    Returns:\n        TestClient: Configured test client for making HTTP requests\n    \"\"\"\n    return TestClient(app)\n\n\n@pytest.fixture(scope=\"function\")\ndef client(test_client: TestClient) -> Generator[TestClient, None, None]:\n    \"\"\"\n    Provide test client for individual test functions.\n    \n    Args:\n        test_client: Session-scoped test client\n        \n    Yields:\n        TestClient: Test client instance for the test function\n    \"\"\"\n    yield test_client\n\n\n@pytest.fixture(scope=\"function\")\ndef mock_datetime() -> Generator[Mock, None, None]:\n    \"\"\"\n    Mock datetime.utcnow() for consistent timestamp testing.\n    \n    Yields:\n        Mock: Mocked datetime object with fixed timestamp\n    \"\"\"\n    fixed_datetime = datetime(2023, 12, 25, 10, 30, 45)\n    with patch('main.datetime') as mock_dt:\n        mock_dt.utcnow.return_value = fixed_datetime\n        mock_dt.side_effect = lambda *args, **kw: datetime(*args, **kw)\n        yield mock_dt\n\n\n@pytest.fixture(scope=\"function\")\ndef sample_valid_names() -> list[str]:\n    \"\"\"\n    Provide list of valid name parameters for testing.\n    \n    Returns:\n        list[str]: Valid name strings for testing\n    \"\"\"\n    return [\n        \"John\",\n        \"Jane Doe\",\n        \"Alice123\",\n        \"Bob Smith Jr\",\n        \"Test User 42\",\n        \"a\",  # Single character\n        \"A\" * 100,  # Maximum length\n        \"User 123 Test\",\n        \"Mary Jane Watson\",\n        \"X  A 12\"  # Contains special characters that should be invalid\n    ]\n\n\n@pytest.fixture(scope=\"function\")\ndef sample_invalid_names() -> list[str]:\n    \"\"\"\n    Provide list of invalid name parameters for testing.\n    \n    Returns:\n        list[str]: Invalid name strings for testing\n    \"\"\"\n    return [\n        \"John@Doe\",  # Contains @\n        \"Jane-Smith\",  # Contains hyphen\n        \"User!\",  # Contains exclamation\n        \"Test#User\",  # Contains hash\n        \"Name$\",  # Contains dollar sign\n        \"User%\",  # Contains percent\n        \"Test^User\",  # Contains caret\n        \"Name&Co\",  # Contains ampersand\n        \"User*\",  # Contains asterisk\n        \"Test(User)\",  # Contains parentheses\n        \"Name+\",  # Contains plus\n        \"User=Test\",  # Contains equals\n        \"Name[Test]\",  # Contains brackets\n        \"User{Test}\",  # Contains braces\n        \"Name|Test\",  # Contains pipe\n        \"User\\\\Test\",  # Contains backslash\n        \"Name:Test\",  # Contains colon\n        \"User;Test\",  # Contains semicolon\n        \"Name\\\"Test\\\"\",  # Contains quotes\n        \"User'Test'\",  # Contains apostrophes\n        \"Name<Test>\",  # Contains angle brackets\n        \"User,Test\",  # Contains comma\n        \"Name.Test\",  # Contains period\n        \"User?Test\",  # Contains question mark\n        \"Name/Test\",  # Contains slash\n        \"User~Test\",  # Contains tilde\n        \"Name`Test`\",  # Contains backticks\n        \"A\" * 101,  # Exceeds maximum length\n        \"\",  # Empty string (should be handled as None)\n        \"   \",  # Only spaces\n        \"\\n\",  # Newline character\n        \"\\t\",  # Tab character\n        \"\\r\",  # Carriage return\n        \"Test\\nUser\",  # Contains newline\n        \"Test\\tUser\",  # Contains tab\n    ]\n\n\n@pytest.fixture(scope=\"function\")\ndef expected_error_responses() -> Dict[str, Dict[str, Any]]:\n    \"\"\"\n    Provide expected error response formats for testing.\n    \n    Returns:\n        Dict[str, Dict[str, Any]]: Expected error response structures\n    \"\"\"\n    return {\n        \"invalid_name\": {\n            \"status_code\": 400,\n            \"response_format\": {\n                \"error\": {\n                    \"code\": \"INVALID_NAME\",\n                    \"message\": \"Name parameter contains invalid characters or exceeds 100 characters\"\n                }\n            }\n        },\n        \"internal_error\": {\n            \"status_code\": 500,\n            \"response_format\": {\n                \"error\": {\n                    \"code\": \"INTERNAL_ERROR\",\n                    \"message\": \"Internal server error\"\n                }\n            }\n        }\n    }\n\n\n@pytest.fixture(scope=\"function\")\ndef expected_success_responses() -> Dict[str, Dict[str, Any]]:\n    \"\"\"\n    Provide expected success response formats for testing.\n    \n    Returns:\n        Dict[str, Dict[str, Any]]: Expected success response structures\n    \"\"\"\n    return {\n        \"hello_default\": {\n            \"status_code\": 200,\n            \"response_format\": {\n                \"message\": \"Hello, World!\"\n            }\n        },\n        \"hello_personalized\": {\n            \"status_code\": 200,\n            \"response_format\": {\n                \"message\": \"Hello, {name}!\"\n            }\n        },\n        \"health\": {\n            \"status_code\": 200,\n            \"response_format\": {\n                \"status\": \"ok\",\n                \"timestamp\": \"2023-12-25T10:30:45Z\"\n            }\n        }\n    }\n\n\n@pytest.fixture(scope=\"function\")\ndef mock_logger() -> Generator[Mock, None, None]:\n    \"\"\"\n    Mock logger for testing error handling and logging behavior.\n    \n    Yields:\n        Mock: Mocked logger instance\n    \"\"\"\n    with patch('main.logger') as mock_log:\n        yield mock_log\n\n\n@pytest.fixture(scope=\"function\")\ndef mock_exception_handler() -> Generator[Mock, None, None]:\n    \"\"\"\n    Mock exception handler for testing error handling behavior.\n    \n    Yields:\n        Mock: Mocked exception handler\n    \"\"\"\n    with patch('main.handle_general_exception') as mock_handler:\n        mock_handler.return_value = {\n            \"error\": {\n                \"code\": \"INTERNAL_ERROR\",\n                \"message\": \"Internal server error\"\n            }\n        }\n        yield mock_handler\n\n\n@pytest.fixture(autouse=True)\ndef reset_app_state():\n    \"\"\"\n    Reset application state before each test to ensure test isolation.\n    \n    This fixture runs automatically before each test function.\n    \"\"\"\n    # Clear any cached data or state if needed\n    # For this simple API, no state reset is required\n    yield\n    # Cleanup after test if needed\n\n\n@pytest.fixture(scope=\"function\")\ndef performance_threshold() -> Dict[str, float]:\n    \"\"\"\n    Provide performance thresholds for endpoint response time testing.\n    \n    Returns:\n        Dict[str, float]: Performance thresholds in seconds\n    \"\"\"\n    return {\n        \"hello_endpoint\": 0.01,  # 10ms\n        \"health_endpoint\": 0.01,  # 10ms\n        \"error_response\": 0.01,  # 10ms\n    }\n\n\n@pytest.fixture(scope=\"function\")\ndef content_type_headers() -> Dict[str, str]:\n    \"\"\"\n    Provide",
      "file_type": "test",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Pytest configuration with test database setup, fixtures for authenticated users, and test client initialization"
    },
    {
      "file_path": "requirements.txt",
      "content": "# Web Framework\nfastapi==0.104.1\nuvicorn==0.24.0\n\n# Data Validation\npydantic==2.5.0\n\n# HTTP Client (for testing)\nhttpx==0.25.2\n\n# Testing Framework\npytest==7.4.3\npytest-asyncio==0.21.1\npytest-cov==4.1.0\n\n# Development Tools\nblack==23.11.0\nflake8==6.1.0\nmypy==1.7.1\n\n# Standard Library Extensions\npython-multipart==0.0.6",
      "file_type": "requirements",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Python dependencies with exact versions for FastAPI, SQLAlchemy, authentication, testing, and database libraries"
    },
    {
      "file_path": ".env.example",
      "content": "# Environment Configuration Template\n# Copy this file to .env and update the values for your environment\n\n# Application Settings\nAPP_NAME=Hello World API\nAPP_VERSION=1.0.0\nAPP_DESCRIPTION=Simple REST API that returns greeting messages\n\n# Server Configuration\nHOST=0.0.0.0\nPORT=8000\nDEBUG=false\nRELOAD=false\n\n# Logging Configuration\nLOG_LEVEL=INFO\nLOG_FORMAT=%(asctime)s - %(name)s - %(levelname)s - %(message)s\n\n# CORS Settings (comma-separated origins)\nALLOWED_ORIGINS=http://localhost:3000,http://localhost:8080",
      "file_type": "config",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Environment variables template including JWT secret, database URL, and application configuration settings"
    },
    {
      "file_path": "alembic.ini",
      "content": "# A generic, single database configuration.\n\n[alembic]\n# path to migration scripts\nscript_location = alembic\n\n# template used to generate migration file names; The default value is %%(rev)s_%%(slug)s\n# Uncomment the line below if you want the files to be prepended with date and time\n# file_template = %%(year)d_%%(month).2d_%%(day).2d_%%(hour).2d%%(minute).2d-%%(rev)s_%%(slug)s\n\n# sys.path path, will be prepended to sys.path if present.\n# defaults to the current working directory.\nprepend_sys_path = .\n\n# timezone to use when rendering the date within the migration file\n# as well as the filename.\n# If specified, requires the python-dateutil library that can be\n# installed by adding `alembic[tz]` to the pip requirements\n# string value is passed to dateutil.tz.gettz()\n# leave blank for localtime\n# timezone =\n\n# max length of characters to apply to the\n# \"slug\" field\n# truncate_slug_length = 40\n\n# set to 'true' to run the environment during\n# the 'revision' command, regardless of autogenerate\n# revision_environment = false\n\n# set to 'true' to allow .pyc and .pyo files without\n# a source .py file to be detected as revisions in the\n# versions/ directory\n# sourceless = false\n\n# version path separator; As mentioned above, this is the character used to split\n# version_locations. The default within new alembic.ini files is \"os\", which uses\n# os.pathsep. If this key is omitted entirely, it falls back to the legacy\n# behavior of splitting on spaces and/or commas.\n# Valid values for version_path_separator are:\n#\n# version_path_separator = :\n# version_path_separator = ;\n# version_path_separator = space\nversion_path_separator = os\n\n# the output encoding used when revision files\n# are written from script.py.mako\n# output_encoding = utf-8\n\nsqlalchemy.url = sqlite:///./hello_world.db\n\n\n[post_write_hooks]\n# post_write_hooks defines scripts or Python functions that are run\n# on newly generated revision scripts.  See the documentation for further\n# detail and examples\n\n# format using \"black\" - use the console_scripts runner, against the \"black\" entrypoint\n# hooks = black\n# black.type = console_scripts\n# black.entrypoint = black\n# black.options = -l 79 REVISION_SCRIPT_FILENAME\n\n# Logging configuration\n[loggers]\nkeys = root,sqlalchemy,alembic\n\n[handlers]\nkeys = console\n\n[formatters]\nkeys = generic\n\n[logger_root]\nlevel = WARN\nhandlers = console\nqualname =\n\n[logger_sqlalchemy]\nlevel = WARN\nhandlers =\nqualname = sqlalchemy.engine\n\n[logger_alembic]\nlevel = INFO\nhandlers =\nqualname = alembic\n\n[handler_console]\nclass = StreamHandler\nargs = (sys.stderr,)\nlevel = NOTSET\nformatter = generic\n\n[formatter_generic]\nformat = %(levelname)-5.5s [%(name)s] %(message)s\ndatefmt = %H:%M:%S",
      "file_type": "config",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Alembic configuration file for database migrations with SQLAlchemy URL and migration settings"
    },
    {
      "file_path": "pytest.ini",
      "content": "[pytest]\n# Test discovery\ntestpaths = tests\npython_files = test_*.py *_test.py\npython_classes = Test*\npython_functions = test_*\n\n# Output options\naddopts = \n    -v\n    --tb=short\n    --strict-markers\n    --strict-config\n    --disable-warnings\n\n# Coverage settings\naddopts = \n    --cov=.\n    --cov-report=term-missing\n    --cov-report=html:htmlcov\n    --cov-fail-under=80\n    --cov-exclude=tests/*\n\n# Markers\nmarkers =\n    unit: Unit tests\n    integration: Integration tests\n    slow: Slow running tests\n\n# Logging\nlog_cli = true\nlog_cli_level = INFO\nlog_cli_format = %(asctime)s [%(levelname)8s] %(name)s: %(message)s\nlog_cli_date_format = %Y-%m-%d %H:%M:%S\n\n# Warnings\nfilterwarnings =\n    ignore::DeprecationWarning\n    ignore::PendingDeprecationWarning",
      "file_type": "config",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Pytest configuration with test discovery, coverage settings, and test database configuration"
    },
    {
      "file_path": ".gitignore",
      "content": "# Byte-compiled / optimized / DLL files\n__pycache__/\n*.py[cod]\n*$py.class\n\n# C extensions\n*.so\n\n# Distribution / packaging\n.Python\nbuild/\ndevelop-eggs/\ndist/\ndownloads/\neggs/\n.eggs/\nlib/\nlib64/\nparts/\nsdist/\nvar/\nwheels/\nshare/python-wheels/\n*.egg-info/\n.installed.cfg\n*.egg\nMANIFEST\n\n# PyInstaller\n#  Usually these files are written by a python script from a template\n#  before PyInstaller builds the exe, so as to inject date/other infos into it.\n*.manifest\n*.spec\n\n# Installer logs\npip-log.txt\npip-delete-this-directory.txt\n\n# Unit test / coverage reports\nhtmlcov/\n.tox/\n.nox/\n.coverage\n.coverage.*\n.cache\nnosetests.xml\ncoverage.xml\n*.cover\n*.py,cover\n.hypothesis/\n.pytest_cache/\ncover/\n\n# Translations\n*.mo\n*.pot\n\n# Django stuff:\n*.log\nlocal_settings.py\ndb.sqlite3\ndb.sqlite3-journal\n\n# Flask stuff:\ninstance/\n.webassets-cache\n\n# Scrapy stuff:\n.scrapy\n\n# Sphinx documentation\ndocs/_build/\n\n# PyBuilder\n.pybuilder/\ntarget/\n\n# Jupyter Notebook\n.ipynb_checkpoints\n\n# IPython\nprofile_default/\nipython_config.py\n\n# pyenv\n#   For a library or package, you might want to ignore these files since the code is\n#   intended to run in multiple environments; otherwise, check them in:\n# .python-version\n\n# pipenv\n#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.\n#   However, in case of collaboration, if having platform-specific dependencies or dependencies\n#   having no cross-platform support, pipenv may install dependencies that don't work, or not\n#   install all needed dependencies.\n#Pipfile.lock\n\n# poetry\n#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.\n#   This is especially recommended for binary packages to ensure reproducibility, and is more\n#   commonly ignored for libraries.\n#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control\n#poetry.lock\n\n# pdm\n#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.\n#pdm.lock\n#   pdm stores project-wide configurations in .pdm.toml, but it is recommended to not include it\n#   in version control.\n#   https://pdm.fming.dev/#use-with-ide\n.pdm.toml\n\n# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm\n__pypackages__/\n\n# Celery stuff\ncelerybeat-schedule\ncelerybeat.pid\n\n# SageMath parsed files\n*.sage.py\n\n# Environments\n.env\n.venv\nenv/\nvenv/\nENV/\nenv.bak/\nvenv.bak/\n\n# Spyder project settings\n.spyderproject\n.spyproject\n\n# Rope project settings\n.ropeproject\n\n# mkdocs documentation\n/site\n\n# mypy\n.mypy_cache/\n.dmypy.json\ndmypy.json\n\n# Pyre type checker\n.pyre/\n\n# pytype static type analyzer\n.pytype/\n\n# Cython debug symbols\ncython_debug/\n\n# PyCharm\n#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can\n#  be added to the global gitignore or merged into this project gitignore.  For a PyCharm\n#  project, it is recommended to ignore the whole .idea directory.\n.idea/\n\n# VS Code\n.vscode/\n\n# macOS\n.DS_Store\n.AppleDouble\n.LSOverride\n\n# Windows\nThumbs.db\nehthumbs.db\nDesktop.ini\n$RECYCLE.BIN/\n\n# Linux\n*~\n\n# Temporary files\n*.tmp\n*.temp\n*.swp\n*.swo\n\n# Log files\n*.log\n\n# Database files\n*.db\n*.sqlite\n*.sqlite3\n\n# Configuration files with sensitive data\nconfig.ini\nsettings.ini\nsecrets.json\n.secrets\n\n# SSL certificates\n*.pem\n*.key\n*.crt\n*.cert",
      "file_type": "config",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Git ignore file for Python projects including virtual environments, cache files, and sensitive data"
    },
    {
      "file_path": "README.md",
      "content": "# Hello World API\n\nA simple FastAPI REST API that returns greeting messages with optional personalization and health monitoring capabilities.\n\n## Features\n\n- **Personalized Greetings**: `/hello` endpoint with optional name parameter\n- **Health Monitoring**: `/health` endpoint with status and timestamp\n- **Input Validation**: Secure name parameter validation with length and character restrictions\n- **Error Handling**: Comprehensive error responses with proper HTTP status codes\n- **Auto Documentation**: FastAPI automatic OpenAPI documentation\n- **Production Ready**: Proper logging, exception handling, and security practices\n\n## Prerequisites\n\n- Python 3.12 or higher\n- pip package manager\n\n## Installation\n\n1. Clone the repository:\n   ```bash\n   git clone <repository-url>\n   cd hello-world-api\n   ```\n\n2. Create a virtual environment (recommended):\n   ```bash\n   python -m venv venv\n   source venv/bin/activate  # On Windows: venv\\Scripts\\activate\n   ```\n\n3. Install dependencies:\n   ```bash\n   pip install -r requirements.txt\n   ```\n\n## Configuration\n\nNo configuration files are required for basic operation. The application uses sensible defaults:\n\n- **Host**: 127.0.0.1 (localhost)\n- **Port**: 8000\n- **Log Level**: INFO\n- **Timezone**: UTC\n\n### Environment Variables (Optional)\n\nYou can customize the application behavior using environment variables:\n\n```bash\n# Server configuration\nHOST=0.0.0.0\nPORT=8000\nLOG_LEVEL=INFO\n\n# Application settings\nAPP_TITLE=\"Hello World API\"\nAPP_VERSION=\"1.0.0\"\n```\n\n## Running the Application\n\n### Development Mode\n\nStart the development server with auto-reload:\n\n```bash\nuvicorn main:app --reload\n```\n\nThe API will be available at http://localhost:8000\n\n### Production Mode\n\nStart the production server:\n\n```bash\nuvicorn main:app --host 0.0.0.0 --port 8000 --workers 4\n```\n\n### Using Docker (Optional)\n\nIf you have a Dockerfile:\n\n```bash\ndocker build -t hello-world-api .\ndocker run -p 8000:8000 hello-world-api\n```\n\n## API Documentation\n\n### GET /hello\n\nReturns a greeting message with optional personalization.\n\n**Parameters:**\n- `name` (optional, query parameter): Name to personalize the greeting\n  - Type: string\n  - Max length: 100 characters\n  - Allowed characters: alphanumeric and spaces only\n  - Example: `?name=John Doe`\n\n**Success Response (200 OK):**\n```json\n{\n  \"message\": \"Hello, World!\"\n}\n```\n\n**Personalized Response (200 OK):**\n```json\n{\n  \"message\": \"Hello, John Doe!\"\n}\n```\n\n**Error Response (400 Bad Request):**\n```json\n{\n  \"error\": {\n    \"code\": \"INVALID_NAME\",\n    \"message\": \"Name parameter contains invalid characters or exceeds 100 characters\"\n  }\n}\n```\n\n**Examples:**\n```bash\n# Basic greeting\ncurl http://localhost:8000/hello\n\n# Personalized greeting\ncurl \"http://localhost:8000/hello?name=Alice\"\n\n# Invalid name (contains special characters)\ncurl \"http://localhost:8000/hello?name=Alice@123\"\n```\n\n### GET /health\n\nHealth check endpoint for monitoring and load balancer health checks.\n\n**Parameters:** None\n\n**Success Response (200 OK):**\n```json\n{\n  \"status\": \"ok\",\n  \"timestamp\": \"2024-01-15T10:30:45.123456Z\"\n}\n```\n\n**Error Response (500 Internal Server Error):**\n```json\n{\n  \"error\": {\n    \"code\": \"INTERNAL_ERROR\",\n    \"message\": \"Internal server error\"\n  }\n}\n```\n\n**Examples:**\n```bash\n# Health check\ncurl http://localhost:8000/health\n```\n\n## Interactive API Documentation\n\nFastAPI automatically generates interactive API documentation:\n\n- **Swagger UI**: http://localhost:8000/docs\n- **ReDoc**: http://localhost:8000/redoc\n- **OpenAPI Schema**: http://localhost:8000/openapi.json\n\n## Testing\n\n### Running Tests\n\nRun the complete test suite:\n\n```bash\npytest tests/ -v\n```\n\nRun tests with coverage report:\n\n```bash\npytest tests/ --cov=. --cov-report=html --cov-report=term\n```\n\nView HTML coverage report:\n\n```bash\nopen htmlcov/index.html  # On macOS\n# or\nstart htmlcov/index.html  # On Windows\n```\n\n### Test Categories\n\n- **Unit Tests**: Test individual functions and components\n- **Integration Tests**: Test API endpoints end-to-end\n- **Validation Tests**: Test input validation and error handling\n- **Edge Case Tests**: Test boundary conditions and error scenarios\n\n### Manual Testing\n\nTest the API manually using curl or any HTTP client:\n\n```bash\n# Test basic hello endpoint\ncurl -X GET \"http://localhost:8000/hello\" -H \"accept: application/json\"\n\n# Test personalized greeting\ncurl -X GET \"http://localhost:8000/hello?name=TestUser\" -H \"accept: application/json\"\n\n# Test health endpoint\ncurl -X GET \"http://localhost:8000/health\" -H \"accept: application/json\"\n\n# Test error handling (invalid name)\ncurl -X GET \"http://localhost:8000/hello?name=Invalid@Name!\" -H \"accept: application/json\"\n```\n\n## Security Considerations\n\n### Input Validation\n\n- **Name Parameter**: Restricted to alphanumeric characters and spaces only\n- **Length Limits**: Maximum 100 characters for name parameter\n- **Regex Validation**: Uses `^[a-zA-Z0-9 ]+$` pattern to prevent injection attacks\n\n### Error Handling\n\n- **No Information Disclosure**: Error messages don't expose internal system details\n- **Consistent Error Format**: All errors follow the same JSON structure\n- **Proper HTTP Status Codes**: 400 for client errors, 500 for server errors\n\n### Best Practices\n\n- **No Sensitive Data**: No authentication tokens or sensitive information in logs\n- **Input Sanitization**: All user inputs are validated before processing\n- **Exception Handling**: Unhandled exceptions are caught and logged securely\n\n## Monitoring and Logging\n\n### Health Checks\n\nUse the `/health` endpoint for:\n- Load balancer health checks\n- Container orchestration health probes\n- Monitoring system status checks\n\n### Logging\n\nThe application logs important events:\n- Request processing errors\n- Validation failures\n- Unhandled exceptions\n- Application startup/shutdown\n\nLog levels:\n- **INFO**: Normal operation events\n- **WARNING**: Validation errors and client mistakes\n- **ERROR**: Server errors and exceptions\n\n## Troubleshooting\n\n### Common Issues\n\n#### Port Already in Use\n\n**Error**: `OSError: [Errno 48] Address already in use`\n\n**Solution**: Use a different port:\n```bash\nuvicorn main:app --port 8001\n```\n\n#### Import Errors\n\n**Error**: `ModuleNotFoundError: No module named 'fastapi'`\n\n**Solution**: Install dependencies:\n```bash\npip install -r requirements.txt\n```\n\n#### Permission Denied (Port 80/443)\n\n**Error**: `PermissionError: [Errno 13] Permission denied`\n\n**Solution**: Use a port above 1024 or run with sudo (not recommended):\n```bash\nuvicorn main:app --port 8080\n```\n\n#### Virtual Environment Issues\n\n**Error**: Dependencies not found despite installation\n\n**Solution**: Ensure virtual environment is activated:\n```bash\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\npip list  # Verify packages are installed\n```\n\n### Performance Issues\n\n#### Slow Response Times\n\n1. Check system resources (CPU, memory)\n2. Verify no blocking operations in endpoints\n3. Consider using multiple workers:\n   ```bash\n   uvicorn main:app --workers 4\n   ```\n\n#### High Memory Usage\n\n1. Monitor for memory leaks\n2. Check log file sizes\n3. Restart the application periodically if needed\n\n### Debugging\n\n#### Enable Debug Mode\n\nFor development debugging:\n```bash\nuvicorn main:app --reload --log-level debug\n```\n\n#### Check Application Logs\n\nMonitor application output for errors:\n```bash\nuvicorn main:app 2>&1 | tee app.log\n```\n\n#### Validate API Responses",
      "file_type": "documentation",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Comprehensive project documentation with setup instructions, API documentation, authentication guide, and troubleshooting"
    },
    {
      "file_path": "docs/api_documentation.md",
      "content": "# Hello World API Documentation\n\nComplete API reference for the Hello World REST API built with FastAPI.\n\n## Base URL\n\n```\nhttp://localhost:8000\n```\n\n## Overview\n\nThe Hello World API is a simple REST service that provides greeting functionality and health monitoring. It features two endpoints with JSON responses and comprehensive error handling.\n\n## Authentication\n\nNo authentication is required for any endpoints in this API.\n\n## Rate Limiting\n\nNo rate limiting is currently implemented.\n\n## Content Type\n\nAll endpoints return JSON responses with `Content-Type: application/json`.\n\n## Error Response Format\n\nAll error responses follow a consistent structure:\n\n```json\n{\n  \"error\": {\n    \"code\": \"ERROR_CODE\",\n    \"message\": \"Human-readable error description\"\n  }\n}\n```\n\n## Endpoints\n\n### GET /hello\n\nReturns a greeting message with optional personalization.\n\n#### Parameters\n\n| Parameter | Type | Location | Required | Description |\n|-----------|------|----------|----------|-------------|\n| `name` | string | query | No | Name to personalize greeting (max 100 chars, alphanumeric and spaces only) |\n\n#### Request Examples\n\n**Basic greeting:**\n```http\nGET /hello HTTP/1.1\nHost: localhost:8000\n```\n\n**Personalized greeting:**\n```http\nGET /hello?name=Alice HTTP/1.1\nHost: localhost:8000\n```\n\n**Multiple word name:**\n```http\nGET /hello?name=John%20Doe HTTP/1.1\nHost: localhost:8000\n```\n\n#### Response Examples\n\n**Success Response (200 OK) - Default:**\n```json\n{\n  \"message\": \"Hello, World!\"\n}\n```\n\n**Success Response (200 OK) - Personalized:**\n```json\n{\n  \"message\": \"Hello, Alice!\"\n}\n```\n\n#### Error Responses\n\n**400 Bad Request - Invalid Name Characters:**\n```json\n{\n  \"error\": {\n    \"code\": \"INVALID_NAME\",\n    \"message\": \"Name parameter contains invalid characters or exceeds 100 characters\"\n  }\n}\n```\n\n**Example invalid requests:**\n- `GET /hello?name=Alice@123` (contains special characters)\n- `GET /hello?name=<script>alert('xss')</script>` (contains HTML/script tags)\n- `GET /hello?name=` + 101 character string (exceeds length limit)\n\n**500 Internal Server Error:**\n```json\n{\n  \"error\": {\n    \"code\": \"INTERNAL_ERROR\",\n    \"message\": \"Internal server error\"\n  }\n}\n```\n\n#### Status Codes\n\n| Code | Description |\n|------|-------------|\n| 200 | Success - greeting returned |\n| 400 | Bad Request - invalid name parameter |\n| 500 | Internal Server Error - unexpected server error |\n\n#### Validation Rules\n\n- **Name parameter validation:**\n  - Optional parameter (can be omitted)\n  - Maximum length: 100 characters\n  - Allowed characters: letters (a-z, A-Z), numbers (0-9), and spaces\n  - Empty string treated as no name provided\n  - Leading/trailing spaces are preserved\n\n### GET /health\n\nReturns application health status and current timestamp for monitoring purposes.\n\n#### Parameters\n\nNone.\n\n#### Request Example\n\n```http\nGET /health HTTP/1.1\nHost: localhost:8000\n```\n\n#### Response Examples\n\n**Success Response (200 OK):**\n```json\n{\n  \"status\": \"ok\",\n  \"timestamp\": \"2024-01-15T10:30:45.123456Z\"\n}\n```\n\n#### Response Fields\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `status` | string | Always returns \"ok\" when service is running |\n| `timestamp` | string | Current UTC timestamp in ISO 8601 format |\n\n#### Error Responses\n\n**500 Internal Server Error:**\n```json\n{\n  \"error\": {\n    \"code\": \"INTERNAL_ERROR\",\n    \"message\": \"Internal server error\"\n  }\n}\n```\n\n#### Status Codes\n\n| Code | Description |\n|------|-------------|\n| 200 | Success - health status returned |\n| 500 | Internal Server Error - unexpected server error |\n\n#### Timestamp Format\n\nThe timestamp follows ISO 8601 format in UTC timezone:\n- Format: `YYYY-MM-DDTHH:MM:SS.fffffZ`\n- Example: `2024-01-15T10:30:45.123456Z`\n- Always ends with 'Z' indicating UTC timezone\n\n## Interactive Documentation\n\nFastAPI automatically generates interactive API documentation:\n\n- **Swagger UI:** `http://localhost:8000/docs`\n- **ReDoc:** `http://localhost:8000/redoc`\n- **OpenAPI Schema:** `http://localhost:8000/openapi.json`\n\n## cURL Examples\n\n### Hello Endpoint Examples\n\n**Basic greeting:**\n```bash\ncurl -X GET \"http://localhost:8000/hello\"\n```\n\n**Personalized greeting:**\n```bash\ncurl -X GET \"http://localhost:8000/hello?name=Alice\"\n```\n\n**Name with spaces:**\n```bash\ncurl -X GET \"http://localhost:8000/hello?name=John%20Doe\"\n```\n\n### Health Endpoint Example\n\n```bash\ncurl -X GET \"http://localhost:8000/health\"\n```\n\n## HTTP Client Examples\n\n### Python (requests)\n\n```python\nimport requests\n\n# Basic greeting\nresponse = requests.get(\"http://localhost:8000/hello\")\nprint(response.json())  # {\"message\": \"Hello, World!\"}\n\n# Personalized greeting\nresponse = requests.get(\"http://localhost:8000/hello\", params={\"name\": \"Alice\"})\nprint(response.json())  # {\"message\": \"Hello, Alice!\"}\n\n# Health check\nresponse = requests.get(\"http://localhost:8000/health\")\nprint(response.json())  # {\"status\": \"ok\", \"timestamp\": \"2024-01-15T10:30:45.123456Z\"}\n```\n\n### JavaScript (fetch)\n\n```javascript\n// Basic greeting\nfetch('http://localhost:8000/hello')\n  .then(response => response.json())\n  .then(data => console.log(data)); // {message: \"Hello, World!\"}\n\n// Personalized greeting\nfetch('http://localhost:8000/hello?name=Alice')\n  .then(response => response.json())\n  .then(data => console.log(data)); // {message: \"Hello, Alice!\"}\n\n// Health check\nfetch('http://localhost:8000/health')\n  .then(response => response.json())\n  .then(data => console.log(data)); // {status: \"ok\", timestamp: \"2024-01-15T10:30:45.123456Z\"}\n```\n\n## Error Handling Best Practices\n\n### Client-Side Error Handling\n\nAlways check the HTTP status code and handle errors appropriately:\n\n```python\nimport requests\n\nresponse = requests.get(\"http://localhost:8000/hello\", params={\"name\": \"Invalid@Name\"})\n\nif response.status_code == 200:\n    data = response.json()\n    print(f\"Success: {data['message']}\")\nelif response.status_code == 400:\n    error = response.json()\n    print(f\"Validation Error: {error['error']['message']}\")\nelif response.status_code == 500:\n    error = response.json()\n    print(f\"Server Error: {error['error']['message']}\")\nelse:\n    print(f\"Unexpected status code: {response.status_code}\")\n```\n\n### Common Error Scenarios\n\n1. **Invalid Name Characters:**\n   - Names containing symbols: `!@#$%^&*()`\n   - Names containing HTML/XML tags: `<script>`, `<div>`\n   - Names containing newlines or control characters\n\n2. **Name Length Validation:**\n   - Names longer than 100 characters will be rejected\n   - Empty names are allowed and treated as no name provided\n\n3. **Server Errors:**\n   - Network connectivity issues\n   - Server overload or maintenance\n   - Unexpected application errors\n\n## Monitoring and Health Checks\n\nThe `/health` endpoint is designed for monitoring systems and load balancers:\n\n### Health Check Integration\n\n**Docker Health Check:**\n```dockerfile\nHEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\\n  CMD curl -f http://localhost:8000/health || exit",
      "file_type": "documentation",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Detailed API endpoint documentation with request/response examples, authentication requirements, and error codes"
    }
  ],
  "file_structure": {
    "src": [
      "main.py"
    ],
    "src/api": [
      "auth.py",
      "tasks.py"
    ],
    "src/models": [
      "user.py",
      "task.py"
    ],
    "src/schemas": [
      "auth.py",
      "task.py"
    ],
    "src/utils": [
      "jwt_utils.py",
      "password.py"
    ],
    "src/database": [
      "connection.py"
    ],
    "src/database/migrations": [
      "001_initial_schema.py"
    ],
    "tests": [
      "test_auth_api.py",
      "test_tasks_api.py",
      "test_user_model.py",
      "test_task_model.py",
      "test_jwt_utils.py",
      "test_password.py",
      "conftest.py"
    ],
    ".": [
      "requirements.txt",
      ".env.example",
      "alembic.ini",
      "pytest.ini",
      ".gitignore",
      "README.md"
    ],
    "docs": [
      "api_documentation.md"
    ]
  },
  "implementation_notes": "Generated using multi-stage approach with 25 files. Manifest estimated 4070 LOC, actual 4049 LOC. Uses 12 external dependencies.",
  "dependencies": [
    "fastapi==0.104.1",
    "uvicorn==0.24.0",
    "python-jose[cryptography]==3.3.0",
    "bcrypt==4.1.1",
    "pydantic==2.5.0",
    "sqlalchemy==2.0.23",
    "alembic==1.13.0",
    "python-multipart==0.0.6",
    "pytest==7.4.3",
    "pytest-asyncio==0.21.1",
    "httpx==0.25.2",
    "python-dotenv==1.0.0"
  ],
  "setup_instructions": "1. Install Python 3.11+\\n2. Create virtual environment: python -m venv venv\\n3. Activate virtual environment: source venv/bin/activate (Linux/Mac) or venv\\Scripts\\activate (Windows)\\n4. Install dependencies: pip install -r requirements.txt\\n5. Copy .env.example to .env and configure environment variables\\n6. Initialize database: alembic upgrade head\\n7. Start development server: uvicorn src.main:app --reload\\n8. Run tests: pytest tests/ -v\\n9. Access API documentation at http://localhost:8000/docs",
  "total_lines_of_code": 4049,
  "total_files": 25,
  "test_coverage_target": 80.0,
  "semantic_units_implemented": [
    "SU-003",
    "SU-008",
    "SU-004",
    "SU-011",
    "SU-005",
    "SU-009",
    "SU-002",
    "SU-001",
    "SU-006",
    "SU-010",
    "SU-007"
  ],
  "components_implemented": [
    "COMP-001",
    "COMP-007",
    "COMP-011",
    "COMP-005",
    "COMP-004",
    "COMP-003",
    "COMP-008",
    "COMP-010",
    "COMP-009",
    "COMP-002",
    "COMP-006"
  ],
  "agent_version": "1.0.0",
  "generation_timestamp": "2025-11-21T03:22:43.311446"
}