{
  "task_id": "HW-001",
  "project_id": "PROJECT-001",
  "files": [
    {
      "file_path": "src/main.py",
      "content": "\"\"\"\nFastAPI Hello World Application\n\nMain application entry point that configures FastAPI with CORS middleware,\nerror handlers, and endpoint routing for a simple greeting API.\n\nComponent ID: COMP-001\nSemantic Unit: SU-001\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport re\nfrom datetime import datetime\nfrom typing import Optional\n\nfrom fastapi import FastAPI, HTTPException, Query, Request\nfrom fastapi.exceptions import RequestValidationError\nfrom fastapi.responses import JSONResponse\nfrom fastapi.middleware.cors import CORSMiddleware\nimport logging\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# Compile regex for name validation\nNAME_PATTERN = re.compile(r'^[a-zA-Z0-9\\s]*$')\n\n\ndef create_app() -> FastAPI:\n    \"\"\"\n    Create and configure FastAPI application instance.\n    \n    Returns:\n        FastAPI: Configured application instance\n    \"\"\"\n    app = FastAPI(\n        title=\"Hello World API\",\n        description=\"Simple REST API that returns greeting messages\",\n        version=\"1.0.0\"\n    )\n    \n    # Add CORS middleware\n    app.add_middleware(\n        CORSMiddleware,\n        allow_origins=[\"*\"],\n        allow_credentials=True,\n        allow_methods=[\"*\"],\n        allow_headers=[\"*\"],\n    )\n    \n    # Setup error handlers\n    setup_error_handlers(app)\n    \n    return app\n\n\ndef setup_error_handlers(app: FastAPI) -> None:\n    \"\"\"\n    Configure global exception handlers for the application.\n    \n    Args:\n        app: FastAPI application instance\n    \"\"\"\n    \n    @app.exception_handler(RequestValidationError)\n    async def handle_validation_error(request: Request, exc: RequestValidationError) -> JSONResponse:\n        \"\"\"\n        Handle FastAPI validation errors and return 400 with proper error format.\n        \n        Args:\n            request: HTTP request object\n            exc: Validation error exception\n            \n        Returns:\n            JSONResponse: Formatted error response\n        \"\"\"\n        logger.warning(f\"Validation error for {request.url}: {exc}\")\n        return JSONResponse(\n            status_code=400,\n            content=format_error_response(400, \"VALIDATION_ERROR\", \"Invalid request parameters\")\n        )\n    \n    @app.exception_handler(HTTPException)\n    async def handle_http_exception(request: Request, exc: HTTPException) -> JSONResponse:\n        \"\"\"\n        Handle HTTP exceptions and return formatted error response.\n        \n        Args:\n            request: HTTP request object\n            exc: HTTP exception\n            \n        Returns:\n            JSONResponse: Formatted error response\n        \"\"\"\n        logger.warning(f\"HTTP exception for {request.url}: {exc.status_code} - {exc.detail}\")\n        error_code = getattr(exc, 'error_code', 'HTTP_ERROR')\n        return JSONResponse(\n            status_code=exc.status_code,\n            content=format_error_response(exc.status_code, error_code, exc.detail)\n        )\n    \n    @app.exception_handler(Exception)\n    async def handle_general_exception(request: Request, exc: Exception) -> JSONResponse:\n        \"\"\"\n        Handle unexpected exceptions and return 500 error.\n        \n        Args:\n            request: HTTP request object\n            exc: General exception\n            \n        Returns:\n            JSONResponse: Formatted error response\n        \"\"\"\n        logger.error(f\"Unexpected error for {request.url}: {exc}\", exc_info=True)\n        return JSONResponse(\n            status_code=500,\n            content=format_error_response(500, \"INTERNAL_ERROR\", \"Internal server error\")\n        )\n\n\ndef format_error_response(status_code: int, error_code: str, message: str) -> dict[str, dict[str, str]]:\n    \"\"\"\n    Format error response with consistent structure.\n    \n    Args:\n        status_code: HTTP status code\n        error_code: Application-specific error code\n        message: Error message description\n        \n    Returns:\n        dict: Formatted error response\n    \"\"\"\n    return {\n        \"error\": {\n            \"code\": error_code,\n            \"message\": message\n        }\n    }\n\n\ndef validate_name(name: str) -> bool:\n    \"\"\"\n    Validate name parameter contains only alphanumeric characters and spaces.\n    \n    Args:\n        name: Name string to validate\n        \n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    if len(name) > 100:\n        return False\n    return bool(NAME_PATTERN.match(name))\n\n\ndef sanitize_name(name: str) -> str:\n    \"\"\"\n    Clean and format name parameter for safe usage.\n    \n    Args:\n        name: Raw name string\n        \n    Returns:\n        str: Sanitized and formatted name\n    \"\"\"\n    return name.strip().title()\n\n\ndef get_current_timestamp() -> str:\n    \"\"\"\n    Generate ISO 8601 formatted UTC timestamp.\n    \n    Returns:\n        str: ISO 8601 timestamp with Z suffix\n    \"\"\"\n    return datetime.utcnow().isoformat() + 'Z'\n\n\n# Create FastAPI application\napp = create_app()\n\n\n@app.get(\"/hello\")\nasync def get_hello(name: Optional[str] = Query(None, max_length=100)) -> dict[str, str]:\n    \"\"\"\n    Return greeting message, personalized if name provided.\n    \n    Args:\n        name: Optional name parameter for personalization\n        \n    Returns:\n        dict: JSON response with greeting message\n        \n    Raises:\n        HTTPException: 400 if name contains invalid characters\n    \"\"\"\n    if name is not None:\n        if not validate_name(name):\n            exc = HTTPException(\n                status_code=400,\n                detail=\"Name parameter contains invalid characters or exceeds 100 characters\"\n            )\n            exc.error_code = \"INVALID_NAME\"\n            raise exc\n        \n        sanitized_name = sanitize_name(name)\n        if sanitized_name:\n            return {\"message\": f\"Hello, {sanitized_name}!\"}\n    \n    return {\"message\": \"Hello, World!\"}\n\n\n@app.get(\"/health\")\nasync def get_health() -> dict[str, str]:\n    \"\"\"\n    Return health status and current UTC timestamp.\n    \n    Returns:\n        dict: JSON response with status and timestamp\n    \"\"\"\n    return {\n        \"status\": \"ok\",\n        \"timestamp\": get_current_timestamp()\n    }",
      "file_type": "source",
      "semantic_unit_id": "SU-001",
      "component_id": "COMP-001",
      "description": "FastAPI application entry point with CORS middleware, router registration, and startup configuration"
    },
    {
      "file_path": "src/api/auth.py",
      "content": "\"\"\"\nAuthentication API endpoints for user registration, login, token refresh, and logout.\n\nThis module provides JWT-based authentication endpoints with secure password handling\nand token management for user authentication and authorization.\n\nComponent ID: COMP-002\nSemantic Unit: SU-002\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport logging\nfrom datetime import datetime, timedelta\nfrom typing import Optional\n\nfrom fastapi import APIRouter, Depends, HTTPException, status\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nfrom pydantic import BaseModel, EmailStr, Field\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy.exc import IntegrityError\n\nfrom src.database.connection import get_db_session\nfrom src.models.user import User\nfrom src.utils.jwt_utils import (\n    create_access_token,\n    create_refresh_token,\n    verify_token,\n    decode_token,\n    blacklist_token,\n    is_token_blacklisted\n)\nfrom src.utils.password import hash_password, verify_password\n\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Initialize router and security\nrouter = APIRouter(prefix=\"/auth\", tags=[\"authentication\"])\nsecurity = HTTPBearer()\n\n\nclass UserRegistrationRequest(BaseModel):\n    \"\"\"Request model for user registration.\"\"\"\n    email: EmailStr = Field(..., description=\"User email address\")\n    password: str = Field(..., min_length=8, max_length=128, description=\"User password\")\n    first_name: str = Field(..., min_length=1, max_length=50, description=\"User first name\")\n    last_name: str = Field(..., min_length=1, max_length=50, description=\"User last name\")\n\n\nclass UserLoginRequest(BaseModel):\n    \"\"\"Request model for user login.\"\"\"\n    email: EmailStr = Field(..., description=\"User email address\")\n    password: str = Field(..., description=\"User password\")\n\n\nclass TokenRefreshRequest(BaseModel):\n    \"\"\"Request model for token refresh.\"\"\"\n    refresh_token: str = Field(..., description=\"Valid refresh token\")\n\n\nclass AuthResponse(BaseModel):\n    \"\"\"Response model for authentication endpoints.\"\"\"\n    access_token: str = Field(..., description=\"JWT access token\")\n    refresh_token: str = Field(..., description=\"JWT refresh token\")\n    token_type: str = Field(default=\"bearer\", description=\"Token type\")\n    expires_in: int = Field(..., description=\"Access token expiration time in seconds\")\n\n\nclass UserResponse(BaseModel):\n    \"\"\"Response model for user information.\"\"\"\n    id: int = Field(..., description=\"User ID\")\n    email: str = Field(..., description=\"User email address\")\n    first_name: str = Field(..., description=\"User first name\")\n    last_name: str = Field(..., description=\"User last name\")\n    created_at: datetime = Field(..., description=\"User creation timestamp\")\n    is_active: bool = Field(..., description=\"User active status\")\n\n\nclass MessageResponse(BaseModel):\n    \"\"\"Response model for simple messages.\"\"\"\n    message: str = Field(..., description=\"Response message\")\n\n\ndef validate_password_strength(password: str) -> None:\n    \"\"\"\n    Validate password meets security requirements.\n    \n    Args:\n        password: Password to validate\n        \n    Raises:\n        HTTPException: If password doesn't meet requirements\n    \"\"\"\n    if len(password) < 8:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Password must be at least 8 characters long\"\n        )\n    \n    if len(password) > 128:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Password must not exceed 128 characters\"\n        )\n    \n    # Check for at least one uppercase letter\n    if not any(c.isupper() for c in password):\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Password must contain at least one uppercase letter\"\n        )\n    \n    # Check for at least one lowercase letter\n    if not any(c.islower() for c in password):\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Password must contain at least one lowercase letter\"\n        )\n    \n    # Check for at least one digit\n    if not any(c.isdigit() for c in password):\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Password must contain at least one digit\"\n        )\n\n\ndef get_current_user(\n    credentials: HTTPAuthorizationCredentials = Depends(security),\n    db: Session = Depends(get_db_session)\n) -> User:\n    \"\"\"\n    Get current authenticated user from JWT token.\n    \n    Args:\n        credentials: HTTP authorization credentials\n        db: Database session\n        \n    Returns:\n        User: Current authenticated user\n        \n    Raises:\n        HTTPException: If token is invalid or user not found\n    \"\"\"\n    token = credentials.credentials\n    \n    # Check if token is blacklisted\n    if is_token_blacklisted(token):\n        logger.warning(f\"Attempt to use blacklisted token\")\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Token has been revoked\",\n            headers={\"WWW-Authenticate\": \"Bearer\"}\n        )\n    \n    try:\n        # Verify and decode token\n        payload = verify_token(token)\n        user_id = payload.get(\"sub\")\n        \n        if user_id is None:\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Invalid token payload\",\n                headers={\"WWW-Authenticate\": \"Bearer\"}\n            )\n        \n        # Get user from database\n        user = db.query(User).filter(User.id == int(user_id)).first()\n        if user is None:\n            logger.warning(f\"Token contains non-existent user ID: {user_id}\")\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"User not found\",\n                headers={\"WWW-Authenticate\": \"Bearer\"}\n            )\n        \n        if not user.is_active:\n            logger.warning(f\"Inactive user attempted access: {user.email}\")\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"User account is inactive\",\n                headers={\"WWW-Authenticate\": \"Bearer\"}\n            )\n        \n        return user\n        \n    except HTTPException:\n        raise\n    except Exception as e:\n        logger.error(f\"Error validating token: {str(e)}\")\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Invalid token\",\n            headers={\"WWW-Authenticate\": \"Bearer\"}\n        )\n\n\n@router.post(\"/register\", response_model=AuthResponse, status_code=status.HTTP_201_CREATED)\ndef register_user(\n    user_data: UserRegistrationRequest,\n    db: Session = Depends(get_db_session)\n) -> AuthResponse:\n    \"\"\"\n    Register a new user account.\n    \n    Args:\n        user_data: User registration data\n        db: Database session\n        \n    Returns:\n        AuthResponse: Authentication tokens and user information\n        \n    Raises:\n        HTTPException: If registration fails or email already exists\n    \"\"\"\n    try:\n        # Validate password strength\n        validate_password_strength(user_data.password)\n        \n        # Check if user already exists\n        existing_user = db.query(User).filter(User.email == user_data.email.lower()).first()\n        if existing_user:\n            logger.warning(f\"Registration attempt with existing email: {user_data.email}\")\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Email address is already registered\"\n            )\n        \n        # Hash password\n        hashed_password = hash_password(user_data.password)\n        \n        # Create new user\n        new_user = User(\n            email=user_data.email.lower(),\n            password_hash=hashed_password,\n            first_name=user_data.first",
      "file_type": "source",
      "semantic_unit_id": "SU-002",
      "component_id": "COMP-002",
      "description": "Authentication API endpoints for user registration, login, token refresh, and logout with JWT token management"
    },
    {
      "file_path": "src/api/tasks.py",
      "content": "\"\"\"\nTask management API endpoints for CRUD operations with authentication middleware and user-specific filtering.\n\nThis module provides REST API endpoints for managing tasks including creation, retrieval,\nupdating, and deletion with proper authentication and user-specific data filtering.\n\nComponent ID: COMP-003\nSemantic Unit: SU-003\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport logging\nfrom datetime import datetime\nfrom typing import List, Optional\nfrom uuid import UUID\n\nfrom fastapi import APIRouter, Depends, HTTPException, Query, status\nfrom fastapi.security import HTTPBearer\nfrom pydantic import BaseModel, Field, validator\nfrom sqlalchemy.exc import SQLAlchemyError\nfrom sqlalchemy.orm import Session\n\nfrom src.database.connection import get_db_session\nfrom src.models.task import Task, TaskStatus, TaskPriority\nfrom src.models.user import User\nfrom src.utils.jwt_utils import decode_jwt_token, get_current_user\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Security scheme\nsecurity = HTTPBearer()\n\n# Router for task endpoints\nrouter = APIRouter(prefix=\"/api/tasks\", tags=[\"tasks\"])\n\n\nclass TaskCreateRequest(BaseModel):\n    \"\"\"Request model for creating a new task.\"\"\"\n    \n    title: str = Field(..., min_length=1, max_length=200, description=\"Task title\")\n    description: Optional[str] = Field(None, max_length=1000, description=\"Task description\")\n    priority: TaskPriority = Field(TaskPriority.MEDIUM, description=\"Task priority level\")\n    due_date: Optional[datetime] = Field(None, description=\"Task due date\")\n    \n    @validator('title')\n    def validate_title(cls, v: str) -> str:\n        \"\"\"Validate and sanitize task title.\"\"\"\n        if not v or not v.strip():\n            raise ValueError(\"Title cannot be empty or whitespace only\")\n        return v.strip()\n    \n    @validator('description')\n    def validate_description(cls, v: Optional[str]) -> Optional[str]:\n        \"\"\"Validate and sanitize task description.\"\"\"\n        if v is not None:\n            return v.strip() if v.strip() else None\n        return v\n    \n    @validator('due_date')\n    def validate_due_date(cls, v: Optional[datetime]) -> Optional[datetime]:\n        \"\"\"Validate due date is not in the past.\"\"\"\n        if v is not None and v < datetime.utcnow():\n            raise ValueError(\"Due date cannot be in the past\")\n        return v\n\n\nclass TaskUpdateRequest(BaseModel):\n    \"\"\"Request model for updating an existing task.\"\"\"\n    \n    title: Optional[str] = Field(None, min_length=1, max_length=200, description=\"Task title\")\n    description: Optional[str] = Field(None, max_length=1000, description=\"Task description\")\n    status: Optional[TaskStatus] = Field(None, description=\"Task status\")\n    priority: Optional[TaskPriority] = Field(None, description=\"Task priority level\")\n    due_date: Optional[datetime] = Field(None, description=\"Task due date\")\n    \n    @validator('title')\n    def validate_title(cls, v: Optional[str]) -> Optional[str]:\n        \"\"\"Validate and sanitize task title.\"\"\"\n        if v is not None:\n            if not v or not v.strip():\n                raise ValueError(\"Title cannot be empty or whitespace only\")\n            return v.strip()\n        return v\n    \n    @validator('description')\n    def validate_description(cls, v: Optional[str]) -> Optional[str]:\n        \"\"\"Validate and sanitize task description.\"\"\"\n        if v is not None:\n            return v.strip() if v.strip() else None\n        return v\n    \n    @validator('due_date')\n    def validate_due_date(cls, v: Optional[datetime]) -> Optional[datetime]:\n        \"\"\"Validate due date is not in the past.\"\"\"\n        if v is not None and v < datetime.utcnow():\n            raise ValueError(\"Due date cannot be in the past\")\n        return v\n\n\nclass TaskResponse(BaseModel):\n    \"\"\"Response model for task data.\"\"\"\n    \n    id: UUID\n    title: str\n    description: Optional[str]\n    status: TaskStatus\n    priority: TaskPriority\n    due_date: Optional[datetime]\n    created_at: datetime\n    updated_at: datetime\n    user_id: UUID\n    \n    class Config:\n        from_attributes = True\n\n\nclass TaskListResponse(BaseModel):\n    \"\"\"Response model for task list with pagination.\"\"\"\n    \n    tasks: List[TaskResponse]\n    total: int\n    page: int\n    page_size: int\n    has_next: bool\n    has_previous: bool\n\n\ndef validate_task_ownership(task: Task, user: User) -> None:\n    \"\"\"\n    Validate that the current user owns the specified task.\n    \n    Args:\n        task: Task instance to validate\n        user: Current authenticated user\n        \n    Raises:\n        HTTPException: If user doesn't own the task\n    \"\"\"\n    if task.user_id != user.id:\n        logger.warning(f\"User {user.id} attempted to access task {task.id} owned by {task.user_id}\")\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Access denied: You can only access your own tasks\"\n        )\n\n\ndef get_task_by_id(task_id: UUID, db: Session, user: User) -> Task:\n    \"\"\"\n    Retrieve a task by ID and validate ownership.\n    \n    Args:\n        task_id: UUID of the task to retrieve\n        db: Database session\n        user: Current authenticated user\n        \n    Returns:\n        Task: The requested task\n        \n    Raises:\n        HTTPException: If task not found or access denied\n    \"\"\"\n    try:\n        task = db.query(Task).filter(Task.id == task_id).first()\n        if not task:\n            raise HTTPException(\n                status_code=status.HTTP_404_NOT_FOUND,\n                detail=f\"Task with ID {task_id} not found\"\n            )\n        \n        validate_task_ownership(task, user)\n        return task\n        \n    except SQLAlchemyError as e:\n        logger.error(f\"Database error retrieving task {task_id}: {str(e)}\")\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Database error occurred\"\n        )\n\n\n@router.post(\"/\", response_model=TaskResponse, status_code=status.HTTP_201_CREATED)\ndef create_task(\n    task_data: TaskCreateRequest,\n    db: Session = Depends(get_db_session),\n    current_user: User = Depends(get_current_user)\n) -> TaskResponse:\n    \"\"\"\n    Create a new task for the authenticated user.\n    \n    Args:\n        task_data: Task creation data\n        db: Database session\n        current_user: Authenticated user\n        \n    Returns:\n        TaskResponse: Created task data\n        \n    Raises:\n        HTTPException: If task creation fails\n    \"\"\"\n    try:\n        # Create new task instance\n        new_task = Task(\n            title=task_data.title,\n            description=task_data.description,\n            priority=task_data.priority,\n            due_date=task_data.due_date,\n            user_id=current_user.id,\n            status=TaskStatus.TODO,\n            created_at=datetime.utcnow(),\n            updated_at=datetime.utcnow()\n        )\n        \n        # Save to database\n        db.add(new_task)\n        db.commit()\n        db.refresh(new_task)\n        \n        logger.info(f\"Task {new_task.id} created successfully for user {current_user.id}\")\n        return TaskResponse.from_orm(new_task)\n        \n    except SQLAlchemyError as e:\n        db.rollback()\n        logger.error(f\"Database error creating task for user {current_user.id}: {str(e)}\")\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Failed to create task due to database error\"\n        )\n    except Exception as",
      "file_type": "source",
      "semantic_unit_id": "SU-003",
      "component_id": "COMP-003",
      "description": "Task management API endpoints for CRUD operations with authentication middleware and user-specific filtering"
    },
    {
      "file_path": "src/models/user.py",
      "content": "\"\"\"\nUser SQLAlchemy model with authentication fields, profile data, and relationship to tasks.\n\nThis module defines the User model for the application with authentication capabilities,\nprofile information, and relationships to other entities.\n\nComponent ID: COMP-004\nSemantic Unit: SU-004\n\nAuthor: ASP Code Agent\n\"\"\"\n\nfrom datetime import datetime\nfrom typing import Optional, List\nfrom sqlalchemy import Column, Integer, String, DateTime, Boolean, Text\nfrom sqlalchemy.orm import relationship\nfrom sqlalchemy.sql import func\nfrom werkzeug.security import generate_password_hash, check_password_hash\nimport re\n\nfrom src.database.connection import Base\n\n\nclass User(Base):\n    \"\"\"\n    User model for authentication and profile management.\n    \n    This model handles user authentication, profile data, and relationships\n    to other entities in the system. Includes password hashing, email validation,\n    and timestamp tracking.\n    \n    Attributes:\n        id: Primary key identifier\n        username: Unique username for login\n        email: Unique email address\n        password_hash: Hashed password for authentication\n        first_name: User's first name\n        last_name: User's last name\n        is_active: Whether the user account is active\n        is_verified: Whether the user's email is verified\n        created_at: Timestamp when user was created\n        updated_at: Timestamp when user was last updated\n        last_login: Timestamp of last successful login\n        bio: Optional user biography\n        tasks: Relationship to user's tasks\n    \"\"\"\n    \n    __tablename__ = \"users\"\n    \n    # Primary key\n    id = Column(Integer, primary_key=True, index=True)\n    \n    # Authentication fields\n    username = Column(String(50), unique=True, index=True, nullable=False)\n    email = Column(String(255), unique=True, index=True, nullable=False)\n    password_hash = Column(String(255), nullable=False)\n    \n    # Profile fields\n    first_name = Column(String(100), nullable=False)\n    last_name = Column(String(100), nullable=False)\n    bio = Column(Text, nullable=True)\n    \n    # Status fields\n    is_active = Column(Boolean, default=True, nullable=False)\n    is_verified = Column(Boolean, default=False, nullable=False)\n    \n    # Timestamp fields\n    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)\n    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False)\n    last_login = Column(DateTime(timezone=True), nullable=True)\n    \n    # Relationships\n    tasks = relationship(\"Task\", back_populates=\"user\", cascade=\"all, delete-orphan\")\n    \n    def __init__(\n        self,\n        username: str,\n        email: str,\n        password: str,\n        first_name: str,\n        last_name: str,\n        bio: Optional[str] = None,\n        is_active: bool = True,\n        is_verified: bool = False\n    ) -> None:\n        \"\"\"\n        Initialize a new User instance.\n        \n        Args:\n            username: Unique username for the user\n            email: User's email address\n            password: Plain text password (will be hashed)\n            first_name: User's first name\n            last_name: User's last name\n            bio: Optional biography text\n            is_active: Whether the account is active\n            is_verified: Whether the email is verified\n            \n        Raises:\n            ValueError: If validation fails for any field\n        \"\"\"\n        self.username = self._validate_username(username)\n        self.email = self._validate_email(email)\n        self.set_password(password)\n        self.first_name = self._validate_name(first_name, \"first_name\")\n        self.last_name = self._validate_name(last_name, \"last_name\")\n        self.bio = self._validate_bio(bio) if bio else None\n        self.is_active = is_active\n        self.is_verified = is_verified\n    \n    def set_password(self, password: str) -> None:\n        \"\"\"\n        Set the user's password by hashing it.\n        \n        Args:\n            password: Plain text password to hash and store\n            \n        Raises:\n            ValueError: If password doesn't meet requirements\n        \"\"\"\n        validated_password = self._validate_password(password)\n        self.password_hash = generate_password_hash(validated_password)\n    \n    def check_password(self, password: str) -> bool:\n        \"\"\"\n        Check if the provided password matches the stored hash.\n        \n        Args:\n            password: Plain text password to verify\n            \n        Returns:\n            bool: True if password matches, False otherwise\n        \"\"\"\n        if not password or not self.password_hash:\n            return False\n        return check_password_hash(self.password_hash, password)\n    \n    def update_last_login(self) -> None:\n        \"\"\"Update the last_login timestamp to current time.\"\"\"\n        self.last_login = datetime.utcnow()\n    \n    def get_full_name(self) -> str:\n        \"\"\"\n        Get the user's full name.\n        \n        Returns:\n            str: Formatted full name (first_name last_name)\n        \"\"\"\n        return f\"{self.first_name} {self.last_name}\".strip()\n    \n    def deactivate(self) -> None:\n        \"\"\"Deactivate the user account.\"\"\"\n        self.is_active = False\n    \n    def activate(self) -> None:\n        \"\"\"Activate the user account.\"\"\"\n        self.is_active = True\n    \n    def verify_email(self) -> None:\n        \"\"\"Mark the user's email as verified.\"\"\"\n        self.is_verified = True\n    \n    def update_profile(\n        self,\n        first_name: Optional[str] = None,\n        last_name: Optional[str] = None,\n        bio: Optional[str] = None\n    ) -> None:\n        \"\"\"\n        Update user profile information.\n        \n        Args:\n            first_name: New first name (optional)\n            last_name: New last name (optional)\n            bio: New biography (optional)\n            \n        Raises:\n            ValueError: If validation fails for any field\n        \"\"\"\n        if first_name is not None:\n            self.first_name = self._validate_name(first_name, \"first_name\")\n        if last_name is not None:\n            self.last_name = self._validate_name(last_name, \"last_name\")\n        if bio is not None:\n            self.bio = self._validate_bio(bio) if bio.strip() else None\n    \n    @staticmethod\n    def _validate_username(username: str) -> str:\n        \"\"\"\n        Validate username format and requirements.\n        \n        Args:\n            username: Username to validate\n            \n        Returns:\n            str: Validated username\n            \n        Raises:\n            ValueError: If username is invalid\n        \"\"\"\n        if not username or not isinstance(username, str):\n            raise ValueError(\"Username is required and must be a string\")\n        \n        username = username.strip()\n        \n        if len(username) < 3:\n            raise ValueError(\"Username must be at least 3 characters long\")\n        if len(username) > 50:\n            raise ValueError(\"Username must not exceed 50 characters\")\n        \n        # Allow alphanumeric characters, underscores, and hyphens\n        if not re.match(r'^[a-zA-Z0-9_-]+$', username):\n            raise ValueError(\"Username can only contain letters, numbers, underscores, and hyphens\")\n        \n        return username\n    \n    @staticmethod\n    def _validate_email(email: str) -> str:\n        \"\"\"\n        Validate email format.\n        \n        Args:\n            email: Email address to validate\n            \n        Returns:\n            str: Validated email address\n            \n        Raises:\n            ValueError: If email is invalid\n        \"\"\"\n        if not email or not isinstance(email, str):\n            raise ValueError(\"Email is required and must be a string\")\n        \n        email = email.strip().lower()\n        \n        if len(email) > 255:",
      "file_type": "source",
      "semantic_unit_id": "SU-004",
      "component_id": "COMP-004",
      "description": "User SQLAlchemy model with authentication fields, profile data, and relationship to tasks"
    },
    {
      "file_path": "src/models/task.py",
      "content": "\"\"\"\nTask SQLAlchemy model with CRUD operations, status management, and foreign key relationship to users.\n\nThis module defines the Task model with comprehensive CRUD operations, status transitions,\nand proper relationship management with the User model.\n\nComponent ID: COMP-005\nSemantic Unit: SU-005\n\nAuthor: ASP Code Agent\n\"\"\"\n\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import List, Optional, Dict, Any\nfrom sqlalchemy import Column, Integer, String, Text, DateTime, ForeignKey, Boolean, Index\nfrom sqlalchemy.orm import relationship, Session\nfrom sqlalchemy.exc import SQLAlchemyError\nimport logging\n\nfrom src.database.connection import Base\nfrom src.models.user import User\n\nlogger = logging.getLogger(__name__)\n\n\nclass TaskStatus(str, Enum):\n    \"\"\"Enumeration of possible task statuses.\"\"\"\n    PENDING = \"pending\"\n    IN_PROGRESS = \"in_progress\"\n    COMPLETED = \"completed\"\n    CANCELLED = \"cancelled\"\n\n\nclass TaskPriority(str, Enum):\n    \"\"\"Enumeration of task priorities.\"\"\"\n    LOW = \"low\"\n    MEDIUM = \"medium\"\n    HIGH = \"high\"\n    URGENT = \"urgent\"\n\n\nclass Task(Base):\n    \"\"\"\n    Task model representing a user task with status management and CRUD operations.\n    \n    This model handles task creation, updates, status transitions, and provides\n    comprehensive querying capabilities with proper foreign key relationships.\n    \"\"\"\n    \n    __tablename__ = \"tasks\"\n    \n    # Primary key\n    id = Column(Integer, primary_key=True, index=True, autoincrement=True)\n    \n    # Task details\n    title = Column(String(200), nullable=False, index=True)\n    description = Column(Text, nullable=True)\n    status = Column(String(20), nullable=False, default=TaskStatus.PENDING.value, index=True)\n    priority = Column(String(10), nullable=False, default=TaskPriority.MEDIUM.value, index=True)\n    \n    # Foreign key relationship\n    user_id = Column(Integer, ForeignKey(\"users.id\", ondelete=\"CASCADE\"), nullable=False, index=True)\n    \n    # Timestamps\n    created_at = Column(DateTime, nullable=False, default=datetime.utcnow, index=True)\n    updated_at = Column(DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)\n    due_date = Column(DateTime, nullable=True, index=True)\n    completed_at = Column(DateTime, nullable=True)\n    \n    # Soft delete flag\n    is_deleted = Column(Boolean, nullable=False, default=False, index=True)\n    \n    # Relationship\n    user = relationship(\"User\", back_populates=\"tasks\")\n    \n    # Indexes for performance\n    __table_args__ = (\n        Index(\"idx_user_status\", \"user_id\", \"status\"),\n        Index(\"idx_user_priority\", \"user_id\", \"priority\"),\n        Index(\"idx_status_due_date\", \"status\", \"due_date\"),\n        Index(\"idx_user_created\", \"user_id\", \"created_at\"),\n    )\n    \n    def __repr__(self) -> str:\n        \"\"\"String representation of the Task model.\"\"\"\n        return f\"<Task(id={self.id}, title='{self.title}', status='{self.status}', user_id={self.user_id})>\"\n    \n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Convert task instance to dictionary representation.\n        \n        Returns:\n            Dict[str, Any]: Dictionary containing all task fields\n        \"\"\"\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"status\": self.status,\n            \"priority\": self.priority,\n            \"user_id\": self.user_id,\n            \"created_at\": self.created_at.isoformat() if self.created_at else None,\n            \"updated_at\": self.updated_at.isoformat() if self.updated_at else None,\n            \"due_date\": self.due_date.isoformat() if self.due_date else None,\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None,\n            \"is_deleted\": self.is_deleted\n        }\n    \n    def is_overdue(self) -> bool:\n        \"\"\"\n        Check if task is overdue based on due_date.\n        \n        Returns:\n            bool: True if task is overdue, False otherwise\n        \"\"\"\n        if not self.due_date or self.status == TaskStatus.COMPLETED.value:\n            return False\n        return datetime.utcnow() > self.due_date\n    \n    def can_transition_to(self, new_status: str) -> bool:\n        \"\"\"\n        Check if task can transition to the specified status.\n        \n        Args:\n            new_status (str): Target status to transition to\n            \n        Returns:\n            bool: True if transition is allowed, False otherwise\n        \"\"\"\n        valid_transitions = {\n            TaskStatus.PENDING.value: [TaskStatus.IN_PROGRESS.value, TaskStatus.CANCELLED.value],\n            TaskStatus.IN_PROGRESS.value: [TaskStatus.COMPLETED.value, TaskStatus.PENDING.value, TaskStatus.CANCELLED.value],\n            TaskStatus.COMPLETED.value: [TaskStatus.IN_PROGRESS.value],\n            TaskStatus.CANCELLED.value: [TaskStatus.PENDING.value]\n        }\n        \n        return new_status in valid_transitions.get(self.status, [])\n    \n    def update_status(self, new_status: str) -> bool:\n        \"\"\"\n        Update task status with validation and timestamp management.\n        \n        Args:\n            new_status (str): New status to set\n            \n        Returns:\n            bool: True if status was updated successfully, False otherwise\n            \n        Raises:\n            ValueError: If status transition is not allowed\n        \"\"\"\n        if not self.can_transition_to(new_status):\n            raise ValueError(f\"Cannot transition from {self.status} to {new_status}\")\n        \n        old_status = self.status\n        self.status = new_status\n        self.updated_at = datetime.utcnow()\n        \n        # Set completion timestamp\n        if new_status == TaskStatus.COMPLETED.value:\n            self.completed_at = datetime.utcnow()\n        elif old_status == TaskStatus.COMPLETED.value:\n            self.completed_at = None\n            \n        logger.info(f\"Task {self.id} status updated from {old_status} to {new_status}\")\n        return True\n\n\nclass TaskCRUD:\n    \"\"\"\n    CRUD operations for Task model with comprehensive querying and management capabilities.\n    \"\"\"\n    \n    @staticmethod\n    def create(\n        db: Session,\n        title: str,\n        user_id: int,\n        description: Optional[str] = None,\n        priority: str = TaskPriority.MEDIUM.value,\n        due_date: Optional[datetime] = None\n    ) -> Task:\n        \"\"\"\n        Create a new task.\n        \n        Args:\n            db (Session): Database session\n            title (str): Task title (max 200 characters)\n            user_id (int): ID of the user who owns the task\n            description (Optional[str]): Task description\n            priority (str): Task priority level\n            due_date (Optional[datetime]): Task due date\n            \n        Returns:\n            Task: Created task instance\n            \n        Raises:\n            ValueError: If validation fails\n            SQLAlchemyError: If database operation fails\n        \"\"\"\n        # Validate inputs\n        if not title or len(title.strip()) == 0:\n            raise ValueError(\"Task title cannot be empty\")\n        \n        if len(title) > 200:\n            raise ValueError(\"Task title cannot exceed 200 characters\")\n        \n        if priority not in [p.value for p in TaskPriority]:\n            raise ValueError(f\"Invalid priority: {priority}\")\n        \n        # Verify user exists\n        user = db.query(User).filter(User.id == user_id, User.is_deleted == False).",
      "file_type": "source",
      "semantic_unit_id": "SU-005",
      "component_id": "COMP-005",
      "description": "Task SQLAlchemy model with CRUD operations, status management, and foreign key relationship to users"
    },
    {
      "file_path": "src/schemas/user.py",
      "content": "\"\"\"\nPydantic schemas for user data validation and serialization.\n\nThis module defines all Pydantic models used for user-related operations including\nregistration, authentication, profile management, and API response formatting.\n\nComponent ID: COMP-006\nSemantic Unit: SU-006\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport re\nfrom datetime import datetime\nfrom typing import Optional\nfrom pydantic import BaseModel, Field, validator, EmailStr\n\n\nclass UserRegistrationRequest(BaseModel):\n    \"\"\"\n    Schema for user registration requests.\n    \n    Validates user input for account creation including email format,\n    password strength, and username requirements.\n    \"\"\"\n    username: str = Field(\n        ...,\n        min_length=3,\n        max_length=50,\n        description=\"Username must be 3-50 characters, alphanumeric and underscores only\"\n    )\n    email: EmailStr = Field(\n        ...,\n        description=\"Valid email address for account verification\"\n    )\n    password: str = Field(\n        ...,\n        min_length=8,\n        max_length=128,\n        description=\"Password must be 8-128 characters with mixed case, numbers, and symbols\"\n    )\n    full_name: str = Field(\n        ...,\n        min_length=1,\n        max_length=100,\n        description=\"User's full name for profile display\"\n    )\n    \n    @validator('username')\n    def validate_username(cls, v: str) -> str:\n        \"\"\"\n        Validate username contains only alphanumeric characters and underscores.\n        \n        Args:\n            v: Username string to validate\n            \n        Returns:\n            str: Validated username\n            \n        Raises:\n            ValueError: If username contains invalid characters\n        \"\"\"\n        if not re.match(r'^[a-zA-Z0-9_]+$', v):\n            raise ValueError('Username must contain only letters, numbers, and underscores')\n        return v.lower()\n    \n    @validator('password')\n    def validate_password_strength(cls, v: str) -> str:\n        \"\"\"\n        Validate password meets security requirements.\n        \n        Password must contain:\n        - At least one uppercase letter\n        - At least one lowercase letter  \n        - At least one digit\n        - At least one special character\n        \n        Args:\n            v: Password string to validate\n            \n        Returns:\n            str: Validated password\n            \n        Raises:\n            ValueError: If password doesn't meet requirements\n        \"\"\"\n        if not re.search(r'[A-Z]', v):\n            raise ValueError('Password must contain at least one uppercase letter')\n        if not re.search(r'[a-z]', v):\n            raise ValueError('Password must contain at least one lowercase letter')\n        if not re.search(r'\\d', v):\n            raise ValueError('Password must contain at least one digit')\n        if not re.search(r'[!@#$%^&*(),.?\":{}|<>]', v):\n            raise ValueError('Password must contain at least one special character')\n        return v\n    \n    @validator('full_name')\n    def validate_full_name(cls, v: str) -> str:\n        \"\"\"\n        Validate and sanitize full name.\n        \n        Args:\n            v: Full name string to validate\n            \n        Returns:\n            str: Sanitized full name\n            \n        Raises:\n            ValueError: If name contains invalid characters\n        \"\"\"\n        # Allow letters, spaces, hyphens, and apostrophes\n        if not re.match(r\"^[a-zA-Z\\s\\-']+$\", v):\n            raise ValueError('Full name can only contain letters, spaces, hyphens, and apostrophes')\n        return v.strip().title()\n\n\nclass UserLoginRequest(BaseModel):\n    \"\"\"\n    Schema for user login requests.\n    \n    Accepts either username or email for authentication along with password.\n    \"\"\"\n    username_or_email: str = Field(\n        ...,\n        min_length=3,\n        max_length=100,\n        description=\"Username or email address for login\"\n    )\n    password: str = Field(\n        ...,\n        min_length=1,\n        max_length=128,\n        description=\"User password\"\n    )\n    \n    @validator('username_or_email')\n    def validate_username_or_email(cls, v: str) -> str:\n        \"\"\"\n        Validate login identifier is either valid username or email format.\n        \n        Args:\n            v: Username or email string to validate\n            \n        Returns:\n            str: Validated identifier\n        \"\"\"\n        v = v.strip().lower()\n        \n        # Check if it's an email format\n        if '@' in v:\n            email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n            if not re.match(email_pattern, v):\n                raise ValueError('Invalid email format')\n        else:\n            # Validate as username\n            if not re.match(r'^[a-zA-Z0-9_]+$', v):\n                raise ValueError('Username must contain only letters, numbers, and underscores')\n        \n        return v\n\n\nclass UserProfileUpdateRequest(BaseModel):\n    \"\"\"\n    Schema for user profile update requests.\n    \n    All fields are optional to support partial updates.\n    \"\"\"\n    full_name: Optional[str] = Field(\n        None,\n        min_length=1,\n        max_length=100,\n        description=\"Updated full name\"\n    )\n    email: Optional[EmailStr] = Field(\n        None,\n        description=\"Updated email address\"\n    )\n    bio: Optional[str] = Field(\n        None,\n        max_length=500,\n        description=\"User biography or description\"\n    )\n    \n    @validator('full_name')\n    def validate_full_name(cls, v: Optional[str]) -> Optional[str]:\n        \"\"\"\n        Validate and sanitize full name if provided.\n        \n        Args:\n            v: Full name string to validate or None\n            \n        Returns:\n            Optional[str]: Sanitized full name or None\n            \n        Raises:\n            ValueError: If name contains invalid characters\n        \"\"\"\n        if v is None:\n            return v\n        \n        if not re.match(r\"^[a-zA-Z\\s\\-']+$\", v):\n            raise ValueError('Full name can only contain letters, spaces, hyphens, and apostrophes')\n        return v.strip().title()\n    \n    @validator('bio')\n    def validate_bio(cls, v: Optional[str]) -> Optional[str]:\n        \"\"\"\n        Validate and sanitize bio if provided.\n        \n        Args:\n            v: Bio string to validate or None\n            \n        Returns:\n            Optional[str]: Sanitized bio or None\n        \"\"\"\n        if v is None:\n            return v\n        \n        # Remove excessive whitespace and strip\n        bio = re.sub(r'\\s+', ' ', v.strip())\n        return bio if bio else None\n\n\nclass UserPasswordChangeRequest(BaseModel):\n    \"\"\"\n    Schema for password change requests.\n    \n    Requires current password for verification and new password meeting security requirements.\n    \"\"\"\n    current_password: str = Field(\n        ...,\n        description=\"Current password for verification\"\n    )\n    new_password: str = Field(\n        ...,\n        min_length=8,\n        max_length=128,\n        description=\"New password meeting security requirements\"\n    )\n    confirm_password: str = Field(\n        ...,\n        description=\"Confirmation of new password\"\n    )\n    \n    @validator('new_password')\n    def validate_new_password_strength(cls, v: str) -> str:\n        \"\"\"\n        Validate new password meets security requirements.\n        \n        Args:\n            v: New password string to validate\n            \n        Returns:\n            str: Validated password\n            \n        Raises:\n            ValueError: If password doesn't meet requirements\n        \"\"\"\n        if not re.search(r'[A-Z]', v):\n            raise ValueError('Password must contain at least one uppercase letter')\n        if not re.search(r'[a-z]', v):\n            raise ValueError('Password must contain at",
      "file_type": "source",
      "semantic_unit_id": "SU-006",
      "component_id": "COMP-006",
      "description": "Pydantic schemas for user registration, login, profile updates, and API response serialization"
    },
    {
      "file_path": "src/schemas/task.py",
      "content": "\"\"\"\nPydantic schemas for task management API\n\nDefines data models for task creation, updates, filtering, and API responses\nwith comprehensive validation rules and serialization logic.\n\nComponent ID: COMP-007\nSemantic Unit: SU-007\n\nAuthor: ASP Code Agent\n\"\"\"\n\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Optional, List, Dict, Any\nfrom uuid import UUID\n\nfrom pydantic import BaseModel, Field, validator, root_validator\n\n\nclass TaskStatus(str, Enum):\n    \"\"\"Enumeration of valid task statuses.\"\"\"\n    PENDING = \"pending\"\n    IN_PROGRESS = \"in_progress\"\n    COMPLETED = \"completed\"\n    CANCELLED = \"cancelled\"\n\n\nclass TaskPriority(str, Enum):\n    \"\"\"Enumeration of valid task priorities.\"\"\"\n    LOW = \"low\"\n    MEDIUM = \"medium\"\n    HIGH = \"high\"\n    URGENT = \"urgent\"\n\n\nclass TaskBase(BaseModel):\n    \"\"\"Base schema with common task fields.\"\"\"\n    \n    title: str = Field(\n        ...,\n        min_length=1,\n        max_length=200,\n        description=\"Task title\"\n    )\n    description: Optional[str] = Field(\n        None,\n        max_length=2000,\n        description=\"Detailed task description\"\n    )\n    priority: TaskPriority = Field(\n        TaskPriority.MEDIUM,\n        description=\"Task priority level\"\n    )\n    due_date: Optional[datetime] = Field(\n        None,\n        description=\"Task due date and time\"\n    )\n    tags: List[str] = Field(\n        default_factory=list,\n        description=\"List of task tags\"\n    )\n    \n    @validator('title')\n    def validate_title(cls, v: str) -> str:\n        \"\"\"Validate and clean task title.\"\"\"\n        if not v or not v.strip():\n            raise ValueError('Title cannot be empty or whitespace only')\n        return v.strip()\n    \n    @validator('description')\n    def validate_description(cls, v: Optional[str]) -> Optional[str]:\n        \"\"\"Validate and clean task description.\"\"\"\n        if v is not None:\n            v = v.strip()\n            if not v:\n                return None\n        return v\n    \n    @validator('due_date')\n    def validate_due_date(cls, v: Optional[datetime]) -> Optional[datetime]:\n        \"\"\"Validate due date is not in the past.\"\"\"\n        if v is not None and v < datetime.utcnow():\n            raise ValueError('Due date cannot be in the past')\n        return v\n    \n    @validator('tags')\n    def validate_tags(cls, v: List[str]) -> List[str]:\n        \"\"\"Validate and clean task tags.\"\"\"\n        if not v:\n            return []\n        \n        # Remove duplicates and empty tags\n        cleaned_tags = []\n        seen = set()\n        \n        for tag in v:\n            if not isinstance(tag, str):\n                raise ValueError('All tags must be strings')\n            \n            tag = tag.strip().lower()\n            if tag and len(tag) <= 50 and tag not in seen:\n                if not tag.replace('_', '').replace('-', '').isalnum():\n                    raise ValueError(f'Tag \"{tag}\" contains invalid characters')\n                cleaned_tags.append(tag)\n                seen.add(tag)\n        \n        if len(cleaned_tags) > 10:\n            raise ValueError('Maximum 10 tags allowed per task')\n        \n        return cleaned_tags\n\n\nclass TaskCreate(TaskBase):\n    \"\"\"Schema for creating a new task.\"\"\"\n    \n    assigned_to: Optional[UUID] = Field(\n        None,\n        description=\"UUID of user assigned to this task\"\n    )\n    \n    class Config:\n        \"\"\"Pydantic configuration.\"\"\"\n        schema_extra = {\n            \"example\": {\n                \"title\": \"Complete project documentation\",\n                \"description\": \"Write comprehensive documentation for the new API\",\n                \"priority\": \"high\",\n                \"due_date\": \"2024-12-31T23:59:59Z\",\n                \"tags\": [\"documentation\", \"api\", \"project\"],\n                \"assigned_to\": \"550e8400-e29b-41d4-a716-446655440000\"\n            }\n        }\n\n\nclass TaskUpdate(BaseModel):\n    \"\"\"Schema for updating an existing task.\"\"\"\n    \n    title: Optional[str] = Field(\n        None,\n        min_length=1,\n        max_length=200,\n        description=\"Updated task title\"\n    )\n    description: Optional[str] = Field(\n        None,\n        max_length=2000,\n        description=\"Updated task description\"\n    )\n    status: Optional[TaskStatus] = Field(\n        None,\n        description=\"Updated task status\"\n    )\n    priority: Optional[TaskPriority] = Field(\n        None,\n        description=\"Updated task priority\"\n    )\n    due_date: Optional[datetime] = Field(\n        None,\n        description=\"Updated due date\"\n    )\n    assigned_to: Optional[UUID] = Field(\n        None,\n        description=\"Updated assigned user UUID\"\n    )\n    tags: Optional[List[str]] = Field(\n        None,\n        description=\"Updated task tags\"\n    )\n    \n    @validator('title')\n    def validate_title(cls, v: Optional[str]) -> Optional[str]:\n        \"\"\"Validate and clean task title.\"\"\"\n        if v is not None:\n            if not v or not v.strip():\n                raise ValueError('Title cannot be empty or whitespace only')\n            return v.strip()\n        return v\n    \n    @validator('description')\n    def validate_description(cls, v: Optional[str]) -> Optional[str]:\n        \"\"\"Validate and clean task description.\"\"\"\n        if v is not None:\n            v = v.strip()\n            if not v:\n                return None\n        return v\n    \n    @validator('due_date')\n    def validate_due_date(cls, v: Optional[datetime]) -> Optional[datetime]:\n        \"\"\"Validate due date is not in the past.\"\"\"\n        if v is not None and v < datetime.utcnow():\n            raise ValueError('Due date cannot be in the past')\n        return v\n    \n    @validator('tags')\n    def validate_tags(cls, v: Optional[List[str]]) -> Optional[List[str]]:\n        \"\"\"Validate and clean task tags.\"\"\"\n        if v is None:\n            return None\n        \n        # Remove duplicates and empty tags\n        cleaned_tags = []\n        seen = set()\n        \n        for tag in v:\n            if not isinstance(tag, str):\n                raise ValueError('All tags must be strings')\n            \n            tag = tag.strip().lower()\n            if tag and len(tag) <= 50 and tag not in seen:\n                if not tag.replace('_', '').replace('-', '').isalnum():\n                    raise ValueError(f'Tag \"{tag}\" contains invalid characters')\n                cleaned_tags.append(tag)\n                seen.add(tag)\n        \n        if len(cleaned_tags) > 10:\n            raise ValueError('Maximum 10 tags allowed per task')\n        \n        return cleaned_tags\n    \n    @root_validator\n    def validate_at_least_one_field(cls, values: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Ensure at least one field is provided for update.\"\"\"\n        if not any(v is not None for v in values.values()):\n            raise ValueError('At least one field must be provided for update')\n        return values\n    \n    class Config:\n        \"\"\"Pydantic configuration.\"\"\"\n        schema_extra = {\n            \"example\": {\n                \"status\": \"in_progress\",\n                \"priority\": \"urgent\",\n                \"due_date\": \"2024-12-25T18:00:00Z\"\n            }\n        }\n\n\nclass TaskFilter(BaseModel):\n    \"\"\"Schema for filtering tasks in list queries.\"\"\"\n    \n    status: Optional[TaskStatus] = Field(\n        None,\n        description=\"Filter by task status\"\n    )\n    priority: Optional[TaskPriority] = Field(\n        None,\n        description=\"Filter by task priority\"\n    )\n    assigned_to: Optional[UUID] = Field(\n        None,\n        description=\"Filter by assigne",
      "file_type": "source",
      "semantic_unit_id": "SU-007",
      "component_id": "COMP-007",
      "description": "Pydantic schemas for task creation, updates, filtering, and API response serialization with validation"
    },
    {
      "file_path": "src/utils/jwt_utils.py",
      "content": "\"\"\"\nJWT token utilities for authentication and authorization.\n\nProvides functions for generating, validating, decoding, and refreshing JWT tokens\nusing the python-jose library with RS256 algorithm.\n\nComponent ID: COMP-008\nSemantic Unit: SU-008\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport logging\nfrom datetime import datetime, timedelta, timezone\nfrom typing import Any, Dict, Optional, Union\n\nfrom jose import JWTError, jwt\nfrom jose.constants import ALGORITHMS\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass JWTConfig:\n    \"\"\"Configuration class for JWT token settings.\"\"\"\n    \n    def __init__(\n        self,\n        secret_key: str,\n        algorithm: str = ALGORITHMS.HS256,\n        access_token_expire_minutes: int = 30,\n        refresh_token_expire_days: int = 7,\n        issuer: str = \"hello-world-api\",\n        audience: str = \"hello-world-users\"\n    ):\n        \"\"\"\n        Initialize JWT configuration.\n        \n        Args:\n            secret_key: Secret key for signing tokens\n            algorithm: JWT signing algorithm (default: HS256)\n            access_token_expire_minutes: Access token expiration in minutes\n            refresh_token_expire_days: Refresh token expiration in days\n            issuer: Token issuer identifier\n            audience: Token audience identifier\n        \"\"\"\n        self.secret_key = secret_key\n        self.algorithm = algorithm\n        self.access_token_expire_minutes = access_token_expire_minutes\n        self.refresh_token_expire_days = refresh_token_expire_days\n        self.issuer = issuer\n        self.audience = audience\n\n\nclass JWTTokenError(Exception):\n    \"\"\"Base exception for JWT token operations.\"\"\"\n    pass\n\n\nclass JWTTokenExpiredError(JWTTokenError):\n    \"\"\"Exception raised when JWT token has expired.\"\"\"\n    pass\n\n\nclass JWTTokenInvalidError(JWTTokenError):\n    \"\"\"Exception raised when JWT token is invalid.\"\"\"\n    pass\n\n\nclass JWTUtils:\n    \"\"\"Utility class for JWT token operations.\"\"\"\n    \n    def __init__(self, config: JWTConfig):\n        \"\"\"\n        Initialize JWT utilities with configuration.\n        \n        Args:\n            config: JWT configuration object\n        \"\"\"\n        self.config = config\n    \n    def generate_access_token(\n        self,\n        subject: str,\n        additional_claims: Optional[Dict[str, Any]] = None\n    ) -> str:\n        \"\"\"\n        Generate a new access token.\n        \n        Args:\n            subject: Token subject (typically user ID)\n            additional_claims: Optional additional claims to include\n            \n        Returns:\n            str: Encoded JWT access token\n            \n        Raises:\n            JWTTokenError: If token generation fails\n            \n        Example:\n            >>> jwt_utils = JWTUtils(config)\n            >>> token = jwt_utils.generate_access_token(\"user123\")\n            >>> isinstance(token, str)\n            True\n        \"\"\"\n        try:\n            now = datetime.now(timezone.utc)\n            expire = now + timedelta(minutes=self.config.access_token_expire_minutes)\n            \n            payload = {\n                \"sub\": subject,\n                \"iat\": now,\n                \"exp\": expire,\n                \"iss\": self.config.issuer,\n                \"aud\": self.config.audience,\n                \"type\": \"access\"\n            }\n            \n            if additional_claims:\n                payload.update(additional_claims)\n            \n            token = jwt.encode(\n                payload,\n                self.config.secret_key,\n                algorithm=self.config.algorithm\n            )\n            \n            logger.info(f\"Generated access token for subject: {subject}\")\n            return token\n            \n        except Exception as e:\n            logger.error(f\"Failed to generate access token: {str(e)}\")\n            raise JWTTokenError(f\"Token generation failed: {str(e)}\") from e\n    \n    def generate_refresh_token(\n        self,\n        subject: str,\n        additional_claims: Optional[Dict[str, Any]] = None\n    ) -> str:\n        \"\"\"\n        Generate a new refresh token.\n        \n        Args:\n            subject: Token subject (typically user ID)\n            additional_claims: Optional additional claims to include\n            \n        Returns:\n            str: Encoded JWT refresh token\n            \n        Raises:\n            JWTTokenError: If token generation fails\n            \n        Example:\n            >>> jwt_utils = JWTUtils(config)\n            >>> token = jwt_utils.generate_refresh_token(\"user123\")\n            >>> isinstance(token, str)\n            True\n        \"\"\"\n        try:\n            now = datetime.now(timezone.utc)\n            expire = now + timedelta(days=self.config.refresh_token_expire_days)\n            \n            payload = {\n                \"sub\": subject,\n                \"iat\": now,\n                \"exp\": expire,\n                \"iss\": self.config.issuer,\n                \"aud\": self.config.audience,\n                \"type\": \"refresh\"\n            }\n            \n            if additional_claims:\n                payload.update(additional_claims)\n            \n            token = jwt.encode(\n                payload,\n                self.config.secret_key,\n                algorithm=self.config.algorithm\n            )\n            \n            logger.info(f\"Generated refresh token for subject: {subject}\")\n            return token\n            \n        except Exception as e:\n            logger.error(f\"Failed to generate refresh token: {str(e)}\")\n            raise JWTTokenError(f\"Token generation failed: {str(e)}\") from e\n    \n    def decode_token(\n        self,\n        token: str,\n        verify_expiration: bool = True\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Decode and validate a JWT token.\n        \n        Args:\n            token: JWT token to decode\n            verify_expiration: Whether to verify token expiration\n            \n        Returns:\n            Dict[str, Any]: Decoded token payload\n            \n        Raises:\n            JWTTokenExpiredError: If token has expired\n            JWTTokenInvalidError: If token is invalid\n            \n        Example:\n            >>> jwt_utils = JWTUtils(config)\n            >>> payload = jwt_utils.decode_token(token)\n            >>> \"sub\" in payload\n            True\n        \"\"\"\n        try:\n            options = {\n                \"verify_exp\": verify_expiration,\n                \"verify_aud\": True,\n                \"verify_iss\": True\n            }\n            \n            payload = jwt.decode(\n                token,\n                self.config.secret_key,\n                algorithms=[self.config.algorithm],\n                audience=self.config.audience,\n                issuer=self.config.issuer,\n                options=options\n            )\n            \n            logger.debug(f\"Successfully decoded token for subject: {payload.get('sub')}\")\n            return payload\n            \n        except jwt.ExpiredSignatureError as e:\n            logger.warning(f\"Token expired: {str(e)}\")\n            raise JWTTokenExpiredError(\"Token has expired\") from e\n        except JWTError as e:\n            logger.warning(f\"Invalid token: {str(e)}\")\n            raise JWTTokenInvalidError(f\"Invalid token: {str(e)}\") from e\n        except Exception as e:\n            logger.error(f\"Token decode error: {str(e)}\")\n            raise JWTTokenInvalidError(f\"Token decode failed: {str(e)}\") from e\n    \n    def validate_token(self, token: str) -> bool:\n        \"\"\"\n        Validate a JWT token without decoding.\n        \n        Args:\n            token: JWT token to validate\n            \n        Returns:\n            bool: True if token is valid, False otherwise\n            \n        Example:\n            >>> jwt_utils = JWTUtils(config)\n            >>> jwt_utils.validate_token(valid_token)\n            True\n            >>> jwt_utils.validate_token(\"invalid_token\")\n            False\n        \"\"\"\n        try:\n            self.decode_token(token)\n            return True\n        except (JWTTokenExpiredError, JWTTokenInvalidError):\n            return False\n    \n    def get_token_subject(self, token: str",
      "file_type": "source",
      "semantic_unit_id": "SU-008",
      "component_id": "COMP-008",
      "description": "JWT token generation, validation, decoding, and refresh token management using python-jose library"
    },
    {
      "file_path": "src/utils/password.py",
      "content": "\"\"\"\nPassword utilities for secure password hashing, verification, and strength validation.\n\nThis module provides secure password handling using bcrypt with proper salt generation\nand comprehensive password strength validation.\n\nComponent ID: COMP-009\nSemantic Unit: SU-009\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport re\nimport secrets\nfrom typing import Dict, List, Optional\n\nimport bcrypt\n\n\nclass PasswordStrengthError(Exception):\n    \"\"\"Raised when password does not meet strength requirements.\"\"\"\n    pass\n\n\nclass PasswordHashError(Exception):\n    \"\"\"Raised when password hashing fails.\"\"\"\n    pass\n\n\nclass PasswordVerificationError(Exception):\n    \"\"\"Raised when password verification fails.\"\"\"\n    pass\n\n\ndef hash_password(password: str, rounds: int = 12) -> str:\n    \"\"\"\n    Hash a password using bcrypt with secure salt generation.\n    \n    Args:\n        password: Plain text password to hash\n        rounds: Number of bcrypt rounds (default 12, min 10, max 15)\n        \n    Returns:\n        str: Base64 encoded bcrypt hash\n        \n    Raises:\n        PasswordHashError: If hashing fails or invalid parameters\n        ValueError: If password is empty or rounds out of range\n        \n    Example:\n        >>> hashed = hash_password(\"mypassword123\")\n        >>> len(hashed) > 50\n        True\n    \"\"\"\n    if not password:\n        raise ValueError(\"Password cannot be empty\")\n        \n    if not isinstance(password, str):\n        raise ValueError(\"Password must be a string\")\n        \n    if not (10 <= rounds <= 15):\n        raise ValueError(\"Rounds must be between 10 and 15\")\n        \n    try:\n        # Generate salt and hash password\n        salt = bcrypt.gensalt(rounds=rounds)\n        hashed = bcrypt.hashpw(password.encode('utf-8'), salt)\n        return hashed.decode('utf-8')\n    except Exception as e:\n        raise PasswordHashError(f\"Failed to hash password: {str(e)}\") from e\n\n\ndef verify_password(password: str, hashed_password: str) -> bool:\n    \"\"\"\n    Verify a password against its bcrypt hash.\n    \n    Args:\n        password: Plain text password to verify\n        hashed_password: Base64 encoded bcrypt hash\n        \n    Returns:\n        bool: True if password matches hash, False otherwise\n        \n    Raises:\n        PasswordVerificationError: If verification process fails\n        ValueError: If parameters are invalid\n        \n    Example:\n        >>> hashed = hash_password(\"mypassword123\")\n        >>> verify_password(\"mypassword123\", hashed)\n        True\n        >>> verify_password(\"wrongpassword\", hashed)\n        False\n    \"\"\"\n    if not password:\n        raise ValueError(\"Password cannot be empty\")\n        \n    if not hashed_password:\n        raise ValueError(\"Hashed password cannot be empty\")\n        \n    if not isinstance(password, str) or not isinstance(hashed_password, str):\n        raise ValueError(\"Password and hashed password must be strings\")\n        \n    try:\n        return bcrypt.checkpw(\n            password.encode('utf-8'),\n            hashed_password.encode('utf-8')\n        )\n    except Exception as e:\n        raise PasswordVerificationError(f\"Failed to verify password: {str(e)}\") from e\n\n\ndef validate_password_strength(password: str, min_length: int = 8) -> Dict[str, bool]:\n    \"\"\"\n    Validate password strength against security requirements.\n    \n    Args:\n        password: Password to validate\n        min_length: Minimum required length (default 8)\n        \n    Returns:\n        Dict[str, bool]: Dictionary with validation results:\n            - length: True if meets minimum length\n            - uppercase: True if contains uppercase letter\n            - lowercase: True if contains lowercase letter\n            - digit: True if contains digit\n            - special: True if contains special character\n            - no_whitespace: True if contains no whitespace\n            - valid: True if all requirements met\n            \n    Raises:\n        ValueError: If password is None or min_length is invalid\n        \n    Example:\n        >>> result = validate_password_strength(\"MyPass123!\")\n        >>> result['valid']\n        True\n        >>> result['uppercase']\n        True\n    \"\"\"\n    if password is None:\n        raise ValueError(\"Password cannot be None\")\n        \n    if not isinstance(password, str):\n        raise ValueError(\"Password must be a string\")\n        \n    if min_length < 1:\n        raise ValueError(\"Minimum length must be at least 1\")\n        \n    # Check individual requirements\n    checks = {\n        'length': len(password) >= min_length,\n        'uppercase': bool(re.search(r'[A-Z]', password)),\n        'lowercase': bool(re.search(r'[a-z]', password)),\n        'digit': bool(re.search(r'\\d', password)),\n        'special': bool(re.search(r'[!@#$%^&*(),.?\":{}|<>]', password)),\n        'no_whitespace': not bool(re.search(r'\\s', password))\n    }\n    \n    # Overall validity\n    checks['valid'] = all(checks.values())\n    \n    return checks\n\n\ndef check_password_strength(password: str, min_length: int = 8) -> bool:\n    \"\"\"\n    Check if password meets all strength requirements.\n    \n    Args:\n        password: Password to check\n        min_length: Minimum required length (default 8)\n        \n    Returns:\n        bool: True if password meets all requirements\n        \n    Raises:\n        PasswordStrengthError: If password fails strength requirements\n        ValueError: If parameters are invalid\n        \n    Example:\n        >>> check_password_strength(\"MyPass123!\")\n        True\n        >>> check_password_strength(\"weak\")\n        False\n    \"\"\"\n    validation_result = validate_password_strength(password, min_length)\n    \n    if not validation_result['valid']:\n        failed_checks = [\n            check for check, passed in validation_result.items()\n            if check != 'valid' and not passed\n        ]\n        raise PasswordStrengthError(\n            f\"Password fails strength requirements: {', '.join(failed_checks)}\"\n        )\n    \n    return True\n\n\ndef get_password_strength_requirements(min_length: int = 8) -> List[str]:\n    \"\"\"\n    Get list of password strength requirements.\n    \n    Args:\n        min_length: Minimum required length (default 8)\n        \n    Returns:\n        List[str]: List of requirement descriptions\n        \n    Example:\n        >>> requirements = get_password_strength_requirements()\n        >>> len(requirements)\n        6\n    \"\"\"\n    return [\n        f\"At least {min_length} characters long\",\n        \"Contains at least one uppercase letter (A-Z)\",\n        \"Contains at least one lowercase letter (a-z)\",\n        \"Contains at least one digit (0-9)\",\n        \"Contains at least one special character (!@#$%^&*(),.?\\\":{}|<>)\",\n        \"Contains no whitespace characters\"\n    ]\n\n\ndef generate_secure_password(length: int = 16) -> str:\n    \"\"\"\n    Generate a cryptographically secure random password.\n    \n    Args:\n        length: Length of password to generate (default 16, min 8, max 128)\n        \n    Returns:\n        str: Randomly generated password meeting strength requirements\n        \n    Raises:\n        ValueError: If length is out of valid range\n        \n    Example:\n        >>> password = generate_secure_password(12)\n        >>> len(password)\n        12\n        >>> check_password_strength(password)\n        True\n    \"\"\"\n    if not (8 <= length <= 128):\n        raise ValueError(\"Password length must be between 8 and 128 characters\")\n    \n    # Character sets\n    uppercase = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase = \"abcdefghijklmnopqrstuvwxyz\"\n    digits = \"0123456789\"\n    special = \"!@#$%^&*(),.?\\\":{}|<>\"\n    all_chars = uppercase + lowercase + digits + special\n    \n    # Ensure at least one character from each required set\n    passwor",
      "file_type": "source",
      "semantic_unit_id": "SU-009",
      "component_id": "COMP-009",
      "description": "Password hashing, verification, and strength validation using bcrypt with secure salt generation"
    },
    {
      "file_path": "src/database/connection.py",
      "content": "\"\"\"\nSQLAlchemy database connection setup, session management, and base model configuration.\n\nThis module provides database connection management, session handling, and base model\nconfiguration for SQLAlchemy ORM operations.\n\nComponent ID: COMP-010\nSemantic Unit: SU-010\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport logging\nimport os\nfrom contextlib import contextmanager\nfrom typing import Generator, Optional\n\nfrom sqlalchemy import create_engine, event, Engine\nfrom sqlalchemy.exc import SQLAlchemyError\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom sqlalchemy.pool import StaticPool\n\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Base class for all database models\nBase = declarative_base()\n\n# Global database engine and session factory\n_engine: Optional[Engine] = None\n_session_factory: Optional[sessionmaker] = None\n\n\nclass DatabaseConfig:\n    \"\"\"Database configuration settings.\"\"\"\n    \n    def __init__(self) -> None:\n        \"\"\"Initialize database configuration from environment variables.\"\"\"\n        self.database_url = os.getenv(\n            \"DATABASE_URL\", \n            \"sqlite:///./hello_world.db\"\n        )\n        self.echo_sql = os.getenv(\"DATABASE_ECHO\", \"false\").lower() == \"true\"\n        self.pool_size = int(os.getenv(\"DATABASE_POOL_SIZE\", \"5\"))\n        self.max_overflow = int(os.getenv(\"DATABASE_MAX_OVERFLOW\", \"10\"))\n        self.pool_timeout = int(os.getenv(\"DATABASE_POOL_TIMEOUT\", \"30\"))\n        self.pool_recycle = int(os.getenv(\"DATABASE_POOL_RECYCLE\", \"3600\"))\n\n\ndef create_database_engine(config: Optional[DatabaseConfig] = None) -> Engine:\n    \"\"\"\n    Create and configure SQLAlchemy database engine.\n    \n    Args:\n        config: Database configuration object. If None, creates default config.\n        \n    Returns:\n        Engine: Configured SQLAlchemy engine\n        \n    Raises:\n        SQLAlchemyError: If engine creation fails\n        \n    Example:\n        >>> engine = create_database_engine()\n        >>> engine.url.database\n        './hello_world.db'\n    \"\"\"\n    if config is None:\n        config = DatabaseConfig()\n    \n    try:\n        # Configure engine parameters based on database type\n        engine_kwargs = {\n            \"echo\": config.echo_sql,\n            \"future\": True,  # Use SQLAlchemy 2.0 style\n        }\n        \n        # SQLite-specific configuration\n        if config.database_url.startswith(\"sqlite\"):\n            engine_kwargs.update({\n                \"poolclass\": StaticPool,\n                \"connect_args\": {\n                    \"check_same_thread\": False,\n                    \"timeout\": 20,\n                }\n            })\n        else:\n            # PostgreSQL/MySQL configuration\n            engine_kwargs.update({\n                \"pool_size\": config.pool_size,\n                \"max_overflow\": config.max_overflow,\n                \"pool_timeout\": config.pool_timeout,\n                \"pool_recycle\": config.pool_recycle,\n                \"pool_pre_ping\": True,  # Verify connections before use\n            })\n        \n        engine = create_engine(config.database_url, **engine_kwargs)\n        \n        # Add connection event listeners\n        _setup_engine_events(engine)\n        \n        logger.info(f\"Database engine created successfully: {config.database_url}\")\n        return engine\n        \n    except Exception as e:\n        logger.error(f\"Failed to create database engine: {e}\")\n        raise SQLAlchemyError(f\"Database engine creation failed: {e}\") from e\n\n\ndef _setup_engine_events(engine: Engine) -> None:\n    \"\"\"\n    Set up database engine event listeners for connection management.\n    \n    Args:\n        engine: SQLAlchemy engine to configure\n    \"\"\"\n    @event.listens_for(engine, \"connect\")\n    def set_sqlite_pragma(dbapi_connection, connection_record):\n        \"\"\"Configure SQLite connection settings.\"\"\"\n        if engine.url.drivername == \"sqlite\":\n            cursor = dbapi_connection.cursor()\n            # Enable foreign key constraints\n            cursor.execute(\"PRAGMA foreign_keys=ON\")\n            # Set journal mode for better concurrency\n            cursor.execute(\"PRAGMA journal_mode=WAL\")\n            # Set synchronous mode for better performance\n            cursor.execute(\"PRAGMA synchronous=NORMAL\")\n            cursor.close()\n    \n    @event.listens_for(engine, \"engine_connect\")\n    def log_connection(conn, branch):\n        \"\"\"Log database connections.\"\"\"\n        logger.debug(\"Database connection established\")\n\n\ndef initialize_database(config: Optional[DatabaseConfig] = None) -> None:\n    \"\"\"\n    Initialize the global database engine and session factory.\n    \n    Args:\n        config: Database configuration object. If None, creates default config.\n        \n    Raises:\n        SQLAlchemyError: If database initialization fails\n        RuntimeError: If database is already initialized\n        \n    Example:\n        >>> initialize_database()\n        >>> get_engine() is not None\n        True\n    \"\"\"\n    global _engine, _session_factory\n    \n    if _engine is not None:\n        raise RuntimeError(\"Database already initialized. Call close_database() first.\")\n    \n    try:\n        _engine = create_database_engine(config)\n        _session_factory = sessionmaker(\n            bind=_engine,\n            autocommit=False,\n            autoflush=False,\n            expire_on_commit=False,\n        )\n        \n        logger.info(\"Database initialized successfully\")\n        \n    except Exception as e:\n        logger.error(f\"Database initialization failed: {e}\")\n        _engine = None\n        _session_factory = None\n        raise\n\n\ndef get_engine() -> Engine:\n    \"\"\"\n    Get the global database engine.\n    \n    Returns:\n        Engine: The global SQLAlchemy engine\n        \n    Raises:\n        RuntimeError: If database is not initialized\n        \n    Example:\n        >>> initialize_database()\n        >>> engine = get_engine()\n        >>> engine.url is not None\n        True\n    \"\"\"\n    if _engine is None:\n        raise RuntimeError(\"Database not initialized. Call initialize_database() first.\")\n    return _engine\n\n\ndef get_session_factory() -> sessionmaker:\n    \"\"\"\n    Get the global session factory.\n    \n    Returns:\n        sessionmaker: The global SQLAlchemy session factory\n        \n    Raises:\n        RuntimeError: If database is not initialized\n        \n    Example:\n        >>> initialize_database()\n        >>> factory = get_session_factory()\n        >>> session = factory()\n        >>> isinstance(session, Session)\n        True\n    \"\"\"\n    if _session_factory is None:\n        raise RuntimeError(\"Database not initialized. Call initialize_database() first.\")\n    return _session_factory\n\n\ndef create_session() -> Session:\n    \"\"\"\n    Create a new database session.\n    \n    Returns:\n        Session: New SQLAlchemy session\n        \n    Raises:\n        RuntimeError: If database is not initialized\n        SQLAlchemyError: If session creation fails\n        \n    Example:\n        >>> initialize_database()\n        >>> session = create_session()\n        >>> session.is_active\n        True\n        >>> session.close()\n    \"\"\"\n    try:\n        session_factory = get_session_factory()\n        session = session_factory()\n        logger.debug(\"Database session created\")\n        return session\n        \n    except Exception as e:\n        logger.error(f\"Failed to create database session: {e}\")\n        raise SQLAlchemyError(f\"Session creation failed: {e}\") from e\n\n\n@contextmanager\ndef get_db_session() -> Generator[Session, None, None]:\n    \"\"\"\n    Context manager for database sessions with automatic cleanup.\n    \n    Yields:\n        Session: Database session that will be automatically closed\n        \n    Raises:\n        RuntimeError: If database is not initialized\n        SQLAlchemyError: If session operations fail\n        \n    Example:\n        >>> initialize_database()\n        >>> with get_db_session() as session:\n        ...     # Use session for database operations\n        ...     result = session.execute(\"SELECT 1\")\n        ...",
      "file_type": "source",
      "semantic_unit_id": "SU-010",
      "component_id": "COMP-010",
      "description": "SQLAlchemy database connection setup, session management, and base model configuration"
    },
    {
      "file_path": "src/database/migrations/001_initial_schema.py",
      "content": "\"\"\"\nInitial database schema migration for Hello World API\n\nCreates the foundational database tables for users and tasks with proper\nindexes, constraints, and relationships.\n\nRevision ID: 001\nRevises: \nCreate Date: 2025-11-21 03:48:25.246374\n\nComponent ID: COMP-011\nSemantic Unit: SU-011\n\nAuthor: ASP Code Agent\n\"\"\"\nfrom typing import Sequence, Union\n\nfrom alembic import op\nimport sqlalchemy as sa\nfrom sqlalchemy.dialects import postgresql\n\n# revision identifiers, used by Alembic.\nrevision: str = '001'\ndown_revision: Union[str, None] = None\nbranch_labels: Union[str, Sequence[str], None] = None\ndepends_on: Union[str, Sequence[str], None] = None\n\n\ndef upgrade() -> None:\n    \"\"\"\n    Create initial database schema with users and tasks tables.\n    \n    This migration creates:\n    - users table with authentication and profile information\n    - tasks table with task management functionality\n    - Proper indexes for query performance\n    - Foreign key constraints for data integrity\n    - Check constraints for data validation\n    \"\"\"\n    # Create users table\n    op.create_table(\n        'users',\n        sa.Column(\n            'id',\n            sa.Integer(),\n            primary_key=True,\n            autoincrement=True,\n            nullable=False,\n            comment='Primary key for users table'\n        ),\n        sa.Column(\n            'email',\n            sa.String(255),\n            nullable=False,\n            comment='User email address, must be unique'\n        ),\n        sa.Column(\n            'username',\n            sa.String(50),\n            nullable=False,\n            comment='User display name, must be unique'\n        ),\n        sa.Column(\n            'password_hash',\n            sa.String(255),\n            nullable=False,\n            comment='Bcrypt hashed password'\n        ),\n        sa.Column(\n            'first_name',\n            sa.String(100),\n            nullable=True,\n            comment='User first name'\n        ),\n        sa.Column(\n            'last_name',\n            sa.String(100),\n            nullable=True,\n            comment='User last name'\n        ),\n        sa.Column(\n            'is_active',\n            sa.Boolean(),\n            nullable=False,\n            default=True,\n            comment='Whether user account is active'\n        ),\n        sa.Column(\n            'is_verified',\n            sa.Boolean(),\n            nullable=False,\n            default=False,\n            comment='Whether user email is verified'\n        ),\n        sa.Column(\n            'created_at',\n            sa.DateTime(timezone=True),\n            nullable=False,\n            server_default=sa.text('CURRENT_TIMESTAMP'),\n            comment='Timestamp when user was created'\n        ),\n        sa.Column(\n            'updated_at',\n            sa.DateTime(timezone=True),\n            nullable=False,\n            server_default=sa.text('CURRENT_TIMESTAMP'),\n            comment='Timestamp when user was last updated'\n        ),\n        sa.Column(\n            'last_login_at',\n            sa.DateTime(timezone=True),\n            nullable=True,\n            comment='Timestamp of last successful login'\n        ),\n        comment='User accounts and authentication information'\n    )\n\n    # Create tasks table\n    op.create_table(\n        'tasks',\n        sa.Column(\n            'id',\n            sa.Integer(),\n            primary_key=True,\n            autoincrement=True,\n            nullable=False,\n            comment='Primary key for tasks table'\n        ),\n        sa.Column(\n            'user_id',\n            sa.Integer(),\n            sa.ForeignKey('users.id', ondelete='CASCADE'),\n            nullable=False,\n            comment='Foreign key reference to users table'\n        ),\n        sa.Column(\n            'title',\n            sa.String(200),\n            nullable=False,\n            comment='Task title or summary'\n        ),\n        sa.Column(\n            'description',\n            sa.Text(),\n            nullable=True,\n            comment='Detailed task description'\n        ),\n        sa.Column(\n            'status',\n            sa.Enum('pending', 'in_progress', 'completed', 'cancelled', name='task_status'),\n            nullable=False,\n            default='pending',\n            comment='Current status of the task'\n        ),\n        sa.Column(\n            'priority',\n            sa.Enum('low', 'medium', 'high', 'urgent', name='task_priority'),\n            nullable=False,\n            default='medium',\n            comment='Task priority level'\n        ),\n        sa.Column(\n            'due_date',\n            sa.DateTime(timezone=True),\n            nullable=True,\n            comment='Optional due date for task completion'\n        ),\n        sa.Column(\n            'completed_at',\n            sa.DateTime(timezone=True),\n            nullable=True,\n            comment='Timestamp when task was marked as completed'\n        ),\n        sa.Column(\n            'created_at',\n            sa.DateTime(timezone=True),\n            nullable=False,\n            server_default=sa.text('CURRENT_TIMESTAMP'),\n            comment='Timestamp when task was created'\n        ),\n        sa.Column(\n            'updated_at',\n            sa.DateTime(timezone=True),\n            nullable=False,\n            server_default=sa.text('CURRENT_TIMESTAMP'),\n            comment='Timestamp when task was last updated'\n        ),\n        comment='User tasks and todo items'\n    )\n\n    # Create unique constraints\n    op.create_unique_constraint('uq_users_email', 'users', ['email'])\n    op.create_unique_constraint('uq_users_username', 'users', ['username'])\n\n    # Create indexes for performance optimization\n    \n    # Users table indexes\n    op.create_index(\n        'ix_users_email',\n        'users',\n        ['email'],\n        unique=True,\n        postgresql_using='btree'\n    )\n    op.create_index(\n        'ix_users_username',\n        'users',\n        ['username'],\n        unique=True,\n        postgresql_using='btree'\n    )\n    op.create_index(\n        'ix_users_is_active',\n        'users',\n        ['is_active'],\n        postgresql_using='btree'\n    )\n    op.create_index(\n        'ix_users_created_at',\n        'users',\n        ['created_at'],\n        postgresql_using='btree'\n    )\n    op.create_index(\n        'ix_users_last_login_at',\n        'users',\n        ['last_login_at'],\n        postgresql_using='btree'\n    )\n\n    # Tasks table indexes\n    op.create_index(\n        'ix_tasks_user_id',\n        'tasks',\n        ['user_id'],\n        postgresql_using='btree'\n    )\n    op.create_index(\n        'ix_tasks_status',\n        'tasks',\n        ['status'],\n        postgresql_using='btree'\n    )\n    op.create_index(\n        'ix_tasks_priority',\n        'tasks',\n        ['priority'],\n        postgresql_using='btree'\n    )\n    op.create_index(\n        'ix_tasks_due_date',\n        'tasks',\n        ['due_date'],\n        postgresql_using='btree'\n    )\n    op.create_index(\n        'ix_tasks_created_at',\n        'tasks',\n        ['created_at'],\n        postgresql_using='btree'\n    )\n    op.create_index(\n        'ix_tasks_completed_at',\n        'tasks',\n        ['completed_at'],\n        postgresql_using='btree'\n    )\n\n    # Composite indexes for common query patterns\n    op.create_index(\n        'ix_tasks_user_status',\n        'tasks',\n        ['user_id', 'status'],\n        postgresql_using='btree'\n    )\n    op.create_index(\n        'ix_tasks_user_priority',\n        'tasks',\n        ['user_id', 'priority'],\n        postgresql_using='btree'\n    )",
      "file_type": "schema",
      "semantic_unit_id": "SU-011",
      "component_id": "COMP-011",
      "description": "Alembic migration script for creating initial users and tasks tables with indexes and constraints"
    },
    {
      "file_path": "src/middleware/auth.py",
      "content": "\"\"\"\nFastAPI Authentication Middleware\n\nJWT token validation middleware that extracts and validates JWT tokens from requests,\ninjects user context into request state, and handles authentication errors.\n\nComponent ID: COMP-012\nSemantic Unit: SU-012\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport logging\nfrom typing import Optional, Callable, Any\nfrom datetime import datetime\n\nfrom fastapi import Request, Response, HTTPException, status\nfrom fastapi.responses import JSONResponse\nfrom starlette.middleware.base import BaseHTTPMiddleware\nfrom starlette.types import ASGIApp\n\nfrom src.utils.jwt_utils import JWTUtils, JWTError, TokenExpiredError, InvalidTokenError\nfrom src.models.user import User\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass AuthenticationError(Exception):\n    \"\"\"Custom exception for authentication failures.\"\"\"\n    \n    def __init__(self, message: str, status_code: int = status.HTTP_401_UNAUTHORIZED):\n        self.message = message\n        self.status_code = status_code\n        super().__init__(self.message)\n\n\nclass AuthMiddleware(BaseHTTPMiddleware):\n    \"\"\"\n    JWT Authentication Middleware for FastAPI applications.\n    \n    This middleware validates JWT tokens from Authorization headers,\n    extracts user information, and injects user context into request state.\n    Handles token validation errors and provides proper HTTP responses.\n    \"\"\"\n    \n    def __init__(\n        self,\n        app: ASGIApp,\n        jwt_utils: JWTUtils,\n        excluded_paths: Optional[list[str]] = None,\n        require_auth: bool = True\n    ):\n        \"\"\"\n        Initialize authentication middleware.\n        \n        Args:\n            app: ASGI application instance\n            jwt_utils: JWT utility instance for token operations\n            excluded_paths: List of paths that don't require authentication\n            require_auth: Whether authentication is required by default\n        \"\"\"\n        super().__init__(app)\n        self.jwt_utils = jwt_utils\n        self.excluded_paths = excluded_paths or [\"/health\", \"/docs\", \"/redoc\", \"/openapi.json\"]\n        self.require_auth = require_auth\n        \n        logger.info(\n            f\"AuthMiddleware initialized with {len(self.excluded_paths)} excluded paths\"\n        )\n    \n    async def dispatch(self, request: Request, call_next: Callable) -> Response:\n        \"\"\"\n        Process incoming request and validate authentication.\n        \n        Args:\n            request: Incoming HTTP request\n            call_next: Next middleware/handler in chain\n            \n        Returns:\n            Response: HTTP response from downstream handler or error response\n        \"\"\"\n        try:\n            # Check if path is excluded from authentication\n            if self._is_path_excluded(request.url.path):\n                logger.debug(f\"Skipping auth for excluded path: {request.url.path}\")\n                return await call_next(request)\n            \n            # Extract and validate JWT token\n            token = self._extract_token(request)\n            \n            if not token:\n                if self.require_auth:\n                    return self._create_error_response(\n                        \"Missing authentication token\",\n                        status.HTTP_401_UNAUTHORIZED,\n                        \"MISSING_TOKEN\"\n                    )\n                else:\n                    # Allow request without token if auth not required\n                    request.state.user = None\n                    request.state.authenticated = False\n                    return await call_next(request)\n            \n            # Validate token and extract user information\n            user = await self._validate_token_and_get_user(token)\n            \n            # Inject user context into request state\n            request.state.user = user\n            request.state.authenticated = True\n            request.state.token = token\n            \n            logger.debug(f\"Authenticated user {user.id} for path: {request.url.path}\")\n            \n            # Continue to next handler\n            response = await call_next(request)\n            \n            # Add authentication headers to response\n            self._add_auth_headers(response, user)\n            \n            return response\n            \n        except AuthenticationError as e:\n            logger.warning(f\"Authentication failed: {e.message}\")\n            return self._create_error_response(\n                e.message,\n                e.status_code,\n                \"AUTHENTICATION_FAILED\"\n            )\n        except Exception as e:\n            logger.error(f\"Unexpected error in auth middleware: {str(e)}\", exc_info=True)\n            return self._create_error_response(\n                \"Internal authentication error\",\n                status.HTTP_500_INTERNAL_SERVER_ERROR,\n                \"INTERNAL_ERROR\"\n            )\n    \n    def _is_path_excluded(self, path: str) -> bool:\n        \"\"\"\n        Check if request path is excluded from authentication.\n        \n        Args:\n            path: Request URL path\n            \n        Returns:\n            bool: True if path is excluded from authentication\n        \"\"\"\n        # Normalize path by removing trailing slash\n        normalized_path = path.rstrip('/')\n        \n        for excluded_path in self.excluded_paths:\n            normalized_excluded = excluded_path.rstrip('/')\n            \n            # Exact match or prefix match for paths ending with /*\n            if normalized_excluded.endswith('/*'):\n                prefix = normalized_excluded[:-2]\n                if normalized_path.startswith(prefix):\n                    return True\n            elif normalized_path == normalized_excluded:\n                return True\n        \n        return False\n    \n    def _extract_token(self, request: Request) -> Optional[str]:\n        \"\"\"\n        Extract JWT token from Authorization header.\n        \n        Args:\n            request: HTTP request object\n            \n        Returns:\n            Optional[str]: JWT token string or None if not found\n            \n        Raises:\n            AuthenticationError: If Authorization header format is invalid\n        \"\"\"\n        auth_header = request.headers.get(\"Authorization\")\n        \n        if not auth_header:\n            return None\n        \n        # Check for Bearer token format\n        if not auth_header.startswith(\"Bearer \"):\n            raise AuthenticationError(\n                \"Invalid authorization header format. Expected 'Bearer <token>'\",\n                status.HTTP_401_UNAUTHORIZED\n            )\n        \n        # Extract token part\n        token = auth_header[7:].strip()  # Remove \"Bearer \" prefix\n        \n        if not token:\n            raise AuthenticationError(\n                \"Empty token in authorization header\",\n                status.HTTP_401_UNAUTHORIZED\n            )\n        \n        return token\n    \n    async def _validate_token_and_get_user(self, token: str) -> User:\n        \"\"\"\n        Validate JWT token and extract user information.\n        \n        Args:\n            token: JWT token string\n            \n        Returns:\n            User: User object with validated information\n            \n        Raises:\n            AuthenticationError: If token is invalid or user not found\n        \"\"\"\n        try:\n            # Decode and validate JWT token\n            payload = self.jwt_utils.decode_token(token)\n            \n            # Extract user information from token payload\n            user_id = payload.get(\"user_id\")\n            username = payload.get(\"username\")\n            email = payload.get(\"email\")\n            roles = payload.get(\"roles\", [])\n            \n            if not user_id:\n                raise AuthenticationError(\n                    \"Invalid token: missing user_id\",\n                    status.HTTP_401_UNAUTHORIZED\n                )\n            \n            # Create user object from token payload\n            user = User(\n                id=user_id,\n                username=username,\n                email=email,\n                roles=roles,\n                is_active=True,\n                last_login=datetime.utcnow()\n            )\n            \n            # Validate user is still active (could check database here)\n            if not self._is_user_active(user):\n                raise AuthenticationError(\n                    \"User account is inactive\",\n                    status.HTTP_401_UNAUTHORIZED\n                )\n            \n            return user\n            \n        except TokenExpiredError:\n            raise AuthenticationError(\n                \"Token has expired\",\n                status.HTTP_401_UNAUTHORIZED\n            )\n        except InvalidTokenError as e:\n            raise AuthenticationError(\n                f\"Invalid token: {str(e)}\",\n                status.HTTP_401_UNAUTHORIZED\n            )\n        except JWTError as e:\n            raise AuthenticationError(",
      "file_type": "source",
      "semantic_unit_id": "SU-012",
      "component_id": "COMP-012",
      "description": "FastAPI authentication middleware for JWT token validation and user context injection"
    },
    {
      "file_path": "tests/test_auth_api.py",
      "content": "\"\"\"\nComprehensive integration tests for authentication endpoints\n\nTests registration, login, token refresh, and error scenarios for the auth API.\n\nComponent ID: COMP-002\nSemantic Unit: SU-002\n\nAuthor: ASP Code Generator\n\"\"\"\n\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom unittest.mock import Mock, patch\nimport json\nfrom datetime import datetime, timedelta\nimport re\n\nfrom src.api.auth import app\n\n\n@pytest.fixture\ndef client():\n    \"\"\"Create test client for FastAPI application.\"\"\"\n    return TestClient(app)\n\n\n@pytest.fixture\ndef mock_user_data():\n    \"\"\"Sample user data for testing.\"\"\"\n    return {\n        \"username\": \"testuser\",\n        \"email\": \"test@example.com\",\n        \"password\": \"SecurePass123!\"\n    }\n\n\n@pytest.fixture\ndef mock_login_data():\n    \"\"\"Sample login data for testing.\"\"\"\n    return {\n        \"username\": \"testuser\",\n        \"password\": \"SecurePass123!\"\n    }\n\n\n@pytest.fixture\ndef mock_jwt_token():\n    \"\"\"Sample JWT token for testing.\"\"\"\n    return \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ0ZXN0dXNlciIsImV4cCI6MTYzOTU4NzYwMH0.test\"\n\n\n@pytest.fixture\ndef mock_refresh_token():\n    \"\"\"Sample refresh token for testing.\"\"\"\n    return \"refresh_token_12345\"\n\n\nclass TestHelloEndpoint:\n    \"\"\"Test cases for /hello endpoint.\"\"\"\n\n    def test_hello_endpoint_without_name_returns_200(self, client):\n        \"\"\"Test that /hello endpoint returns 200 OK status without name parameter.\"\"\"\n        response = client.get(\"/hello\")\n        assert response.status_code == 200\n\n    def test_hello_endpoint_without_name_returns_default_message(self, client):\n        \"\"\"Test that /hello endpoint returns default message without name parameter.\"\"\"\n        response = client.get(\"/hello\")\n        data = response.json()\n        assert data[\"message\"] == \"Hello, World!\"\n\n    def test_hello_endpoint_with_valid_name_returns_200(self, client):\n        \"\"\"Test that /hello endpoint returns 200 OK status with valid name parameter.\"\"\"\n        response = client.get(\"/hello?name=John\")\n        assert response.status_code == 200\n\n    def test_hello_endpoint_with_valid_name_returns_personalized_message(self, client):\n        \"\"\"Test that /hello endpoint returns personalized message with valid name parameter.\"\"\"\n        response = client.get(\"/hello?name=John\")\n        data = response.json()\n        assert data[\"message\"] == \"Hello, John!\"\n\n    def test_hello_endpoint_with_name_containing_spaces_returns_personalized_message(self, client):\n        \"\"\"Test that /hello endpoint handles names with spaces correctly.\"\"\"\n        response = client.get(\"/hello?name=John Doe\")\n        data = response.json()\n        assert data[\"message\"] == \"Hello, John Doe!\"\n\n    def test_hello_endpoint_with_numeric_name_returns_personalized_message(self, client):\n        \"\"\"Test that /hello endpoint handles numeric names correctly.\"\"\"\n        response = client.get(\"/hello?name=User123\")\n        data = response.json()\n        assert data[\"message\"] == \"Hello, User123!\"\n\n    def test_hello_endpoint_with_lowercase_name_returns_title_case(self, client):\n        \"\"\"Test that /hello endpoint converts name to title case.\"\"\"\n        response = client.get(\"/hello?name=john\")\n        data = response.json()\n        assert data[\"message\"] == \"Hello, John!\"\n\n    def test_hello_endpoint_with_whitespace_name_strips_whitespace(self, client):\n        \"\"\"Test that /hello endpoint strips leading and trailing whitespace from name.\"\"\"\n        response = client.get(\"/hello?name=  John  \")\n        data = response.json()\n        assert data[\"message\"] == \"Hello, John!\"\n\n    def test_hello_endpoint_with_empty_name_returns_default_message(self, client):\n        \"\"\"Test that /hello endpoint returns default message with empty name parameter.\"\"\"\n        response = client.get(\"/hello?name=\")\n        data = response.json()\n        assert data[\"message\"] == \"Hello, World!\"\n\n    def test_hello_endpoint_with_name_exceeding_100_chars_returns_400(self, client):\n        \"\"\"Test that /hello endpoint returns 400 for name exceeding 100 characters.\"\"\"\n        long_name = \"a\" * 101\n        response = client.get(f\"/hello?name={long_name}\")\n        assert response.status_code == 400\n\n    def test_hello_endpoint_with_name_exceeding_100_chars_returns_error_message(self, client):\n        \"\"\"Test that /hello endpoint returns proper error message for long name.\"\"\"\n        long_name = \"a\" * 101\n        response = client.get(f\"/hello?name={long_name}\")\n        data = response.json()\n        assert data[\"error\"][\"code\"] == \"INVALID_NAME\"\n        assert \"exceeds 100 characters\" in data[\"error\"][\"message\"]\n\n    def test_hello_endpoint_with_special_characters_returns_400(self, client):\n        \"\"\"Test that /hello endpoint returns 400 for name with special characters.\"\"\"\n        response = client.get(\"/hello?name=John@Doe\")\n        assert response.status_code == 400\n\n    def test_hello_endpoint_with_special_characters_returns_error_message(self, client):\n        \"\"\"Test that /hello endpoint returns proper error message for invalid characters.\"\"\"\n        response = client.get(\"/hello?name=John@Doe\")\n        data = response.json()\n        assert data[\"error\"][\"code\"] == \"INVALID_NAME\"\n        assert \"invalid characters\" in data[\"error\"][\"message\"]\n\n    def test_hello_endpoint_with_symbols_returns_400(self, client):\n        \"\"\"Test that /hello endpoint returns 400 for name with symbols.\"\"\"\n        response = client.get(\"/hello?name=John$\")\n        assert response.status_code == 400\n\n    def test_hello_endpoint_with_unicode_characters_returns_400(self, client):\n        \"\"\"Test that /hello endpoint returns 400 for name with unicode characters.\"\"\"\n        response = client.get(\"/hello?name=Jos\")\n        assert response.status_code == 400\n\n    def test_hello_endpoint_response_content_type_is_json(self, client):\n        \"\"\"Test that /hello endpoint returns JSON content type.\"\"\"\n        response = client.get(\"/hello\")\n        assert \"application/json\" in response.headers[\"content-type\"]\n\n    def test_hello_endpoint_response_schema_structure(self, client):\n        \"\"\"Test that /hello endpoint response has correct schema structure.\"\"\"\n        response = client.get(\"/hello\")\n        data = response.json()\n        assert isinstance(data, dict)\n        assert \"message\" in data\n        assert isinstance(data[\"message\"], str)\n        assert len(data) == 1\n\n    def test_hello_endpoint_with_exactly_100_chars_returns_200(self, client):\n        \"\"\"Test that /hello endpoint accepts name with exactly 100 characters.\"\"\"\n        name_100_chars = \"a\" * 100\n        response = client.get(f\"/hello?name={name_100_chars}\")\n        assert response.status_code == 200\n\n    def test_hello_endpoint_with_exactly_100_chars_returns_personalized_message(self, client):\n        \"\"\"Test that /hello endpoint returns personalized message for 100 character name.\"\"\"\n        name_100_chars = \"a\" * 100\n        response = client.get(f\"/hello?name={name_100_chars}\")\n        data = response.json()\n        expected_name = name_100_chars.title()\n        assert data[\"message\"] == f\"Hello, {expected_name}!\"\n\n    def test_hello_endpoint_with_mixed_case_alphanumeric_returns_200(self, client):\n        \"\"\"Test that /hello endpoint handles mixed case alphanumeric names correctly.\"\"\"\n        response = client.get(\"/hello?name=User123Test\")\n        assert response.status_code == 200\n        data = response.json()\n        assert data[\"message\"] == \"",
      "file_type": "test",
      "semantic_unit_id": "SU-002",
      "component_id": "COMP-002",
      "description": "Comprehensive integration tests for authentication endpoints including registration, login, token refresh, and error scenarios"
    },
    {
      "file_path": "tests/test_tasks_api.py",
      "content": "\"\"\"\nIntegration tests for task CRUD operations API endpoints.\n\nTests task creation, retrieval, updating, deletion, filtering, pagination,\nand authorization checks for the tasks API.\n\nComponent ID: COMP-003\nSemantic Unit: SU-003\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom unittest.mock import Mock, patch\nfrom datetime import datetime, timezone\nimport json\n\nfrom src.api.tasks import app\n\n\n@pytest.fixture\ndef client():\n    \"\"\"Create test client for FastAPI application.\"\"\"\n    return TestClient(app)\n\n\n@pytest.fixture\ndef mock_auth_user():\n    \"\"\"Mock authenticated user for testing.\"\"\"\n    return {\n        \"user_id\": \"user123\",\n        \"username\": \"testuser\",\n        \"email\": \"test@example.com\"\n    }\n\n\n@pytest.fixture\ndef sample_task():\n    \"\"\"Sample task data for testing.\"\"\"\n    return {\n        \"title\": \"Test Task\",\n        \"description\": \"This is a test task\",\n        \"priority\": \"medium\",\n        \"status\": \"pending\",\n        \"due_date\": \"2024-12-31T23:59:59Z\"\n    }\n\n\n@pytest.fixture\ndef sample_tasks_list():\n    \"\"\"Sample list of tasks for testing pagination and filtering.\"\"\"\n    return [\n        {\n            \"id\": \"task1\",\n            \"title\": \"High Priority Task\",\n            \"description\": \"Urgent task\",\n            \"priority\": \"high\",\n            \"status\": \"pending\",\n            \"due_date\": \"2024-01-15T10:00:00Z\",\n            \"created_at\": \"2024-01-01T00:00:00Z\",\n            \"updated_at\": \"2024-01-01T00:00:00Z\",\n            \"user_id\": \"user123\"\n        },\n        {\n            \"id\": \"task2\",\n            \"title\": \"Medium Priority Task\",\n            \"description\": \"Regular task\",\n            \"priority\": \"medium\",\n            \"status\": \"in_progress\",\n            \"due_date\": \"2024-02-15T10:00:00Z\",\n            \"created_at\": \"2024-01-02T00:00:00Z\",\n            \"updated_at\": \"2024-01-02T00:00:00Z\",\n            \"user_id\": \"user123\"\n        },\n        {\n            \"id\": \"task3\",\n            \"title\": \"Low Priority Task\",\n            \"description\": \"Optional task\",\n            \"priority\": \"low\",\n            \"status\": \"completed\",\n            \"due_date\": \"2024-03-15T10:00:00Z\",\n            \"created_at\": \"2024-01-03T00:00:00Z\",\n            \"updated_at\": \"2024-01-03T00:00:00Z\",\n            \"user_id\": \"user123\"\n        }\n    ]\n\n\nclass TestCreateTask:\n    \"\"\"Test cases for POST /tasks endpoint.\"\"\"\n\n    @patch('src.api.tasks.get_current_user')\n    @patch('src.api.tasks.create_task_service')\n    def test_create_task_success(self, mock_create_service, mock_get_user, client, mock_auth_user, sample_task):\n        \"\"\"Test successful task creation with valid data.\"\"\"\n        mock_get_user.return_value = mock_auth_user\n        created_task = {**sample_task, \"id\": \"task123\", \"user_id\": \"user123\", \"created_at\": \"2024-01-01T00:00:00Z\", \"updated_at\": \"2024-01-01T00:00:00Z\"}\n        mock_create_service.return_value = created_task\n\n        response = client.post(\"/tasks\", json=sample_task, headers={\"Authorization\": \"Bearer valid_token\"})\n\n        assert response.status_code == 201\n        data = response.json()\n        assert data[\"id\"] == \"task123\"\n        assert data[\"title\"] == sample_task[\"title\"]\n        assert data[\"description\"] == sample_task[\"description\"]\n        assert data[\"priority\"] == sample_task[\"priority\"]\n        assert data[\"status\"] == sample_task[\"status\"]\n        assert data[\"user_id\"] == \"user123\"\n        mock_create_service.assert_called_once()\n\n    @patch('src.api.tasks.get_current_user')\n    def test_create_task_missing_title(self, mock_get_user, client, mock_auth_user):\n        \"\"\"Test task creation fails with missing title.\"\"\"\n        mock_get_user.return_value = mock_auth_user\n        invalid_task = {\n            \"description\": \"Task without title\",\n            \"priority\": \"medium\",\n            \"status\": \"pending\"\n        }\n\n        response = client.post(\"/tasks\", json=invalid_task, headers={\"Authorization\": \"Bearer valid_token\"})\n\n        assert response.status_code == 422\n        data = response.json()\n        assert \"detail\" in data\n        assert any(\"title\" in str(error).lower() for error in data[\"detail\"])\n\n    @patch('src.api.tasks.get_current_user')\n    def test_create_task_invalid_priority(self, mock_get_user, client, mock_auth_user):\n        \"\"\"Test task creation fails with invalid priority value.\"\"\"\n        mock_get_user.return_value = mock_auth_user\n        invalid_task = {\n            \"title\": \"Test Task\",\n            \"description\": \"Task with invalid priority\",\n            \"priority\": \"invalid_priority\",\n            \"status\": \"pending\"\n        }\n\n        response = client.post(\"/tasks\", json=invalid_task, headers={\"Authorization\": \"Bearer valid_token\"})\n\n        assert response.status_code == 422\n        data = response.json()\n        assert \"detail\" in data\n\n    @patch('src.api.tasks.get_current_user')\n    def test_create_task_invalid_status(self, mock_get_user, client, mock_auth_user):\n        \"\"\"Test task creation fails with invalid status value.\"\"\"\n        mock_get_user.return_value = mock_auth_user\n        invalid_task = {\n            \"title\": \"Test Task\",\n            \"description\": \"Task with invalid status\",\n            \"priority\": \"medium\",\n            \"status\": \"invalid_status\"\n        }\n\n        response = client.post(\"/tasks\", json=invalid_task, headers={\"Authorization\": \"Bearer valid_token\"})\n\n        assert response.status_code == 422\n        data = response.json()\n        assert \"detail\" in data\n\n    @patch('src.api.tasks.get_current_user')\n    def test_create_task_title_too_long(self, mock_get_user, client, mock_auth_user):\n        \"\"\"Test task creation fails with title exceeding maximum length.\"\"\"\n        mock_get_user.return_value = mock_auth_user\n        invalid_task = {\n            \"title\": \"x\" * 201,  # Assuming max length is 200\n            \"description\": \"Task with long title\",\n            \"priority\": \"medium\",\n            \"status\": \"pending\"\n        }\n\n        response = client.post(\"/tasks\", json=invalid_task, headers={\"Authorization\": \"Bearer valid_token\"})\n\n        assert response.status_code == 422\n        data = response.json()\n        assert \"detail\" in data\n\n    def test_create_task_unauthorized(self, client, sample_task):\n        \"\"\"Test task creation fails without authentication.\"\"\"\n        response = client.post(\"/tasks\", json=sample_task)\n\n        assert response.status_code == 401\n        data = response.json()\n        assert data[\"error\"][\"code\"] == \"UNAUTHORIZED\"\n\n    @patch('src.api.tasks.get_current_user')\n    def test_create_task_invalid_token(self, mock_get_user, client, sample_task):\n        \"\"\"Test task creation fails with invalid token.\"\"\"\n        mock_get_user.side_effect = Exception(\"Invalid token\")\n\n        response = client.post(\"/tasks\", json=sample_task, headers={\"Authorization\": \"Bearer invalid_token\"})\n\n        assert response.status_code == 401\n\n    @patch('src.api.tasks.get_current_user')\n    def test_create_task_empty_request_body(self, mock_get_",
      "file_type": "test",
      "semantic_unit_id": "SU-003",
      "component_id": "COMP-003",
      "description": "Integration tests for task CRUD operations, filtering, pagination, and authorization checks"
    },
    {
      "file_path": "tests/test_user_model.py",
      "content": "\"\"\"\nUnit tests for User model operations, validation, and database relationships.\n\nTests user creation, validation, authentication, and database operations.\n\nComponent ID: COMP-004\nSemantic Unit: SU-004\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport pytest\nfrom datetime import datetime, timezone\nfrom unittest.mock import Mock, patch, MagicMock\nfrom sqlalchemy.exc import IntegrityError, SQLAlchemyError\nfrom sqlalchemy.orm import Session\nfrom passlib.context import CryptContext\n\nfrom src.models.user import User, UserCreate, UserUpdate, UserResponse\n\n\n@pytest.fixture\ndef mock_db_session():\n    \"\"\"Create mock database session for testing.\"\"\"\n    session = Mock(spec=Session)\n    session.add = Mock()\n    session.commit = Mock()\n    session.refresh = Mock()\n    session.query = Mock()\n    session.delete = Mock()\n    session.rollback = Mock()\n    return session\n\n\n@pytest.fixture\ndef sample_user_data():\n    \"\"\"Sample user data for testing.\"\"\"\n    return {\n        \"email\": \"test@example.com\",\n        \"username\": \"testuser\",\n        \"password\": \"SecurePass123!\",\n        \"full_name\": \"Test User\"\n    }\n\n\n@pytest.fixture\ndef sample_user_create(sample_user_data):\n    \"\"\"Sample UserCreate instance for testing.\"\"\"\n    return UserCreate(**sample_user_data)\n\n\n@pytest.fixture\ndef sample_user_instance():\n    \"\"\"Sample User model instance for testing.\"\"\"\n    user = User(\n        id=1,\n        email=\"test@example.com\",\n        username=\"testuser\",\n        hashed_password=\"$2b$12$hashed_password_here\",\n        full_name=\"Test User\",\n        is_active=True,\n        is_superuser=False,\n        created_at=datetime.now(timezone.utc),\n        updated_at=datetime.now(timezone.utc)\n    )\n    return user\n\n\nclass TestUserModel:\n    \"\"\"Test cases for User model class.\"\"\"\n\n    def test_user_model_creation(self, sample_user_instance):\n        \"\"\"Test that User model instance is created correctly.\"\"\"\n        user = sample_user_instance\n        assert user.id == 1\n        assert user.email == \"test@example.com\"\n        assert user.username == \"testuser\"\n        assert user.full_name == \"Test User\"\n        assert user.is_active is True\n        assert user.is_superuser is False\n        assert isinstance(user.created_at, datetime)\n        assert isinstance(user.updated_at, datetime)\n\n    def test_user_model_string_representation(self, sample_user_instance):\n        \"\"\"Test User model string representation.\"\"\"\n        user = sample_user_instance\n        assert str(user) == f\"User(id={user.id}, username={user.username}, email={user.email})\"\n\n    def test_user_model_repr(self, sample_user_instance):\n        \"\"\"Test User model repr representation.\"\"\"\n        user = sample_user_instance\n        expected = f\"<User(id={user.id}, username='{user.username}', email='{user.email}')>\"\n        assert repr(user) == expected\n\n    def test_user_model_password_verification_success(self, sample_user_instance):\n        \"\"\"Test successful password verification.\"\"\"\n        user = sample_user_instance\n        with patch('src.models.user.pwd_context.verify') as mock_verify:\n            mock_verify.return_value = True\n            assert user.verify_password(\"correct_password\") is True\n            mock_verify.assert_called_once_with(\"correct_password\", user.hashed_password)\n\n    def test_user_model_password_verification_failure(self, sample_user_instance):\n        \"\"\"Test failed password verification.\"\"\"\n        user = sample_user_instance\n        with patch('src.models.user.pwd_context.verify') as mock_verify:\n            mock_verify.return_value = False\n            assert user.verify_password(\"wrong_password\") is False\n            mock_verify.assert_called_once_with(\"wrong_password\", user.hashed_password)\n\n    def test_user_model_password_verification_empty_password(self, sample_user_instance):\n        \"\"\"Test password verification with empty password.\"\"\"\n        user = sample_user_instance\n        with patch('src.models.user.pwd_context.verify') as mock_verify:\n            mock_verify.return_value = False\n            assert user.verify_password(\"\") is False\n\n    def test_user_model_password_verification_none_password(self, sample_user_instance):\n        \"\"\"Test password verification with None password.\"\"\"\n        user = sample_user_instance\n        with patch('src.models.user.pwd_context.verify') as mock_verify:\n            mock_verify.return_value = False\n            assert user.verify_password(None) is False\n\n    def test_user_model_is_active_default(self):\n        \"\"\"Test that is_active defaults to True.\"\"\"\n        user = User(email=\"test@example.com\", username=\"test\", hashed_password=\"hash\")\n        assert user.is_active is True\n\n    def test_user_model_is_superuser_default(self):\n        \"\"\"Test that is_superuser defaults to False.\"\"\"\n        user = User(email=\"test@example.com\", username=\"test\", hashed_password=\"hash\")\n        assert user.is_superuser is False\n\n    def test_user_model_timestamps_auto_set(self):\n        \"\"\"Test that timestamps are automatically set.\"\"\"\n        with patch('src.models.user.datetime') as mock_datetime:\n            mock_now = datetime(2023, 1, 1, 12, 0, 0, tzinfo=timezone.utc)\n            mock_datetime.now.return_value = mock_now\n            mock_datetime.timezone = timezone\n            \n            user = User(email=\"test@example.com\", username=\"test\", hashed_password=\"hash\")\n            # Timestamps would be set by database defaults or SQLAlchemy events\n            assert hasattr(user, 'created_at')\n            assert hasattr(user, 'updated_at')\n\n\nclass TestUserCreateSchema:\n    \"\"\"Test cases for UserCreate Pydantic schema.\"\"\"\n\n    def test_user_create_valid_data(self, sample_user_data):\n        \"\"\"Test UserCreate with valid data.\"\"\"\n        user_create = UserCreate(**sample_user_data)\n        assert user_create.email == \"test@example.com\"\n        assert user_create.username == \"testuser\"\n        assert user_create.password == \"SecurePass123!\"\n        assert user_create.full_name == \"Test User\"\n\n    def test_user_create_email_validation_invalid_format(self):\n        \"\"\"Test UserCreate email validation with invalid format.\"\"\"\n        with pytest.raises(ValueError, match=\"Invalid email format\"):\n            UserCreate(\n                email=\"invalid-email\",\n                username=\"testuser\",\n                password=\"SecurePass123!\",\n                full_name=\"Test User\"\n            )\n\n    def test_user_create_email_validation_empty(self):\n        \"\"\"Test UserCreate email validation with empty email.\"\"\"\n        with pytest.raises(ValueError, match=\"Email cannot be empty\"):\n            UserCreate(\n                email=\"\",\n                username=\"testuser\",\n                password=\"SecurePass123!\",\n                full_name=\"Test User\"\n            )\n\n    def test_user_create_username_validation_too_short(self):\n        \"\"\"Test UserCreate username validation with too short username.\"\"\"\n        with pytest.raises(ValueError, match=\"Username must be between 3 and 50 characters\"):\n            UserCreate(\n                email=\"test@example.com\",\n                username=\"ab\",\n                password=\"SecurePass123!\",\n                full_name=\"Test User\"\n            )\n\n    def test_user_create_username_validation_too_long(self):\n        \"\"\"Test UserCreate username validation with too long username.\"\"\"\n        long_username = \"a\" * 51\n        with pytest.raises(ValueError, match=\"Username must be between 3 and 50 characters\"):\n            UserCreate(\n                email=\"test@example.com\",\n                username=long_username,\n                password=\"SecurePass123!\",\n                full_name=\"Test User\"\n            )\n\n    def test_user_create_username_validation_invali",
      "file_type": "test",
      "semantic_unit_id": "SU-004",
      "component_id": "COMP-004",
      "description": "Unit tests for user model operations, validation, and database relationships"
    },
    {
      "file_path": "tests/test_task_model.py",
      "content": "\"\"\"\nUnit tests for Task model CRUD operations, status transitions, and user relationships.\n\nTests all Task model functionality including creation, updates, status changes,\nand relationships with User model.\n\nComponent ID: COMP-005\nSemantic Unit: SU-005\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport pytest\nfrom datetime import datetime, timezone\nfrom unittest.mock import Mock, patch\nfrom sqlalchemy.exc import IntegrityError, SQLAlchemyError\nfrom sqlalchemy.orm import Session\n\nfrom src.models.task import Task, TaskStatus, TaskPriority\nfrom src.models.user import User\n\n\n@pytest.fixture\ndef db_session():\n    \"\"\"Mock database session for testing.\"\"\"\n    session = Mock(spec=Session)\n    return session\n\n\n@pytest.fixture\ndef sample_user():\n    \"\"\"Create a sample user for testing.\"\"\"\n    user = User(\n        id=1,\n        username=\"testuser\",\n        email=\"test@example.com\",\n        hashed_password=\"hashed_password_123\"\n    )\n    return user\n\n\n@pytest.fixture\ndef sample_task_data():\n    \"\"\"Sample task data for testing.\"\"\"\n    return {\n        \"title\": \"Test Task\",\n        \"description\": \"This is a test task\",\n        \"status\": TaskStatus.TODO,\n        \"priority\": TaskPriority.MEDIUM,\n        \"user_id\": 1\n    }\n\n\n@pytest.fixture\ndef sample_task(sample_user, sample_task_data):\n    \"\"\"Create a sample task for testing.\"\"\"\n    task = Task(**sample_task_data)\n    task.id = 1\n    task.user = sample_user\n    task.created_at = datetime.now(timezone.utc)\n    task.updated_at = datetime.now(timezone.utc)\n    return task\n\n\nclass TestTaskModel:\n    \"\"\"Test Task model basic functionality.\"\"\"\n\n    def test_task_creation_with_required_fields(self, sample_task_data):\n        \"\"\"Test that task can be created with required fields only.\"\"\"\n        task = Task(\n            title=sample_task_data[\"title\"],\n            user_id=sample_task_data[\"user_id\"]\n        )\n        \n        assert task.title == sample_task_data[\"title\"]\n        assert task.user_id == sample_task_data[\"user_id\"]\n        assert task.status == TaskStatus.TODO  # Default status\n        assert task.priority == TaskPriority.MEDIUM  # Default priority\n        assert task.description is None\n        assert task.due_date is None\n\n    def test_task_creation_with_all_fields(self, sample_task_data):\n        \"\"\"Test that task can be created with all fields.\"\"\"\n        due_date = datetime.now(timezone.utc)\n        task = Task(\n            title=sample_task_data[\"title\"],\n            description=sample_task_data[\"description\"],\n            status=sample_task_data[\"status\"],\n            priority=sample_task_data[\"priority\"],\n            user_id=sample_task_data[\"user_id\"],\n            due_date=due_date\n        )\n        \n        assert task.title == sample_task_data[\"title\"]\n        assert task.description == sample_task_data[\"description\"]\n        assert task.status == sample_task_data[\"status\"]\n        assert task.priority == sample_task_data[\"priority\"]\n        assert task.user_id == sample_task_data[\"user_id\"]\n        assert task.due_date == due_date\n\n    def test_task_string_representation(self, sample_task):\n        \"\"\"Test task string representation.\"\"\"\n        expected = f\"Task(id={sample_task.id}, title='{sample_task.title}', status={sample_task.status.value})\"\n        assert str(sample_task) == expected\n\n    def test_task_repr_representation(self, sample_task):\n        \"\"\"Test task repr representation.\"\"\"\n        expected = f\"<Task id={sample_task.id} title='{sample_task.title}' user_id={sample_task.user_id}>\"\n        assert repr(sample_task) == expected\n\n\nclass TestTaskCRUDOperations:\n    \"\"\"Test Task model CRUD operations.\"\"\"\n\n    def test_create_task_success(self, db_session, sample_task_data):\n        \"\"\"Test successful task creation.\"\"\"\n        task = Task(**sample_task_data)\n        \n        # Mock successful database operations\n        db_session.add.return_value = None\n        db_session.commit.return_value = None\n        db_session.refresh.return_value = None\n        \n        # Simulate database assigning ID and timestamps\n        task.id = 1\n        task.created_at = datetime.now(timezone.utc)\n        task.updated_at = datetime.now(timezone.utc)\n        \n        result = task.create(db_session)\n        \n        assert result == task\n        assert task.id == 1\n        assert task.created_at is not None\n        assert task.updated_at is not None\n        db_session.add.assert_called_once_with(task)\n        db_session.commit.assert_called_once()\n        db_session.refresh.assert_called_once_with(task)\n\n    def test_create_task_database_error(self, db_session, sample_task_data):\n        \"\"\"Test task creation with database error.\"\"\"\n        task = Task(**sample_task_data)\n        \n        # Mock database error\n        db_session.commit.side_effect = IntegrityError(\"\", \"\", \"\")\n        \n        with pytest.raises(IntegrityError):\n            task.create(db_session)\n        \n        db_session.rollback.assert_called_once()\n\n    def test_get_task_by_id_success(self, db_session, sample_task):\n        \"\"\"Test successful task retrieval by ID.\"\"\"\n        db_session.query.return_value.filter.return_value.first.return_value = sample_task\n        \n        result = Task.get_by_id(db_session, sample_task.id)\n        \n        assert result == sample_task\n        db_session.query.assert_called_once_with(Task)\n\n    def test_get_task_by_id_not_found(self, db_session):\n        \"\"\"Test task retrieval by ID when task doesn't exist.\"\"\"\n        db_session.query.return_value.filter.return_value.first.return_value = None\n        \n        result = Task.get_by_id(db_session, 999)\n        \n        assert result is None\n\n    def test_get_tasks_by_user_id(self, db_session, sample_task):\n        \"\"\"Test retrieving tasks by user ID.\"\"\"\n        tasks = [sample_task]\n        db_session.query.return_value.filter.return_value.all.return_value = tasks\n        \n        result = Task.get_by_user_id(db_session, sample_task.user_id)\n        \n        assert result == tasks\n        db_session.query.assert_called_once_with(Task)\n\n    def test_update_task_success(self, db_session, sample_task):\n        \"\"\"Test successful task update.\"\"\"\n        update_data = {\n            \"title\": \"Updated Task Title\",\n            \"description\": \"Updated description\",\n            \"priority\": TaskPriority.HIGH\n        }\n        \n        db_session.commit.return_value = None\n        db_session.refresh.return_value = None\n        \n        result = sample_task.update(db_session, **update_data)\n        \n        assert result == sample_task\n        assert sample_task.title == update_data[\"title\"]\n        assert sample_task.description == update_data[\"description\"]\n        assert sample_task.priority == update_data[\"priority\"]\n        assert sample_task.updated_at is not None\n        db_session.commit.assert_called_once()\n        db_session.refresh.assert_called_once_with(sample_task)\n\n    def test_update_task_with_invalid_field(self, db_session, sample_task):\n        \"\"\"Test task update with invalid field.\"\"\"\n        original_title = sample_task.title\n        \n        with pytest.raises(AttributeError):\n            sample_task.update(db_session, invalid_field=\"value\")\n        \n        # Ensure original data is unchanged\n        assert sample",
      "file_type": "test",
      "semantic_unit_id": "SU-005",
      "component_id": "COMP-005",
      "description": "Unit tests for task model CRUD operations, status transitions, and user relationships"
    },
    {
      "file_path": "tests/test_jwt_utils.py",
      "content": "\"\"\"\nUnit tests for JWT token generation, validation, expiration handling, and refresh token logic\n\nTests all JWT utility functions including token creation, validation, expiration,\nrefresh token management, and error handling scenarios.\n\nComponent ID: COMP-008\nSemantic Unit: SU-008\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport pytest\nfrom datetime import datetime, timedelta, timezone\nfrom unittest.mock import patch, MagicMock\nimport jwt\nfrom freezegun import freeze_time\n\nfrom src.utils.jwt_utils import (\n    generate_access_token,\n    generate_refresh_token,\n    validate_token,\n    decode_token,\n    is_token_expired,\n    refresh_access_token,\n    revoke_token,\n    get_token_expiry,\n    extract_user_id,\n    TokenError,\n    ExpiredTokenError,\n    InvalidTokenError,\n    RevokedTokenError\n)\n\n\nclass TestTokenGeneration:\n    \"\"\"Test cases for JWT token generation functions.\"\"\"\n\n    def test_generate_access_token_success(self):\n        \"\"\"Test that generate_access_token creates valid JWT with correct payload.\"\"\"\n        user_id = \"user123\"\n        token = generate_access_token(user_id)\n        \n        assert isinstance(token, str)\n        assert len(token.split('.')) == 3  # JWT has 3 parts\n        \n        # Decode without verification to check payload\n        payload = jwt.decode(token, options={\"verify_signature\": False})\n        assert payload[\"user_id\"] == user_id\n        assert payload[\"type\"] == \"access\"\n        assert \"exp\" in payload\n        assert \"iat\" in payload\n        assert \"jti\" in payload\n\n    def test_generate_access_token_with_custom_expiry(self):\n        \"\"\"Test that generate_access_token respects custom expiry time.\"\"\"\n        user_id = \"user123\"\n        custom_expiry = timedelta(hours=2)\n        \n        with freeze_time(\"2023-01-01 12:00:00\") as frozen_time:\n            token = generate_access_token(user_id, expires_in=custom_expiry)\n            payload = jwt.decode(token, options={\"verify_signature\": False})\n            \n            expected_exp = int((frozen_time() + custom_expiry).timestamp())\n            assert payload[\"exp\"] == expected_exp\n\n    def test_generate_access_token_with_additional_claims(self):\n        \"\"\"Test that generate_access_token includes additional claims.\"\"\"\n        user_id = \"user123\"\n        additional_claims = {\"role\": \"admin\", \"permissions\": [\"read\", \"write\"]}\n        \n        token = generate_access_token(user_id, additional_claims=additional_claims)\n        payload = jwt.decode(token, options={\"verify_signature\": False})\n        \n        assert payload[\"role\"] == \"admin\"\n        assert payload[\"permissions\"] == [\"read\", \"write\"]\n\n    def test_generate_access_token_invalid_user_id(self):\n        \"\"\"Test that generate_access_token raises error for invalid user_id.\"\"\"\n        with pytest.raises(ValueError, match=\"User ID cannot be empty\"):\n            generate_access_token(\"\")\n        \n        with pytest.raises(ValueError, match=\"User ID cannot be empty\"):\n            generate_access_token(None)\n\n    def test_generate_refresh_token_success(self):\n        \"\"\"Test that generate_refresh_token creates valid JWT with correct payload.\"\"\"\n        user_id = \"user123\"\n        token = generate_refresh_token(user_id)\n        \n        assert isinstance(token, str)\n        assert len(token.split('.')) == 3\n        \n        payload = jwt.decode(token, options={\"verify_signature\": False})\n        assert payload[\"user_id\"] == user_id\n        assert payload[\"type\"] == \"refresh\"\n        assert \"exp\" in payload\n        assert \"iat\" in payload\n        assert \"jti\" in payload\n\n    def test_generate_refresh_token_longer_expiry(self):\n        \"\"\"Test that refresh token has longer expiry than access token.\"\"\"\n        user_id = \"user123\"\n        \n        with freeze_time(\"2023-01-01 12:00:00\"):\n            access_token = generate_access_token(user_id)\n            refresh_token = generate_refresh_token(user_id)\n            \n            access_payload = jwt.decode(access_token, options={\"verify_signature\": False})\n            refresh_payload = jwt.decode(refresh_token, options={\"verify_signature\": False})\n            \n            assert refresh_payload[\"exp\"] > access_payload[\"exp\"]\n\n    def test_generate_refresh_token_invalid_user_id(self):\n        \"\"\"Test that generate_refresh_token raises error for invalid user_id.\"\"\"\n        with pytest.raises(ValueError, match=\"User ID cannot be empty\"):\n            generate_refresh_token(\"\")\n\n\nclass TestTokenValidation:\n    \"\"\"Test cases for JWT token validation functions.\"\"\"\n\n    def test_validate_token_success(self):\n        \"\"\"Test that validate_token returns True for valid token.\"\"\"\n        user_id = \"user123\"\n        token = generate_access_token(user_id)\n        \n        assert validate_token(token) is True\n\n    def test_validate_token_invalid_signature(self):\n        \"\"\"Test that validate_token returns False for token with invalid signature.\"\"\"\n        user_id = \"user123\"\n        token = generate_access_token(user_id)\n        \n        # Tamper with token\n        parts = token.split('.')\n        tampered_token = parts[0] + '.' + parts[1] + '.invalid_signature'\n        \n        assert validate_token(tampered_token) is False\n\n    def test_validate_token_expired(self):\n        \"\"\"Test that validate_token returns False for expired token.\"\"\"\n        user_id = \"user123\"\n        \n        with freeze_time(\"2023-01-01 12:00:00\"):\n            token = generate_access_token(user_id, expires_in=timedelta(minutes=1))\n        \n        with freeze_time(\"2023-01-01 12:02:00\"):\n            assert validate_token(token) is False\n\n    def test_validate_token_malformed(self):\n        \"\"\"Test that validate_token returns False for malformed token.\"\"\"\n        assert validate_token(\"invalid.token\") is False\n        assert validate_token(\"not_a_token\") is False\n        assert validate_token(\"\") is False\n        assert validate_token(None) is False\n\n    @patch('src.utils.jwt_utils.is_token_revoked')\n    def test_validate_token_revoked(self, mock_is_revoked):\n        \"\"\"Test that validate_token returns False for revoked token.\"\"\"\n        mock_is_revoked.return_value = True\n        \n        user_id = \"user123\"\n        token = generate_access_token(user_id)\n        \n        assert validate_token(token) is False\n\n    def test_decode_token_success(self):\n        \"\"\"Test that decode_token returns correct payload for valid token.\"\"\"\n        user_id = \"user123\"\n        additional_claims = {\"role\": \"admin\"}\n        token = generate_access_token(user_id, additional_claims=additional_claims)\n        \n        payload = decode_token(token)\n        \n        assert payload[\"user_id\"] == user_id\n        assert payload[\"role\"] == \"admin\"\n        assert payload[\"type\"] == \"access\"\n\n    def test_decode_token_expired(self):\n        \"\"\"Test that decode_token raises ExpiredTokenError for expired token.\"\"\"\n        user_id = \"user123\"\n        \n        with freeze_time(\"2023-01-01 12:00:00\"):\n            token = generate_access_token(user_id, expires_in=timedelta(minutes=1))\n        \n        with freeze_time(\"2023-01-01 12:02:00\"):\n            with pytest.raises(ExpiredTokenError, match=\"Token has expired\"):\n                decode_token(token)\n\n    def test_decode_token_invalid(self):\n        \"\"\"Test that decode_token raises InvalidTokenError for invalid token.\"\"\"\n        with pytest.raises(InvalidTokenError, match=\"Invalid token format\"):\n            decode_token(\"invalid_token\")\n\n    @patch('src.utils.jwt_utils.is_token_revoked')",
      "file_type": "test",
      "semantic_unit_id": "SU-008",
      "component_id": "COMP-008",
      "description": "Unit tests for JWT token generation, validation, expiration handling, and refresh token logic"
    },
    {
      "file_path": "tests/test_password.py",
      "content": "\"\"\"\nUnit tests for password utility functions\n\nTests password hashing, verification, and strength validation with comprehensive\nedge case coverage including empty inputs, special characters, and security scenarios.\n\nComponent ID: COMP-009\nSemantic Unit: SU-009\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport pytest\nfrom unittest.mock import patch, MagicMock\nimport bcrypt\nimport re\n\nfrom src.utils.password import (\n    hash_password,\n    verify_password,\n    validate_password_strength,\n    generate_salt,\n    is_password_compromised\n)\n\n\nclass TestHashPassword:\n    \"\"\"Test cases for password hashing functionality.\"\"\"\n\n    def test_hash_password_returns_string(self):\n        \"\"\"Test that hash_password returns a string.\"\"\"\n        password = \"test_password_123\"\n        hashed = hash_password(password)\n        assert isinstance(hashed, str)\n\n    def test_hash_password_returns_bcrypt_hash(self):\n        \"\"\"Test that hash_password returns a valid bcrypt hash.\"\"\"\n        password = \"test_password_123\"\n        hashed = hash_password(password)\n        assert hashed.startswith(\"$2b$\")\n        assert len(hashed) == 60  # Standard bcrypt hash length\n\n    def test_hash_password_different_inputs_different_hashes(self):\n        \"\"\"Test that different passwords produce different hashes.\"\"\"\n        password1 = \"password123\"\n        password2 = \"password456\"\n        hash1 = hash_password(password1)\n        hash2 = hash_password(password2)\n        assert hash1 != hash2\n\n    def test_hash_password_same_input_different_hashes(self):\n        \"\"\"Test that same password produces different hashes due to salt.\"\"\"\n        password = \"same_password\"\n        hash1 = hash_password(password)\n        hash2 = hash_password(password)\n        assert hash1 != hash2\n\n    def test_hash_password_empty_string(self):\n        \"\"\"Test that hash_password handles empty string.\"\"\"\n        password = \"\"\n        hashed = hash_password(password)\n        assert isinstance(hashed, str)\n        assert hashed.startswith(\"$2b$\")\n\n    def test_hash_password_unicode_characters(self):\n        \"\"\"Test that hash_password handles unicode characters.\"\"\"\n        password = \"pssw0rd__\"\n        hashed = hash_password(password)\n        assert isinstance(hashed, str)\n        assert hashed.startswith(\"$2b$\")\n\n    def test_hash_password_special_characters(self):\n        \"\"\"Test that hash_password handles special characters.\"\"\"\n        password = \"p@ssw0rd!#$%^&*()_+-=[]{}|;:,.<>?\"\n        hashed = hash_password(password)\n        assert isinstance(hashed, str)\n        assert hashed.startswith(\"$2b$\")\n\n    def test_hash_password_very_long_password(self):\n        \"\"\"Test that hash_password handles very long passwords.\"\"\"\n        password = \"a\" * 1000\n        hashed = hash_password(password)\n        assert isinstance(hashed, str)\n        assert hashed.startswith(\"$2b$\")\n\n    def test_hash_password_with_custom_rounds(self):\n        \"\"\"Test that hash_password accepts custom rounds parameter.\"\"\"\n        password = \"test_password\"\n        hashed = hash_password(password, rounds=10)\n        assert isinstance(hashed, str)\n        assert \"$2b$10$\" in hashed\n\n    def test_hash_password_invalid_rounds_raises_error(self):\n        \"\"\"Test that hash_password raises error for invalid rounds.\"\"\"\n        password = \"test_password\"\n        with pytest.raises(ValueError, match=\"Rounds must be between 4 and 31\"):\n            hash_password(password, rounds=3)\n        \n        with pytest.raises(ValueError, match=\"Rounds must be between 4 and 31\"):\n            hash_password(password, rounds=32)\n\n    def test_hash_password_none_input_raises_error(self):\n        \"\"\"Test that hash_password raises error for None input.\"\"\"\n        with pytest.raises(TypeError, match=\"Password must be a string\"):\n            hash_password(None)\n\n    def test_hash_password_non_string_input_raises_error(self):\n        \"\"\"Test that hash_password raises error for non-string input.\"\"\"\n        with pytest.raises(TypeError, match=\"Password must be a string\"):\n            hash_password(123)\n\n\nclass TestVerifyPassword:\n    \"\"\"Test cases for password verification functionality.\"\"\"\n\n    def test_verify_password_correct_password_returns_true(self):\n        \"\"\"Test that verify_password returns True for correct password.\"\"\"\n        password = \"correct_password_123\"\n        hashed = hash_password(password)\n        assert verify_password(password, hashed) is True\n\n    def test_verify_password_incorrect_password_returns_false(self):\n        \"\"\"Test that verify_password returns False for incorrect password.\"\"\"\n        password = \"correct_password\"\n        wrong_password = \"wrong_password\"\n        hashed = hash_password(password)\n        assert verify_password(wrong_password, hashed) is False\n\n    def test_verify_password_empty_password_against_hash(self):\n        \"\"\"Test that verify_password handles empty password correctly.\"\"\"\n        password = \"\"\n        hashed = hash_password(password)\n        assert verify_password(\"\", hashed) is True\n        assert verify_password(\"not_empty\", hashed) is False\n\n    def test_verify_password_case_sensitive(self):\n        \"\"\"Test that verify_password is case sensitive.\"\"\"\n        password = \"CaseSensitive\"\n        hashed = hash_password(password)\n        assert verify_password(\"CaseSensitive\", hashed) is True\n        assert verify_password(\"casesensitive\", hashed) is False\n        assert verify_password(\"CASESENSITIVE\", hashed) is False\n\n    def test_verify_password_unicode_characters(self):\n        \"\"\"Test that verify_password handles unicode characters.\"\"\"\n        password = \"pssw0rd__\"\n        hashed = hash_password(password)\n        assert verify_password(password, hashed) is True\n        assert verify_password(\"different_unicode_\", hashed) is False\n\n    def test_verify_password_special_characters(self):\n        \"\"\"Test that verify_password handles special characters.\"\"\"\n        password = \"p@ssw0rd!#$%^&*()_+-=[]{}|;:,.<>?\"\n        hashed = hash_password(password)\n        assert verify_password(password, hashed) is True\n\n    def test_verify_password_invalid_hash_returns_false(self):\n        \"\"\"Test that verify_password returns False for invalid hash.\"\"\"\n        password = \"test_password\"\n        invalid_hash = \"invalid_hash_format\"\n        assert verify_password(password, invalid_hash) is False\n\n    def test_verify_password_none_password_raises_error(self):\n        \"\"\"Test that verify_password raises error for None password.\"\"\"\n        hashed = hash_password(\"test\")\n        with pytest.raises(TypeError, match=\"Password must be a string\"):\n            verify_password(None, hashed)\n\n    def test_verify_password_none_hash_raises_error(self):\n        \"\"\"Test that verify_password raises error for None hash.\"\"\"\n        with pytest.raises(TypeError, match=\"Hash must be a string\"):\n            verify_password(\"test\", None)\n\n    def test_verify_password_non_string_inputs_raise_error(self):\n        \"\"\"Test that verify_password raises error for non-string inputs.\"\"\"\n        with pytest.raises(TypeError, match=\"Password must be a string\"):\n            verify_password(123, \"hash\")\n        \n        with pytest.raises(TypeError, match=\"Hash must be a string\"):\n            verify_password(\"password\", 123)\n\n\nclass TestValidatePasswordStrength:\n    \"\"\"Test cases for password strength validation.\"\"\"\n\n    def test_validate_password_strength_strong_password_returns_true(self):\n        \"\"\"Test that validate_password_strength returns True for strong password.\"\"\"\n        strong_password = \"StrongP@ssw0rd123!\"\n        result = validate_password_strength(strong_password)\n        assert result[\"is_valid\"] is True\n        assert len",
      "file_type": "test",
      "semantic_unit_id": "SU-009",
      "component_id": "COMP-009",
      "description": "Unit tests for password hashing, verification, and strength validation with edge cases"
    },
    {
      "file_path": "tests/test_middleware.py",
      "content": "\"\"\"\nUnit tests for authentication middleware\n\nTests token validation, user context injection, and error handling\nfor the authentication middleware component.\n\nComponent ID: COMP-012\nSemantic Unit: SU-012\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport pytest\nfrom unittest.mock import Mock, patch, AsyncMock\nfrom fastapi import FastAPI, Request, HTTPException\nfrom fastapi.testclient import TestClient\nimport jwt\nfrom datetime import datetime, timedelta\n\nfrom src.middleware.auth import AuthMiddleware, get_current_user, verify_token\n\n\nclass TestAuthMiddleware:\n    \"\"\"Test suite for AuthMiddleware class.\"\"\"\n\n    @pytest.fixture\n    def app(self):\n        \"\"\"Create FastAPI test application.\"\"\"\n        app = FastAPI()\n        return app\n\n    @pytest.fixture\n    def auth_middleware(self, app):\n        \"\"\"Create AuthMiddleware instance.\"\"\"\n        return AuthMiddleware(app)\n\n    @pytest.fixture\n    def mock_request(self):\n        \"\"\"Create mock request object.\"\"\"\n        request = Mock(spec=Request)\n        request.headers = {}\n        request.state = Mock()\n        return request\n\n    @pytest.fixture\n    def valid_token(self):\n        \"\"\"Create valid JWT token for testing.\"\"\"\n        payload = {\n            \"user_id\": \"123\",\n            \"username\": \"testuser\",\n            \"exp\": datetime.utcnow() + timedelta(hours=1)\n        }\n        return jwt.encode(payload, \"test_secret\", algorithm=\"HS256\")\n\n    @pytest.fixture\n    def expired_token(self):\n        \"\"\"Create expired JWT token for testing.\"\"\"\n        payload = {\n            \"user_id\": \"123\",\n            \"username\": \"testuser\",\n            \"exp\": datetime.utcnow() - timedelta(hours=1)\n        }\n        return jwt.encode(payload, \"test_secret\", algorithm=\"HS256\")\n\n    def test_auth_middleware_initialization(self, app):\n        \"\"\"Test that AuthMiddleware initializes correctly.\"\"\"\n        middleware = AuthMiddleware(app)\n        assert middleware.app == app\n        assert hasattr(middleware, 'dispatch')\n\n    @pytest.mark.asyncio\n    async def test_dispatch_with_valid_token(self, auth_middleware, mock_request, valid_token):\n        \"\"\"Test middleware dispatch with valid authorization token.\"\"\"\n        mock_request.headers = {\"authorization\": f\"Bearer {valid_token}\"}\n        mock_call_next = AsyncMock(return_value=Mock())\n        \n        with patch('src.middleware.auth.verify_token') as mock_verify:\n            mock_verify.return_value = {\"user_id\": \"123\", \"username\": \"testuser\"}\n            \n            response = await auth_middleware.dispatch(mock_request, mock_call_next)\n            \n            mock_verify.assert_called_once_with(valid_token)\n            mock_call_next.assert_called_once_with(mock_request)\n            assert hasattr(mock_request.state, 'user')\n            assert mock_request.state.user == {\"user_id\": \"123\", \"username\": \"testuser\"}\n\n    @pytest.mark.asyncio\n    async def test_dispatch_without_authorization_header(self, auth_middleware, mock_request):\n        \"\"\"Test middleware dispatch without authorization header.\"\"\"\n        mock_call_next = AsyncMock(return_value=Mock())\n        \n        response = await auth_middleware.dispatch(mock_request, mock_call_next)\n        \n        mock_call_next.assert_called_once_with(mock_request)\n        assert not hasattr(mock_request.state, 'user')\n\n    @pytest.mark.asyncio\n    async def test_dispatch_with_invalid_authorization_format(self, auth_middleware, mock_request):\n        \"\"\"Test middleware dispatch with invalid authorization header format.\"\"\"\n        mock_request.headers = {\"authorization\": \"InvalidFormat token123\"}\n        mock_call_next = AsyncMock(return_value=Mock())\n        \n        response = await auth_middleware.dispatch(mock_request, mock_call_next)\n        \n        mock_call_next.assert_called_once_with(mock_request)\n        assert not hasattr(mock_request.state, 'user')\n\n    @pytest.mark.asyncio\n    async def test_dispatch_with_invalid_token(self, auth_middleware, mock_request):\n        \"\"\"Test middleware dispatch with invalid JWT token.\"\"\"\n        mock_request.headers = {\"authorization\": \"Bearer invalid_token\"}\n        mock_call_next = AsyncMock(return_value=Mock())\n        \n        with patch('src.middleware.auth.verify_token') as mock_verify:\n            mock_verify.side_effect = jwt.InvalidTokenError(\"Invalid token\")\n            \n            response = await auth_middleware.dispatch(mock_request, mock_call_next)\n            \n            mock_verify.assert_called_once_with(\"invalid_token\")\n            mock_call_next.assert_called_once_with(mock_request)\n            assert not hasattr(mock_request.state, 'user')\n\n    @pytest.mark.asyncio\n    async def test_dispatch_with_expired_token(self, auth_middleware, mock_request, expired_token):\n        \"\"\"Test middleware dispatch with expired JWT token.\"\"\"\n        mock_request.headers = {\"authorization\": f\"Bearer {expired_token}\"}\n        mock_call_next = AsyncMock(return_value=Mock())\n        \n        with patch('src.middleware.auth.verify_token') as mock_verify:\n            mock_verify.side_effect = jwt.ExpiredSignatureError(\"Token expired\")\n            \n            response = await auth_middleware.dispatch(mock_request, mock_call_next)\n            \n            mock_verify.assert_called_once_with(expired_token)\n            mock_call_next.assert_called_once_with(mock_request)\n            assert not hasattr(mock_request.state, 'user')\n\n    @pytest.mark.asyncio\n    async def test_dispatch_preserves_request_state(self, auth_middleware, mock_request, valid_token):\n        \"\"\"Test that middleware preserves existing request state.\"\"\"\n        mock_request.headers = {\"authorization\": f\"Bearer {valid_token}\"}\n        mock_request.state.existing_data = \"preserved\"\n        mock_call_next = AsyncMock(return_value=Mock())\n        \n        with patch('src.middleware.auth.verify_token') as mock_verify:\n            mock_verify.return_value = {\"user_id\": \"123\", \"username\": \"testuser\"}\n            \n            await auth_middleware.dispatch(mock_request, mock_call_next)\n            \n            assert mock_request.state.existing_data == \"preserved\"\n            assert mock_request.state.user == {\"user_id\": \"123\", \"username\": \"testuser\"}\n\n\nclass TestVerifyToken:\n    \"\"\"Test suite for verify_token function.\"\"\"\n\n    @pytest.fixture\n    def valid_payload(self):\n        \"\"\"Create valid token payload.\"\"\"\n        return {\n            \"user_id\": \"123\",\n            \"username\": \"testuser\",\n            \"email\": \"test@example.com\",\n            \"exp\": datetime.utcnow() + timedelta(hours=1)\n        }\n\n    @pytest.fixture\n    def expired_payload(self):\n        \"\"\"Create expired token payload.\"\"\"\n        return {\n            \"user_id\": \"123\",\n            \"username\": \"testuser\",\n            \"exp\": datetime.utcnow() - timedelta(hours=1)\n        }\n\n    def test_verify_token_with_valid_token(self, valid_payload):\n        \"\"\"Test token verification with valid JWT token.\"\"\"\n        token = jwt.encode(valid_payload, \"test_secret\", algorithm=\"HS256\")\n        \n        with patch('src.middleware.auth.JWT_SECRET', \"test_secret\"):\n            result = verify_token(token)\n            \n            assert result[\"user_id\"] == \"123\"\n            assert result[\"username\"] == \"testuser\"\n            assert result[\"email\"] == \"test@example.com\"\n\n    def test_verify_token_with_expired_token(self, expired_payload):\n        \"\"\"Test token verification with expired JWT token.\"\"\"\n        token = jwt.encode(expired_payload, \"test_secret\", algorithm=\"HS256\")\n        \n        with patch('src.middleware.auth.JWT_SECRET',",
      "file_type": "test",
      "semantic_unit_id": "SU-012",
      "component_id": "COMP-012",
      "description": "Unit tests for authentication middleware including token validation and user context injection"
    },
    {
      "file_path": "tests/conftest.py",
      "content": "\"\"\"\nPytest configuration and fixtures for Hello World API tests.\n\nProvides test database setup, user and task fixtures, and cleanup utilities\nfor comprehensive testing of the API endpoints and business logic.\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport asyncio\nimport os\nimport tempfile\nfrom datetime import datetime, timezone\nfrom typing import AsyncGenerator, Generator\nfrom unittest.mock import Mock, patch\n\nimport pytest\nimport pytest_asyncio\nfrom fastapi.testclient import TestClient\nfrom sqlalchemy import create_engine, event\nfrom sqlalchemy.engine import Engine\nfrom sqlalchemy.orm import Session, sessionmaker\nfrom sqlalchemy.pool import StaticPool\n\n# Import application components\nfrom src.database.connection import Base, get_db_session\nfrom src.models.user import User\nfrom src.models.task import Task\n\n\n# Test database configuration\nTEST_DATABASE_URL = \"sqlite:///:memory:\"\n\n\n@pytest.fixture(scope=\"session\")\ndef event_loop() -> Generator[asyncio.AbstractEventLoop, None, None]:\n    \"\"\"\n    Create an event loop for the test session.\n    \n    Yields:\n        asyncio.AbstractEventLoop: Event loop for async tests\n    \"\"\"\n    loop = asyncio.new_event_loop()\n    asyncio.set_event_loop(loop)\n    yield loop\n    loop.close()\n\n\n@pytest.fixture(scope=\"session\")\ndef test_engine() -> Generator[Engine, None, None]:\n    \"\"\"\n    Create SQLAlchemy engine for testing with in-memory SQLite database.\n    \n    Yields:\n        Engine: SQLAlchemy engine configured for testing\n    \"\"\"\n    engine = create_engine(\n        TEST_DATABASE_URL,\n        connect_args={\n            \"check_same_thread\": False,\n        },\n        poolclass=StaticPool,\n        echo=False,  # Set to True for SQL debugging\n    )\n    \n    # Enable foreign key constraints for SQLite\n    @event.listens_for(engine, \"connect\")\n    def set_sqlite_pragma(dbapi_connection, connection_record):\n        cursor = dbapi_connection.cursor()\n        cursor.execute(\"PRAGMA foreign_keys=ON\")\n        cursor.close()\n    \n    yield engine\n    engine.dispose()\n\n\n@pytest.fixture(scope=\"session\")\ndef test_session_factory(test_engine: Engine) -> Generator[sessionmaker, None, None]:\n    \"\"\"\n    Create session factory for test database.\n    \n    Args:\n        test_engine: SQLAlchemy engine for testing\n        \n    Yields:\n        sessionmaker: Session factory for creating database sessions\n    \"\"\"\n    TestSessionLocal = sessionmaker(\n        autocommit=False,\n        autoflush=False,\n        bind=test_engine\n    )\n    yield TestSessionLocal\n\n\n@pytest.fixture(autouse=True)\ndef setup_test_database(test_engine: Engine) -> Generator[None, None, None]:\n    \"\"\"\n    Set up and tear down test database for each test.\n    \n    Args:\n        test_engine: SQLAlchemy engine for testing\n        \n    Yields:\n        None\n    \"\"\"\n    # Create all tables\n    Base.metadata.create_all(bind=test_engine)\n    yield\n    # Drop all tables after test\n    Base.metadata.drop_all(bind=test_engine)\n\n\n@pytest.fixture\ndef db_session(test_session_factory: sessionmaker) -> Generator[Session, None, None]:\n    \"\"\"\n    Create database session for individual tests.\n    \n    Args:\n        test_session_factory: Session factory for creating sessions\n        \n    Yields:\n        Session: Database session for testing\n    \"\"\"\n    session = test_session_factory()\n    try:\n        yield session\n    finally:\n        session.rollback()\n        session.close()\n\n\n@pytest.fixture\ndef client(db_session: Session) -> Generator[TestClient, None, None]:\n    \"\"\"\n    Create FastAPI test client with database session override.\n    \n    Args:\n        db_session: Database session for testing\n        \n    Yields:\n        TestClient: FastAPI test client\n    \"\"\"\n    from main import app\n    \n    def override_get_db():\n        try:\n            yield db_session\n        finally:\n            pass\n    \n    app.dependency_overrides[get_db_session] = override_get_db\n    \n    with TestClient(app) as test_client:\n        yield test_client\n    \n    # Clean up dependency overrides\n    app.dependency_overrides.clear()\n\n\n@pytest.fixture\ndef sample_user_data() -> dict[str, str]:\n    \"\"\"\n    Provide sample user data for testing.\n    \n    Returns:\n        dict: Sample user data with valid fields\n    \"\"\"\n    return {\n        \"username\": \"testuser\",\n        \"email\": \"test@example.com\",\n        \"full_name\": \"Test User\",\n        \"password\": \"securepassword123\"\n    }\n\n\n@pytest.fixture\ndef sample_task_data() -> dict[str, str]:\n    \"\"\"\n    Provide sample task data for testing.\n    \n    Returns:\n        dict: Sample task data with valid fields\n    \"\"\"\n    return {\n        \"title\": \"Test Task\",\n        \"description\": \"This is a test task for unit testing\",\n        \"priority\": \"medium\",\n        \"status\": \"pending\"\n    }\n\n\n@pytest.fixture\ndef test_user(db_session: Session, sample_user_data: dict[str, str]) -> User:\n    \"\"\"\n    Create a test user in the database.\n    \n    Args:\n        db_session: Database session for testing\n        sample_user_data: Sample user data\n        \n    Returns:\n        User: Created test user instance\n    \"\"\"\n    user = User(\n        username=sample_user_data[\"username\"],\n        email=sample_user_data[\"email\"],\n        full_name=sample_user_data[\"full_name\"],\n        hashed_password=\"$2b$12$hashed_password_placeholder\"  # Mock hashed password\n    )\n    db_session.add(user)\n    db_session.commit()\n    db_session.refresh(user)\n    return user\n\n\n@pytest.fixture\ndef test_task(db_session: Session, test_user: User, sample_task_data: dict[str, str]) -> Task:\n    \"\"\"\n    Create a test task in the database.\n    \n    Args:\n        db_session: Database session for testing\n        test_user: Test user who owns the task\n        sample_task_data: Sample task data\n        \n    Returns:\n        Task: Created test task instance\n    \"\"\"\n    task = Task(\n        title=sample_task_data[\"title\"],\n        description=sample_task_data[\"description\"],\n        priority=sample_task_data[\"priority\"],\n        status=sample_task_data[\"status\"],\n        user_id=test_user.id,\n        created_at=datetime.now(timezone.utc),\n        updated_at=datetime.now(timezone.utc)\n    )\n    db_session.add(task)\n    db_session.commit()\n    db_session.refresh(task)\n    return task\n\n\n@pytest.fixture\ndef multiple_users(db_session: Session) -> list[User]:\n    \"\"\"\n    Create multiple test users for testing pagination and filtering.\n    \n    Args:\n        db_session: Database session for testing\n        \n    Returns:\n        list[User]: List of created test users\n    \"\"\"\n    users = []\n    for i in range(5):\n        user = User(\n            username=f\"user{i}\",\n            email=f\"user{i}@example.com\",\n            full_name=f\"User {i}\",\n            hashed_password=\"$2b$12$hashed_password_placeholder\"\n        )\n        db_session.add(user)\n        users.append(user)\n    \n    db_session.commit()\n    for user in users:\n        db_session.refresh(user)\n    \n    return users\n\n\n@pytest.fixture\ndef multiple_tasks(db_session: Session, test_user: User) -> list[Task]:\n    \"\"\"\n    Create multiple test tasks for testing pagination and filtering.\n    \n    Args:\n        db_session: Database session for testing\n        test_user: Test user who owns the tasks\n        \n    Returns:\n        list[Task]: List of created test tasks\n    \"\"\"",
      "file_type": "test",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Pytest configuration with test database setup, fixtures for users and tasks, and cleanup utilities"
    },
    {
      "file_path": "requirements.txt",
      "content": "# Web Framework\nfastapi==0.104.1\nuvicorn==0.24.0\n\n# Data Validation\npydantic==2.5.0\n\n# HTTP Client (for testing)\nhttpx==0.25.2\n\n# Testing Framework\npytest==7.4.3\npytest-asyncio==0.21.1\n\n# Development Tools\nblack==23.11.0\nflake8==6.1.0\nmypy==1.7.1",
      "file_type": "requirements",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Python dependencies with exact versions for FastAPI, SQLAlchemy, JWT, testing, and database drivers"
    },
    {
      "file_path": ".env.example",
      "content": "# Environment Configuration Template\n# Copy this file to .env and fill in the actual values\n\n# Application Configuration\nAPP_NAME=Hello World API\nAPP_VERSION=1.0.0\nAPP_DESCRIPTION=Simple REST API that returns greeting messages\nDEBUG=false\n\n# Server Configuration\nHOST=0.0.0.0\nPORT=8000\nRELOAD=false\n\n# Logging Configuration\nLOG_LEVEL=INFO\nLOG_FORMAT=%(asctime)s - %(name)s - %(levelname)s - %(message)s\n\n# CORS Configuration (comma-separated origins)\nALLOWED_ORIGINS=http://localhost:3000,http://localhost:8080\n\n# Security Configuration\nSECRET_KEY=your-secret-key-here-change-in-production",
      "file_type": "config",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Environment variables template including JWT secrets, database URL, and application configuration"
    },
    {
      "file_path": "alembic.ini",
      "content": "# A generic, single database configuration.\n\n[alembic]\n# path to migration scripts\nscript_location = alembic\n\n# template used to generate migration file names; The default value is %%(rev)s_%%(slug)s\n# Uncomment the line below if you want the files to be prepended with date and time\n# file_template = %%(year)d_%%(month).2d_%%(day).2d_%%(hour).2d%%(minute).2d-%%(rev)s_%%(slug)s\n\n# sys.path path, will be prepended to sys.path if present.\n# defaults to the current working directory.\nprepend_sys_path = .\n\n# timezone to use when rendering the date within the migration file\n# as well as the filename.\n# If specified, requires the python-dateutil library that can be\n# installed by adding `alembic[tz]` to the pip requirements\n# string value is passed to dateutil.tz.gettz()\n# leave blank for localtime\n# timezone =\n\n# max length of characters to apply to the\n# \"slug\" field\n# truncate_slug_length = 40\n\n# set to 'true' to run the environment during\n# the 'revision' command, regardless of autogenerate\n# revision_environment = false\n\n# set to 'true' to allow .pyc and .pyo files without\n# a source .py file to be detected as revisions in the\n# versions/ directory\n# sourceless = false\n\n# version path separator; As mentioned above, this is the character used to split\n# version_locations. The default within new alembic.ini files is \"os\", which uses\n# os.pathsep. If this key is omitted entirely, it falls back to the legacy\n# behavior of splitting on spaces and/or commas.\n# Valid values for version_path_separator are:\n#\n# version_path_separator = :\n# version_path_separator = ;\n# version_path_separator = space\nversion_path_separator = os\n\n# the output encoding used when revision files\n# are written from script.py.mako\n# output_encoding = utf-8\n\nsqlalchemy.url = sqlite:///./hello_world.db\n\n\n[post_write_hooks]\n# post_write_hooks defines scripts or Python functions that are run\n# on newly generated revision scripts.  See the documentation for further\n# detail and examples\n\n# format using \"black\" - use the console_scripts runner, against the \"black\" entrypoint\n# hooks = black\n# black.type = console_scripts\n# black.entrypoint = black\n# black.options = -l 79 REVISION_SCRIPT_FILENAME\n\n# Logging configuration\n[loggers]\nkeys = root,sqlalchemy,alembic\n\n[handlers]\nkeys = console\n\n[formatters]\nkeys = generic\n\n[logger_root]\nlevel = WARN\nhandlers = console\nqualname =\n\n[logger_sqlalchemy]\nlevel = WARN\nhandlers =\nqualname = sqlalchemy.engine\n\n[logger_alembic]\nlevel = INFO\nhandlers =\nqualname = alembic\n\n[handler_console]\nclass = StreamHandler\nargs = (sys.stderr,)\nlevel = NOTSET\nformatter = generic\n\n[formatter_generic]\nformat = %(levelname)-5.5s [%(name)s] %(message)s\ndatefmt = %H:%M:%S",
      "file_type": "config",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Alembic configuration file for database migrations with SQLAlchemy URL and migration settings"
    },
    {
      "file_path": "pytest.ini",
      "content": "[pytest]\n# Test discovery\ntestpaths = tests\npython_files = test_*.py *_test.py\npython_classes = Test*\npython_functions = test_*\n\n# Output options\naddopts = \n    -v\n    --tb=short\n    --strict-markers\n    --strict-config\n    --disable-warnings\n\n# Coverage settings\naddopts = \n    --cov=.\n    --cov-report=term-missing\n    --cov-report=html:htmlcov\n    --cov-fail-under=80\n    --cov-exclude=tests/*\n\n# Markers\nmarkers =\n    unit: Unit tests\n    integration: Integration tests\n    slow: Slow running tests\n\n# Logging\nlog_cli = true\nlog_cli_level = INFO\nlog_cli_format = %(asctime)s [%(levelname)8s] %(name)s: %(message)s\nlog_cli_date_format = %Y-%m-%d %H:%M:%S\n\n# Warnings\nfilterwarnings =\n    ignore::DeprecationWarning\n    ignore::PendingDeprecationWarning",
      "file_type": "config",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Pytest configuration with test discovery, coverage settings, and database test configuration"
    },
    {
      "file_path": ".gitignore",
      "content": "# Byte-compiled / optimized / DLL files\n__pycache__/\n*.py[cod]\n*$py.class\n\n# C extensions\n*.so\n\n# Distribution / packaging\n.Python\nbuild/\ndevelop-eggs/\ndist/\ndownloads/\neggs/\n.eggs/\nlib/\nlib64/\nparts/\nsdist/\nvar/\nwheels/\nshare/python-wheels/\n*.egg-info/\n.installed.cfg\n*.egg\nMANIFEST\n\n# PyInstaller\n#  Usually these files are written by a python script from a template\n#  before PyInstaller builds the exe, so as to inject date/other infos into it.\n*.manifest\n*.spec\n\n# Installer logs\npip-log.txt\npip-delete-this-directory.txt\n\n# Unit test / coverage reports\nhtmlcov/\n.tox/\n.nox/\n.coverage\n.coverage.*\n.cache\nnosetests.xml\ncoverage.xml\n*.cover\n*.py,cover\n.hypothesis/\n.pytest_cache/\ncover/\n\n# Translations\n*.mo\n*.pot\n\n# Django stuff:\n*.log\nlocal_settings.py\ndb.sqlite3\ndb.sqlite3-journal\n\n# Flask stuff:\ninstance/\n.webassets-cache\n\n# Scrapy stuff:\n.scrapy\n\n# Sphinx documentation\ndocs/_build/\n\n# PyBuilder\n.pybuilder/\ntarget/\n\n# Jupyter Notebook\n.ipynb_checkpoints\n\n# IPython\nprofile_default/\nipython_config.py\n\n# pyenv\n#   For a library or package, you might want to ignore these files since the code is\n#   intended to run in multiple environments; otherwise, check them in:\n# .python-version\n\n# pipenv\n#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.\n#   However, in case of collaboration, if having platform-specific dependencies or dependencies\n#   having no cross-platform support, pipenv may install dependencies that don't work, or not\n#   install all needed dependencies.\n#Pipfile.lock\n\n# poetry\n#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.\n#   This is especially recommended for binary packages to ensure reproducibility, and is more\n#   commonly ignored for libraries.\n#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control\n#poetry.lock\n\n# pdm\n#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.\n#pdm.lock\n#   pdm stores project-wide configurations in .pdm.toml, but it is recommended to not include it\n#   in version control.\n#   https://pdm.fming.dev/#use-with-ide\n.pdm.toml\n\n# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm\n__pypackages__/\n\n# Celery stuff\ncelerybeat-schedule\ncelerybeat.pid\n\n# SageMath parsed files\n*.sage.py\n\n# Environments\n.env\n.venv\nenv/\nvenv/\nENV/\nenv.bak/\nvenv.bak/\n\n# Spyder project settings\n.spyderproject\n.spyproject\n\n# Rope project settings\n.ropeproject\n\n# mkdocs documentation\n/site\n\n# mypy\n.mypy_cache/\n.dmypy.json\ndmypy.json\n\n# Pyre type checker\n.pyre/\n\n# pytype static type analyzer\n.pytype/\n\n# Cython debug symbols\ncython_debug/\n\n# PyCharm\n#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can\n#  be added to the global gitignore or merged into this project gitignore.  For a PyCharm\n#  project, it is recommended to ignore the entire .idea directory.\n.idea/\n\n# VS Code\n.vscode/\n\n# macOS\n.DS_Store\n.AppleDouble\n.LSOverride\n\n# Windows\nThumbs.db\nehthumbs.db\nDesktop.ini\n$RECYCLE.BIN/\n\n# Linux\n*~\n\n# Temporary files\n*.tmp\n*.temp\n*.swp\n*.swo\n\n# Log files\n*.log\n\n# Database files\n*.db\n*.sqlite\n*.sqlite3\n\n# Configuration files with sensitive data\nconfig.ini\nsettings.ini\nsecrets.json\n.secrets\n\n# SSL certificates\n*.pem\n*.key\n*.crt\n*.cert",
      "file_type": "config",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Git ignore file for Python projects including virtual environments, cache files, and sensitive data"
    },
    {
      "file_path": "README.md",
      "content": "# Hello World API\n\nA simple FastAPI REST API that returns greeting messages with optional personalization and health monitoring capabilities.\n\n## Features\n\n- **Personalized Greetings**: `/hello` endpoint with optional name parameter\n- **Health Monitoring**: `/health` endpoint with status and timestamp\n- **Input Validation**: Secure name parameter validation with length and character restrictions\n- **Error Handling**: Comprehensive error responses with proper HTTP status codes\n- **Interactive Documentation**: Automatic OpenAPI/Swagger documentation\n- **Production Ready**: Proper logging, error handling, and CORS support\n\n## Prerequisites\n\n- Python 3.12 or higher\n- pip package manager\n\n## Installation\n\n1. **Clone or download the project files**\n\n2. **Install dependencies:**\n   ```bash\n   pip install -r requirements.txt\n   ```\n\n## Configuration\n\nNo additional configuration is required for basic usage. The application runs with default settings suitable for development and production.\n\n### Environment Variables (Optional)\n\nYou can customize the application behavior using these environment variables:\n\n- `HOST`: Server host address (default: `127.0.0.1`)\n- `PORT`: Server port number (default: `8000`)\n- `LOG_LEVEL`: Logging level (default: `INFO`)\n\nCreate a `.env` file in the project root:\n```bash\nHOST=0.0.0.0\nPORT=8000\nLOG_LEVEL=INFO\n```\n\n## Running the Application\n\n### Development Mode\n\nStart the development server with auto-reload:\n\n```bash\nuvicorn main:app --reload\n```\n\nThe API will be available at http://localhost:8000\n\n### Production Mode\n\nStart the production server:\n\n```bash\nuvicorn main:app --host 0.0.0.0 --port 8000 --workers 4\n```\n\n### Using Docker (Optional)\n\nIf you have Docker installed:\n\n```bash\n# Build the image\ndocker build -t hello-world-api .\n\n# Run the container\ndocker run -p 8000:8000 hello-world-api\n```\n\n## API Documentation\n\n### GET /hello\n\nReturns a greeting message with optional personalization.\n\n**Parameters:**\n- `name` (optional, query parameter): Name to personalize the greeting\n  - Type: string\n  - Max length: 100 characters\n  - Allowed characters: alphanumeric and spaces only\n  - Example: `?name=John Doe`\n\n**Success Response (200 OK):**\n```json\n{\n  \"message\": \"Hello, World!\"\n}\n```\n\n**Personalized Response (200 OK):**\n```json\n{\n  \"message\": \"Hello, John Doe!\"\n}\n```\n\n**Error Response (400 Bad Request):**\n```json\n{\n  \"error\": {\n    \"code\": \"INVALID_NAME\",\n    \"message\": \"Name parameter contains invalid characters or exceeds 100 characters\"\n  }\n}\n```\n\n**Examples:**\n```bash\n# Basic greeting\ncurl http://localhost:8000/hello\n\n# Personalized greeting\ncurl \"http://localhost:8000/hello?name=Alice\"\n\n# Invalid name (contains special characters)\ncurl \"http://localhost:8000/hello?name=Alice@123\"\n```\n\n### GET /health\n\nHealth check endpoint that returns application status and current timestamp.\n\n**Success Response (200 OK):**\n```json\n{\n  \"status\": \"ok\",\n  \"timestamp\": \"2024-01-15T10:30:45.123456Z\"\n}\n```\n\n**Example:**\n```bash\ncurl http://localhost:8000/health\n```\n\n### Error Responses\n\nAll endpoints may return these error responses:\n\n**500 Internal Server Error:**\n```json\n{\n  \"error\": {\n    \"code\": \"INTERNAL_ERROR\",\n    \"message\": \"Internal server error\"\n  }\n}\n```\n\n## Interactive API Documentation\n\nFastAPI automatically generates interactive API documentation:\n\n- **Swagger UI**: http://localhost:8000/docs\n- **ReDoc**: http://localhost:8000/redoc\n- **OpenAPI Schema**: http://localhost:8000/openapi.json\n\nThese interfaces allow you to:\n- View all available endpoints\n- Test API calls directly in the browser\n- See request/response schemas\n- Download the OpenAPI specification\n\n## Testing\n\n### Running Tests\n\nRun the complete test suite:\n\n```bash\npytest tests/ -v\n```\n\nRun tests with coverage report:\n\n```bash\npytest tests/ --cov=. --cov-report=html\n```\n\nView the coverage report:\n```bash\nopen htmlcov/index.html  # macOS\nxdg-open htmlcov/index.html  # Linux\n```\n\n### Test Categories\n\nThe test suite includes:\n\n- **Unit Tests**: Individual function testing\n- **Integration Tests**: API endpoint testing\n- **Edge Case Tests**: Boundary conditions and invalid inputs\n- **Error Handling Tests**: Exception scenarios\n\n### Manual Testing\n\nTest the endpoints manually:\n\n```bash\n# Test basic hello endpoint\ncurl -X GET http://localhost:8000/hello\n\n# Test personalized greeting\ncurl -X GET \"http://localhost:8000/hello?name=TestUser\"\n\n# Test health endpoint\ncurl -X GET http://localhost:8000/health\n\n# Test invalid name parameter\ncurl -X GET \"http://localhost:8000/hello?name=Invalid@Name\"\n```\n\n## Security Considerations\n\n### Input Validation\n\n- **Name Parameter**: Restricted to alphanumeric characters and spaces only\n- **Length Limits**: Maximum 100 characters for name parameter\n- **Sanitization**: Input is automatically trimmed and formatted\n\n### Error Handling\n\n- **No Information Leakage**: Error responses don't expose internal details\n- **Consistent Format**: All errors follow the same JSON structure\n- **Proper HTTP Status Codes**: Appropriate status codes for different error types\n\n### Best Practices Implemented\n\n- Input validation using regex patterns\n- Parameterized responses (no string injection)\n- Proper HTTP status codes\n- Comprehensive error handling\n- Request/response logging\n\n## Monitoring and Logging\n\n### Health Checks\n\nUse the `/health` endpoint for:\n- Load balancer health checks\n- Container orchestration health probes\n- Monitoring system status checks\n\n### Logging\n\nThe application logs:\n- Request information (INFO level)\n- Validation errors (WARNING level)\n- Internal errors (ERROR level)\n\nLog format includes timestamp, level, and message details.\n\n## Troubleshooting\n\n### Common Issues\n\n#### Port Already in Use\n\n**Error**: `OSError: [Errno 48] Address already in use`\n\n**Solution**: Use a different port:\n```bash\nuvicorn main:app --port 8001\n```\n\n#### Import Errors\n\n**Error**: `ModuleNotFoundError: No module named 'fastapi'`\n\n**Solution**: Install dependencies:\n```bash\npip install -r requirements.txt\n```\n\n#### Permission Denied (Port 80/443)\n\n**Error**: `PermissionError: [Errno 13] Permission denied`\n\n**Solution**: Use a port above 1024 or run with sudo (not recommended):\n```bash\nuvicorn main:app --port 8080\n```\n\n#### Invalid Name Parameter\n\n**Error**: 400 Bad Request with INVALID_NAME code\n\n**Solution**: Ensure name parameter:\n- Contains only letters, numbers, and spaces\n- Is 100 characters or less\n- Example: `name=John Doe` , `name=John@Doe` \n\n### Performance Issues\n\n#### Slow Response Times\n\n1. **Check system resources**: CPU and memory usage\n2. **Monitor logs**: Look for error patterns\n3. **Use production server**: Run with multiple workers:\n   ```bash\n   uvicorn main:app --workers 4\n   ```\n\n#### High Memory Usage\n\n1. **Update dependencies**: Ensure latest versions\n2. **Monitor for memory leaks**: Use memory profiling tools\n3. **Restart application**: Temporary solution for memory issues\n\n### Debugging\n\n#### Enable Debug Mode\n\nFor development debugging:\n```bash\nuvicorn main:app --reload --log-level debug\n```\n\n#### Check Application Logs\n\nView detailed request/response information in the console output.\n\n#### Validate API Responses\n\nUse the interactive documentation at `/docs` to test endpoints and validate responses.\n\n## Development\n\n### Project Structure\n\n```\nhello-world-api/\n main.py              # FastAPI application and endpoints\n requirements.txt     # Python dependencies\n tests/              # Test files\n    __init__.py\n    test_main.py    # Unit and integration tests\n    conftest.py     # Test configuration\n README",
      "file_type": "documentation",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Comprehensive project documentation with setup instructions, API endpoints, authentication guide, and troubleshooting"
    },
    {
      "file_path": "docs/api_spec.yaml",
      "content": "openapi: 3.0.3\ninfo:\n  title: Hello World API\n  description: Simple REST API that returns greeting messages with optional personalization and health status monitoring\n  version: 1.0.0\n  contact:\n    name: API Support\n    email: support@example.com\n  license:\n    name: MIT\n    url: https://opensource.org/licenses/MIT\n\nservers:\n  - url: http://localhost:8000\n    description: Development server\n  - url: https://api.example.com\n    description: Production server\n\npaths:\n  /hello:\n    get:\n      summary: Get greeting message\n      description: Returns a greeting message with optional personalization via name parameter\n      operationId: getHello\n      tags:\n        - Greeting\n      parameters:\n        - name: name\n          in: query\n          description: Optional name for personalized greeting (alphanumeric and spaces only, max 100 characters)\n          required: false\n          schema:\n            type: string\n            maxLength: 100\n            pattern: '^[a-zA-Z0-9\\s]*$'\n            example: \"John Doe\"\n      responses:\n        '200':\n          description: Successful greeting response\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/HelloResponse'\n              examples:\n                default_greeting:\n                  summary: Default greeting without name\n                  value:\n                    message: \"Hello, World!\"\n                personalized_greeting:\n                  summary: Personalized greeting with name\n                  value:\n                    message: \"Hello, John Doe!\"\n        '400':\n          description: Invalid name parameter\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/ErrorResponse'\n              examples:\n                invalid_characters:\n                  summary: Name contains invalid characters\n                  value:\n                    error:\n                      code: \"INVALID_NAME\"\n                      message: \"Name parameter contains invalid characters or exceeds 100 characters\"\n                too_long:\n                  summary: Name exceeds maximum length\n                  value:\n                    error:\n                      code: \"INVALID_NAME\"\n                      message: \"Name parameter contains invalid characters or exceeds 100 characters\"\n        '500':\n          description: Internal server error\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/ErrorResponse'\n              example:\n                error:\n                  code: \"INTERNAL_ERROR\"\n                  message: \"Internal server error\"\n\n  /health:\n    get:\n      summary: Health check\n      description: Returns application health status and current timestamp for monitoring purposes\n      operationId: getHealth\n      tags:\n        - Health\n      responses:\n        '200':\n          description: Application is healthy\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/HealthResponse'\n              example:\n                status: \"ok\"\n                timestamp: \"2023-12-01T10:30:45.123456Z\"\n        '500':\n          description: Internal server error\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/ErrorResponse'\n              example:\n                error:\n                  code: \"INTERNAL_ERROR\"\n                  message: \"Internal server error\"\n\ncomponents:\n  schemas:\n    HelloResponse:\n      type: object\n      description: Response containing greeting message\n      required:\n        - message\n      properties:\n        message:\n          type: string\n          description: Greeting message, either default or personalized\n          example: \"Hello, World!\"\n          minLength: 1\n          maxLength: 200\n      additionalProperties: false\n\n    HealthResponse:\n      type: object\n      description: Response containing application health status and timestamp\n      required:\n        - status\n        - timestamp\n      properties:\n        status:\n          type: string\n          description: Application health status\n          enum:\n            - \"ok\"\n          example: \"ok\"\n        timestamp:\n          type: string\n          description: Current UTC timestamp in ISO 8601 format\n          format: date-time\n          example: \"2023-12-01T10:30:45.123456Z\"\n          pattern: '^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d{6})?Z$'\n      additionalProperties: false\n\n    ErrorResponse:\n      type: object\n      description: Standard error response format\n      required:\n        - error\n      properties:\n        error:\n          type: object\n          description: Error details\n          required:\n            - code\n            - message\n          properties:\n            code:\n              type: string\n              description: Error code for programmatic handling\n              enum:\n                - \"INVALID_NAME\"\n                - \"INTERNAL_ERROR\"\n              example: \"INVALID_NAME\"\n            message:\n              type: string\n              description: Human-readable error message\n              example: \"Name parameter contains invalid characters or exceeds 100 characters\"\n              minLength: 1\n              maxLength: 500\n          additionalProperties: false\n      additionalProperties: false\n\n    ValidationError:\n      type: object\n      description: Request validation error details\n      required:\n        - error\n      properties:\n        error:\n          type: object\n          required:\n            - code\n            - message\n            - details\n          properties:\n            code:\n              type: string\n              enum:\n                - \"VALIDATION_ERROR\"\n            message:\n              type: string\n              example: \"Request validation failed\"\n            details:\n              type: array\n              items:\n                type: object\n                properties:\n                  field:\n                    type: string\n                    description: Field that failed validation\n                  value:\n                    description: Invalid value provided\n                  constraint:\n                    type: string\n                    description: Validation constraint that was violated\n                required:\n                  - field\n                  - constraint\n\n  parameters:\n    NameParameter:\n      name: name\n      in: query\n      description: Optional name for personalized greeting\n      required: false\n      schema:\n        type: string\n        maxLength: 100\n        pattern: '^[a-zA-Z0-9\\s]*$'\n        example: \"John Doe\"\n      style: form\n      explode: false\n\n  responses:\n    BadRequest:\n      description: Bad request - invalid input parameters\n      content:\n        application/json:\n          schema:\n            $ref: '#/components/schemas/ErrorResponse'\n\n    InternalServerError:\n      description: Internal server error\n      content:\n        application/json:\n          schema:\n            $ref: '#/components/schemas/ErrorResponse'\n\n    ValidationError:\n      description: Request validation failed\n      content:\n        application/json:\n          schema:\n            $ref: '#/components/schemas/ValidationError'\n\n  examples:\n    DefaultGreeting:\n      summary: Default greeting message\n      description: Response when no name parameter is provided\n      value:\n        message: \"Hello, World!\"\n\n    PersonalizedGreeting:\n      summary: Personalized greeting message\n      description: Response when valid name parameter is provided\n      value:\n        message: \"Hello, John Doe!\"\n\n    HealthyStatus:\n      summary: Healthy application status\n      description: Normal health check response\n      value:\n        status: \"ok\"\n        timestamp: \"2023-12-01T10:30:45.123456Z\"\n\n    InvalidNameError:\n      summary: Invalid name parameter error\n      description: Error when name contains invalid characters or is too long\n      value:\n        error:\n          code: \"INVALID_NAME\"\n          message: \"Name parameter contains invalid characters or exceeds 100 characters\"\n\n    InternalError:\n      summary: Internal server error\n      description: Generic server error response\n      value:\n        error:\n          code: \"INTERNAL_ERROR\"\n          message: \"Internal server error\"\n\ntags:\n  - name: Greeting\n    description: Endpoints for greeting functionality\n  - name: Health\n    description: Health check and monitoring endpoints\n\nexternalDocs:\n  description: Find more information about FastAPI\n  url: https://fastapi.tiangolo.com/\n\nx-api-features:\n  - Input validation with regex patterns\n  - Consistent error response format\n  - UTC timestamp generation\n  - No",
      "file_type": "documentation",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "OpenAPI 3.0 specification with complete API documentation, request/response schemas, and authentication details"
    }
  ],
  "file_structure": {
    "src": [
      "main.py"
    ],
    "src/api": [
      "auth.py",
      "tasks.py"
    ],
    "src/models": [
      "user.py",
      "task.py"
    ],
    "src/schemas": [
      "user.py",
      "task.py"
    ],
    "src/utils": [
      "jwt_utils.py",
      "password.py"
    ],
    "src/database": [
      "connection.py"
    ],
    "src/database/migrations": [
      "001_initial_schema.py"
    ],
    "src/middleware": [
      "auth.py"
    ],
    "tests": [
      "test_auth_api.py",
      "test_tasks_api.py",
      "test_user_model.py",
      "test_task_model.py",
      "test_jwt_utils.py",
      "test_password.py",
      "test_middleware.py",
      "conftest.py"
    ],
    ".": [
      "requirements.txt",
      ".env.example",
      "alembic.ini",
      "pytest.ini",
      ".gitignore",
      "README.md"
    ],
    "docs": [
      "api_spec.yaml"
    ]
  },
  "implementation_notes": "Generated using multi-stage approach with 27 files. Manifest estimated 4650 LOC, actual 4556 LOC. Uses 13 external dependencies.",
  "dependencies": [
    "fastapi==0.104.1",
    "uvicorn[standard]==0.24.0",
    "python-jose[cryptography]==3.3.0",
    "bcrypt==4.1.1",
    "pydantic==2.5.0",
    "sqlalchemy==2.0.23",
    "alembic==1.13.0",
    "python-multipart==0.0.6",
    "pytest==7.4.3",
    "pytest-asyncio==0.21.1",
    "httpx==0.25.2",
    "pytest-cov==4.1.0",
    "psycopg2-binary==2.9.9"
  ],
  "setup_instructions": "1. Install Python 3.11+\\n2. Create virtual environment: python -m venv venv\\n3. Activate: source venv/bin/activate (Linux/Mac) or venv\\Scripts\\activate (Windows)\\n4. Install dependencies: pip install -r requirements.txt\\n5. Copy .env.example to .env and configure variables\\n6. Run migrations: alembic upgrade head\\n7. Start server: uvicorn src.main:app --reload\\n8. Run tests: pytest tests/ -v --cov=src",
  "total_lines_of_code": 4556,
  "total_files": 27,
  "test_coverage_target": 80.0,
  "semantic_units_implemented": [
    "SU-005",
    "SU-003",
    "SU-010",
    "SU-008",
    "SU-012",
    "SU-007",
    "SU-001",
    "SU-002",
    "SU-006",
    "SU-011",
    "SU-004",
    "SU-009"
  ],
  "components_implemented": [
    "COMP-007",
    "COMP-006",
    "COMP-004",
    "COMP-005",
    "COMP-010",
    "COMP-008",
    "COMP-011",
    "COMP-012",
    "COMP-009",
    "COMP-002",
    "COMP-001",
    "COMP-003"
  ],
  "agent_version": "1.0.0",
  "generation_timestamp": "2025-11-21T03:58:32.955647"
}