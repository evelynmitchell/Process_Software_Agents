{
  "task_id": "HW-001",
  "project_id": "PROJECT-001",
  "files": [
    {
      "file_path": "src/main.py",
      "content": "\"\"\"\nFastAPI Hello World Application\n\nMain application entry point with CORS middleware, router registration, and startup configuration.\nProvides /hello and /health endpoints with comprehensive error handling.\n\nComponent ID: COMP-001\nSemantic Unit: SU-001\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport re\nfrom datetime import datetime\nfrom typing import Optional\n\nfrom fastapi import FastAPI, HTTPException, Query, Request\nfrom fastapi.exceptions import RequestValidationError\nfrom fastapi.responses import JSONResponse\nfrom pydantic import BaseModel\n\n\nclass HelloResponse(BaseModel):\n    \"\"\"Response model for /hello endpoint.\"\"\"\n    message: str\n\n\nclass HealthResponse(BaseModel):\n    \"\"\"Response model for /health endpoint.\"\"\"\n    status: str\n    timestamp: str\n\n\nclass ErrorResponse(BaseModel):\n    \"\"\"Response model for error responses.\"\"\"\n    code: str\n    message: str\n\n\ndef create_app() -> FastAPI:\n    \"\"\"\n    Create and configure FastAPI application instance.\n    \n    Returns:\n        FastAPI: Configured application instance\n    \"\"\"\n    app = FastAPI(\n        title=\"Hello World API\",\n        description=\"Simple REST API with greeting and health check endpoints\",\n        version=\"1.0.0\",\n    )\n    \n    setup_error_handlers(app)\n    return app\n\n\ndef setup_error_handlers(app: FastAPI) -> None:\n    \"\"\"\n    Configure global exception handlers for the application.\n    \n    Args:\n        app: FastAPI application instance\n    \"\"\"\n    \n    @app.exception_handler(RequestValidationError)\n    async def handle_validation_error(request: Request, exc: RequestValidationError) -> JSONResponse:\n        \"\"\"\n        Handle FastAPI validation errors and return 400 response.\n        \n        Args:\n            request: HTTP request object\n            exc: Validation error exception\n            \n        Returns:\n            JSONResponse: 400 error response with INVALID_NAME code\n        \"\"\"\n        return JSONResponse(\n            status_code=400,\n            content={\n                \"code\": \"INVALID_NAME\",\n                \"message\": \"Name parameter contains invalid characters or exceeds 100 characters\"\n            }\n        )\n    \n    @app.exception_handler(HTTPException)\n    async def handle_http_exception(request: Request, exc: HTTPException) -> JSONResponse:\n        \"\"\"\n        Handle HTTP exceptions and return appropriate error response.\n        \n        Args:\n            request: HTTP request object\n            exc: HTTP exception\n            \n        Returns:\n            JSONResponse: Error response with original status and detail\n        \"\"\"\n        # Extract error code from detail if it's in the expected format\n        detail = exc.detail\n        if isinstance(detail, dict) and \"code\" in detail:\n            return JSONResponse(\n                status_code=exc.status_code,\n                content=detail\n            )\n        \n        # Default error response format\n        code = \"INVALID_NAME\" if exc.status_code == 400 else \"INTERNAL_ERROR\"\n        return JSONResponse(\n            status_code=exc.status_code,\n            content={\n                \"code\": code,\n                \"message\": detail if isinstance(detail, str) else \"An error occurred\"\n            }\n        )\n    \n    @app.exception_handler(Exception)\n    async def handle_general_exception(request: Request, exc: Exception) -> JSONResponse:\n        \"\"\"\n        Handle unexpected exceptions and return 500 response.\n        \n        Args:\n            request: HTTP request object\n            exc: General exception\n            \n        Returns:\n            JSONResponse: 500 error response with INTERNAL_ERROR code\n        \"\"\"\n        return JSONResponse(\n            status_code=500,\n            content={\n                \"code\": \"INTERNAL_ERROR\",\n                \"message\": \"Internal server error\"\n            }\n        )\n\n\ndef validate_name(name: str) -> bool:\n    \"\"\"\n    Validate name parameter contains only alphanumeric characters and spaces.\n    \n    Args:\n        name: Name string to validate\n        \n    Returns:\n        bool: True if name is valid, False otherwise\n    \"\"\"\n    if len(name) > 100:\n        return False\n    \n    # Check if name contains only alphanumeric characters and spaces\n    pattern = r'^[a-zA-Z0-9\\s]*$'\n    return bool(re.match(pattern, name))\n\n\ndef sanitize_name(name: str) -> str:\n    \"\"\"\n    Clean and format name parameter for safe usage.\n    \n    Args:\n        name: Raw name string\n        \n    Returns:\n        str: Sanitized and formatted name\n    \"\"\"\n    # Strip whitespace and title-case the name\n    return name.strip().title()\n\n\ndef get_current_timestamp() -> str:\n    \"\"\"\n    Generate ISO 8601 formatted UTC timestamp.\n    \n    Returns:\n        str: Current UTC timestamp in ISO 8601 format\n    \"\"\"\n    return datetime.utcnow().isoformat() + 'Z'\n\n\n# Initialize FastAPI application\napp = create_app()\n\n\n@app.get(\"/hello\", response_model=HelloResponse)\nasync def get_hello(name: Optional[str] = Query(None, max_length=100)) -> HelloResponse:\n    \"\"\"\n    Return greeting message, personalized if name provided.\n    \n    Args:\n        name: Optional name parameter for personalization\n        \n    Returns:\n        HelloResponse: JSON response with greeting message\n        \n    Raises:\n        HTTPException: 400 if name parameter is invalid\n        \n    Example:\n        >>> response = await get_hello()\n        >>> response.message\n        'Hello, World!'\n        \n        >>> response = await get_hello(\"John\")\n        >>> response.message\n        'Hello, John!'\n    \"\"\"\n    if name is None:\n        return HelloResponse(message=\"Hello, World!\")\n    \n    # Validate name parameter\n    if not validate_name(name):\n        raise HTTPException(\n            status_code=400,\n            detail={\n                \"code\": \"INVALID_NAME\",\n                \"message\": \"Name parameter contains invalid characters or exceeds 100 characters\"\n            }\n        )\n    \n    # Sanitize and format name\n    clean_name = sanitize_name(name)\n    \n    # Handle empty name after sanitization\n    if not clean_name:\n        return HelloResponse(message=\"Hello, World!\")\n    \n    return HelloResponse(message=f\"Hello, {clean_name}!\")\n\n\n@app.get(\"/health\", response_model=HealthResponse)\nasync def get_health() -> HealthResponse:\n    \"\"\"\n    Return health status and current UTC timestamp.\n    \n    Returns:\n        HealthResponse: JSON response with status and timestamp\n        \n    Example:\n        >>> response = await get_health()\n        >>> response.status\n        'ok'\n        >>> response.timestamp\n        '2023-12-01T10:30:45.123456Z'\n    \"\"\"\n    timestamp = get_current_timestamp()\n    return HealthResponse(status=\"ok\", timestamp=timestamp)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)",
      "file_type": "source",
      "semantic_unit_id": "SU-001",
      "component_id": "COMP-001",
      "description": "FastAPI application entry point with CORS middleware, router registration, and startup configuration"
    },
    {
      "file_path": "src/api/auth.py",
      "content": "\"\"\"\nAuthentication API endpoints for user registration, login, token refresh, and logout.\n\nThis module provides JWT-based authentication endpoints with secure password handling\nand token management for user authentication and authorization.\n\nComponent ID: COMP-002\nSemantic Unit: SU-002\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport logging\nfrom datetime import datetime, timedelta\nfrom typing import Optional\n\nfrom fastapi import APIRouter, Depends, HTTPException, status\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nfrom pydantic import BaseModel, EmailStr, Field\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy.exc import IntegrityError\n\nfrom src.database.connection import get_db_session\nfrom src.models.user import User\nfrom src.utils.jwt_utils import (\n    create_access_token,\n    create_refresh_token,\n    verify_token,\n    decode_token,\n    blacklist_token,\n    is_token_blacklisted\n)\nfrom src.utils.password import hash_password, verify_password\n\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Initialize router and security\nrouter = APIRouter(prefix=\"/auth\", tags=[\"authentication\"])\nsecurity = HTTPBearer()\n\n\n# Request/Response Models\nclass UserRegistrationRequest(BaseModel):\n    \"\"\"Request model for user registration.\"\"\"\n    email: EmailStr = Field(..., description=\"User email address\")\n    password: str = Field(..., min_length=8, max_length=128, description=\"User password\")\n    first_name: str = Field(..., min_length=1, max_length=50, description=\"User first name\")\n    last_name: str = Field(..., min_length=1, max_length=50, description=\"User last name\")\n\n\nclass UserLoginRequest(BaseModel):\n    \"\"\"Request model for user login.\"\"\"\n    email: EmailStr = Field(..., description=\"User email address\")\n    password: str = Field(..., description=\"User password\")\n\n\nclass TokenRefreshRequest(BaseModel):\n    \"\"\"Request model for token refresh.\"\"\"\n    refresh_token: str = Field(..., description=\"Valid refresh token\")\n\n\nclass AuthResponse(BaseModel):\n    \"\"\"Response model for authentication endpoints.\"\"\"\n    access_token: str = Field(..., description=\"JWT access token\")\n    refresh_token: str = Field(..., description=\"JWT refresh token\")\n    token_type: str = Field(default=\"bearer\", description=\"Token type\")\n    expires_in: int = Field(..., description=\"Token expiration time in seconds\")\n\n\nclass UserResponse(BaseModel):\n    \"\"\"Response model for user information.\"\"\"\n    id: int = Field(..., description=\"User ID\")\n    email: str = Field(..., description=\"User email address\")\n    first_name: str = Field(..., description=\"User first name\")\n    last_name: str = Field(..., description=\"User last name\")\n    created_at: datetime = Field(..., description=\"User creation timestamp\")\n    is_active: bool = Field(..., description=\"User active status\")\n\n\nclass MessageResponse(BaseModel):\n    \"\"\"Response model for simple messages.\"\"\"\n    message: str = Field(..., description=\"Response message\")\n\n\n# Dependency functions\ndef get_current_user(\n    credentials: HTTPAuthorizationCredentials = Depends(security),\n    db: Session = Depends(get_db_session)\n) -> User:\n    \"\"\"\n    Get current authenticated user from JWT token.\n    \n    Args:\n        credentials: HTTP authorization credentials containing JWT token\n        db: Database session\n        \n    Returns:\n        User: Current authenticated user\n        \n    Raises:\n        HTTPException: If token is invalid, expired, or user not found\n    \"\"\"\n    token = credentials.credentials\n    \n    # Check if token is blacklisted\n    if is_token_blacklisted(token):\n        logger.warning(\"Attempt to use blacklisted token\")\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Token has been revoked\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n    \n    # Verify and decode token\n    try:\n        payload = verify_token(token)\n        user_id = payload.get(\"sub\")\n        if user_id is None:\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Invalid token payload\",\n                headers={\"WWW-Authenticate\": \"Bearer\"},\n            )\n    except Exception as e:\n        logger.warning(f\"Token verification failed: {str(e)}\")\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Invalid or expired token\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n    \n    # Get user from database\n    user = db.query(User).filter(User.id == int(user_id)).first()\n    if user is None:\n        logger.warning(f\"User not found for token: {user_id}\")\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"User not found\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n    \n    if not user.is_active:\n        logger.warning(f\"Inactive user attempted access: {user.email}\")\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"User account is inactive\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n    \n    return user\n\n\ndef validate_password_strength(password: str) -> None:\n    \"\"\"\n    Validate password meets security requirements.\n    \n    Args:\n        password: Password to validate\n        \n    Raises:\n        HTTPException: If password doesn't meet requirements\n    \"\"\"\n    if len(password) < 8:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Password must be at least 8 characters long\"\n        )\n    \n    if len(password) > 128:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Password must be no more than 128 characters long\"\n        )\n    \n    # Check for at least one uppercase letter\n    if not any(c.isupper() for c in password):\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Password must contain at least one uppercase letter\"\n        )\n    \n    # Check for at least one lowercase letter\n    if not any(c.islower() for c in password):\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Password must contain at least one lowercase letter\"\n        )\n    \n    # Check for at least one digit\n    if not any(c.isdigit() for c in password):\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Password must contain at least one digit\"\n        )\n\n\ndef sanitize_user_input(value: str) -> str:\n    \"\"\"\n    Sanitize user input to prevent injection attacks.\n    \n    Args:\n        value: Input string to sanitize\n        \n    Returns:\n        str: Sanitized string\n    \"\"\"\n    if not isinstance(value, str):\n        return str(value)\n    \n    # Strip whitespace and limit length\n    sanitized = value.strip()[:255]\n    \n    # Remove null bytes and control characters\n    sanitized = ''.join(char for char in sanitized if ord(char) >= 32 or char in '\\t\\n\\r')\n    \n    return sanitized\n\n\n# Authentication endpoints\n@router.post(\"/register\", response_model=AuthResponse, status_code=status.HTTP_201_CREATED)\ndef register_user(\n    user_data: UserRegistrationRequest,\n    db: Session = Depends(get_db_session)\n) -> AuthResponse:\n    \"\"\"\n    Register a new user account.\n    \n    Args:\n        user_data: User registration data\n        db: Database session\n        \n    Returns:\n        AuthResponse: JWT tokens and user information\n        \n    Raises:\n        HTTPException: If email already exists or validation fails\n    \"\"\"\n    logger.info(f\"User registration attempt for email: {user_data.email}\")\n    \n    # Validate password strength\n    validate_password_strength(user_",
      "file_type": "source",
      "semantic_unit_id": "SU-002",
      "component_id": "COMP-002",
      "description": "Authentication API endpoints for user registration, login, token refresh, and logout with JWT token management"
    },
    {
      "file_path": "src/api/tasks.py",
      "content": "\"\"\"\nTask management API endpoints for CRUD operations with authentication middleware and user-specific filtering.\n\nThis module provides REST API endpoints for managing tasks including creation, retrieval,\nupdating, and deletion with proper authentication and user-specific data filtering.\n\nComponent ID: COMP-003\nSemantic Unit: SU-003\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport logging\nfrom datetime import datetime\nfrom typing import List, Optional\nfrom uuid import UUID\n\nfrom fastapi import APIRouter, Depends, HTTPException, Query, status\nfrom fastapi.security import HTTPBearer\nfrom pydantic import BaseModel, Field, validator\nfrom sqlalchemy.exc import SQLAlchemyError\nfrom sqlalchemy.orm import Session\n\nfrom src.database.connection import get_db_session\nfrom src.models.task import Task, TaskStatus, TaskPriority\nfrom src.models.user import User\nfrom src.utils.jwt_utils import decode_jwt_token, get_current_user\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Initialize router and security\nrouter = APIRouter(prefix=\"/api/v1/tasks\", tags=[\"tasks\"])\nsecurity = HTTPBearer()\n\n\nclass TaskCreateRequest(BaseModel):\n    \"\"\"Request model for creating a new task.\"\"\"\n    \n    title: str = Field(..., min_length=1, max_length=200, description=\"Task title\")\n    description: Optional[str] = Field(None, max_length=1000, description=\"Task description\")\n    priority: TaskPriority = Field(TaskPriority.MEDIUM, description=\"Task priority level\")\n    due_date: Optional[datetime] = Field(None, description=\"Task due date\")\n    \n    @validator('title')\n    def validate_title(cls, v: str) -> str:\n        \"\"\"Validate and sanitize task title.\"\"\"\n        if not v or not v.strip():\n            raise ValueError(\"Title cannot be empty or whitespace only\")\n        return v.strip()\n    \n    @validator('description')\n    def validate_description(cls, v: Optional[str]) -> Optional[str]:\n        \"\"\"Validate and sanitize task description.\"\"\"\n        if v is not None:\n            return v.strip() if v.strip() else None\n        return v\n    \n    @validator('due_date')\n    def validate_due_date(cls, v: Optional[datetime]) -> Optional[datetime]:\n        \"\"\"Validate due date is not in the past.\"\"\"\n        if v is not None and v < datetime.utcnow():\n            raise ValueError(\"Due date cannot be in the past\")\n        return v\n\n\nclass TaskUpdateRequest(BaseModel):\n    \"\"\"Request model for updating an existing task.\"\"\"\n    \n    title: Optional[str] = Field(None, min_length=1, max_length=200, description=\"Task title\")\n    description: Optional[str] = Field(None, max_length=1000, description=\"Task description\")\n    status: Optional[TaskStatus] = Field(None, description=\"Task status\")\n    priority: Optional[TaskPriority] = Field(None, description=\"Task priority level\")\n    due_date: Optional[datetime] = Field(None, description=\"Task due date\")\n    \n    @validator('title')\n    def validate_title(cls, v: Optional[str]) -> Optional[str]:\n        \"\"\"Validate and sanitize task title.\"\"\"\n        if v is not None:\n            if not v or not v.strip():\n                raise ValueError(\"Title cannot be empty or whitespace only\")\n            return v.strip()\n        return v\n    \n    @validator('description')\n    def validate_description(cls, v: Optional[str]) -> Optional[str]:\n        \"\"\"Validate and sanitize task description.\"\"\"\n        if v is not None:\n            return v.strip() if v.strip() else None\n        return v\n    \n    @validator('due_date')\n    def validate_due_date(cls, v: Optional[datetime]) -> Optional[datetime]:\n        \"\"\"Validate due date is not in the past.\"\"\"\n        if v is not None and v < datetime.utcnow():\n            raise ValueError(\"Due date cannot be in the past\")\n        return v\n\n\nclass TaskResponse(BaseModel):\n    \"\"\"Response model for task data.\"\"\"\n    \n    id: UUID\n    title: str\n    description: Optional[str]\n    status: TaskStatus\n    priority: TaskPriority\n    due_date: Optional[datetime]\n    created_at: datetime\n    updated_at: datetime\n    user_id: UUID\n    \n    class Config:\n        from_attributes = True\n\n\nclass TaskListResponse(BaseModel):\n    \"\"\"Response model for task list with pagination metadata.\"\"\"\n    \n    tasks: List[TaskResponse]\n    total: int\n    page: int\n    page_size: int\n    total_pages: int\n\n\ndef validate_task_ownership(task: Task, user: User) -> None:\n    \"\"\"\n    Validate that the current user owns the specified task.\n    \n    Args:\n        task: Task instance to validate\n        user: Current authenticated user\n        \n    Raises:\n        HTTPException: If user doesn't own the task\n    \"\"\"\n    if task.user_id != user.id:\n        logger.warning(f\"User {user.id} attempted to access task {task.id} owned by {task.user_id}\")\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Access denied: You can only access your own tasks\"\n        )\n\n\ndef get_task_by_id(task_id: UUID, db: Session, user: User) -> Task:\n    \"\"\"\n    Retrieve a task by ID and validate ownership.\n    \n    Args:\n        task_id: UUID of the task to retrieve\n        db: Database session\n        user: Current authenticated user\n        \n    Returns:\n        Task: The requested task\n        \n    Raises:\n        HTTPException: If task not found or access denied\n    \"\"\"\n    try:\n        task = db.query(Task).filter(Task.id == task_id).first()\n        if not task:\n            raise HTTPException(\n                status_code=status.HTTP_404_NOT_FOUND,\n                detail=f\"Task with ID {task_id} not found\"\n            )\n        \n        validate_task_ownership(task, user)\n        return task\n        \n    except SQLAlchemyError as e:\n        logger.error(f\"Database error retrieving task {task_id}: {str(e)}\")\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Database error occurred while retrieving task\"\n        )\n\n\n@router.post(\"/\", response_model=TaskResponse, status_code=status.HTTP_201_CREATED)\ndef create_task(\n    task_data: TaskCreateRequest,\n    db: Session = Depends(get_db_session),\n    current_user: User = Depends(get_current_user)\n) -> TaskResponse:\n    \"\"\"\n    Create a new task for the authenticated user.\n    \n    Args:\n        task_data: Task creation data\n        db: Database session\n        current_user: Authenticated user\n        \n    Returns:\n        TaskResponse: Created task data\n        \n    Raises:\n        HTTPException: If task creation fails\n    \"\"\"\n    try:\n        logger.info(f\"Creating new task for user {current_user.id}\")\n        \n        # Create new task instance\n        new_task = Task(\n            title=task_data.title,\n            description=task_data.description,\n            priority=task_data.priority,\n            due_date=task_data.due_date,\n            status=TaskStatus.TODO,\n            user_id=current_user.id,\n            created_at=datetime.utcnow(),\n            updated_at=datetime.utcnow()\n        )\n        \n        # Save to database\n        db.add(new_task)\n        db.commit()\n        db.refresh(new_task)\n        \n        logger.info(f\"Successfully created task {new_task.id} for user {current_user.id}\")\n        return TaskResponse.from_orm(new_task)\n        \n    except SQLAlchemyError as e:\n        logger.error(f\"Database error creating task: {str(e)}\")\n        db.rollback()\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Database error occurred while creating task",
      "file_type": "source",
      "semantic_unit_id": "SU-003",
      "component_id": "COMP-003",
      "description": "Task management API endpoints for CRUD operations with authentication middleware and user-specific filtering"
    },
    {
      "file_path": "src/models/user.py",
      "content": "\"\"\"\nUser SQLAlchemy model with authentication fields, profile data, and relationship to tasks.\n\nThis module defines the User model for the application with authentication capabilities,\nprofile information, and relationships to other entities.\n\nComponent ID: COMP-004\nSemantic Unit: SU-004\n\nAuthor: ASP Code Generator\n\"\"\"\n\nfrom datetime import datetime\nfrom typing import Optional, List\nfrom sqlalchemy import Column, Integer, String, DateTime, Boolean, Text\nfrom sqlalchemy.orm import relationship\nfrom sqlalchemy.sql import func\nfrom werkzeug.security import generate_password_hash, check_password_hash\nimport re\n\nfrom src.database.connection import Base\n\n\nclass User(Base):\n    \"\"\"\n    User model for authentication and profile management.\n    \n    This model handles user authentication, profile data, and relationships\n    to other entities in the system. Includes password hashing, email validation,\n    and timestamp tracking.\n    \n    Attributes:\n        id: Primary key identifier\n        username: Unique username for login\n        email: Unique email address\n        password_hash: Hashed password for authentication\n        first_name: User's first name\n        last_name: User's last name\n        is_active: Whether the user account is active\n        is_verified: Whether the user's email is verified\n        created_at: Timestamp when user was created\n        updated_at: Timestamp when user was last updated\n        last_login: Timestamp of last successful login\n        bio: Optional user biography\n        tasks: Relationship to user's tasks\n    \"\"\"\n    \n    __tablename__ = \"users\"\n    \n    # Primary key\n    id = Column(Integer, primary_key=True, index=True)\n    \n    # Authentication fields\n    username = Column(String(50), unique=True, index=True, nullable=False)\n    email = Column(String(255), unique=True, index=True, nullable=False)\n    password_hash = Column(String(255), nullable=False)\n    \n    # Profile fields\n    first_name = Column(String(100), nullable=False)\n    last_name = Column(String(100), nullable=False)\n    bio = Column(Text, nullable=True)\n    \n    # Status fields\n    is_active = Column(Boolean, default=True, nullable=False)\n    is_verified = Column(Boolean, default=False, nullable=False)\n    \n    # Timestamp fields\n    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)\n    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False)\n    last_login = Column(DateTime(timezone=True), nullable=True)\n    \n    # Relationships\n    tasks = relationship(\"Task\", back_populates=\"user\", cascade=\"all, delete-orphan\")\n    \n    def __init__(\n        self,\n        username: str,\n        email: str,\n        password: str,\n        first_name: str,\n        last_name: str,\n        bio: Optional[str] = None,\n        is_active: bool = True,\n        is_verified: bool = False\n    ) -> None:\n        \"\"\"\n        Initialize a new User instance.\n        \n        Args:\n            username: Unique username for the user\n            email: User's email address\n            password: Plain text password (will be hashed)\n            first_name: User's first name\n            last_name: User's last name\n            bio: Optional biography text\n            is_active: Whether the account is active\n            is_verified: Whether the email is verified\n            \n        Raises:\n            ValueError: If username, email, or password validation fails\n        \"\"\"\n        self.username = self._validate_username(username)\n        self.email = self._validate_email(email)\n        self.set_password(password)\n        self.first_name = self._validate_name(first_name, \"first_name\")\n        self.last_name = self._validate_name(last_name, \"last_name\")\n        self.bio = bio\n        self.is_active = is_active\n        self.is_verified = is_verified\n    \n    def set_password(self, password: str) -> None:\n        \"\"\"\n        Set the user's password by hashing it.\n        \n        Args:\n            password: Plain text password to hash and store\n            \n        Raises:\n            ValueError: If password doesn't meet requirements\n        \"\"\"\n        if not self._validate_password(password):\n            raise ValueError(\n                \"Password must be at least 8 characters long and contain \"\n                \"at least one uppercase letter, one lowercase letter, and one digit\"\n            )\n        \n        self.password_hash = generate_password_hash(password, method='pbkdf2:sha256')\n    \n    def check_password(self, password: str) -> bool:\n        \"\"\"\n        Check if the provided password matches the stored hash.\n        \n        Args:\n            password: Plain text password to verify\n            \n        Returns:\n            bool: True if password matches, False otherwise\n        \"\"\"\n        if not password or not self.password_hash:\n            return False\n        \n        return check_password_hash(self.password_hash, password)\n    \n    def update_last_login(self) -> None:\n        \"\"\"Update the last_login timestamp to current time.\"\"\"\n        self.last_login = datetime.utcnow()\n    \n    def get_full_name(self) -> str:\n        \"\"\"\n        Get the user's full name.\n        \n        Returns:\n            str: Formatted full name (first_name last_name)\n        \"\"\"\n        return f\"{self.first_name} {self.last_name}\".strip()\n    \n    def to_dict(self, include_sensitive: bool = False) -> dict:\n        \"\"\"\n        Convert user instance to dictionary.\n        \n        Args:\n            include_sensitive: Whether to include sensitive fields like password_hash\n            \n        Returns:\n            dict: User data as dictionary\n        \"\"\"\n        user_dict = {\n            \"id\": self.id,\n            \"username\": self.username,\n            \"email\": self.email,\n            \"first_name\": self.first_name,\n            \"last_name\": self.last_name,\n            \"full_name\": self.get_full_name(),\n            \"bio\": self.bio,\n            \"is_active\": self.is_active,\n            \"is_verified\": self.is_verified,\n            \"created_at\": self.created_at.isoformat() if self.created_at else None,\n            \"updated_at\": self.updated_at.isoformat() if self.updated_at else None,\n            \"last_login\": self.last_login.isoformat() if self.last_login else None,\n        }\n        \n        if include_sensitive:\n            user_dict[\"password_hash\"] = self.password_hash\n        \n        return user_dict\n    \n    @staticmethod\n    def _validate_username(username: str) -> str:\n        \"\"\"\n        Validate username format and requirements.\n        \n        Args:\n            username: Username to validate\n            \n        Returns:\n            str: Validated username\n            \n        Raises:\n            ValueError: If username is invalid\n        \"\"\"\n        if not username or not isinstance(username, str):\n            raise ValueError(\"Username is required and must be a string\")\n        \n        username = username.strip()\n        \n        if len(username) < 3 or len(username) > 50:\n            raise ValueError(\"Username must be between 3 and 50 characters\")\n        \n        if not re.match(r'^[a-zA-Z0-9_-]+$', username):\n            raise ValueError(\"Username can only contain letters, numbers, underscores, and hyphens\")\n        \n        return username\n    \n    @staticmethod\n    def _validate_email(email: str) -> str:\n        \"\"\"\n        Validate email format.\n        \n        Args:\n            email: Email address to validate\n            \n        Returns:\n            str: Validated email address\n            \n        Raises:\n            ValueError: If email is invalid\n        \"\"\"\n        if not email or not isinstance(email, str):\n            raise ValueError(\"Email is required and must be a string\")\n        \n        email = email.strip().lower()\n        \n        if len(email) > 255:\n            raise ValueError(\"Email address is too long (maximum",
      "file_type": "source",
      "semantic_unit_id": "SU-004",
      "component_id": "COMP-004",
      "description": "User SQLAlchemy model with authentication fields, profile data, and relationship to tasks"
    },
    {
      "file_path": "src/models/task.py",
      "content": "\"\"\"\nTask SQLAlchemy model with CRUD operations, status management, and foreign key relationship to users.\n\nThis module defines the Task model with comprehensive CRUD operations, status transitions,\nand proper relationship management with the User model.\n\nComponent ID: COMP-005\nSemantic Unit: SU-005\n\nAuthor: ASP Code Agent\n\"\"\"\n\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import List, Optional, Dict, Any\nfrom sqlalchemy import Column, Integer, String, Text, DateTime, ForeignKey, Boolean, Index\nfrom sqlalchemy.orm import relationship, Session\nfrom sqlalchemy.exc import SQLAlchemyError\nimport logging\n\nfrom src.database.connection import Base\nfrom src.models.user import User\n\nlogger = logging.getLogger(__name__)\n\n\nclass TaskStatus(str, Enum):\n    \"\"\"Enumeration of possible task statuses.\"\"\"\n    PENDING = \"pending\"\n    IN_PROGRESS = \"in_progress\"\n    COMPLETED = \"completed\"\n    CANCELLED = \"cancelled\"\n\n\nclass TaskPriority(str, Enum):\n    \"\"\"Enumeration of task priorities.\"\"\"\n    LOW = \"low\"\n    MEDIUM = \"medium\"\n    HIGH = \"high\"\n    URGENT = \"urgent\"\n\n\nclass Task(Base):\n    \"\"\"\n    Task model representing a user task with status management and CRUD operations.\n    \n    This model provides comprehensive task management functionality including\n    status transitions, priority levels, and user relationships.\n    \"\"\"\n    \n    __tablename__ = \"tasks\"\n    \n    # Primary key\n    id = Column(Integer, primary_key=True, index=True, autoincrement=True)\n    \n    # Task details\n    title = Column(String(200), nullable=False, index=True)\n    description = Column(Text, nullable=True)\n    status = Column(String(20), nullable=False, default=TaskStatus.PENDING.value, index=True)\n    priority = Column(String(10), nullable=False, default=TaskPriority.MEDIUM.value, index=True)\n    \n    # Timestamps\n    created_at = Column(DateTime, nullable=False, default=datetime.utcnow, index=True)\n    updated_at = Column(DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)\n    due_date = Column(DateTime, nullable=True, index=True)\n    completed_at = Column(DateTime, nullable=True)\n    \n    # User relationship\n    user_id = Column(Integer, ForeignKey(\"users.id\", ondelete=\"CASCADE\"), nullable=False, index=True)\n    \n    # Soft delete flag\n    is_deleted = Column(Boolean, nullable=False, default=False, index=True)\n    \n    # Relationships\n    user = relationship(\"User\", back_populates=\"tasks\")\n    \n    # Indexes for performance\n    __table_args__ = (\n        Index(\"idx_task_user_status\", \"user_id\", \"status\"),\n        Index(\"idx_task_user_priority\", \"user_id\", \"priority\"),\n        Index(\"idx_task_due_date_status\", \"due_date\", \"status\"),\n        Index(\"idx_task_created_user\", \"created_at\", \"user_id\"),\n    )\n    \n    def __repr__(self) -> str:\n        \"\"\"String representation of the Task model.\"\"\"\n        return f\"<Task(id={self.id}, title='{self.title}', status='{self.status}', user_id={self.user_id})>\"\n    \n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Convert task instance to dictionary representation.\n        \n        Returns:\n            Dict[str, Any]: Dictionary containing task data\n        \"\"\"\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"status\": self.status,\n            \"priority\": self.priority,\n            \"created_at\": self.created_at.isoformat() if self.created_at else None,\n            \"updated_at\": self.updated_at.isoformat() if self.updated_at else None,\n            \"due_date\": self.due_date.isoformat() if self.due_date else None,\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None,\n            \"user_id\": self.user_id,\n            \"is_deleted\": self.is_deleted\n        }\n    \n    def update_status(self, new_status: TaskStatus) -> bool:\n        \"\"\"\n        Update task status with validation and automatic timestamp management.\n        \n        Args:\n            new_status (TaskStatus): New status to set\n            \n        Returns:\n            bool: True if status was updated successfully\n            \n        Raises:\n            ValueError: If status transition is invalid\n        \"\"\"\n        if not self._is_valid_status_transition(self.status, new_status.value):\n            raise ValueError(f\"Invalid status transition from {self.status} to {new_status.value}\")\n        \n        old_status = self.status\n        self.status = new_status.value\n        self.updated_at = datetime.utcnow()\n        \n        # Set completion timestamp when task is completed\n        if new_status == TaskStatus.COMPLETED and old_status != TaskStatus.COMPLETED.value:\n            self.completed_at = datetime.utcnow()\n        elif new_status != TaskStatus.COMPLETED and self.completed_at:\n            self.completed_at = None\n            \n        logger.info(f\"Task {self.id} status updated from {old_status} to {new_status.value}\")\n        return True\n    \n    def _is_valid_status_transition(self, current_status: str, new_status: str) -> bool:\n        \"\"\"\n        Validate if status transition is allowed.\n        \n        Args:\n            current_status (str): Current task status\n            new_status (str): Proposed new status\n            \n        Returns:\n            bool: True if transition is valid\n        \"\"\"\n        valid_transitions = {\n            TaskStatus.PENDING.value: [TaskStatus.IN_PROGRESS.value, TaskStatus.CANCELLED.value],\n            TaskStatus.IN_PROGRESS.value: [TaskStatus.COMPLETED.value, TaskStatus.PENDING.value, TaskStatus.CANCELLED.value],\n            TaskStatus.COMPLETED.value: [TaskStatus.IN_PROGRESS.value],\n            TaskStatus.CANCELLED.value: [TaskStatus.PENDING.value, TaskStatus.IN_PROGRESS.value]\n        }\n        \n        return new_status in valid_transitions.get(current_status, [])\n    \n    def is_overdue(self) -> bool:\n        \"\"\"\n        Check if task is overdue based on due_date.\n        \n        Returns:\n            bool: True if task is overdue\n        \"\"\"\n        if not self.due_date or self.status == TaskStatus.COMPLETED.value:\n            return False\n        return datetime.utcnow() > self.due_date\n    \n    @classmethod\n    def create(cls, db: Session, title: str, user_id: int, description: Optional[str] = None,\n               priority: TaskPriority = TaskPriority.MEDIUM, due_date: Optional[datetime] = None) -> \"Task\":\n        \"\"\"\n        Create a new task with validation.\n        \n        Args:\n            db (Session): Database session\n            title (str): Task title (max 200 characters)\n            user_id (int): ID of the user who owns the task\n            description (Optional[str]): Task description\n            priority (TaskPriority): Task priority level\n            due_date (Optional[datetime]): Task due date\n            \n        Returns:\n            Task: Created task instance\n            \n        Raises:\n            ValueError: If validation fails\n            SQLAlchemyError: If database operation fails\n        \"\"\"\n        # Validate inputs\n        if not title or len(title.strip()) == 0:\n            raise ValueError(\"Task title cannot be empty\")\n        if len(title) > 200:\n            raise ValueError(\"Task title cannot exceed 200 characters\")\n        if due_date and due_date < datetime.utcnow():\n            raise ValueError(\"Due date cannot be in the past\")\n            \n        # Verify user exists\n        user = db.query(User).",
      "file_type": "source",
      "semantic_unit_id": "SU-005",
      "component_id": "COMP-005",
      "description": "Task SQLAlchemy model with CRUD operations, status management, and foreign key relationship to users"
    },
    {
      "file_path": "src/schemas/user.py",
      "content": "\"\"\"\nPydantic schemas for user data validation and serialization.\n\nThis module defines all Pydantic models used for user-related operations including\nregistration, authentication, profile management, and API response serialization.\n\nComponent ID: COMP-006\nSemantic Unit: SU-006\n\nAuthor: ASP Code Agent\n\"\"\"\n\nfrom datetime import datetime\nfrom typing import Optional\nfrom pydantic import BaseModel, EmailStr, Field, validator\nimport re\n\n\nclass UserRegistrationRequest(BaseModel):\n    \"\"\"\n    Schema for user registration requests.\n    \n    Validates user input for creating new accounts including email format,\n    password strength, and username requirements.\n    \"\"\"\n    username: str = Field(\n        ...,\n        min_length=3,\n        max_length=50,\n        description=\"Username must be 3-50 characters, alphanumeric and underscores only\"\n    )\n    email: EmailStr = Field(\n        ...,\n        description=\"Valid email address\"\n    )\n    password: str = Field(\n        ...,\n        min_length=8,\n        max_length=128,\n        description=\"Password must be 8-128 characters with at least one uppercase, lowercase, digit, and special character\"\n    )\n    full_name: str = Field(\n        ...,\n        min_length=1,\n        max_length=100,\n        description=\"Full name, 1-100 characters\"\n    )\n    \n    @validator('username')\n    def validate_username(cls, v: str) -> str:\n        \"\"\"\n        Validate username contains only alphanumeric characters and underscores.\n        \n        Args:\n            v: Username string to validate\n            \n        Returns:\n            str: Validated username\n            \n        Raises:\n            ValueError: If username contains invalid characters\n        \"\"\"\n        if not re.match(r'^[a-zA-Z0-9_]+$', v):\n            raise ValueError('Username must contain only alphanumeric characters and underscores')\n        return v.lower()\n    \n    @validator('password')\n    def validate_password_strength(cls, v: str) -> str:\n        \"\"\"\n        Validate password meets security requirements.\n        \n        Args:\n            v: Password string to validate\n            \n        Returns:\n            str: Validated password\n            \n        Raises:\n            ValueError: If password doesn't meet requirements\n        \"\"\"\n        if not re.search(r'[A-Z]', v):\n            raise ValueError('Password must contain at least one uppercase letter')\n        if not re.search(r'[a-z]', v):\n            raise ValueError('Password must contain at least one lowercase letter')\n        if not re.search(r'\\d', v):\n            raise ValueError('Password must contain at least one digit')\n        if not re.search(r'[!@#$%^&*(),.?\":{}|<>]', v):\n            raise ValueError('Password must contain at least one special character')\n        return v\n    \n    @validator('full_name')\n    def validate_full_name(cls, v: str) -> str:\n        \"\"\"\n        Validate and sanitize full name.\n        \n        Args:\n            v: Full name string to validate\n            \n        Returns:\n            str: Sanitized full name\n            \n        Raises:\n            ValueError: If full name contains invalid characters\n        \"\"\"\n        # Allow letters, spaces, hyphens, and apostrophes\n        if not re.match(r\"^[a-zA-Z\\s\\-']+$\", v):\n            raise ValueError('Full name must contain only letters, spaces, hyphens, and apostrophes')\n        return v.strip().title()\n\n\nclass UserLoginRequest(BaseModel):\n    \"\"\"\n    Schema for user login requests.\n    \n    Validates user credentials for authentication.\n    \"\"\"\n    username: str = Field(\n        ...,\n        min_length=3,\n        max_length=50,\n        description=\"Username or email address\"\n    )\n    password: str = Field(\n        ...,\n        min_length=1,\n        max_length=128,\n        description=\"User password\"\n    )\n    \n    @validator('username')\n    def normalize_username(cls, v: str) -> str:\n        \"\"\"\n        Normalize username for consistent lookup.\n        \n        Args:\n            v: Username string to normalize\n            \n        Returns:\n            str: Normalized username\n        \"\"\"\n        return v.lower().strip()\n\n\nclass UserProfileUpdateRequest(BaseModel):\n    \"\"\"\n    Schema for user profile update requests.\n    \n    Allows partial updates to user profile information.\n    \"\"\"\n    full_name: Optional[str] = Field(\n        None,\n        min_length=1,\n        max_length=100,\n        description=\"Updated full name\"\n    )\n    email: Optional[EmailStr] = Field(\n        None,\n        description=\"Updated email address\"\n    )\n    \n    @validator('full_name')\n    def validate_full_name(cls, v: Optional[str]) -> Optional[str]:\n        \"\"\"\n        Validate and sanitize full name if provided.\n        \n        Args:\n            v: Full name string to validate\n            \n        Returns:\n            Optional[str]: Sanitized full name or None\n            \n        Raises:\n            ValueError: If full name contains invalid characters\n        \"\"\"\n        if v is None:\n            return v\n        \n        # Allow letters, spaces, hyphens, and apostrophes\n        if not re.match(r\"^[a-zA-Z\\s\\-']+$\", v):\n            raise ValueError('Full name must contain only letters, spaces, hyphens, and apostrophes')\n        return v.strip().title()\n\n\nclass PasswordChangeRequest(BaseModel):\n    \"\"\"\n    Schema for password change requests.\n    \n    Validates current password and new password for security.\n    \"\"\"\n    current_password: str = Field(\n        ...,\n        min_length=1,\n        max_length=128,\n        description=\"Current password for verification\"\n    )\n    new_password: str = Field(\n        ...,\n        min_length=8,\n        max_length=128,\n        description=\"New password meeting security requirements\"\n    )\n    \n    @validator('new_password')\n    def validate_new_password_strength(cls, v: str) -> str:\n        \"\"\"\n        Validate new password meets security requirements.\n        \n        Args:\n            v: New password string to validate\n            \n        Returns:\n            str: Validated new password\n            \n        Raises:\n            ValueError: If password doesn't meet requirements\n        \"\"\"\n        if not re.search(r'[A-Z]', v):\n            raise ValueError('Password must contain at least one uppercase letter')\n        if not re.search(r'[a-z]', v):\n            raise ValueError('Password must contain at least one lowercase letter')\n        if not re.search(r'\\d', v):\n            raise ValueError('Password must contain at least one digit')\n        if not re.search(r'[!@#$%^&*(),.?\":{}|<>]', v):\n            raise ValueError('Password must contain at least one special character')\n        return v\n\n\nclass UserResponse(BaseModel):\n    \"\"\"\n    Schema for user data in API responses.\n    \n    Serializes user information for client consumption, excluding sensitive data.\n    \"\"\"\n    id: int = Field(\n        ...,\n        description=\"Unique user identifier\"\n    )\n    username: str = Field(\n        ...,\n        description=\"User's username\"\n    )\n    email: str = Field(\n        ...,\n        description=\"User's email address\"\n    )\n    full_name: str = Field(\n        ...,\n        description=\"User's full name\"\n    )\n    is_active: bool = Field(\n        ...,\n        description=\"Whether the user account is active\"\n    )\n    created_at: datetime = Field(\n        ...,\n        description=\"Account creation timestamp\"\n    )\n    updated_at: datetime = Field(\n        ...,\n        description=\"Last profile update timestamp\"\n    )\n    \n    class Config:\n        \"\"\"Pydantic configuration for UserResponse.\"\"\"\n        from_attributes = True\n        json_encoders = {\n            datetime: lambda v: v.isoformat() + 'Z' if v else None\n        }\n\n\nclass UserListResponse(BaseModel):\n    \"\"\"",
      "file_type": "source",
      "semantic_unit_id": "SU-006",
      "component_id": "COMP-006",
      "description": "Pydantic schemas for user registration, login, profile updates, and API response serialization"
    },
    {
      "file_path": "src/schemas/task.py",
      "content": "\"\"\"\nPydantic schemas for task management API\n\nDefines data models for task creation, updates, filtering, and API responses\nwith comprehensive validation rules.\n\nComponent ID: COMP-007\nSemantic Unit: SU-007\n\nAuthor: ASP Code Agent\n\"\"\"\n\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Optional, List\nfrom uuid import UUID\n\nfrom pydantic import BaseModel, Field, validator, root_validator\n\n\nclass TaskStatus(str, Enum):\n    \"\"\"Enumeration of valid task statuses.\"\"\"\n    PENDING = \"pending\"\n    IN_PROGRESS = \"in_progress\"\n    COMPLETED = \"completed\"\n    CANCELLED = \"cancelled\"\n\n\nclass TaskPriority(str, Enum):\n    \"\"\"Enumeration of valid task priorities.\"\"\"\n    LOW = \"low\"\n    MEDIUM = \"medium\"\n    HIGH = \"high\"\n    URGENT = \"urgent\"\n\n\nclass TaskBase(BaseModel):\n    \"\"\"Base schema with common task fields.\"\"\"\n    \n    title: str = Field(\n        ...,\n        min_length=1,\n        max_length=200,\n        description=\"Task title\"\n    )\n    description: Optional[str] = Field(\n        None,\n        max_length=2000,\n        description=\"Detailed task description\"\n    )\n    priority: TaskPriority = Field(\n        TaskPriority.MEDIUM,\n        description=\"Task priority level\"\n    )\n    due_date: Optional[datetime] = Field(\n        None,\n        description=\"Task due date and time\"\n    )\n    tags: List[str] = Field(\n        default_factory=list,\n        description=\"List of task tags\"\n    )\n\n    @validator('title')\n    def validate_title(cls, v: str) -> str:\n        \"\"\"Validate and clean task title.\"\"\"\n        if not v or not v.strip():\n            raise ValueError('Title cannot be empty or whitespace only')\n        \n        # Remove extra whitespace and normalize\n        cleaned_title = ' '.join(v.strip().split())\n        \n        if len(cleaned_title) < 1:\n            raise ValueError('Title must contain at least one non-whitespace character')\n        \n        return cleaned_title\n\n    @validator('description')\n    def validate_description(cls, v: Optional[str]) -> Optional[str]:\n        \"\"\"Validate and clean task description.\"\"\"\n        if v is None:\n            return None\n        \n        # Remove extra whitespace but preserve line breaks\n        cleaned_desc = v.strip()\n        \n        if not cleaned_desc:\n            return None\n        \n        return cleaned_desc\n\n    @validator('due_date')\n    def validate_due_date(cls, v: Optional[datetime]) -> Optional[datetime]:\n        \"\"\"Validate due date is not in the past.\"\"\"\n        if v is None:\n            return None\n        \n        if v < datetime.utcnow():\n            raise ValueError('Due date cannot be in the past')\n        \n        return v\n\n    @validator('tags')\n    def validate_tags(cls, v: List[str]) -> List[str]:\n        \"\"\"Validate and clean task tags.\"\"\"\n        if not v:\n            return []\n        \n        # Remove duplicates and empty tags, normalize case\n        cleaned_tags = []\n        seen_tags = set()\n        \n        for tag in v:\n            if not isinstance(tag, str):\n                raise ValueError('All tags must be strings')\n            \n            cleaned_tag = tag.strip().lower()\n            \n            if not cleaned_tag:\n                continue  # Skip empty tags\n            \n            if len(cleaned_tag) > 50:\n                raise ValueError('Tag length cannot exceed 50 characters')\n            \n            if not cleaned_tag.replace('_', '').replace('-', '').isalnum():\n                raise ValueError('Tags can only contain alphanumeric characters, hyphens, and underscores')\n            \n            if cleaned_tag not in seen_tags:\n                cleaned_tags.append(cleaned_tag)\n                seen_tags.add(cleaned_tag)\n        \n        if len(cleaned_tags) > 10:\n            raise ValueError('Cannot have more than 10 tags per task')\n        \n        return cleaned_tags\n\n\nclass TaskCreate(TaskBase):\n    \"\"\"Schema for creating a new task.\"\"\"\n    \n    assigned_to: Optional[UUID] = Field(\n        None,\n        description=\"UUID of user assigned to this task\"\n    )\n\n    class Config:\n        \"\"\"Pydantic configuration.\"\"\"\n        schema_extra = {\n            \"example\": {\n                \"title\": \"Complete project documentation\",\n                \"description\": \"Write comprehensive documentation for the new API endpoints\",\n                \"priority\": \"high\",\n                \"due_date\": \"2024-12-31T23:59:59Z\",\n                \"tags\": [\"documentation\", \"api\", \"urgent\"],\n                \"assigned_to\": \"550e8400-e29b-41d4-a716-446655440000\"\n            }\n        }\n\n\nclass TaskUpdate(BaseModel):\n    \"\"\"Schema for updating an existing task.\"\"\"\n    \n    title: Optional[str] = Field(\n        None,\n        min_length=1,\n        max_length=200,\n        description=\"Updated task title\"\n    )\n    description: Optional[str] = Field(\n        None,\n        max_length=2000,\n        description=\"Updated task description\"\n    )\n    status: Optional[TaskStatus] = Field(\n        None,\n        description=\"Updated task status\"\n    )\n    priority: Optional[TaskPriority] = Field(\n        None,\n        description=\"Updated task priority\"\n    )\n    due_date: Optional[datetime] = Field(\n        None,\n        description=\"Updated due date\"\n    )\n    assigned_to: Optional[UUID] = Field(\n        None,\n        description=\"Updated assigned user UUID\"\n    )\n    tags: Optional[List[str]] = Field(\n        None,\n        description=\"Updated list of tags\"\n    )\n\n    @validator('title')\n    def validate_title(cls, v: Optional[str]) -> Optional[str]:\n        \"\"\"Validate and clean task title.\"\"\"\n        if v is None:\n            return None\n        \n        if not v or not v.strip():\n            raise ValueError('Title cannot be empty or whitespace only')\n        \n        cleaned_title = ' '.join(v.strip().split())\n        \n        if len(cleaned_title) < 1:\n            raise ValueError('Title must contain at least one non-whitespace character')\n        \n        return cleaned_title\n\n    @validator('description')\n    def validate_description(cls, v: Optional[str]) -> Optional[str]:\n        \"\"\"Validate and clean task description.\"\"\"\n        if v is None:\n            return None\n        \n        cleaned_desc = v.strip()\n        \n        if not cleaned_desc:\n            return None\n        \n        return cleaned_desc\n\n    @validator('due_date')\n    def validate_due_date(cls, v: Optional[datetime]) -> Optional[datetime]:\n        \"\"\"Validate due date is not in the past.\"\"\"\n        if v is None:\n            return None\n        \n        if v < datetime.utcnow():\n            raise ValueError('Due date cannot be in the past')\n        \n        return v\n\n    @validator('tags')\n    def validate_tags(cls, v: Optional[List[str]]) -> Optional[List[str]]:\n        \"\"\"Validate and clean task tags.\"\"\"\n        if v is None:\n            return None\n        \n        # Use same validation logic as TaskBase\n        cleaned_tags = []\n        seen_tags = set()\n        \n        for tag in v:\n            if not isinstance(tag, str):\n                raise ValueError('All tags must be strings')\n            \n            cleaned_tag = tag.strip().lower()\n            \n            if not cleaned_tag:\n                continue\n            \n            if len(cleaned_tag) > 50:\n                raise ValueError('Tag length cannot exceed 50 characters')\n            \n            if not cleaned_tag.replace('_', '').replace('-', '').isalnum():\n                raise ValueError('Tags can only contain alphanumeric characters, hyphens, and underscores')\n            \n            if cleaned_tag not in seen_tags:\n                cleaned_tags.append(cleaned_tag)\n                seen_tags.add(cleaned_tag)\n        \n        if len(cleaned_tags) > 10:\n            raise ValueError('Cannot have more than 10",
      "file_type": "source",
      "semantic_unit_id": "SU-007",
      "component_id": "COMP-007",
      "description": "Pydantic schemas for task creation, updates, filtering, and API response serialization with validation"
    },
    {
      "file_path": "src/utils/jwt_utils.py",
      "content": "\"\"\"\nJWT token utilities for authentication and authorization.\n\nProvides functions for generating, validating, decoding, and refreshing JWT tokens\nusing the python-jose library with RS256 algorithm.\n\nComponent ID: COMP-008\nSemantic Unit: SU-008\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport os\nimport logging\nfrom datetime import datetime, timedelta, timezone\nfrom typing import Optional, Dict, Any, Union\n\nfrom jose import JWTError, jwt\nfrom jose.constants import ALGORITHMS\n\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# JWT Configuration\nJWT_ALGORITHM = ALGORITHMS.RS256\nJWT_ACCESS_TOKEN_EXPIRE_MINUTES = 30\nJWT_REFRESH_TOKEN_EXPIRE_DAYS = 7\nJWT_ISSUER = \"hello-world-api\"\nJWT_AUDIENCE = \"hello-world-users\"\n\n# Default RSA keys (in production, these should be loaded from environment variables)\nDEFAULT_PRIVATE_KEY = \"\"\"-----BEGIN RSA PRIVATE KEY-----\nMIIEpAIBAAKCAQEA4f5wg5l2hKsTeNem/V41fGnJm6gOdrj8ym3rFkEjWT2btNjcIBFu5d2gcfQQWd0JurplakZfFNNmvl/Y8ZtaD5S/TQYhqvNHSBRiley5OEXEgdtAjmDcYnRr6nK4hpDdGFKoInkRiHxpK7iosKI2v2MqQQhJNADEpd7L7jdqGYsFRN6bzRQi6/+4wjd4ptVAh6kapbptu5Mxc6+rkgJNrxXHd2qN5PUFjYjVvQaaqBdHFNehwgiw5SIkpX/rJ3/AgMBAAECggEBAJGRw/3AqT7hOdNqBPnM3a9EX8xMZpqbaN4fWeLjwpHtK9kTjnFHRgbhTrfB5inQiLlOWM2HLrQ8UVdSZcGy2HNUVZ2lxWw2D8MA8EqaAiQqfxgB7jfT1LN+cozadoABuKdVrfD6ki4n2h5+8P5Io1rI4ZHdgRdOjHdNlNNjuQWiEiKvMXZnxtK/wJlyfD8MldVEz4PqD5PaHMXcMU5YQxSN8EMwjVcaEeD0xhzbNz6Y5rnqiMeGmB1+24JdGVQBpw==\n-----END RSA PRIVATE KEY-----\"\"\"\n\nDEFAULT_PUBLIC_KEY = \"\"\"-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA4f5wg5l2hKsTeNem/V41fGnJm6gOdrj8ym3rFkEjWT2btNjcIBFu5d2gcfQQWd0JurplakZfFNNmvl/Y8ZtaD5S/TQYhqvNHSBRiley5OEXEgdtAjmDcYnRr6nK4hpDdGFKoInkRiHxpK7iosKI2v2MqQQhJNADEpd7L7jdqGYsFRN6bzRQi6/+4wjd4ptVAh6kapbptu5Mxc6+rkgJNrxXHd2qN5PUFjYjVvQaaqBdHFNehwgiw5SIkpX/rJ3/AgMBAAE=\n-----END PUBLIC KEY-----\"\"\"\n\n\nclass JWTError(Exception):\n    \"\"\"Custom JWT error for token-related exceptions.\"\"\"\n    pass\n\n\nclass TokenExpiredError(JWTError):\n    \"\"\"Raised when a JWT token has expired.\"\"\"\n    pass\n\n\nclass TokenInvalidError(JWTError):\n    \"\"\"Raised when a JWT token is invalid or malformed.\"\"\"\n    pass\n\n\ndef get_private_key() -> str:\n    \"\"\"\n    Get the RSA private key for signing JWT tokens.\n    \n    Returns:\n        str: RSA private key in PEM format\n        \n    Raises:\n        JWTError: If private key is not available or invalid\n    \"\"\"\n    try:\n        private_key = os.getenv(\"JWT_PRIVATE_KEY\", DEFAULT_PRIVATE_KEY)\n        if not private_key or not private_key.strip():\n            raise JWTError(\"JWT private key is not configured\")\n        return private_key.strip()\n    except Exception as e:\n        logger.error(f\"Failed to load JWT private key: {e}\")\n        raise JWTError(f\"Failed to load JWT private key: {e}\")\n\n\ndef get_public_key() -> str:\n    \"\"\"\n    Get the RSA public key for verifying JWT tokens.\n    \n    Returns:\n        str: RSA public key in PEM format\n        \n    Raises:\n        JWTError: If public key is not available or invalid\n    \"\"\"\n    try:\n        public_key = os.getenv(\"JWT_PUBLIC_KEY\", DEFAULT_PUBLIC_KEY)\n        if not public_key or not public_key.strip():\n            raise JWTError(\"JWT public key is not configured\")\n        return public_key.strip()\n    except Exception as e:\n        logger.error(f\"Failed to load JWT public key: {e}\")\n        raise JWTError(f\"Failed to load JWT public key: {e}\")\n\n\ndef get_current_timestamp() -> datetime:\n    \"\"\"\n    Get the current UTC timestamp.\n    \n    Returns:\n        datetime: Current UTC timestamp\n    \"\"\"\n    return datetime.now(timezone.utc)\n\n\ndef generate_access_token(\n    user_id: str,\n    email: str,\n    roles: Optional[list[str]] = None,\n    expires_delta: Optional[timedelta] = None\n) -> str:\n    \"\"\"\n    Generate a JWT access token for user authentication.\n    \n    Args:\n        user_id: Unique user identifier\n        email: User email address\n        roles: List of user roles/permissions\n        expires_delta: Custom expiration time (defaults to 30 minutes)\n        \n    Returns:\n        str: Encoded JWT access token\n        \n    Raises:\n        JWTError: If token generation fails\n        ValueError: If required parameters are invalid\n    \"\"\"\n    if not user_id or not isinstance(user_id, str):\n        raise ValueError(\"user_id must be a non-empty string\")\n    \n    if not email or not isinstance(email, str):\n        raise ValueError(\"email must be a non-empty string\")\n    \n    if roles is None:\n        roles = []\n    \n    if not isinstance(roles, list):\n        raise ValueError(\"roles must be a list\")\n    \n    try:\n        now = get_current_timestamp()\n        \n        if expires_delta is None:\n            expires_delta = timedelta(minutes=JWT_ACCESS_TOKEN_EXPIRE_MINUTES)\n        \n        expire = now + expires_delta\n        \n        payload = {\n            \"sub\": user_id,\n            \"email\": email,\n            \"roles\": roles,\n            \"type\": \"access\",\n            \"iat\": int(now.timestamp()),\n            \"exp\": int(expire.timestamp()),\n            \"iss\": JWT_ISSUER,\n            \"aud\": JWT_AUDIENCE,\n        }\n        \n        private_key = get_private_key()\n        token = jwt.encode(payload, private_key, algorithm=JWT_ALGORITHM)\n        \n        logger.info(f\"Generated access token for user",
      "file_type": "source",
      "semantic_unit_id": "SU-008",
      "component_id": "COMP-008",
      "description": "JWT token generation, validation, decoding, and refresh token management using python-jose library"
    },
    {
      "file_path": "src/utils/password.py",
      "content": "\"\"\"\nPassword utilities for secure password hashing, verification, and strength validation.\n\nThis module provides secure password handling using bcrypt with proper salt generation\nand comprehensive password strength validation.\n\nComponent ID: COMP-009\nSemantic Unit: SU-009\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport re\nimport secrets\nfrom typing import Optional\n\nimport bcrypt\n\n\nclass PasswordStrengthError(Exception):\n    \"\"\"Raised when password does not meet strength requirements.\"\"\"\n    pass\n\n\nclass PasswordHashError(Exception):\n    \"\"\"Raised when password hashing fails.\"\"\"\n    pass\n\n\nclass PasswordVerificationError(Exception):\n    \"\"\"Raised when password verification fails.\"\"\"\n    pass\n\n\ndef hash_password(password: str) -> str:\n    \"\"\"\n    Hash a password using bcrypt with secure salt generation.\n    \n    Args:\n        password: Plain text password to hash\n        \n    Returns:\n        str: Base64 encoded bcrypt hash\n        \n    Raises:\n        PasswordHashError: If password hashing fails\n        ValueError: If password is empty or None\n        \n    Example:\n        >>> hashed = hash_password(\"my_secure_password\")\n        >>> len(hashed) > 50\n        True\n    \"\"\"\n    if not password:\n        raise ValueError(\"Password cannot be empty or None\")\n    \n    try:\n        # Generate salt with cost factor 12 (recommended for 2024)\n        salt = bcrypt.gensalt(rounds=12)\n        \n        # Hash password with salt\n        password_bytes = password.encode('utf-8')\n        hashed = bcrypt.hashpw(password_bytes, salt)\n        \n        # Return as string for storage\n        return hashed.decode('utf-8')\n        \n    except Exception as e:\n        raise PasswordHashError(f\"Failed to hash password: {str(e)}\") from e\n\n\ndef verify_password(password: str, hashed_password: str) -> bool:\n    \"\"\"\n    Verify a password against its bcrypt hash.\n    \n    Args:\n        password: Plain text password to verify\n        hashed_password: Previously hashed password to check against\n        \n    Returns:\n        bool: True if password matches hash, False otherwise\n        \n    Raises:\n        PasswordVerificationError: If verification process fails\n        ValueError: If password or hash is empty or None\n        \n    Example:\n        >>> hashed = hash_password(\"test123\")\n        >>> verify_password(\"test123\", hashed)\n        True\n        >>> verify_password(\"wrong\", hashed)\n        False\n    \"\"\"\n    if not password:\n        raise ValueError(\"Password cannot be empty or None\")\n    \n    if not hashed_password:\n        raise ValueError(\"Hashed password cannot be empty or None\")\n    \n    try:\n        password_bytes = password.encode('utf-8')\n        hashed_bytes = hashed_password.encode('utf-8')\n        \n        return bcrypt.checkpw(password_bytes, hashed_bytes)\n        \n    except Exception as e:\n        raise PasswordVerificationError(f\"Failed to verify password: {str(e)}\") from e\n\n\ndef validate_password_strength(password: str, min_length: int = 8) -> None:\n    \"\"\"\n    Validate password meets strength requirements.\n    \n    Requirements:\n    - Minimum length (default 8 characters)\n    - At least one uppercase letter\n    - At least one lowercase letter\n    - At least one digit\n    - At least one special character\n    - No common weak passwords\n    \n    Args:\n        password: Password to validate\n        min_length: Minimum required length (default 8)\n        \n    Raises:\n        PasswordStrengthError: If password doesn't meet requirements\n        ValueError: If password is empty or None\n        \n    Example:\n        >>> validate_password_strength(\"SecurePass123!\")\n        >>> # No exception raised - password is strong\n        \n        >>> validate_password_strength(\"weak\")\n        Traceback (most recent call last):\n        ...\n        PasswordStrengthError: Password must be at least 8 characters long\n    \"\"\"\n    if not password:\n        raise ValueError(\"Password cannot be empty or None\")\n    \n    # Check minimum length\n    if len(password) < min_length:\n        raise PasswordStrengthError(f\"Password must be at least {min_length} characters long\")\n    \n    # Check for uppercase letter\n    if not re.search(r'[A-Z]', password):\n        raise PasswordStrengthError(\"Password must contain at least one uppercase letter\")\n    \n    # Check for lowercase letter\n    if not re.search(r'[a-z]', password):\n        raise PasswordStrengthError(\"Password must contain at least one lowercase letter\")\n    \n    # Check for digit\n    if not re.search(r'\\d', password):\n        raise PasswordStrengthError(\"Password must contain at least one digit\")\n    \n    # Check for special character\n    if not re.search(r'[!@#$%^&*(),.?\":{}|<>]', password):\n        raise PasswordStrengthError(\"Password must contain at least one special character (!@#$%^&*(),.?\\\":{}|<>)\")\n    \n    # Check against common weak passwords\n    weak_passwords = {\n        'password', 'password123', '123456', '123456789', 'qwerty',\n        'abc123', 'password1', 'admin', 'letmein', 'welcome',\n        'monkey', '1234567890', 'dragon', 'master', 'hello'\n    }\n    \n    if password.lower() in weak_passwords:\n        raise PasswordStrengthError(\"Password is too common and easily guessable\")\n\n\ndef generate_secure_password(length: int = 16) -> str:\n    \"\"\"\n    Generate a cryptographically secure random password.\n    \n    Generated password will contain:\n    - Uppercase letters (A-Z)\n    - Lowercase letters (a-z)\n    - Digits (0-9)\n    - Special characters (!@#$%^&*)\n    \n    Args:\n        length: Length of password to generate (minimum 8, default 16)\n        \n    Returns:\n        str: Randomly generated secure password\n        \n    Raises:\n        ValueError: If length is less than 8\n        \n    Example:\n        >>> password = generate_secure_password(12)\n        >>> len(password)\n        12\n        >>> validate_password_strength(password)\n        >>> # No exception - generated password is strong\n    \"\"\"\n    if length < 8:\n        raise ValueError(\"Password length must be at least 8 characters\")\n    \n    # Character sets\n    uppercase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    lowercase = 'abcdefghijklmnopqrstuvwxyz'\n    digits = '0123456789'\n    special = '!@#$%^&*'\n    \n    # Ensure at least one character from each set\n    password_chars = [\n        secrets.choice(uppercase),\n        secrets.choice(lowercase),\n        secrets.choice(digits),\n        secrets.choice(special)\n    ]\n    \n    # Fill remaining length with random characters from all sets\n    all_chars = uppercase + lowercase + digits + special\n    for _ in range(length - 4):\n        password_chars.append(secrets.choice(all_chars))\n    \n    # Shuffle the characters to avoid predictable patterns\n    secrets.SystemRandom().shuffle(password_chars)\n    \n    return ''.join(password_chars)\n\n\ndef check_password_complexity(password: str) -> dict[str, bool]:\n    \"\"\"\n    Check password complexity and return detailed results.\n    \n    Args:\n        password: Password to analyze\n        \n    Returns:\n        dict: Dictionary with complexity check results\n        \n    Example:\n        >>> results = check_password_complexity(\"Test123!\")\n        >>> results['has_uppercase']\n        True\n        >>> results['has_lowercase']\n        True\n    \"\"\"\n    if not password:\n        return {\n            'has_minimum_length': False,\n            'has_uppercase': False,\n            'has_lowercase': False,\n            'has_digit': False,\n            'has_special': False,\n            'is_not_common': False,\n            'overall_strong': False\n        }",
      "file_type": "source",
      "semantic_unit_id": "SU-009",
      "component_id": "COMP-009",
      "description": "Password hashing, verification, and strength validation using bcrypt with secure salt generation"
    },
    {
      "file_path": "src/database/connection.py",
      "content": "\"\"\"\nSQLAlchemy database connection setup, session management, and base model configuration.\n\nThis module provides database connection management, session handling, and base model\nconfiguration for SQLAlchemy ORM operations.\n\nComponent ID: COMP-010\nSemantic Unit: SU-010\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport logging\nimport os\nfrom contextlib import contextmanager\nfrom typing import Generator, Optional\n\nfrom sqlalchemy import create_engine, event, Engine\nfrom sqlalchemy.exc import SQLAlchemyError\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom sqlalchemy.pool import StaticPool\n\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Base class for all database models\nBase = declarative_base()\n\n# Global database engine and session factory\n_engine: Optional[Engine] = None\n_session_factory: Optional[sessionmaker] = None\n\n\nclass DatabaseConfig:\n    \"\"\"Database configuration settings.\"\"\"\n    \n    def __init__(self) -> None:\n        \"\"\"Initialize database configuration from environment variables.\"\"\"\n        self.database_url = os.getenv(\n            \"DATABASE_URL\", \n            \"sqlite:///./hello_world.db\"\n        )\n        self.echo = os.getenv(\"DATABASE_ECHO\", \"false\").lower() == \"true\"\n        self.pool_size = int(os.getenv(\"DATABASE_POOL_SIZE\", \"5\"))\n        self.max_overflow = int(os.getenv(\"DATABASE_MAX_OVERFLOW\", \"10\"))\n        self.pool_timeout = int(os.getenv(\"DATABASE_POOL_TIMEOUT\", \"30\"))\n        self.pool_recycle = int(os.getenv(\"DATABASE_POOL_RECYCLE\", \"3600\"))\n        \n    def get_engine_kwargs(self) -> dict:\n        \"\"\"\n        Get SQLAlchemy engine configuration parameters.\n        \n        Returns:\n            dict: Engine configuration parameters\n        \"\"\"\n        kwargs = {\n            \"echo\": self.echo,\n            \"future\": True,\n        }\n        \n        # SQLite-specific configuration\n        if self.database_url.startswith(\"sqlite\"):\n            kwargs.update({\n                \"poolclass\": StaticPool,\n                \"connect_args\": {\n                    \"check_same_thread\": False,\n                    \"timeout\": 20,\n                }\n            })\n        else:\n            # PostgreSQL/MySQL configuration\n            kwargs.update({\n                \"pool_size\": self.pool_size,\n                \"max_overflow\": self.max_overflow,\n                \"pool_timeout\": self.pool_timeout,\n                \"pool_recycle\": self.pool_recycle,\n                \"pool_pre_ping\": True,\n            })\n            \n        return kwargs\n\n\ndef create_database_engine(config: Optional[DatabaseConfig] = None) -> Engine:\n    \"\"\"\n    Create and configure SQLAlchemy database engine.\n    \n    Args:\n        config: Database configuration object. If None, creates default config.\n        \n    Returns:\n        Engine: Configured SQLAlchemy engine\n        \n    Raises:\n        SQLAlchemyError: If engine creation fails\n    \"\"\"\n    if config is None:\n        config = DatabaseConfig()\n        \n    try:\n        engine = create_engine(\n            config.database_url,\n            **config.get_engine_kwargs()\n        )\n        \n        # Add connection event listeners\n        _setup_engine_events(engine)\n        \n        logger.info(f\"Database engine created successfully: {config.database_url}\")\n        return engine\n        \n    except Exception as e:\n        logger.error(f\"Failed to create database engine: {e}\")\n        raise SQLAlchemyError(f\"Database engine creation failed: {e}\") from e\n\n\ndef _setup_engine_events(engine: Engine) -> None:\n    \"\"\"\n    Set up SQLAlchemy engine event listeners.\n    \n    Args:\n        engine: SQLAlchemy engine to configure\n    \"\"\"\n    @event.listens_for(engine, \"connect\")\n    def set_sqlite_pragma(dbapi_connection, connection_record):\n        \"\"\"Enable foreign key constraints for SQLite connections.\"\"\"\n        if engine.url.drivername == \"sqlite\":\n            cursor = dbapi_connection.cursor()\n            cursor.execute(\"PRAGMA foreign_keys=ON\")\n            cursor.close()\n            \n    @event.listens_for(engine, \"engine_connect\")\n    def receive_engine_connect(conn, branch):\n        \"\"\"Log database connections.\"\"\"\n        logger.debug(\"Database connection established\")\n\n\ndef initialize_database(config: Optional[DatabaseConfig] = None) -> None:\n    \"\"\"\n    Initialize database connection and session factory.\n    \n    Args:\n        config: Database configuration object. If None, creates default config.\n        \n    Raises:\n        SQLAlchemyError: If database initialization fails\n    \"\"\"\n    global _engine, _session_factory\n    \n    try:\n        _engine = create_database_engine(config)\n        _session_factory = sessionmaker(\n            bind=_engine,\n            autocommit=False,\n            autoflush=False,\n            expire_on_commit=False\n        )\n        \n        logger.info(\"Database initialized successfully\")\n        \n    except Exception as e:\n        logger.error(f\"Database initialization failed: {e}\")\n        raise SQLAlchemyError(f\"Database initialization failed: {e}\") from e\n\n\ndef create_tables() -> None:\n    \"\"\"\n    Create all database tables defined in models.\n    \n    Raises:\n        SQLAlchemyError: If table creation fails\n    \"\"\"\n    if _engine is None:\n        raise SQLAlchemyError(\"Database not initialized. Call initialize_database() first.\")\n        \n    try:\n        Base.metadata.create_all(bind=_engine)\n        logger.info(\"Database tables created successfully\")\n        \n    except Exception as e:\n        logger.error(f\"Failed to create database tables: {e}\")\n        raise SQLAlchemyError(f\"Table creation failed: {e}\") from e\n\n\ndef drop_tables() -> None:\n    \"\"\"\n    Drop all database tables.\n    \n    Raises:\n        SQLAlchemyError: If table dropping fails\n    \"\"\"\n    if _engine is None:\n        raise SQLAlchemyError(\"Database not initialized. Call initialize_database() first.\")\n        \n    try:\n        Base.metadata.drop_all(bind=_engine)\n        logger.info(\"Database tables dropped successfully\")\n        \n    except Exception as e:\n        logger.error(f\"Failed to drop database tables: {e}\")\n        raise SQLAlchemyError(f\"Table dropping failed: {e}\") from e\n\n\ndef get_session() -> Session:\n    \"\"\"\n    Create a new database session.\n    \n    Returns:\n        Session: SQLAlchemy database session\n        \n    Raises:\n        SQLAlchemyError: If session creation fails\n    \"\"\"\n    if _session_factory is None:\n        raise SQLAlchemyError(\"Database not initialized. Call initialize_database() first.\")\n        \n    try:\n        return _session_factory()\n    except Exception as e:\n        logger.error(f\"Failed to create database session: {e}\")\n        raise SQLAlchemyError(f\"Session creation failed: {e}\") from e\n\n\n@contextmanager\ndef get_db_session() -> Generator[Session, None, None]:\n    \"\"\"\n    Context manager for database sessions with automatic cleanup.\n    \n    Yields:\n        Session: SQLAlchemy database session\n        \n    Raises:\n        SQLAlchemyError: If session operations fail\n    \"\"\"\n    session = get_session()\n    try:\n        yield session\n        session.commit()\n    except Exception as e:\n        session.rollback()\n        logger.error(f\"Database session error: {e}\")\n        raise SQLAlchemyError(f\"Database operation failed: {e}\") from e\n    finally:\n        session.close()\n\n\ndef close_database() -> None:\n    \"\"\"\n    Close database connections and clean up resources.\n    \"\"\"\n    global _engine, _session_factory\n    \n    if _engine is not None:\n        _engine.dispose()\n        _engine = None\n        logger.info(\"Database engine disposed\")\n        \n    _session_factory = None\n    logger.info(\"Database connections closed\")\n\n\ndef get_engine() -> Engine:\n    \"\"\"\n    Get the current database engine.",
      "file_type": "source",
      "semantic_unit_id": "SU-010",
      "component_id": "COMP-010",
      "description": "SQLAlchemy database connection setup, session management, and base model configuration"
    },
    {
      "file_path": "src/database/migrations/001_initial_schema.py",
      "content": "\"\"\"\nInitial database schema migration for Hello World API\n\nCreates the initial database tables, indexes, and constraints.\nThis is a placeholder migration as the Hello World API doesn't require a database.\n\nRevision ID: 001\nRevises: \nCreate Date: 2025-11-21 02:21:40.723332\n\nComponent ID: COMP-011\nSemantic Unit: SU-011\n\nAuthor: ASP Code Agent\n\"\"\"\nfrom typing import Sequence, Union\n\nfrom alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision: str = '001'\ndown_revision: Union[str, None] = None\nbranch_labels: Union[str, Sequence[str], None] = None\ndepends_on: Union[str, Sequence[str], None] = None\n\n\ndef upgrade() -> None:\n    \"\"\"\n    Upgrade database schema to revision 001.\n    \n    Creates initial database tables for the Hello World API.\n    Note: The Hello World API is stateless and doesn't require database tables,\n    but this migration is included for completeness and future extensibility.\n    \n    Tables created:\n    - api_metadata: Stores API version and configuration metadata\n    - request_logs: Optional table for request logging (disabled by default)\n    \"\"\"\n    # Create api_metadata table for storing API configuration\n    op.create_table(\n        'api_metadata',\n        sa.Column('id', sa.Integer(), nullable=False, primary_key=True),\n        sa.Column('key', sa.String(100), nullable=False, unique=True),\n        sa.Column('value', sa.Text(), nullable=True),\n        sa.Column('description', sa.String(255), nullable=True),\n        sa.Column('created_at', sa.DateTime(timezone=True), nullable=False, \n                 server_default=sa.text('CURRENT_TIMESTAMP')),\n        sa.Column('updated_at', sa.DateTime(timezone=True), nullable=False,\n                 server_default=sa.text('CURRENT_TIMESTAMP')),\n        sa.PrimaryKeyConstraint('id'),\n        sa.UniqueConstraint('key', name='uq_api_metadata_key')\n    )\n    \n    # Create index on key column for fast lookups\n    op.create_index(\n        'ix_api_metadata_key',\n        'api_metadata',\n        ['key'],\n        unique=True\n    )\n    \n    # Create index on created_at for time-based queries\n    op.create_index(\n        'ix_api_metadata_created_at',\n        'api_metadata',\n        ['created_at']\n    )\n    \n    # Create request_logs table for optional request logging\n    # This table is not used by the current Hello World API but provides\n    # foundation for future logging requirements\n    op.create_table(\n        'request_logs',\n        sa.Column('id', sa.BigInteger(), nullable=False, primary_key=True),\n        sa.Column('request_id', sa.String(36), nullable=False, unique=True),\n        sa.Column('method', sa.String(10), nullable=False),\n        sa.Column('path', sa.String(255), nullable=False),\n        sa.Column('query_params', sa.Text(), nullable=True),\n        sa.Column('user_agent', sa.String(500), nullable=True),\n        sa.Column('ip_address', sa.String(45), nullable=True),  # IPv6 compatible\n        sa.Column('status_code', sa.Integer(), nullable=True),\n        sa.Column('response_time_ms', sa.Integer(), nullable=True),\n        sa.Column('error_code', sa.String(50), nullable=True),\n        sa.Column('error_message', sa.Text(), nullable=True),\n        sa.Column('created_at', sa.DateTime(timezone=True), nullable=False,\n                 server_default=sa.text('CURRENT_TIMESTAMP')),\n        sa.PrimaryKeyConstraint('id'),\n        sa.UniqueConstraint('request_id', name='uq_request_logs_request_id')\n    )\n    \n    # Create indexes for request_logs table\n    op.create_index(\n        'ix_request_logs_request_id',\n        'request_logs',\n        ['request_id'],\n        unique=True\n    )\n    \n    op.create_index(\n        'ix_request_logs_created_at',\n        'request_logs',\n        ['created_at']\n    )\n    \n    op.create_index(\n        'ix_request_logs_method_path',\n        'request_logs',\n        ['method', 'path']\n    )\n    \n    op.create_index(\n        'ix_request_logs_status_code',\n        'request_logs',\n        ['status_code']\n    )\n    \n    op.create_index(\n        'ix_request_logs_ip_address',\n        'request_logs',\n        ['ip_address']\n    )\n    \n    # Insert initial API metadata\n    op.execute(\n        sa.text(\"\"\"\n        INSERT INTO api_metadata (key, value, description) VALUES\n        ('api_version', '1.0.0', 'Current API version'),\n        ('api_title', 'Hello World API', 'API title'),\n        ('api_description', 'Simple REST API that returns greeting messages', 'API description'),\n        ('schema_version', '001', 'Current database schema version'),\n        ('created_date', :created_date, 'Date when API was first deployed'),\n        ('logging_enabled', 'false', 'Whether request logging is enabled'),\n        ('max_name_length', '100', 'Maximum allowed length for name parameter'),\n        ('allowed_name_pattern', '^[a-zA-Z0-9\\\\s]*$', 'Regex pattern for valid name characters')\n        \"\"\"),\n        created_date='2025-11-21T02:21:40.723332Z'\n    )\n\n\ndef downgrade() -> None:\n    \"\"\"\n    Downgrade database schema from revision 001.\n    \n    Drops all tables and indexes created in the upgrade() function.\n    This will permanently delete all data in these tables.\n    \"\"\"\n    # Drop indexes first (foreign key constraints would be dropped here if they existed)\n    op.drop_index('ix_request_logs_ip_address', table_name='request_logs')\n    op.drop_index('ix_request_logs_status_code', table_name='request_logs')\n    op.drop_index('ix_request_logs_method_path', table_name='request_logs')\n    op.drop_index('ix_request_logs_created_at', table_name='request_logs')\n    op.drop_index('ix_request_logs_request_id', table_name='request_logs')\n    \n    op.drop_index('ix_api_metadata_created_at', table_name='api_metadata')\n    op.drop_index('ix_api_metadata_key', table_name='api_metadata')\n    \n    # Drop tables\n    op.drop_table('request_logs')\n    op.drop_table('api_metadata')\n\n\ndef get_current_schema_version() -> str:\n    \"\"\"\n    Get the current schema version from this migration.\n    \n    Returns:\n        str: The revision identifier for this migration\n        \n    Note:\n        This is a utility function that can be used by the application\n        to verify the current database schema version.\n    \"\"\"\n    return revision\n\n\ndef validate_schema_compatibility() -> bool:\n    \"\"\"\n    Validate that the current schema is compatible with the API requirements.\n    \n    Returns:\n        bool: True if schema is compatible, False otherwise\n        \n    Note:\n        This function can be extended to perform more complex validation\n        as the API evolves and requires additional database features.\n    \"\"\"\n    # For the Hello World API, any schema version is compatible\n    # since the API doesn't actually use the database tables\n    return True\n\n\ndef get_migration_description() -> str:\n    \"\"\"\n    Get a human-readable description of what this migration does.\n    \n    Returns:\n        str: Description of the migration changes\n    \"\"\"\n    return (\n        \"Initial schema migration for Hello World API. \"\n        \"Creates api_metadata table for configuration storage and \"\n        \"request_",
      "file_type": "schema",
      "semantic_unit_id": "SU-011",
      "component_id": "COMP-011",
      "description": "Alembic migration script for creating initial users and tasks tables with indexes and constraints"
    },
    {
      "file_path": "src/middleware/auth.py",
      "content": "\"\"\"\nFastAPI Authentication Middleware\n\nJWT token validation middleware that extracts and validates JWT tokens from requests,\ninjects user context, and handles authentication errors.\n\nComponent ID: COMP-012\nSemantic Unit: SU-012\n\nAuthor: ASP Code Generator\n\"\"\"\n\nimport logging\nfrom typing import Optional, Callable, Any\nfrom datetime import datetime\n\nfrom fastapi import Request, Response, HTTPException, status\nfrom fastapi.responses import JSONResponse\nfrom starlette.middleware.base import BaseHTTPMiddleware\nfrom starlette.types import ASGIApp\n\nfrom src.utils.jwt_utils import JWTUtils, JWTError, TokenExpiredError, InvalidTokenError\nfrom src.models.user import User\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass AuthenticationError(Exception):\n    \"\"\"Custom exception for authentication failures.\"\"\"\n    \n    def __init__(self, message: str, status_code: int = status.HTTP_401_UNAUTHORIZED):\n        self.message = message\n        self.status_code = status_code\n        super().__init__(self.message)\n\n\nclass AuthMiddleware(BaseHTTPMiddleware):\n    \"\"\"\n    JWT Authentication Middleware for FastAPI applications.\n    \n    Validates JWT tokens from Authorization header, extracts user information,\n    and injects user context into request state for downstream handlers.\n    \n    Attributes:\n        jwt_utils: JWT utility instance for token operations\n        excluded_paths: List of paths that bypass authentication\n        optional_auth_paths: List of paths where auth is optional\n    \"\"\"\n    \n    def __init__(\n        self,\n        app: ASGIApp,\n        jwt_utils: JWTUtils,\n        excluded_paths: Optional[list[str]] = None,\n        optional_auth_paths: Optional[list[str]] = None\n    ):\n        \"\"\"\n        Initialize authentication middleware.\n        \n        Args:\n            app: ASGI application instance\n            jwt_utils: JWT utility for token validation\n            excluded_paths: Paths that bypass authentication (default: [\"/health\", \"/docs\", \"/openapi.json\"])\n            optional_auth_paths: Paths where authentication is optional\n        \"\"\"\n        super().__init__(app)\n        self.jwt_utils = jwt_utils\n        self.excluded_paths = excluded_paths or [\"/health\", \"/docs\", \"/openapi.json\", \"/redoc\"]\n        self.optional_auth_paths = optional_auth_paths or []\n        \n        logger.info(\n            f\"AuthMiddleware initialized with {len(self.excluded_paths)} excluded paths \"\n            f\"and {len(self.optional_auth_paths)} optional auth paths\"\n        )\n    \n    async def dispatch(self, request: Request, call_next: Callable) -> Response:\n        \"\"\"\n        Process incoming request through authentication middleware.\n        \n        Args:\n            request: Incoming HTTP request\n            call_next: Next middleware/handler in chain\n            \n        Returns:\n            Response: HTTP response from downstream handler or error response\n        \"\"\"\n        try:\n            # Check if path is excluded from authentication\n            if self._is_excluded_path(request.url.path):\n                logger.debug(f\"Skipping auth for excluded path: {request.url.path}\")\n                return await call_next(request)\n            \n            # Extract and validate token\n            token = self._extract_token(request)\n            user = None\n            \n            if token:\n                try:\n                    user = await self._validate_token(token)\n                    logger.debug(f\"Successfully authenticated user: {user.id}\")\n                except AuthenticationError as e:\n                    if not self._is_optional_auth_path(request.url.path):\n                        logger.warning(f\"Authentication failed for {request.url.path}: {e.message}\")\n                        return self._create_error_response(e.message, e.status_code)\n                    logger.debug(f\"Optional auth failed for {request.url.path}: {e.message}\")\n            elif not self._is_optional_auth_path(request.url.path):\n                logger.warning(f\"No token provided for protected path: {request.url.path}\")\n                return self._create_error_response(\n                    \"Authentication required\", \n                    status.HTTP_401_UNAUTHORIZED\n                )\n            \n            # Inject user context into request state\n            request.state.user = user\n            request.state.authenticated = user is not None\n            request.state.auth_timestamp = datetime.utcnow()\n            \n            # Continue to next handler\n            response = await call_next(request)\n            \n            # Add authentication headers to response\n            if user:\n                response.headers[\"X-User-ID\"] = str(user.id)\n                response.headers[\"X-Authenticated\"] = \"true\"\n            else:\n                response.headers[\"X-Authenticated\"] = \"false\"\n            \n            return response\n            \n        except Exception as e:\n            logger.error(f\"Unexpected error in auth middleware: {str(e)}\", exc_info=True)\n            return self._create_error_response(\n                \"Internal authentication error\",\n                status.HTTP_500_INTERNAL_SERVER_ERROR\n            )\n    \n    def _is_excluded_path(self, path: str) -> bool:\n        \"\"\"\n        Check if request path is excluded from authentication.\n        \n        Args:\n            path: Request URL path\n            \n        Returns:\n            bool: True if path is excluded from authentication\n        \"\"\"\n        # Normalize path by removing trailing slash\n        normalized_path = path.rstrip('/')\n        \n        for excluded_path in self.excluded_paths:\n            normalized_excluded = excluded_path.rstrip('/')\n            if normalized_path == normalized_excluded or normalized_path.startswith(normalized_excluded + '/'):\n                return True\n        \n        return False\n    \n    def _is_optional_auth_path(self, path: str) -> bool:\n        \"\"\"\n        Check if request path has optional authentication.\n        \n        Args:\n            path: Request URL path\n            \n        Returns:\n            bool: True if authentication is optional for this path\n        \"\"\"\n        # Normalize path by removing trailing slash\n        normalized_path = path.rstrip('/')\n        \n        for optional_path in self.optional_auth_paths:\n            normalized_optional = optional_path.rstrip('/')\n            if normalized_path == normalized_optional or normalized_path.startswith(normalized_optional + '/'):\n                return True\n        \n        return False\n    \n    def _extract_token(self, request: Request) -> Optional[str]:\n        \"\"\"\n        Extract JWT token from Authorization header.\n        \n        Args:\n            request: HTTP request object\n            \n        Returns:\n            Optional[str]: JWT token string or None if not found\n            \n        Raises:\n            AuthenticationError: If Authorization header format is invalid\n        \"\"\"\n        auth_header = request.headers.get(\"Authorization\")\n        \n        if not auth_header:\n            return None\n        \n        # Validate Authorization header format\n        if not auth_header.startswith(\"Bearer \"):\n            raise AuthenticationError(\n                \"Invalid Authorization header format. Expected 'Bearer <token>'\",\n                status.HTTP_401_UNAUTHORIZED\n            )\n        \n        # Extract token part\n        token = auth_header[7:]  # Remove \"Bearer \" prefix\n        \n        if not token.strip():\n            raise AuthenticationError(\n                \"Empty token in Authorization header\",\n                status.HTTP_401_UNAUTHORIZED\n            )\n        \n        return token.strip()\n    \n    async def _validate_token(self, token: str) -> User:\n        \"\"\"\n        Validate JWT token and extract user information.\n        \n        Args:\n            token: JWT token string\n            \n        Returns:\n            User: Authenticated user object\n            \n        Raises:\n            AuthenticationError: If token is invalid or expired\n        \"\"\"\n        try:\n            # Decode and validate token\n            payload = self.jwt_utils.decode_token(token)\n            \n            # Extract user information from token payload\n            user_id = payload.get(\"user_id\")\n            email = payload.get(\"email\")\n            username = payload.get(\"username\")\n            \n            if not user_id:\n                raise AuthenticationError(\n                    \"Invalid token: missing user_id\",\n                    status.HTTP_401_UNAUTHORIZED\n                )\n            \n            # Create user object from token payload\n            user = User(",
      "file_type": "source",
      "semantic_unit_id": "SU-012",
      "component_id": "COMP-012",
      "description": "FastAPI authentication middleware for JWT token validation and user context injection"
    },
    {
      "file_path": "tests/test_auth_api.py",
      "content": "\"\"\"\nComprehensive integration tests for authentication endpoints\n\nTests registration, login, token refresh, and error scenarios for the authentication API.\nCovers happy path, edge cases, and security validation.\n\nComponent ID: COMP-002\nSemantic Unit: SU-002\n\nAuthor: ASP Code Generator\n\"\"\"\n\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom unittest.mock import Mock, patch\nimport json\nfrom datetime import datetime, timedelta\nimport re\n\nfrom src.api.auth import app\n\n\n@pytest.fixture\ndef client():\n    \"\"\"Create test client for FastAPI authentication application.\"\"\"\n    return TestClient(app)\n\n\n@pytest.fixture\ndef valid_user_data():\n    \"\"\"Valid user registration data for testing.\"\"\"\n    return {\n        \"username\": \"testuser\",\n        \"email\": \"test@example.com\",\n        \"password\": \"SecurePass123!\"\n    }\n\n\n@pytest.fixture\ndef valid_login_data():\n    \"\"\"Valid login credentials for testing.\"\"\"\n    return {\n        \"username\": \"testuser\",\n        \"password\": \"SecurePass123!\"\n    }\n\n\n@pytest.fixture\ndef mock_user_db():\n    \"\"\"Mock user database for testing.\"\"\"\n    return {\n        \"testuser\": {\n            \"username\": \"testuser\",\n            \"email\": \"test@example.com\",\n            \"password_hash\": \"$2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewdBPj3QJgupsqHK\",  # SecurePass123!\n            \"created_at\": \"2023-01-01T00:00:00Z\",\n            \"is_active\": True\n        }\n    }\n\n\nclass TestRegistrationEndpoint:\n    \"\"\"Test cases for POST /auth/register endpoint.\"\"\"\n\n    def test_register_valid_user_returns_201(self, client, valid_user_data):\n        \"\"\"Test that registration with valid data returns 201 Created.\"\"\"\n        response = client.post(\"/auth/register\", json=valid_user_data)\n        assert response.status_code == 201\n\n    def test_register_valid_user_returns_user_data(self, client, valid_user_data):\n        \"\"\"Test that registration returns user data without password.\"\"\"\n        response = client.post(\"/auth/register\", json=valid_user_data)\n        data = response.json()\n        \n        assert \"user\" in data\n        assert data[\"user\"][\"username\"] == valid_user_data[\"username\"]\n        assert data[\"user\"][\"email\"] == valid_user_data[\"email\"]\n        assert \"password\" not in data[\"user\"]\n        assert \"password_hash\" not in data[\"user\"]\n\n    def test_register_valid_user_returns_tokens(self, client, valid_user_data):\n        \"\"\"Test that registration returns access and refresh tokens.\"\"\"\n        response = client.post(\"/auth/register\", json=valid_user_data)\n        data = response.json()\n        \n        assert \"access_token\" in data\n        assert \"refresh_token\" in data\n        assert \"token_type\" in data\n        assert data[\"token_type\"] == \"bearer\"\n        assert isinstance(data[\"access_token\"], str)\n        assert isinstance(data[\"refresh_token\"], str)\n        assert len(data[\"access_token\"]) > 0\n        assert len(data[\"refresh_token\"]) > 0\n\n    def test_register_duplicate_username_returns_409(self, client, valid_user_data):\n        \"\"\"Test that registering duplicate username returns 409 Conflict.\"\"\"\n        # Register user first time\n        client.post(\"/auth/register\", json=valid_user_data)\n        \n        # Try to register same username again\n        response = client.post(\"/auth/register\", json=valid_user_data)\n        assert response.status_code == 409\n\n    def test_register_duplicate_username_returns_error_message(self, client, valid_user_data):\n        \"\"\"Test that duplicate username registration returns proper error message.\"\"\"\n        client.post(\"/auth/register\", json=valid_user_data)\n        response = client.post(\"/auth/register\", json=valid_user_data)\n        data = response.json()\n        \n        assert \"code\" in data\n        assert \"message\" in data\n        assert data[\"code\"] == \"USERNAME_EXISTS\"\n        assert \"already exists\" in data[\"message\"].lower()\n\n    def test_register_duplicate_email_returns_409(self, client, valid_user_data):\n        \"\"\"Test that registering duplicate email returns 409 Conflict.\"\"\"\n        client.post(\"/auth/register\", json=valid_user_data)\n        \n        # Try different username but same email\n        duplicate_email_data = {\n            \"username\": \"differentuser\",\n            \"email\": valid_user_data[\"email\"],\n            \"password\": \"AnotherPass123!\"\n        }\n        response = client.post(\"/auth/register\", json=duplicate_email_data)\n        assert response.status_code == 409\n\n    def test_register_invalid_email_format_returns_400(self, client, valid_user_data):\n        \"\"\"Test that invalid email format returns 400 Bad Request.\"\"\"\n        invalid_data = valid_user_data.copy()\n        invalid_data[\"email\"] = \"invalid-email\"\n        \n        response = client.post(\"/auth/register\", json=invalid_data)\n        assert response.status_code == 400\n\n    def test_register_weak_password_returns_400(self, client, valid_user_data):\n        \"\"\"Test that weak password returns 400 Bad Request.\"\"\"\n        weak_password_data = valid_user_data.copy()\n        weak_password_data[\"password\"] = \"weak\"\n        \n        response = client.post(\"/auth/register\", json=weak_password_data)\n        assert response.status_code == 400\n\n    def test_register_short_username_returns_400(self, client, valid_user_data):\n        \"\"\"Test that username shorter than 3 characters returns 400.\"\"\"\n        short_username_data = valid_user_data.copy()\n        short_username_data[\"username\"] = \"ab\"\n        \n        response = client.post(\"/auth/register\", json=short_username_data)\n        assert response.status_code == 400\n\n    def test_register_long_username_returns_400(self, client, valid_user_data):\n        \"\"\"Test that username longer than 50 characters returns 400.\"\"\"\n        long_username_data = valid_user_data.copy()\n        long_username_data[\"username\"] = \"a\" * 51\n        \n        response = client.post(\"/auth/register\", json=long_username_data)\n        assert response.status_code == 400\n\n    def test_register_username_with_special_chars_returns_400(self, client, valid_user_data):\n        \"\"\"Test that username with special characters returns 400.\"\"\"\n        special_char_data = valid_user_data.copy()\n        special_char_data[\"username\"] = \"user@name!\"\n        \n        response = client.post(\"/auth/register\", json=special_char_data)\n        assert response.status_code == 400\n\n    def test_register_missing_required_fields_returns_422(self, client):\n        \"\"\"Test that missing required fields returns 422 Unprocessable Entity.\"\"\"\n        incomplete_data = {\"username\": \"testuser\"}\n        \n        response = client.post(\"/auth/register\", json=incomplete_data)\n        assert response.status_code == 422\n\n    def test_register_empty_request_body_returns_422(self, client):\n        \"\"\"Test that empty request body returns 422.\"\"\"\n        response = client.post(\"/auth/register\", json={})\n        assert response.status_code == 422\n\n    def test_register_malformed_json_returns_422(self, client):\n        \"\"\"Test that malformed JSON returns 422.\"\"\"\n        response = client.post(\"/auth/register\", data=\"invalid json\")\n        assert response.status_code == 422\n\n\nclass TestLoginEndpoint:\n    \"\"\"Test cases for POST /auth/login endpoint.\"\"\"\n\n    @patch('src.api.auth.user_db')\n    def test_login_valid_credentials_returns_200(self, mock_db, client, valid_login_data, mock_user_db):\n        \"\"\"Test that login with valid credentials returns 200",
      "file_type": "test",
      "semantic_unit_id": "SU-002",
      "component_id": "COMP-002",
      "description": "Comprehensive integration tests for authentication endpoints including registration, login, token refresh, and error scenarios"
    },
    {
      "file_path": "tests/test_tasks_api.py",
      "content": "\"\"\"\nIntegration tests for task CRUD operations API endpoints.\n\nTests task creation, retrieval, updating, deletion, filtering, pagination,\nand authorization checks for the tasks API.\n\nComponent ID: COMP-003\nSemantic Unit: SU-003\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom unittest.mock import Mock, patch\nfrom datetime import datetime, timezone\nimport json\n\nfrom src.api.tasks import app\n\n\n@pytest.fixture\ndef client():\n    \"\"\"Create test client for FastAPI application.\"\"\"\n    return TestClient(app)\n\n\n@pytest.fixture\ndef mock_db():\n    \"\"\"Mock database connection for testing.\"\"\"\n    with patch('src.api.tasks.get_db') as mock:\n        db_mock = Mock()\n        mock.return_value = db_mock\n        yield db_mock\n\n\n@pytest.fixture\ndef sample_task():\n    \"\"\"Sample task data for testing.\"\"\"\n    return {\n        \"title\": \"Test Task\",\n        \"description\": \"This is a test task\",\n        \"priority\": \"medium\",\n        \"status\": \"pending\",\n        \"due_date\": \"2024-12-31T23:59:59Z\"\n    }\n\n\n@pytest.fixture\ndef sample_task_response():\n    \"\"\"Sample task response data for testing.\"\"\"\n    return {\n        \"id\": 1,\n        \"title\": \"Test Task\",\n        \"description\": \"This is a test task\",\n        \"priority\": \"medium\",\n        \"status\": \"pending\",\n        \"due_date\": \"2024-12-31T23:59:59Z\",\n        \"created_at\": \"2024-01-01T00:00:00Z\",\n        \"updated_at\": \"2024-01-01T00:00:00Z\",\n        \"user_id\": 1\n    }\n\n\n@pytest.fixture\ndef auth_headers():\n    \"\"\"Authentication headers for testing.\"\"\"\n    return {\"Authorization\": \"Bearer valid_token\"}\n\n\n@pytest.fixture\ndef invalid_auth_headers():\n    \"\"\"Invalid authentication headers for testing.\"\"\"\n    return {\"Authorization\": \"Bearer invalid_token\"}\n\n\nclass TestCreateTask:\n    \"\"\"Test cases for POST /tasks endpoint.\"\"\"\n\n    def test_create_task_success(self, client, mock_db, sample_task, sample_task_response, auth_headers):\n        \"\"\"Test successful task creation with valid data.\"\"\"\n        mock_db.execute.return_value.fetchone.return_value = sample_task_response\n        \n        response = client.post(\"/tasks\", json=sample_task, headers=auth_headers)\n        \n        assert response.status_code == 201\n        data = response.json()\n        assert data[\"title\"] == sample_task[\"title\"]\n        assert data[\"description\"] == sample_task[\"description\"]\n        assert data[\"priority\"] == sample_task[\"priority\"]\n        assert data[\"status\"] == sample_task[\"status\"]\n        assert \"id\" in data\n        assert \"created_at\" in data\n        assert \"updated_at\" in data\n\n    def test_create_task_missing_title(self, client, auth_headers):\n        \"\"\"Test task creation fails with missing title.\"\"\"\n        task_data = {\n            \"description\": \"Task without title\",\n            \"priority\": \"medium\",\n            \"status\": \"pending\"\n        }\n        \n        response = client.post(\"/tasks\", json=task_data, headers=auth_headers)\n        \n        assert response.status_code == 422\n        data = response.json()\n        assert \"title\" in str(data[\"detail\"])\n\n    def test_create_task_invalid_priority(self, client, auth_headers):\n        \"\"\"Test task creation fails with invalid priority.\"\"\"\n        task_data = {\n            \"title\": \"Test Task\",\n            \"description\": \"Task with invalid priority\",\n            \"priority\": \"invalid_priority\",\n            \"status\": \"pending\"\n        }\n        \n        response = client.post(\"/tasks\", json=task_data, headers=auth_headers)\n        \n        assert response.status_code == 422\n        data = response.json()\n        assert \"priority\" in str(data[\"detail\"])\n\n    def test_create_task_invalid_status(self, client, auth_headers):\n        \"\"\"Test task creation fails with invalid status.\"\"\"\n        task_data = {\n            \"title\": \"Test Task\",\n            \"description\": \"Task with invalid status\",\n            \"priority\": \"medium\",\n            \"status\": \"invalid_status\"\n        }\n        \n        response = client.post(\"/tasks\", json=task_data, headers=auth_headers)\n        \n        assert response.status_code == 422\n        data = response.json()\n        assert \"status\" in str(data[\"detail\"])\n\n    def test_create_task_title_too_long(self, client, auth_headers):\n        \"\"\"Test task creation fails with title exceeding maximum length.\"\"\"\n        task_data = {\n            \"title\": \"x\" * 201,  # Exceeds 200 character limit\n            \"description\": \"Task with long title\",\n            \"priority\": \"medium\",\n            \"status\": \"pending\"\n        }\n        \n        response = client.post(\"/tasks\", json=task_data, headers=auth_headers)\n        \n        assert response.status_code == 422\n        data = response.json()\n        assert \"title\" in str(data[\"detail\"])\n\n    def test_create_task_invalid_due_date_format(self, client, auth_headers):\n        \"\"\"Test task creation fails with invalid due date format.\"\"\"\n        task_data = {\n            \"title\": \"Test Task\",\n            \"description\": \"Task with invalid due date\",\n            \"priority\": \"medium\",\n            \"status\": \"pending\",\n            \"due_date\": \"invalid-date-format\"\n        }\n        \n        response = client.post(\"/tasks\", json=task_data, headers=auth_headers)\n        \n        assert response.status_code == 422\n        data = response.json()\n        assert \"due_date\" in str(data[\"detail\"])\n\n    def test_create_task_unauthorized(self, client, sample_task):\n        \"\"\"Test task creation fails without authentication.\"\"\"\n        response = client.post(\"/tasks\", json=sample_task)\n        \n        assert response.status_code == 401\n        data = response.json()\n        assert data[\"code\"] == \"UNAUTHORIZED\"\n        assert \"authentication required\" in data[\"message\"].lower()\n\n    def test_create_task_invalid_token(self, client, sample_task, invalid_auth_headers):\n        \"\"\"Test task creation fails with invalid authentication token.\"\"\"\n        response = client.post(\"/tasks\", json=sample_task, headers=invalid_auth_headers)\n        \n        assert response.status_code == 401\n        data = response.json()\n        assert data[\"code\"] == \"INVALID_TOKEN\"\n\n    def test_create_task_database_error(self, client, mock_db, sample_task, auth_headers):\n        \"\"\"Test task creation handles database errors gracefully.\"\"\"\n        mock_db.execute.side_effect = Exception(\"Database connection failed\")\n        \n        response = client.post(\"/tasks\", json=sample_task, headers=auth_headers)\n        \n        assert response.status_code == 500\n        data = response.json()\n        assert data[\"code\"] == \"INTERNAL_ERROR\"\n\n\nclass TestGetTasks:\n    \"\"\"Test cases for GET /tasks endpoint.\"\"\"\n\n    def test_get_tasks_success(self, client, mock_db, auth_headers):\n        \"\"\"Test successful retrieval of tasks list.\"\"\"\n        mock_tasks = [\n            {\"id\": 1, \"title\": \"Task 1\", \"status\": \"pending\", \"priority\": \"high\"},\n            {\"id\": 2, \"title\": \"Task 2\", \"status\": \"completed\", \"priority\": \"medium\"}\n        ]\n        mock_db.execute.return_value.fetchall.return_value = mock_tasks\n        mock_db.execute.return_value.fetchone.return_value = {\"total\": 2}\n        \n        response = client.get(\"/tasks\", headers=auth_headers)\n        \n        assert response.status_code == 200\n        data = response.json()\n        assert \"tasks\" in data\n        assert \"total\" in data\n        assert \"page\" in data\n        assert \"per_page\" in data\n        assert len(data[\"tasks\"]) == 2\n        assert data[\"total\"] == 2\n\n    def test_",
      "file_type": "test",
      "semantic_unit_id": "SU-003",
      "component_id": "COMP-003",
      "description": "Integration tests for task CRUD operations, filtering, pagination, and authorization checks"
    },
    {
      "file_path": "tests/test_user_model.py",
      "content": "\"\"\"\nUnit tests for User model operations, validation, and database relationships.\n\nTests user creation, validation, authentication, and database operations\nincluding relationships with other models.\n\nComponent ID: COMP-004\nSemantic Unit: SU-004\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport pytest\nfrom datetime import datetime, timedelta\nfrom unittest.mock import Mock, patch, MagicMock\nfrom sqlalchemy.exc import IntegrityError, SQLAlchemyError\nfrom sqlalchemy.orm import Session\nfrom passlib.context import CryptContext\n\nfrom src.models.user import User, UserCreate, UserUpdate, UserResponse\n\n\nclass TestUserModel:\n    \"\"\"Test cases for User model class.\"\"\"\n\n    def test_user_model_creation_with_valid_data(self):\n        \"\"\"Test that User model can be created with valid data.\"\"\"\n        user = User(\n            username=\"testuser\",\n            email=\"test@example.com\",\n            hashed_password=\"hashed_password_123\",\n            full_name=\"Test User\"\n        )\n        \n        assert user.username == \"testuser\"\n        assert user.email == \"test@example.com\"\n        assert user.hashed_password == \"hashed_password_123\"\n        assert user.full_name == \"Test User\"\n        assert user.is_active is True\n        assert user.is_superuser is False\n        assert isinstance(user.created_at, datetime)\n        assert isinstance(user.updated_at, datetime)\n\n    def test_user_model_creation_with_minimal_data(self):\n        \"\"\"Test that User model can be created with minimal required data.\"\"\"\n        user = User(\n            username=\"minimaluser\",\n            email=\"minimal@example.com\",\n            hashed_password=\"hashed_password_456\"\n        )\n        \n        assert user.username == \"minimaluser\"\n        assert user.email == \"minimal@example.com\"\n        assert user.hashed_password == \"hashed_password_456\"\n        assert user.full_name is None\n        assert user.is_active is True\n        assert user.is_superuser is False\n\n    def test_user_model_string_representation(self):\n        \"\"\"Test that User model has proper string representation.\"\"\"\n        user = User(\n            username=\"repruser\",\n            email=\"repr@example.com\",\n            hashed_password=\"hashed_password_789\"\n        )\n        \n        assert str(user) == \"repruser\"\n        assert repr(user) == \"<User(username='repruser', email='repr@example.com')>\"\n\n    def test_user_model_timestamps_auto_update(self):\n        \"\"\"Test that timestamps are automatically set and updated.\"\"\"\n        user = User(\n            username=\"timeuser\",\n            email=\"time@example.com\",\n            hashed_password=\"hashed_password_time\"\n        )\n        \n        original_created = user.created_at\n        original_updated = user.updated_at\n        \n        # Simulate update\n        user.full_name = \"Updated Name\"\n        user.updated_at = datetime.utcnow()\n        \n        assert user.created_at == original_created\n        assert user.updated_at > original_updated\n\n    def test_user_model_password_verification(self):\n        \"\"\"Test password verification functionality.\"\"\"\n        user = User(\n            username=\"passuser\",\n            email=\"pass@example.com\",\n            hashed_password=\"$2b$12$test_hashed_password\"\n        )\n        \n        with patch('passlib.context.CryptContext.verify') as mock_verify:\n            mock_verify.return_value = True\n            assert user.verify_password(\"correct_password\") is True\n            \n            mock_verify.return_value = False\n            assert user.verify_password(\"wrong_password\") is False\n\n    def test_user_model_password_hashing(self):\n        \"\"\"Test password hashing functionality.\"\"\"\n        with patch('passlib.context.CryptContext.hash') as mock_hash:\n            mock_hash.return_value = \"$2b$12$hashed_test_password\"\n            \n            user = User(\n                username=\"hashuser\",\n                email=\"hash@example.com\"\n            )\n            user.set_password(\"plain_password\")\n            \n            assert user.hashed_password == \"$2b$12$hashed_test_password\"\n            mock_hash.assert_called_once_with(\"plain_password\")\n\n\nclass TestUserCreate:\n    \"\"\"Test cases for UserCreate Pydantic model.\"\"\"\n\n    def test_user_create_with_valid_data(self):\n        \"\"\"Test UserCreate model with valid data.\"\"\"\n        user_data = {\n            \"username\": \"newuser\",\n            \"email\": \"new@example.com\",\n            \"password\": \"securepassword123\",\n            \"full_name\": \"New User\"\n        }\n        \n        user_create = UserCreate(**user_data)\n        \n        assert user_create.username == \"newuser\"\n        assert user_create.email == \"new@example.com\"\n        assert user_create.password == \"securepassword123\"\n        assert user_create.full_name == \"New User\"\n\n    def test_user_create_with_minimal_data(self):\n        \"\"\"Test UserCreate model with minimal required data.\"\"\"\n        user_data = {\n            \"username\": \"minuser\",\n            \"email\": \"min@example.com\",\n            \"password\": \"password123\"\n        }\n        \n        user_create = UserCreate(**user_data)\n        \n        assert user_create.username == \"minuser\"\n        assert user_create.email == \"min@example.com\"\n        assert user_create.password == \"password123\"\n        assert user_create.full_name is None\n\n    def test_user_create_username_validation(self):\n        \"\"\"Test username validation in UserCreate model.\"\"\"\n        # Valid username\n        valid_data = {\n            \"username\": \"validuser123\",\n            \"email\": \"valid@example.com\",\n            \"password\": \"password123\"\n        }\n        user_create = UserCreate(**valid_data)\n        assert user_create.username == \"validuser123\"\n\n        # Invalid username - too short\n        with pytest.raises(ValueError, match=\"Username must be at least 3 characters\"):\n            UserCreate(username=\"ab\", email=\"test@example.com\", password=\"password123\")\n\n        # Invalid username - too long\n        with pytest.raises(ValueError, match=\"Username must be at most 50 characters\"):\n            UserCreate(username=\"a\" * 51, email=\"test@example.com\", password=\"password123\")\n\n        # Invalid username - invalid characters\n        with pytest.raises(ValueError, match=\"Username can only contain letters, numbers, and underscores\"):\n            UserCreate(username=\"user@name\", email=\"test@example.com\", password=\"password123\")\n\n    def test_user_create_email_validation(self):\n        \"\"\"Test email validation in UserCreate model.\"\"\"\n        # Valid email\n        valid_data = {\n            \"username\": \"testuser\",\n            \"email\": \"valid.email@example.com\",\n            \"password\": \"password123\"\n        }\n        user_create = UserCreate(**valid_data)\n        assert user_create.email == \"valid.email@example.com\"\n\n        # Invalid email format\n        with pytest.raises(ValueError, match=\"Invalid email format\"):\n            UserCreate(username=\"testuser\", email=\"invalid-email\", password=\"password123\")\n\n        # Empty email\n        with pytest.raises(ValueError, match=\"Email is required\"):\n            UserCreate(username=\"testuser\", email=\"\", password=\"password123\")\n\n    def test_user_create_password_validation(self):\n        \"\"\"Test password validation in UserCreate model.\"\"\"\n        # Valid password\n        valid_data = {\n            \"username\": \"testuser\",\n            \"email\": \"test@example.com\",\n            \"password\": \"securepassword123\"\n        }\n        user_create = UserCreate(**valid_data)\n        assert user_create.password == \"securepassword123\"\n\n        # Invalid password - too short\n        with pytest.raises(ValueError, match=\"Password must be at least 8 characters\"):\n            UserCreate(username=\"testuser\", email=\"test@example.com\", password=\"short\")\n\n        # Invalid password - too long\n        with pytest.raises(ValueError, match=\"Password must be at most 128 characters\"):",
      "file_type": "test",
      "semantic_unit_id": "SU-004",
      "component_id": "COMP-004",
      "description": "Unit tests for user model operations, validation, and database relationships"
    },
    {
      "file_path": "tests/test_task_model.py",
      "content": "\"\"\"\nUnit tests for Task model CRUD operations, status transitions, and user relationships.\n\nTests all Task model functionality including creation, updates, status changes,\nand relationships with User model.\n\nComponent ID: COMP-005\nSemantic Unit: SU-005\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport pytest\nfrom datetime import datetime, timedelta\nfrom unittest.mock import Mock, patch\nfrom sqlalchemy.exc import IntegrityError, SQLAlchemyError\nfrom sqlalchemy.orm import Session\n\nfrom src.models.task import Task, TaskStatus, TaskPriority\nfrom src.models.user import User\n\n\n@pytest.fixture\ndef db_session():\n    \"\"\"Mock database session for testing.\"\"\"\n    session = Mock(spec=Session)\n    return session\n\n\n@pytest.fixture\ndef sample_user():\n    \"\"\"Create a sample user for testing.\"\"\"\n    user = User(\n        id=1,\n        username=\"testuser\",\n        email=\"test@example.com\",\n        hashed_password=\"hashed_password_123\"\n    )\n    return user\n\n\n@pytest.fixture\ndef sample_task(sample_user):\n    \"\"\"Create a sample task for testing.\"\"\"\n    task = Task(\n        id=1,\n        title=\"Test Task\",\n        description=\"This is a test task\",\n        status=TaskStatus.TODO,\n        priority=TaskPriority.MEDIUM,\n        user_id=sample_user.id,\n        user=sample_user,\n        created_at=datetime.utcnow(),\n        updated_at=datetime.utcnow()\n    )\n    return task\n\n\nclass TestTaskModel:\n    \"\"\"Test cases for Task model basic functionality.\"\"\"\n\n    def test_task_creation_with_required_fields(self, sample_user):\n        \"\"\"Test that task can be created with only required fields.\"\"\"\n        task = Task(\n            title=\"New Task\",\n            description=\"Task description\",\n            user_id=sample_user.id\n        )\n        \n        assert task.title == \"New Task\"\n        assert task.description == \"Task description\"\n        assert task.user_id == sample_user.id\n        assert task.status == TaskStatus.TODO  # Default status\n        assert task.priority == TaskPriority.MEDIUM  # Default priority\n        assert task.created_at is None  # Set by database\n        assert task.updated_at is None  # Set by database\n\n    def test_task_creation_with_all_fields(self, sample_user):\n        \"\"\"Test that task can be created with all fields specified.\"\"\"\n        now = datetime.utcnow()\n        task = Task(\n            title=\"Complete Task\",\n            description=\"Detailed description\",\n            status=TaskStatus.IN_PROGRESS,\n            priority=TaskPriority.HIGH,\n            user_id=sample_user.id,\n            due_date=now + timedelta(days=7),\n            created_at=now,\n            updated_at=now\n        )\n        \n        assert task.title == \"Complete Task\"\n        assert task.description == \"Detailed description\"\n        assert task.status == TaskStatus.IN_PROGRESS\n        assert task.priority == TaskPriority.HIGH\n        assert task.user_id == sample_user.id\n        assert task.due_date == now + timedelta(days=7)\n        assert task.created_at == now\n        assert task.updated_at == now\n\n    def test_task_string_representation(self, sample_task):\n        \"\"\"Test task string representation.\"\"\"\n        expected = f\"<Task(id=1, title='Test Task', status=TaskStatus.TODO)>\"\n        assert str(sample_task) == expected\n\n    def test_task_repr_representation(self, sample_task):\n        \"\"\"Test task repr representation.\"\"\"\n        expected = f\"<Task(id=1, title='Test Task', status=TaskStatus.TODO)>\"\n        assert repr(sample_task) == expected\n\n\nclass TestTaskCRUDOperations:\n    \"\"\"Test cases for Task CRUD operations.\"\"\"\n\n    def test_create_task_success(self, db_session, sample_user):\n        \"\"\"Test successful task creation.\"\"\"\n        task_data = {\n            \"title\": \"New Task\",\n            \"description\": \"Task description\",\n            \"user_id\": sample_user.id\n        }\n        \n        task = Task.create(db_session, **task_data)\n        \n        db_session.add.assert_called_once()\n        db_session.commit.assert_called_once()\n        db_session.refresh.assert_called_once()\n        assert task.title == \"New Task\"\n        assert task.description == \"Task description\"\n        assert task.user_id == sample_user.id\n\n    def test_create_task_database_error(self, db_session, sample_user):\n        \"\"\"Test task creation with database error.\"\"\"\n        db_session.commit.side_effect = IntegrityError(\"\", \"\", \"\")\n        \n        task_data = {\n            \"title\": \"New Task\",\n            \"description\": \"Task description\",\n            \"user_id\": sample_user.id\n        }\n        \n        with pytest.raises(IntegrityError):\n            Task.create(db_session, **task_data)\n        \n        db_session.rollback.assert_called_once()\n\n    def test_get_task_by_id_success(self, db_session, sample_task):\n        \"\"\"Test successful task retrieval by ID.\"\"\"\n        db_session.query.return_value.filter.return_value.first.return_value = sample_task\n        \n        result = Task.get_by_id(db_session, 1)\n        \n        assert result == sample_task\n        db_session.query.assert_called_once_with(Task)\n\n    def test_get_task_by_id_not_found(self, db_session):\n        \"\"\"Test task retrieval by ID when task doesn't exist.\"\"\"\n        db_session.query.return_value.filter.return_value.first.return_value = None\n        \n        result = Task.get_by_id(db_session, 999)\n        \n        assert result is None\n\n    def test_get_tasks_by_user_id(self, db_session, sample_task, sample_user):\n        \"\"\"Test retrieving all tasks for a specific user.\"\"\"\n        db_session.query.return_value.filter.return_value.all.return_value = [sample_task]\n        \n        result = Task.get_by_user_id(db_session, sample_user.id)\n        \n        assert result == [sample_task]\n        db_session.query.assert_called_once_with(Task)\n\n    def test_get_tasks_by_user_id_empty(self, db_session):\n        \"\"\"Test retrieving tasks for user with no tasks.\"\"\"\n        db_session.query.return_value.filter.return_value.all.return_value = []\n        \n        result = Task.get_by_user_id(db_session, 999)\n        \n        assert result == []\n\n    def test_update_task_success(self, db_session, sample_task):\n        \"\"\"Test successful task update.\"\"\"\n        update_data = {\n            \"title\": \"Updated Task\",\n            \"description\": \"Updated description\",\n            \"priority\": TaskPriority.HIGH\n        }\n        \n        updated_task = Task.update(db_session, sample_task, **update_data)\n        \n        assert updated_task.title == \"Updated Task\"\n        assert updated_task.description == \"Updated description\"\n        assert updated_task.priority == TaskPriority.HIGH\n        db_session.commit.assert_called_once()\n        db_session.refresh.assert_called_once()\n\n    def test_update_task_database_error(self, db_session, sample_task):\n        \"\"\"Test task update with database error.\"\"\"\n        db_session.commit.side_effect = SQLAlchemyError(\"Database error\")\n        \n        update_data = {\"title\": \"Updated Task\"}\n        \n        with pytest.raises(SQLAlchemyError):\n            Task.update(db_session, sample_task, **update_data)\n        \n        db_session.rollback.assert_called_once()\n\n    def test_delete_task_success(self, db_session, sample_task):\n        \"\"\"Test successful task deletion.\"\"\"\n        result = Task.delete(db_session, sample",
      "file_type": "test",
      "semantic_unit_id": "SU-005",
      "component_id": "COMP-005",
      "description": "Unit tests for task model CRUD operations, status transitions, and user relationships"
    },
    {
      "file_path": "tests/test_jwt_utils.py",
      "content": "\"\"\"\nUnit tests for JWT token generation, validation, expiration handling, and refresh token logic\n\nTests all JWT utility functions including token creation, validation, expiration,\nrefresh token management, and error handling scenarios.\n\nComponent ID: COMP-008\nSemantic Unit: SU-008\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport pytest\nfrom datetime import datetime, timedelta, timezone\nfrom unittest.mock import patch, MagicMock\nimport jwt\nfrom freezegun import freeze_time\n\nfrom src.utils.jwt_utils import (\n    generate_access_token,\n    generate_refresh_token,\n    validate_token,\n    decode_token,\n    is_token_expired,\n    refresh_access_token,\n    revoke_token,\n    get_token_expiry,\n    extract_user_id,\n    TokenError,\n    ExpiredTokenError,\n    InvalidTokenError,\n    RevokedTokenError\n)\n\n\n@pytest.fixture\ndef mock_secret_key():\n    \"\"\"Mock JWT secret key for testing.\"\"\"\n    return \"test-secret-key-12345\"\n\n\n@pytest.fixture\ndef mock_algorithm():\n    \"\"\"Mock JWT algorithm for testing.\"\"\"\n    return \"HS256\"\n\n\n@pytest.fixture\ndef sample_user_id():\n    \"\"\"Sample user ID for testing.\"\"\"\n    return \"user123\"\n\n\n@pytest.fixture\ndef sample_payload():\n    \"\"\"Sample JWT payload for testing.\"\"\"\n    return {\n        \"user_id\": \"user123\",\n        \"email\": \"test@example.com\",\n        \"role\": \"user\"\n    }\n\n\n@pytest.fixture\ndef valid_access_token(mock_secret_key, mock_algorithm, sample_payload):\n    \"\"\"Generate a valid access token for testing.\"\"\"\n    payload = sample_payload.copy()\n    payload[\"exp\"] = datetime.now(timezone.utc) + timedelta(hours=1)\n    payload[\"iat\"] = datetime.now(timezone.utc)\n    payload[\"type\"] = \"access\"\n    return jwt.encode(payload, mock_secret_key, algorithm=mock_algorithm)\n\n\n@pytest.fixture\ndef valid_refresh_token(mock_secret_key, mock_algorithm, sample_payload):\n    \"\"\"Generate a valid refresh token for testing.\"\"\"\n    payload = sample_payload.copy()\n    payload[\"exp\"] = datetime.now(timezone.utc) + timedelta(days=7)\n    payload[\"iat\"] = datetime.now(timezone.utc)\n    payload[\"type\"] = \"refresh\"\n    return jwt.encode(payload, mock_secret_key, algorithm=mock_algorithm)\n\n\n@pytest.fixture\ndef expired_token(mock_secret_key, mock_algorithm, sample_payload):\n    \"\"\"Generate an expired token for testing.\"\"\"\n    payload = sample_payload.copy()\n    payload[\"exp\"] = datetime.now(timezone.utc) - timedelta(hours=1)\n    payload[\"iat\"] = datetime.now(timezone.utc) - timedelta(hours=2)\n    payload[\"type\"] = \"access\"\n    return jwt.encode(payload, mock_secret_key, algorithm=mock_algorithm)\n\n\nclass TestGenerateAccessToken:\n    \"\"\"Test cases for generate_access_token function.\"\"\"\n\n    @patch('src.utils.jwt_utils.JWT_SECRET_KEY', 'test-secret')\n    @patch('src.utils.jwt_utils.JWT_ALGORITHM', 'HS256')\n    def test_generate_access_token_success(self, sample_user_id):\n        \"\"\"Test successful access token generation.\"\"\"\n        token = generate_access_token(sample_user_id)\n        \n        assert isinstance(token, str)\n        assert len(token) > 0\n        \n        # Decode to verify structure\n        decoded = jwt.decode(token, 'test-secret', algorithms=['HS256'])\n        assert decoded['user_id'] == sample_user_id\n        assert decoded['type'] == 'access'\n        assert 'exp' in decoded\n        assert 'iat' in decoded\n\n    @patch('src.utils.jwt_utils.JWT_SECRET_KEY', 'test-secret')\n    @patch('src.utils.jwt_utils.JWT_ALGORITHM', 'HS256')\n    def test_generate_access_token_with_custom_expiry(self, sample_user_id):\n        \"\"\"Test access token generation with custom expiry time.\"\"\"\n        custom_expiry = timedelta(minutes=30)\n        token = generate_access_token(sample_user_id, expires_delta=custom_expiry)\n        \n        decoded = jwt.decode(token, 'test-secret', algorithms=['HS256'])\n        exp_time = datetime.fromtimestamp(decoded['exp'], tz=timezone.utc)\n        iat_time = datetime.fromtimestamp(decoded['iat'], tz=timezone.utc)\n        \n        assert (exp_time - iat_time) == custom_expiry\n\n    @patch('src.utils.jwt_utils.JWT_SECRET_KEY', 'test-secret')\n    @patch('src.utils.jwt_utils.JWT_ALGORITHM', 'HS256')\n    def test_generate_access_token_with_additional_claims(self, sample_user_id):\n        \"\"\"Test access token generation with additional claims.\"\"\"\n        additional_claims = {\"role\": \"admin\", \"permissions\": [\"read\", \"write\"]}\n        token = generate_access_token(sample_user_id, additional_claims=additional_claims)\n        \n        decoded = jwt.decode(token, 'test-secret', algorithms=['HS256'])\n        assert decoded['role'] == 'admin'\n        assert decoded['permissions'] == [\"read\", \"write\"]\n\n    def test_generate_access_token_invalid_user_id(self):\n        \"\"\"Test access token generation with invalid user ID.\"\"\"\n        with pytest.raises(ValueError, match=\"User ID cannot be empty\"):\n            generate_access_token(\"\")\n        \n        with pytest.raises(ValueError, match=\"User ID cannot be None\"):\n            generate_access_token(None)\n\n    def test_generate_access_token_invalid_expiry(self, sample_user_id):\n        \"\"\"Test access token generation with invalid expiry delta.\"\"\"\n        with pytest.raises(ValueError, match=\"Expiry delta must be positive\"):\n            generate_access_token(sample_user_id, expires_delta=timedelta(seconds=-1))\n\n\nclass TestGenerateRefreshToken:\n    \"\"\"Test cases for generate_refresh_token function.\"\"\"\n\n    @patch('src.utils.jwt_utils.JWT_SECRET_KEY', 'test-secret')\n    @patch('src.utils.jwt_utils.JWT_ALGORITHM', 'HS256')\n    def test_generate_refresh_token_success(self, sample_user_id):\n        \"\"\"Test successful refresh token generation.\"\"\"\n        token = generate_refresh_token(sample_user_id)\n        \n        assert isinstance(token, str)\n        assert len(token) > 0\n        \n        decoded = jwt.decode(token, 'test-secret', algorithms=['HS256'])\n        assert decoded['user_id'] == sample_user_id\n        assert decoded['type'] == 'refresh'\n        assert 'exp' in decoded\n        assert 'iat' in decoded\n\n    @patch('src.utils.jwt_utils.JWT_SECRET_KEY', 'test-secret')\n    @patch('src.utils.jwt_utils.JWT_ALGORITHM', 'HS256')\n    def test_generate_refresh_token_default_expiry(self, sample_user_id):\n        \"\"\"Test refresh token has longer expiry than access token.\"\"\"\n        refresh_token = generate_refresh_token(sample_user_id)\n        access_token = generate_access_token(sample_user_id)\n        \n        refresh_decoded = jwt.decode(refresh_token, 'test-secret', algorithms=['HS256'])\n        access_decoded = jwt.decode(access_token, 'test-secret', algorithms=['HS256'])\n        \n        assert refresh_decoded['exp'] > access_decoded['exp']\n\n    def test_generate_refresh_token_invalid_user_id(self):\n        \"\"\"Test refresh token generation with invalid user ID.\"\"\"\n        with pytest.raises(ValueError, match=\"User ID cannot be empty\"):\n            generate_refresh_token(\"\")\n\n\nclass TestValidateToken:\n    \"\"\"Test cases for validate_token function.\"\"\"\n\n    @patch('src.utils",
      "file_type": "test",
      "semantic_unit_id": "SU-008",
      "component_id": "COMP-008",
      "description": "Unit tests for JWT token generation, validation, expiration handling, and refresh token logic"
    },
    {
      "file_path": "tests/test_password.py",
      "content": "\"\"\"\nUnit tests for password utility functions\n\nTests password hashing, verification, and strength validation with comprehensive\nedge case coverage including empty inputs, special characters, and security scenarios.\n\nComponent ID: COMP-009\nSemantic Unit: SU-009\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport pytest\nfrom unittest.mock import patch, MagicMock\nimport bcrypt\nimport re\n\nfrom src.utils.password import (\n    hash_password,\n    verify_password,\n    validate_password_strength,\n    generate_salt,\n    is_password_compromised\n)\n\n\nclass TestHashPassword:\n    \"\"\"Test cases for password hashing functionality.\"\"\"\n\n    def test_hash_password_returns_string(self):\n        \"\"\"Test that hash_password returns a string.\"\"\"\n        password = \"test_password_123\"\n        hashed = hash_password(password)\n        assert isinstance(hashed, str)\n\n    def test_hash_password_returns_bcrypt_hash(self):\n        \"\"\"Test that hash_password returns a valid bcrypt hash.\"\"\"\n        password = \"test_password_123\"\n        hashed = hash_password(password)\n        assert hashed.startswith(\"$2b$\")\n        assert len(hashed) == 60  # Standard bcrypt hash length\n\n    def test_hash_password_different_inputs_different_hashes(self):\n        \"\"\"Test that different passwords produce different hashes.\"\"\"\n        password1 = \"password123\"\n        password2 = \"password456\"\n        hash1 = hash_password(password1)\n        hash2 = hash_password(password2)\n        assert hash1 != hash2\n\n    def test_hash_password_same_input_different_hashes(self):\n        \"\"\"Test that same password produces different hashes due to salt.\"\"\"\n        password = \"same_password\"\n        hash1 = hash_password(password)\n        hash2 = hash_password(password)\n        assert hash1 != hash2\n\n    def test_hash_password_empty_string(self):\n        \"\"\"Test that hash_password handles empty string.\"\"\"\n        password = \"\"\n        hashed = hash_password(password)\n        assert isinstance(hashed, str)\n        assert hashed.startswith(\"$2b$\")\n\n    def test_hash_password_unicode_characters(self):\n        \"\"\"Test that hash_password handles unicode characters.\"\"\"\n        password = \"pssw0rd__\"\n        hashed = hash_password(password)\n        assert isinstance(hashed, str)\n        assert hashed.startswith(\"$2b$\")\n\n    def test_hash_password_special_characters(self):\n        \"\"\"Test that hash_password handles special characters.\"\"\"\n        password = \"p@ssw0rd!#$%^&*()_+-=[]{}|;:,.<>?\"\n        hashed = hash_password(password)\n        assert isinstance(hashed, str)\n        assert hashed.startswith(\"$2b$\")\n\n    def test_hash_password_very_long_password(self):\n        \"\"\"Test that hash_password handles very long passwords.\"\"\"\n        password = \"a\" * 1000\n        hashed = hash_password(password)\n        assert isinstance(hashed, str)\n        assert hashed.startswith(\"$2b$\")\n\n    def test_hash_password_with_custom_rounds(self):\n        \"\"\"Test that hash_password accepts custom rounds parameter.\"\"\"\n        password = \"test_password\"\n        hashed = hash_password(password, rounds=10)\n        assert isinstance(hashed, str)\n        assert \"$2b$10$\" in hashed\n\n    def test_hash_password_invalid_rounds_raises_error(self):\n        \"\"\"Test that hash_password raises error for invalid rounds.\"\"\"\n        password = \"test_password\"\n        with pytest.raises(ValueError, match=\"Rounds must be between 4 and 31\"):\n            hash_password(password, rounds=3)\n        \n        with pytest.raises(ValueError, match=\"Rounds must be between 4 and 31\"):\n            hash_password(password, rounds=32)\n\n    def test_hash_password_none_input_raises_error(self):\n        \"\"\"Test that hash_password raises error for None input.\"\"\"\n        with pytest.raises(TypeError, match=\"Password must be a string\"):\n            hash_password(None)\n\n    def test_hash_password_non_string_input_raises_error(self):\n        \"\"\"Test that hash_password raises error for non-string input.\"\"\"\n        with pytest.raises(TypeError, match=\"Password must be a string\"):\n            hash_password(123)\n\n\nclass TestVerifyPassword:\n    \"\"\"Test cases for password verification functionality.\"\"\"\n\n    def test_verify_password_correct_password_returns_true(self):\n        \"\"\"Test that verify_password returns True for correct password.\"\"\"\n        password = \"correct_password_123\"\n        hashed = hash_password(password)\n        assert verify_password(password, hashed) is True\n\n    def test_verify_password_incorrect_password_returns_false(self):\n        \"\"\"Test that verify_password returns False for incorrect password.\"\"\"\n        password = \"correct_password\"\n        wrong_password = \"wrong_password\"\n        hashed = hash_password(password)\n        assert verify_password(wrong_password, hashed) is False\n\n    def test_verify_password_empty_password_against_hash(self):\n        \"\"\"Test that verify_password handles empty password correctly.\"\"\"\n        password = \"\"\n        hashed = hash_password(password)\n        assert verify_password(\"\", hashed) is True\n        assert verify_password(\"not_empty\", hashed) is False\n\n    def test_verify_password_case_sensitive(self):\n        \"\"\"Test that verify_password is case sensitive.\"\"\"\n        password = \"CaseSensitive\"\n        hashed = hash_password(password)\n        assert verify_password(\"CaseSensitive\", hashed) is True\n        assert verify_password(\"casesensitive\", hashed) is False\n        assert verify_password(\"CASESENSITIVE\", hashed) is False\n\n    def test_verify_password_unicode_characters(self):\n        \"\"\"Test that verify_password handles unicode characters.\"\"\"\n        password = \"pssw0rd__\"\n        hashed = hash_password(password)\n        assert verify_password(password, hashed) is True\n        assert verify_password(\"different_unicode_\", hashed) is False\n\n    def test_verify_password_special_characters(self):\n        \"\"\"Test that verify_password handles special characters.\"\"\"\n        password = \"p@ssw0rd!#$%^&*()_+-=[]{}|;:,.<>?\"\n        hashed = hash_password(password)\n        assert verify_password(password, hashed) is True\n\n    def test_verify_password_invalid_hash_returns_false(self):\n        \"\"\"Test that verify_password returns False for invalid hash.\"\"\"\n        password = \"test_password\"\n        invalid_hash = \"invalid_hash_format\"\n        assert verify_password(password, invalid_hash) is False\n\n    def test_verify_password_none_password_raises_error(self):\n        \"\"\"Test that verify_password raises error for None password.\"\"\"\n        hashed = hash_password(\"test\")\n        with pytest.raises(TypeError, match=\"Password must be a string\"):\n            verify_password(None, hashed)\n\n    def test_verify_password_none_hash_raises_error(self):\n        \"\"\"Test that verify_password raises error for None hash.\"\"\"\n        with pytest.raises(TypeError, match=\"Hash must be a string\"):\n            verify_password(\"test\", None)\n\n    def test_verify_password_non_string_inputs_raise_error(self):\n        \"\"\"Test that verify_password raises error for non-string inputs.\"\"\"\n        with pytest.raises(TypeError, match=\"Password must be a string\"):\n            verify_password(123, \"hash\")\n        \n        with pytest.raises(TypeError, match=\"Hash must be a string\"):\n            verify_password(\"password\", 123)\n\n\nclass TestValidatePasswordStrength:\n    \"\"\"Test cases for password strength validation.\"\"\"\n\n    def test_validate_password_strength_strong_password_returns_true(self):\n        \"\"\"Test that validate_password_strength returns True for strong password.\"\"\"\n        strong_passwords = [\n            \"StrongP@ssw0rd123\",\n            \"MySecure!Password2023\",\n            \"C0mplex#Pass_Word\",\n            \"",
      "file_type": "test",
      "semantic_unit_id": "SU-009",
      "component_id": "COMP-009",
      "description": "Unit tests for password hashing, verification, and strength validation with edge cases"
    },
    {
      "file_path": "tests/test_middleware.py",
      "content": "\"\"\"\nUnit tests for authentication middleware\n\nTests token validation, user context injection, and error handling\nfor the authentication middleware component.\n\nComponent ID: COMP-012\nSemantic Unit: SU-012\n\nAuthor: ASP Code Generator\n\"\"\"\n\nimport pytest\nfrom unittest.mock import Mock, patch, AsyncMock\nfrom fastapi import FastAPI, Request, HTTPException\nfrom fastapi.testclient import TestClient\nimport jwt\nfrom datetime import datetime, timedelta\n\nfrom src.middleware.auth import AuthMiddleware, get_current_user, verify_token\n\n\nclass TestAuthMiddleware:\n    \"\"\"Test suite for AuthMiddleware class.\"\"\"\n\n    @pytest.fixture\n    def app(self):\n        \"\"\"Create FastAPI test application.\"\"\"\n        app = FastAPI()\n        return app\n\n    @pytest.fixture\n    def auth_middleware(self, app):\n        \"\"\"Create AuthMiddleware instance.\"\"\"\n        return AuthMiddleware(app)\n\n    @pytest.fixture\n    def mock_request(self):\n        \"\"\"Create mock request object.\"\"\"\n        request = Mock(spec=Request)\n        request.headers = {}\n        request.state = Mock()\n        return request\n\n    @pytest.fixture\n    def valid_token(self):\n        \"\"\"Create valid JWT token for testing.\"\"\"\n        payload = {\n            \"user_id\": \"123\",\n            \"username\": \"testuser\",\n            \"email\": \"test@example.com\",\n            \"exp\": datetime.utcnow() + timedelta(hours=1)\n        }\n        return jwt.encode(payload, \"test_secret\", algorithm=\"HS256\")\n\n    @pytest.fixture\n    def expired_token(self):\n        \"\"\"Create expired JWT token for testing.\"\"\"\n        payload = {\n            \"user_id\": \"123\",\n            \"username\": \"testuser\",\n            \"email\": \"test@example.com\",\n            \"exp\": datetime.utcnow() - timedelta(hours=1)\n        }\n        return jwt.encode(payload, \"test_secret\", algorithm=\"HS256\")\n\n    def test_auth_middleware_initialization(self, app):\n        \"\"\"Test that AuthMiddleware initializes correctly.\"\"\"\n        middleware = AuthMiddleware(app)\n        assert middleware.app == app\n        assert hasattr(middleware, 'dispatch')\n\n    @pytest.mark.asyncio\n    async def test_dispatch_with_valid_token(self, auth_middleware, mock_request, valid_token):\n        \"\"\"Test middleware dispatch with valid authorization token.\"\"\"\n        mock_request.headers = {\"Authorization\": f\"Bearer {valid_token}\"}\n        mock_call_next = AsyncMock(return_value=Mock())\n        \n        with patch('src.middleware.auth.verify_token') as mock_verify:\n            mock_verify.return_value = {\n                \"user_id\": \"123\",\n                \"username\": \"testuser\",\n                \"email\": \"test@example.com\"\n            }\n            \n            response = await auth_middleware.dispatch(mock_request, mock_call_next)\n            \n            mock_verify.assert_called_once_with(valid_token)\n            mock_call_next.assert_called_once_with(mock_request)\n            assert hasattr(mock_request.state, 'user')\n            assert mock_request.state.user[\"user_id\"] == \"123\"\n\n    @pytest.mark.asyncio\n    async def test_dispatch_without_authorization_header(self, auth_middleware, mock_request):\n        \"\"\"Test middleware dispatch without Authorization header.\"\"\"\n        mock_call_next = AsyncMock(return_value=Mock())\n        \n        response = await auth_middleware.dispatch(mock_request, mock_call_next)\n        \n        mock_call_next.assert_called_once_with(mock_request)\n        assert not hasattr(mock_request.state, 'user')\n\n    @pytest.mark.asyncio\n    async def test_dispatch_with_invalid_token_format(self, auth_middleware, mock_request):\n        \"\"\"Test middleware dispatch with invalid token format.\"\"\"\n        mock_request.headers = {\"Authorization\": \"InvalidFormat token123\"}\n        mock_call_next = AsyncMock(return_value=Mock())\n        \n        response = await auth_middleware.dispatch(mock_request, mock_call_next)\n        \n        mock_call_next.assert_called_once_with(mock_request)\n        assert not hasattr(mock_request.state, 'user')\n\n    @pytest.mark.asyncio\n    async def test_dispatch_with_expired_token(self, auth_middleware, mock_request, expired_token):\n        \"\"\"Test middleware dispatch with expired token.\"\"\"\n        mock_request.headers = {\"Authorization\": f\"Bearer {expired_token}\"}\n        mock_call_next = AsyncMock(return_value=Mock())\n        \n        with patch('src.middleware.auth.verify_token') as mock_verify:\n            mock_verify.side_effect = HTTPException(status_code=401, detail=\"Token expired\")\n            \n            response = await auth_middleware.dispatch(mock_request, mock_call_next)\n            \n            mock_call_next.assert_called_once_with(mock_request)\n            assert not hasattr(mock_request.state, 'user')\n\n    @pytest.mark.asyncio\n    async def test_dispatch_with_malformed_token(self, auth_middleware, mock_request):\n        \"\"\"Test middleware dispatch with malformed JWT token.\"\"\"\n        mock_request.headers = {\"Authorization\": \"Bearer malformed.token.here\"}\n        mock_call_next = AsyncMock(return_value=Mock())\n        \n        with patch('src.middleware.auth.verify_token') as mock_verify:\n            mock_verify.side_effect = HTTPException(status_code=401, detail=\"Invalid token\")\n            \n            response = await auth_middleware.dispatch(mock_request, mock_call_next)\n            \n            mock_call_next.assert_called_once_with(mock_request)\n            assert not hasattr(mock_request.state, 'user')\n\n    @pytest.mark.asyncio\n    async def test_dispatch_preserves_request_state(self, auth_middleware, mock_request, valid_token):\n        \"\"\"Test that middleware preserves existing request state.\"\"\"\n        mock_request.headers = {\"Authorization\": f\"Bearer {valid_token}\"}\n        mock_request.state.existing_data = \"preserved\"\n        mock_call_next = AsyncMock(return_value=Mock())\n        \n        with patch('src.middleware.auth.verify_token') as mock_verify:\n            mock_verify.return_value = {\"user_id\": \"123\", \"username\": \"testuser\"}\n            \n            await auth_middleware.dispatch(mock_request, mock_call_next)\n            \n            assert mock_request.state.existing_data == \"preserved\"\n            assert hasattr(mock_request.state, 'user')\n\n\nclass TestVerifyToken:\n    \"\"\"Test suite for verify_token function.\"\"\"\n\n    @pytest.fixture\n    def valid_payload(self):\n        \"\"\"Create valid token payload.\"\"\"\n        return {\n            \"user_id\": \"123\",\n            \"username\": \"testuser\",\n            \"email\": \"test@example.com\",\n            \"exp\": datetime.utcnow() + timedelta(hours=1)\n        }\n\n    @pytest.fixture\n    def expired_payload(self):\n        \"\"\"Create expired token payload.\"\"\"\n        return {\n            \"user_id\": \"123\",\n            \"username\": \"testuser\",\n            \"email\": \"test@example.com\",\n            \"exp\": datetime.utcnow() - timedelta(hours=1)\n        }\n\n    def test_verify_token_with_valid_token(self, valid_payload):\n        \"\"\"Test token verification with valid token.\"\"\"\n        token = jwt.encode(valid_payload, \"test_secret\", algorithm=\"HS256\")\n        \n        with patch('src.middleware.auth.JWT_SECRET', \"test_secret\"):\n            with patch('src.middleware.auth.JWT_ALGORITHM', \"HS256\"):\n                result = verify_token(token)\n                \n                assert result[\"user_id\"] == \"123\"\n                assert result[\"username\"] == \"testuser\"\n                assert result[\"email\"] == \"test@example.com\"\n\n    def test_verify_token_with_expired_token(self, expired_payload):\n        \"\"\"Test token verification with expired token raises HTTPException.\"\"\"\n        token =",
      "file_type": "test",
      "semantic_unit_id": "SU-012",
      "component_id": "COMP-012",
      "description": "Unit tests for authentication middleware including token validation and user context injection"
    },
    {
      "file_path": "tests/conftest.py",
      "content": "\"\"\"\nPytest configuration and fixtures for Hello World API tests.\n\nProvides test database setup, user and task fixtures, and cleanup utilities\nfor comprehensive testing of the API endpoints.\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport asyncio\nimport os\nimport tempfile\nfrom datetime import datetime, timezone\nfrom typing import AsyncGenerator, Generator\nfrom unittest.mock import Mock, patch\n\nimport pytest\nimport pytest_asyncio\nfrom fastapi.testclient import TestClient\nfrom sqlalchemy import create_engine, event\nfrom sqlalchemy.engine import Engine\nfrom sqlalchemy.orm import Session, sessionmaker\nfrom sqlalchemy.pool import StaticPool\n\n# Mock imports since actual files don't exist yet\nfrom unittest.mock import MagicMock\n\n# Mock the database and model imports\nsys_modules_mock = {\n    'src': MagicMock(),\n    'src.database': MagicMock(),\n    'src.database.connection': MagicMock(),\n    'src.models': MagicMock(),\n    'src.models.user': MagicMock(),\n    'src.models.task': MagicMock(),\n}\n\nimport sys\nfor module_name, mock_module in sys_modules_mock.items():\n    sys.modules[module_name] = mock_module\n\n# Mock database connection components\nclass MockDatabase:\n    \"\"\"Mock database class for testing.\"\"\"\n    \n    def __init__(self, url: str):\n        self.url = url\n        self.engine = None\n        self.session_factory = None\n    \n    def connect(self) -> None:\n        \"\"\"Mock database connection.\"\"\"\n        pass\n    \n    def disconnect(self) -> None:\n        \"\"\"Mock database disconnection.\"\"\"\n        pass\n    \n    def get_session(self) -> Session:\n        \"\"\"Mock session creation.\"\"\"\n        return Mock(spec=Session)\n\n# Mock user model\nclass MockUser:\n    \"\"\"Mock user model for testing.\"\"\"\n    \n    def __init__(self, id: int = None, username: str = None, email: str = None, \n                 password_hash: str = None, created_at: datetime = None):\n        self.id = id\n        self.username = username\n        self.email = email\n        self.password_hash = password_hash\n        self.created_at = created_at or datetime.now(timezone.utc)\n    \n    def to_dict(self) -> dict:\n        \"\"\"Convert user to dictionary.\"\"\"\n        return {\n            'id': self.id,\n            'username': self.username,\n            'email': self.email,\n            'created_at': self.created_at.isoformat()\n        }\n\n# Mock task model\nclass MockTask:\n    \"\"\"Mock task model for testing.\"\"\"\n    \n    def __init__(self, id: int = None, title: str = None, description: str = None,\n                 completed: bool = False, user_id: int = None, \n                 created_at: datetime = None, updated_at: datetime = None):\n        self.id = id\n        self.title = title\n        self.description = description\n        self.completed = completed\n        self.user_id = user_id\n        self.created_at = created_at or datetime.now(timezone.utc)\n        self.updated_at = updated_at or datetime.now(timezone.utc)\n    \n    def to_dict(self) -> dict:\n        \"\"\"Convert task to dictionary.\"\"\"\n        return {\n            'id': self.id,\n            'title': self.title,\n            'description': self.description,\n            'completed': self.completed,\n            'user_id': self.user_id,\n            'created_at': self.created_at.isoformat(),\n            'updated_at': self.updated_at.isoformat()\n        }\n\n\n# Test configuration\nTEST_DATABASE_URL = \"sqlite:///:memory:\"\nTEST_DATA_DIR = \"tests/data\"\n\n\n@pytest.fixture(scope=\"session\")\ndef event_loop() -> Generator[asyncio.AbstractEventLoop, None, None]:\n    \"\"\"\n    Create an instance of the default event loop for the test session.\n    \n    Yields:\n        asyncio.AbstractEventLoop: Event loop for async tests\n    \"\"\"\n    loop = asyncio.get_event_loop_policy().new_event_loop()\n    yield loop\n    loop.close()\n\n\n@pytest.fixture(scope=\"session\")\ndef test_database_url() -> str:\n    \"\"\"\n    Provide test database URL for in-memory SQLite database.\n    \n    Returns:\n        str: Database URL for testing\n    \"\"\"\n    return TEST_DATABASE_URL\n\n\n@pytest.fixture(scope=\"session\")\ndef test_engine(test_database_url: str) -> Generator[Engine, None, None]:\n    \"\"\"\n    Create SQLAlchemy engine for testing with in-memory SQLite database.\n    \n    Args:\n        test_database_url: Database URL for testing\n        \n    Yields:\n        Engine: SQLAlchemy engine instance\n    \"\"\"\n    engine = create_engine(\n        test_database_url,\n        connect_args={\n            \"check_same_thread\": False,\n        },\n        poolclass=StaticPool,\n        echo=False  # Set to True for SQL debugging\n    )\n    \n    # Enable foreign key constraints for SQLite\n    @event.listens_for(engine, \"connect\")\n    def set_sqlite_pragma(dbapi_connection, connection_record):\n        cursor = dbapi_connection.cursor()\n        cursor.execute(\"PRAGMA foreign_keys=ON\")\n        cursor.close()\n    \n    yield engine\n    engine.dispose()\n\n\n@pytest.fixture(scope=\"session\")\ndef test_session_factory(test_engine: Engine) -> sessionmaker:\n    \"\"\"\n    Create session factory for test database.\n    \n    Args:\n        test_engine: SQLAlchemy engine for testing\n        \n    Returns:\n        sessionmaker: Session factory for creating database sessions\n    \"\"\"\n    return sessionmaker(autocommit=False, autoflush=False, bind=test_engine)\n\n\n@pytest.fixture\ndef db_session(test_session_factory: sessionmaker) -> Generator[Session, None, None]:\n    \"\"\"\n    Create database session for individual tests with automatic rollback.\n    \n    Args:\n        test_session_factory: Session factory for creating sessions\n        \n    Yields:\n        Session: Database session for testing\n    \"\"\"\n    session = test_session_factory()\n    try:\n        yield session\n    finally:\n        session.rollback()\n        session.close()\n\n\n@pytest.fixture\ndef mock_database(test_database_url: str) -> MockDatabase:\n    \"\"\"\n    Create mock database instance for testing.\n    \n    Args:\n        test_database_url: Database URL for testing\n        \n    Returns:\n        MockDatabase: Mock database instance\n    \"\"\"\n    return MockDatabase(test_database_url)\n\n\n@pytest.fixture\ndef sample_user_data() -> dict:\n    \"\"\"\n    Provide sample user data for testing.\n    \n    Returns:\n        dict: Sample user data\n    \"\"\"\n    return {\n        \"username\": \"testuser\",\n        \"email\": \"test@example.com\",\n        \"password\": \"securepassword123\",\n        \"password_hash\": \"$2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewdBPj6ukx2.O5K2\"\n    }\n\n\n@pytest.fixture\ndef sample_task_data() -> dict:\n    \"\"\"\n    Provide sample task data for testing.\n    \n    Returns:\n        dict: Sample task data\n    \"\"\"\n    return {\n        \"title\": \"Test Task\",\n        \"description\": \"This is a test task for unit testing\",\n        \"completed\": False\n    }\n\n\n@pytest.fixture\ndef test_user(sample_user_data: dict) -> MockUser:\n    \"\"\"\n    Create test user instance.\n    \n    Args:\n        sample_user_data: Sample user data dictionary\n        \n    Returns:\n        MockUser: Test user instance\n    \"\"\"\n    return MockUser(\n        id=1,\n        username=sample_user_data[\"username\"],\n        email=sample_user_data[\"email\"],\n        password_hash=sample_user_data[\"password_hash\"]\n    )\n\n\n@pytest.fixture\ndef",
      "file_type": "test",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Pytest configuration with test database setup, fixtures for users and tasks, and cleanup utilities"
    },
    {
      "file_path": "requirements.txt",
      "content": "# Web Framework\nfastapi==0.104.1\nuvicorn==0.24.0\n\n# Data Validation\npydantic==2.5.0\n\n# HTTP Client (for testing)\nhttpx==0.25.2\n\n# Testing Framework\npytest==7.4.3\npytest-asyncio==0.21.1\npytest-cov==4.1.0\n\n# Development Tools\nblack==23.11.0\nflake8==6.1.0\nmypy==1.7.1\n\n# ASGI Tools\nasgi-lifespan==2.1.0",
      "file_type": "requirements",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Python dependencies with exact versions for FastAPI, SQLAlchemy, JWT, testing, and database drivers"
    },
    {
      "file_path": ".env.example",
      "content": "# Environment Configuration Template\n# Copy this file to .env and fill in the actual values\n\n# Application Configuration\nAPP_NAME=Hello World API\nAPP_VERSION=1.0.0\nAPP_DESCRIPTION=Simple REST API that returns greeting messages\nDEBUG=false\n\n# Server Configuration\nHOST=0.0.0.0\nPORT=8000\nRELOAD=false\n\n# Security Configuration\nSECRET_KEY=your-secret-key-here-change-in-production\nJWT_SECRET_KEY=your-jwt-secret-key-here-change-in-production\nJWT_ALGORITHM=HS256\nJWT_EXPIRATION_HOURS=24\n\n# Database Configuration\nDATABASE_URL=sqlite:///./app.db\nDATABASE_ECHO=false\n\n# Logging Configuration\nLOG_LEVEL=INFO\nLOG_FORMAT=%(asctime)s - %(name)s - %(levelname)s - %(message)s\n\n# CORS Configuration\nCORS_ORIGINS=http://localhost:3000,http://localhost:8080\nCORS_ALLOW_CREDENTIALS=true\nCORS_ALLOW_METHODS=GET,POST,PUT,DELETE,OPTIONS\nCORS_ALLOW_HEADERS=*\n\n# Rate Limiting\nRATE_LIMIT_ENABLED=false\nRATE_LIMIT_REQUESTS_PER_MINUTE=60\n\n# Health Check Configuration\nHEALTH_CHECK_ENABLED=true",
      "file_type": "config",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Environment variables template including JWT secrets, database URL, and application configuration"
    },
    {
      "file_path": "alembic.ini",
      "content": "# A generic, single database configuration.\n\n[alembic]\n# path to migration scripts\nscript_location = alembic\n\n# template used to generate migration file names; The default value is %%(rev)s_%%(slug)s\n# Uncomment the line below if you want the files to be prepended with date and time\n# file_template = %%(year)d_%%(month).2d_%%(day).2d_%%(hour).2d%%(minute).2d-%%(rev)s_%%(slug)s\n\n# sys.path path, will be prepended to sys.path if present.\n# defaults to the current working directory.\nprepend_sys_path = .\n\n# timezone to use when rendering the date within the migration file\n# as well as the filename.\n# If specified, requires the python-dateutil library that can be\n# installed by adding `alembic[tz]` to the pip requirements\n# string value is passed to dateutil.tz.gettz()\n# leave blank for localtime\n# timezone =\n\n# max length of characters to apply to the\n# \"slug\" field\n# truncate_slug_length = 40\n\n# set to 'true' to run the environment during\n# the 'revision' command, regardless of autogenerate\n# revision_environment = false\n\n# set to 'true' to allow .pyc and .pyo files without\n# a source .py file to be detected as revisions in the\n# versions/ directory\n# sourceless = false\n\n# version path separator; As mentioned above, this is the character used to split\n# version_locations. The default within new alembic.ini files is \"os\", which uses\n# os.pathsep. If this key is omitted entirely, it falls back to the legacy\n# behavior of splitting on spaces and/or commas.\n# Valid values for version_path_separator are:\n#\n# version_path_separator = :\n# version_path_separator = ;\n# version_path_separator = space\nversion_path_separator = os\n\n# the output encoding used when revision files\n# are written from script.py.mako\n# output_encoding = utf-8\n\nsqlalchemy.url = sqlite:///./app.db\n\n\n[post_write_hooks]\n# post_write_hooks defines scripts or Python functions that are run\n# on newly generated revision scripts.  See the documentation for further\n# detail and examples\n\n# format using \"black\" - use the console_scripts runner, against the \"black\" entrypoint\n# hooks = black\n# black.type = console_scripts\n# black.entrypoint = black\n# black.options = -l 79 REVISION_SCRIPT_FILENAME\n\n# Logging configuration\n[loggers]\nkeys = root,sqlalchemy,alembic\n\n[handlers]\nkeys = console\n\n[formatters]\nkeys = generic\n\n[logger_root]\nlevel = WARN\nhandlers = console\nqualname =\n\n[logger_sqlalchemy]\nlevel = WARN\nhandlers =\nqualname = sqlalchemy.engine\n\n[logger_alembic]\nlevel = INFO\nhandlers =\nqualname = alembic\n\n[handler_console]\nclass = StreamHandler\nargs = (sys.stderr,)\nlevel = NOTSET\nformatter = generic\n\n[formatter_generic]\nformat = %(levelname)-5.5s [%(name)s] %(message)s\ndatefmt = %H:%M:%S",
      "file_type": "config",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Alembic configuration file for database migrations with SQLAlchemy URL and migration settings"
    },
    {
      "file_path": "pytest.ini",
      "content": "[pytest]\n# Test discovery\ntestpaths = tests\npython_files = test_*.py *_test.py\npython_classes = Test*\npython_functions = test_*\n\n# Output options\naddopts = \n    -v\n    --tb=short\n    --strict-markers\n    --strict-config\n    --disable-warnings\n\n# Coverage settings\naddopts = \n    --cov=.\n    --cov-report=term-missing\n    --cov-report=html:htmlcov\n    --cov-fail-under=80\n\n# Markers\nmarkers =\n    unit: Unit tests\n    integration: Integration tests\n    slow: Slow running tests\n\n# Minimum version\nminversion = 6.0",
      "file_type": "config",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Pytest configuration with test discovery, coverage settings, and database test configuration"
    },
    {
      "file_path": ".gitignore",
      "content": "# Byte-compiled / optimized / DLL files\n__pycache__/\n*.py[cod]\n*$py.class\n\n# C extensions\n*.so\n\n# Distribution / packaging\n.Python\nbuild/\ndevelop-eggs/\ndist/\ndownloads/\neggs/\n.eggs/\nlib/\nlib64/\nparts/\nsdist/\nvar/\nwheels/\nshare/python-wheels/\n*.egg-info/\n.installed.cfg\n*.egg\nMANIFEST\n\n# PyInstaller\n#  Usually these files are written by a python script from a template\n#  before PyInstaller builds the exe, so as to inject date/other infos into it.\n*.manifest\n*.spec\n\n# Installer logs\npip-log.txt\npip-delete-this-directory.txt\n\n# Unit test / coverage reports\nhtmlcov/\n.tox/\n.nox/\n.coverage\n.coverage.*\n.cache\nnosetests.xml\ncoverage.xml\n*.cover\n*.py,cover\n.hypothesis/\n.pytest_cache/\ncover/\n\n# Translations\n*.mo\n*.pot\n\n# Django stuff:\n*.log\nlocal_settings.py\ndb.sqlite3\ndb.sqlite3-journal\n\n# Flask stuff:\ninstance/\n.webassets-cache\n\n# Scrapy stuff:\n.scrapy\n\n# Sphinx documentation\ndocs/_build/\n\n# PyBuilder\n.pybuilder/\ntarget/\n\n# Jupyter Notebook\n.ipynb_checkpoints\n\n# IPython\nprofile_default/\nipython_config.py\n\n# pyenv\n#   For a library or package, you might want to ignore these files since the code is\n#   intended to run in multiple environments; otherwise, check them in:\n# .python-version\n\n# pipenv\n#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.\n#   However, in case of collaboration, if having platform-specific dependencies or dependencies\n#   having no cross-platform support, pipenv may install dependencies that don't work, or not\n#   install all needed dependencies.\n#Pipfile.lock\n\n# poetry\n#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.\n#   This is especially recommended for binary packages to ensure reproducibility, and is more\n#   commonly ignored for libraries.\n#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control\n#poetry.lock\n\n# pdm\n#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.\n#pdm.lock\n#   pdm stores project-wide configurations in .pdm.toml, but it is recommended to not include it\n#   in version control.\n#   https://pdm.fming.dev/#use-with-ide\n.pdm.toml\n\n# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm\n__pypackages__/\n\n# Celery stuff\ncelerybeat-schedule\ncelerybeat.pid\n\n# SageMath parsed files\n*.sage.py\n\n# Environments\n.env\n.venv\nenv/\nvenv/\nENV/\nenv.bak/\nvenv.bak/\n\n# Spyder project settings\n.spyderproject\n.spyproject\n\n# Rope project settings\n.ropeproject\n\n# mkdocs documentation\n/site\n\n# mypy\n.mypy_cache/\n.dmypy.json\ndmypy.json\n\n# Pyre type checker\n.pyre/\n\n# pytype static type analyzer\n.pytype/\n\n# Cython debug symbols\ncython_debug/\n\n# PyCharm\n#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can\n#  be added to the global gitignore or merged into this project gitignore.  For a PyCharm\n#  project, it is recommended to ignore the entire .idea directory.\n.idea/\n\n# VS Code\n.vscode/\n\n# macOS\n.DS_Store\n.AppleDouble\n.LSOverride\n\n# Windows\nThumbs.db\nehthumbs.db\nDesktop.ini\n$RECYCLE.BIN/\n\n# Linux\n*~\n\n# Temporary files\n*.tmp\n*.temp\n*.swp\n*.swo\n\n# Log files\n*.log\n\n# Database files\n*.db\n*.sqlite\n*.sqlite3\n\n# Configuration files with sensitive data\nconfig.ini\nsettings.ini\nsecrets.json\n.secrets\n\n# SSL certificates\n*.pem\n*.key\n*.crt\n*.cert",
      "file_type": "config",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Git ignore file for Python projects including virtual environments, cache files, and sensitive data"
    },
    {
      "file_path": "README.md",
      "content": "# Hello World API\n\nA simple FastAPI REST API that returns greeting messages with optional personalization and health monitoring capabilities.\n\n## Features\n\n- **Personalized Greetings**: `/hello` endpoint with optional name parameter\n- **Health Monitoring**: `/health` endpoint with status and timestamp\n- **Input Validation**: Secure parameter validation and sanitization\n- **Error Handling**: Comprehensive error responses with proper HTTP status codes\n- **Interactive Documentation**: Auto-generated API docs with Swagger UI and ReDoc\n- **Production Ready**: ASGI server support with uvicorn\n\n## Prerequisites\n\n- Python 3.12 or higher\n- pip package manager\n\n## Installation\n\n1. **Clone or download the project files**\n\n2. **Install dependencies:**\n   ```bash\n   pip install -r requirements.txt\n   ```\n\n## Running the Application\n\n### Development Mode\n\nStart the development server with auto-reload:\n\n```bash\nuvicorn main:app --reload\n```\n\nThe API will be available at http://localhost:8000\n\n### Production Mode\n\nStart the production server:\n\n```bash\nuvicorn main:app --host 0.0.0.0 --port 8000\n```\n\nFor production deployment with multiple workers:\n\n```bash\nuvicorn main:app --host 0.0.0.0 --port 8000 --workers 4\n```\n\n## API Documentation\n\n### GET /hello\n\nReturns a greeting message with optional personalization.\n\n**Parameters:**\n- `name` (optional, query parameter): Name to personalize greeting\n  - Type: string\n  - Max length: 100 characters\n  - Allowed characters: alphanumeric and spaces only\n  - Example: `?name=John Doe`\n\n**Success Response (200 OK):**\n```json\n{\n  \"message\": \"Hello, World!\"\n}\n```\n\n**Success Response with name (200 OK):**\n```json\n{\n  \"message\": \"Hello, John Doe!\"\n}\n```\n\n**Error Response (400 Bad Request):**\n```json\n{\n  \"code\": \"INVALID_NAME\",\n  \"message\": \"Name parameter contains invalid characters or exceeds 100 characters\"\n}\n```\n\n**Examples:**\n```bash\n# Basic greeting\ncurl http://localhost:8000/hello\n\n# Personalized greeting\ncurl \"http://localhost:8000/hello?name=Alice\"\n\n# Invalid name (contains special characters)\ncurl \"http://localhost:8000/hello?name=Alice@123\"\n```\n\n### GET /health\n\nReturns application health status and current timestamp for monitoring purposes.\n\n**Success Response (200 OK):**\n```json\n{\n  \"status\": \"ok\",\n  \"timestamp\": \"2024-01-15T10:30:45.123456Z\"\n}\n```\n\n**Example:**\n```bash\ncurl http://localhost:8000/health\n```\n\n### Error Responses\n\nAll endpoints may return the following error response:\n\n**Internal Server Error (500):**\n```json\n{\n  \"code\": \"INTERNAL_ERROR\",\n  \"message\": \"Internal server error\"\n}\n```\n\n## Interactive API Documentation\n\nFastAPI automatically generates interactive API documentation:\n\n- **Swagger UI**: http://localhost:8000/docs\n- **ReDoc**: http://localhost:8000/redoc\n- **OpenAPI Schema**: http://localhost:8000/openapi.json\n\n## Testing\n\n### Running Tests\n\nRun the complete test suite:\n\n```bash\npytest tests/ -v\n```\n\nRun tests with coverage report:\n\n```bash\npytest tests/ --cov=. --cov-report=html\n```\n\nView coverage report:\n```bash\nopen htmlcov/index.html  # macOS\nxdg-open htmlcov/index.html  # Linux\n```\n\n### Test Categories\n\nThe test suite includes:\n\n- **Unit Tests**: Individual function testing\n- **Integration Tests**: API endpoint testing\n- **Edge Case Tests**: Boundary conditions and invalid inputs\n- **Error Handling Tests**: Exception scenarios\n\n## Configuration\n\n### Environment Variables\n\nThe application supports the following optional environment variables:\n\n```bash\n# Server configuration\nHOST=0.0.0.0\nPORT=8000\nWORKERS=1\n\n# Logging level\nLOG_LEVEL=info\n```\n\nCreate a `.env` file in the project root:\n\n```bash\n# .env file example\nHOST=localhost\nPORT=8000\nLOG_LEVEL=debug\n```\n\n### CORS Configuration\n\nFor cross-origin requests, you can enable CORS by modifying the FastAPI application:\n\n```python\nfrom fastapi.middleware.cors import CORSMiddleware\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],  # Configure appropriately for production\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n```\n\n## Architecture\n\nThe application follows a three-layer architecture:\n\n1. **Application Layer** (`FastAPIApplication`): Handles initialization and configuration\n2. **Endpoint Layer** (`HelloEndpoint`, `HealthEndpoint`): Implements business logic\n3. **Error Handling Layer** (`ErrorHandler`): Provides centralized exception management\n\n### Key Components\n\n- **Input Validation**: Name parameter validation using regex `^[a-zA-Z0-9\\s]*$`\n- **Sanitization**: Automatic whitespace trimming and title-case formatting\n- **Timezone Handling**: All timestamps in UTC using ISO 8601 format\n- **Error Consistency**: Standardized error response format with codes and messages\n\n## Security\n\n### Input Validation\n\n- Name parameter limited to 100 characters\n- Only alphanumeric characters and spaces allowed\n- Automatic sanitization prevents injection attacks\n- No direct string interpolation without validation\n\n### Best Practices\n\n- No sensitive data in logs\n- Proper HTTP status codes\n- Input length restrictions\n- Character set validation\n\n## Troubleshooting\n\n### Common Issues\n\n#### Port Already in Use\n\nIf port 8000 is already in use:\n\n```bash\n# Use a different port\nuvicorn main:app --port 8001\n\n# Or find and kill the process using port 8000\nlsof -ti:8000 | xargs kill -9  # macOS/Linux\n```\n\n#### Import Errors\n\nEnsure all dependencies are installed:\n\n```bash\npip install -r requirements.txt\n\n# Or reinstall specific packages\npip install fastapi uvicorn\n```\n\n#### Module Not Found\n\nMake sure you're in the correct directory:\n\n```bash\n# Should contain main.py\nls -la main.py\n\n# Run from the project root directory\nuvicorn main:app --reload\n```\n\n#### Permission Errors\n\nOn some systems, you might need to use a different port:\n\n```bash\n# Use port > 1024 for non-root users\nuvicorn main:app --port 8080\n```\n\n### Debugging\n\nEnable debug logging:\n\n```bash\n# Set log level to debug\nuvicorn main:app --log-level debug\n\n# Or use environment variable\nLOG_LEVEL=debug uvicorn main:app\n```\n\nCheck application logs for detailed error information.\n\n### Performance Issues\n\nFor high-traffic scenarios:\n\n```bash\n# Use multiple workers\nuvicorn main:app --workers 4\n\n# Or use gunicorn with uvicorn workers\ngunicorn main:app -w 4 -k uvicorn.workers.UvicornWorker\n```\n\n### Health Check Monitoring\n\nUse the `/health` endpoint for monitoring:\n\n```bash\n# Simple health check script\nwhile true; do\n  curl -f http://localhost:8000/health || echo \"Health check failed\"\n  sleep 30\ndone\n```\n\n## Development\n\n### Code Style\n\nThe project follows PEP 8 style guidelines:\n\n- Line length: 88 characters (Black formatter)\n- Type hints for all functions\n- Docstrings for modules, classes, and functions\n- Consistent naming conventions\n\n### Adding New Endpoints\n\n1. Create endpoint function with proper type hints\n2. Add input validation and error handling\n3. Update API documentation\n4. Write comprehensive tests\n5. Update this README with new endpoint details\n\n### Contributing\n\n1. Follow existing code style and patterns\n2. Add tests for new functionality\n3. Update documentation\n4. Ensure all tests pass before submitting changes\n\n## License\n\nThis project is provided as-is for educational and demonstration purposes.",
      "file_type": "documentation",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Comprehensive project documentation with setup instructions, API endpoints, authentication guide, and troubleshooting"
    },
    {
      "file_path": "docs/api_spec.yaml",
      "content": "openapi: 3.0.3\ninfo:\n  title: Hello World API\n  description: |\n    Simple REST API that returns greeting messages with optional personalization.\n    \n    This API provides two main endpoints:\n    - `/hello` - Returns personalized or default greeting messages\n    - `/health` - Returns application health status and timestamp\n    \n    The API is stateless and designed for high throughput with proper input validation\n    and centralized error handling.\n  version: 1.0.0\n  contact:\n    name: API Support\n    email: support@example.com\n  license:\n    name: MIT\n    url: https://opensource.org/licenses/MIT\n\nservers:\n  - url: http://localhost:8000\n    description: Development server\n  - url: https://api.example.com\n    description: Production server\n\npaths:\n  /hello:\n    get:\n      summary: Get greeting message\n      description: |\n        Returns a greeting message with optional personalization via name parameter.\n        \n        If no name is provided, returns a default \"Hello, World!\" message.\n        If a name is provided, returns a personalized greeting like \"Hello, John!\".\n        \n        The name parameter is validated to ensure it contains only alphanumeric \n        characters and spaces, and does not exceed 100 characters in length.\n      operationId: getHello\n      tags:\n        - Greetings\n      parameters:\n        - name: name\n          in: query\n          description: |\n            Optional name for personalized greeting. Must contain only alphanumeric \n            characters and spaces. Maximum length is 100 characters.\n          required: false\n          schema:\n            type: string\n            maxLength: 100\n            pattern: '^[a-zA-Z0-9\\s]*$'\n            example: \"John Doe\"\n          examples:\n            simple_name:\n              summary: Simple name\n              value: \"Alice\"\n            full_name:\n              summary: Full name with space\n              value: \"John Smith\"\n            with_numbers:\n              summary: Name with numbers\n              value: \"User123\"\n      responses:\n        '200':\n          description: Successful greeting response\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/HelloResponse'\n              examples:\n                default_greeting:\n                  summary: Default greeting (no name parameter)\n                  value:\n                    message: \"Hello, World!\"\n                personalized_greeting:\n                  summary: Personalized greeting\n                  value:\n                    message: \"Hello, Alice!\"\n                full_name_greeting:\n                  summary: Full name greeting\n                  value:\n                    message: \"Hello, John Smith!\"\n        '400':\n          description: Invalid name parameter\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/ErrorResponse'\n              examples:\n                invalid_characters:\n                  summary: Name contains invalid characters\n                  value:\n                    code: \"INVALID_NAME\"\n                    message: \"Name parameter contains invalid characters or exceeds 100 characters\"\n                too_long:\n                  summary: Name exceeds maximum length\n                  value:\n                    code: \"INVALID_NAME\"\n                    message: \"Name parameter contains invalid characters or exceeds 100 characters\"\n        '500':\n          description: Internal server error\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/ErrorResponse'\n              example:\n                code: \"INTERNAL_ERROR\"\n                message: \"Internal server error\"\n\n  /health:\n    get:\n      summary: Health check\n      description: |\n        Returns application health status and current timestamp.\n        \n        This endpoint is used for monitoring and health checks. It always returns\n        a status of \"ok\" along with the current UTC timestamp in ISO 8601 format.\n        \n        The timestamp can be used to verify the application is responding and\n        to check for clock synchronization issues.\n      operationId: getHealth\n      tags:\n        - Health\n      responses:\n        '200':\n          description: Successful health check response\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/HealthResponse'\n              examples:\n                health_check:\n                  summary: Typical health check response\n                  value:\n                    status: \"ok\"\n                    timestamp: \"2023-12-01T10:30:45.123456Z\"\n        '500':\n          description: Internal server error\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/ErrorResponse'\n              example:\n                code: \"INTERNAL_ERROR\"\n                message: \"Internal server error\"\n\ncomponents:\n  schemas:\n    HelloResponse:\n      type: object\n      description: Response schema for the /hello endpoint\n      required:\n        - message\n      properties:\n        message:\n          type: string\n          description: |\n            The greeting message. Will be \"Hello, World!\" if no name parameter\n            is provided, or \"Hello, {name}!\" if a valid name is provided.\n          example: \"Hello, World!\"\n          minLength: 1\n          maxLength: 120\n      example:\n        message: \"Hello, Alice!\"\n\n    HealthResponse:\n      type: object\n      description: Response schema for the /health endpoint\n      required:\n        - status\n        - timestamp\n      properties:\n        status:\n          type: string\n          description: Health status of the application\n          enum:\n            - \"ok\"\n          example: \"ok\"\n        timestamp:\n          type: string\n          description: |\n            Current UTC timestamp in ISO 8601 format with microseconds and 'Z' suffix.\n            Format: YYYY-MM-DDTHH:MM:SS.fffffZ\n          format: date-time\n          example: \"2023-12-01T10:30:45.123456Z\"\n          pattern: '^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{6}Z$'\n      example:\n        status: \"ok\"\n        timestamp: \"2023-12-01T10:30:45.123456Z\"\n\n    ErrorResponse:\n      type: object\n      description: Standard error response schema for all error conditions\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: string\n          description: |\n            Error code identifying the specific type of error.\n            Used for programmatic error handling.\n          enum:\n            - \"INVALID_NAME\"\n            - \"INTERNAL_ERROR\"\n          example: \"INVALID_NAME\"\n        message:\n          type: string\n          description: |\n            Human-readable error message describing what went wrong.\n            Should not contain sensitive information.\n          example: \"Name parameter contains invalid characters or exceeds 100 characters\"\n          minLength: 1\n          maxLength: 500\n      examples:\n        - code: \"INVALID_NAME\"\n          message: \"Name parameter contains invalid characters or exceeds 100 characters\"\n        - code: \"INTERNAL_ERROR\"\n          message: \"Internal server error\"\n\n  examples:\n    HelloWorldResponse:\n      summary: Default Hello World response\n      description: Response when no name parameter is provided\n      value:\n        message: \"Hello, World!\"\n\n    PersonalizedHelloResponse:\n      summary: Personalized greeting response\n      description: Response when a valid name parameter is provided\n      value:\n        message: \"Hello, Alice!\"\n\n    HealthCheckResponse:\n      summary: Health check response\n      description: Typical response from the health endpoint\n      value:\n        status: \"ok\"\n        timestamp: \"2023-12-01T10:30:45.123456Z\"\n\n    InvalidNameError:\n      summary: Invalid name parameter error\n      description: Error response when name parameter validation fails\n      value:\n        code: \"INVALID_NAME\"\n        message: \"Name parameter contains invalid characters or exceeds 100 characters\"\n\n    InternalServerError:\n      summary: Internal server error\n      description: Error response for unexpected server errors\n      value:\n        code: \"INTERNAL_ERROR\"\n        message: \"Internal server error\"\n\ntags:\n  - name: Greetings\n    description: |\n      Endpoints related to greeting functionality.\n      \n      These endpoints handle the core greeting logic of the application,\n      including",
      "file_type": "documentation",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "OpenAPI 3.0 specification with complete API documentation, request/response schemas, and authentication details"
    }
  ],
  "file_structure": {
    "src": [
      "main.py"
    ],
    "src/api": [
      "auth.py",
      "tasks.py"
    ],
    "src/models": [
      "user.py",
      "task.py"
    ],
    "src/schemas": [
      "user.py",
      "task.py"
    ],
    "src/utils": [
      "jwt_utils.py",
      "password.py"
    ],
    "src/database": [
      "connection.py"
    ],
    "src/database/migrations": [
      "001_initial_schema.py"
    ],
    "src/middleware": [
      "auth.py"
    ],
    "tests": [
      "test_auth_api.py",
      "test_tasks_api.py",
      "test_user_model.py",
      "test_task_model.py",
      "test_jwt_utils.py",
      "test_password.py",
      "test_middleware.py",
      "conftest.py"
    ],
    ".": [
      "requirements.txt",
      ".env.example",
      "alembic.ini",
      "pytest.ini",
      ".gitignore",
      "README.md"
    ],
    "docs": [
      "api_spec.yaml"
    ]
  },
  "implementation_notes": "Generated using multi-stage approach with 27 files. Manifest estimated 4650 LOC, actual 4334 LOC. Uses 13 external dependencies.",
  "dependencies": [
    "fastapi==0.104.1",
    "uvicorn[standard]==0.24.0",
    "python-jose[cryptography]==3.3.0",
    "bcrypt==4.1.1",
    "pydantic==2.5.0",
    "sqlalchemy==2.0.23",
    "alembic==1.13.0",
    "python-multipart==0.0.6",
    "pytest==7.4.3",
    "pytest-asyncio==0.21.1",
    "httpx==0.25.2",
    "pytest-cov==4.1.0",
    "psycopg2-binary==2.9.9"
  ],
  "setup_instructions": "1. Install Python 3.11+\\n2. Create virtual environment: python -m venv venv\\n3. Activate: source venv/bin/activate (Linux/Mac) or venv\\Scripts\\activate (Windows)\\n4. Install dependencies: pip install -r requirements.txt\\n5. Copy .env.example to .env and configure variables\\n6. Run migrations: alembic upgrade head\\n7. Start server: uvicorn src.main:app --reload\\n8. Run tests: pytest tests/ -v --cov=src",
  "total_lines_of_code": 4334,
  "total_files": 27,
  "test_coverage_target": 80.0,
  "semantic_units_implemented": [
    "SU-004",
    "SU-002",
    "SU-001",
    "SU-006",
    "SU-011",
    "SU-007",
    "SU-008",
    "SU-012",
    "SU-009",
    "SU-010",
    "SU-003",
    "SU-005"
  ],
  "components_implemented": [
    "COMP-003",
    "COMP-004",
    "COMP-009",
    "COMP-005",
    "COMP-007",
    "COMP-001",
    "COMP-002",
    "COMP-010",
    "COMP-008",
    "COMP-012",
    "COMP-006",
    "COMP-011"
  ],
  "agent_version": "1.0.0",
  "generation_timestamp": "2025-11-21T02:32:30.273951"
}