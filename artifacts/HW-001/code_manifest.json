{
  "task_id": "HW-001",
  "project_id": "PROJECT-001",
  "files": [
    {
      "file_path": "src/main.py",
      "content": "\"\"\"\nFastAPI Hello World Application\n\nMain application entry point with CORS middleware, router registration, and startup configuration.\nProvides /hello and /health endpoints with comprehensive error handling.\n\nComponent ID: COMP-001\nSemantic Unit: SU-001\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport re\nfrom datetime import datetime\nfrom typing import Optional\n\nfrom fastapi import FastAPI, HTTPException, Query, Request\nfrom fastapi.exceptions import RequestValidationError\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.responses import JSONResponse\n\n\ndef create_app() -> FastAPI:\n    \"\"\"\n    Create and configure FastAPI application instance.\n    \n    Returns:\n        FastAPI: Configured application instance with middleware and error handlers\n    \"\"\"\n    app = FastAPI(\n        title=\"Hello World API\",\n        description=\"Simple REST API that returns greeting messages and health status\",\n        version=\"1.0.0\",\n    )\n    \n    # Add CORS middleware for development\n    app.add_middleware(\n        CORSMiddleware,\n        allow_origins=[\"*\"],\n        allow_credentials=True,\n        allow_methods=[\"*\"],\n        allow_headers=[\"*\"],\n    )\n    \n    # Setup error handlers\n    setup_error_handlers(app)\n    \n    return app\n\n\ndef setup_error_handlers(app: FastAPI) -> None:\n    \"\"\"\n    Configure global exception handlers for the application.\n    \n    Args:\n        app: FastAPI application instance to configure\n    \"\"\"\n    \n    @app.exception_handler(RequestValidationError)\n    async def handle_validation_error(request: Request, exc: RequestValidationError) -> JSONResponse:\n        \"\"\"\n        Handle FastAPI validation errors and return 400 response.\n        \n        Args:\n            request: The incoming request\n            exc: The validation error exception\n            \n        Returns:\n            JSONResponse: 400 error response with validation details\n        \"\"\"\n        return JSONResponse(\n            status_code=400,\n            content={\n                \"code\": \"INVALID_NAME\",\n                \"message\": \"Name parameter contains invalid characters or exceeds 100 characters\"\n            }\n        )\n    \n    @app.exception_handler(HTTPException)\n    async def handle_http_exception(request: Request, exc: HTTPException) -> JSONResponse:\n        \"\"\"\n        Handle HTTPException and return appropriate JSON response.\n        \n        Args:\n            request: The incoming request\n            exc: The HTTP exception\n            \n        Returns:\n            JSONResponse: JSON error response with preserved status code\n        \"\"\"\n        return JSONResponse(\n            status_code=exc.status_code,\n            content={\n                \"code\": \"INVALID_NAME\" if exc.status_code == 400 else \"HTTP_ERROR\",\n                \"message\": exc.detail\n            }\n        )\n    \n    @app.exception_handler(Exception)\n    async def handle_general_exception(request: Request, exc: Exception) -> JSONResponse:\n        \"\"\"\n        Handle unexpected exceptions and return 500 response.\n        \n        Args:\n            request: The incoming request\n            exc: The general exception\n            \n        Returns:\n            JSONResponse: 500 error response for internal errors\n        \"\"\"\n        return JSONResponse(\n            status_code=500,\n            content={\n                \"code\": \"INTERNAL_ERROR\",\n                \"message\": \"Internal server error\"\n            }\n        )\n\n\ndef validate_name(name: str) -> bool:\n    \"\"\"\n    Validate name parameter contains only alphanumeric characters and spaces.\n    \n    Args:\n        name: The name string to validate\n        \n    Returns:\n        bool: True if name is valid, False otherwise\n    \"\"\"\n    if len(name) > 100:\n        return False\n    \n    pattern = r'^[a-zA-Z0-9 ]+$'\n    return bool(re.match(pattern, name))\n\n\ndef sanitize_name(name: str) -> str:\n    \"\"\"\n    Clean and format name parameter for safe usage.\n    \n    Args:\n        name: The name string to sanitize\n        \n    Returns:\n        str: Cleaned and formatted name\n    \"\"\"\n    return name.strip().title()\n\n\ndef get_current_timestamp() -> str:\n    \"\"\"\n    Generate ISO 8601 formatted UTC timestamp.\n    \n    Returns:\n        str: Current UTC timestamp in ISO 8601 format with Z suffix\n    \"\"\"\n    return datetime.utcnow().isoformat() + 'Z'\n\n\n# Create application instance\napp = create_app()\n\n\n@app.get(\"/hello\")\nasync def get_hello(name: Optional[str] = Query(None, max_length=100)) -> dict[str, str]:\n    \"\"\"\n    Generate greeting message based on optional name parameter.\n    \n    Args:\n        name: Optional name parameter for personalized greeting\n        \n    Returns:\n        dict[str, str]: JSON response with greeting message\n        \n    Raises:\n        HTTPException: 400 error if name contains invalid characters\n        \n    Example:\n        >>> await get_hello()\n        {'message': 'Hello, World!'}\n        >>> await get_hello(\"John\")\n        {'message': 'Hello, John!'}\n    \"\"\"\n    if name is None:\n        return {\"message\": \"Hello, World!\"}\n    \n    if not validate_name(name):\n        raise HTTPException(\n            status_code=400,\n            detail=\"Name parameter contains invalid characters or exceeds 100 characters\"\n        )\n    \n    sanitized_name = sanitize_name(name)\n    return {\"message\": f\"Hello, {sanitized_name}!\"}\n\n\n@app.get(\"/health\")\nasync def get_health() -> dict[str, str]:\n    \"\"\"\n    Return health status and current UTC timestamp.\n    \n    Returns:\n        dict[str, str]: JSON response with status and timestamp\n        \n    Example:\n        >>> await get_health()\n        {'status': 'ok', 'timestamp': '2023-11-21T17:46:28.707525Z'}\n    \"\"\"\n    timestamp = get_current_timestamp()\n    return {\n        \"status\": \"ok\",\n        \"timestamp\": timestamp\n    }",
      "file_type": "source",
      "semantic_unit_id": "SU-001",
      "component_id": "COMP-001",
      "description": "FastAPI application entry point with CORS middleware, router registration, and startup configuration"
    },
    {
      "file_path": "src/api/auth.py",
      "content": "\"\"\"\nAuthentication API endpoints for user registration, login, token validation, and logout functionality.\n\nThis module provides secure authentication endpoints with JWT token management,\npassword hashing, and comprehensive input validation.\n\nComponent ID: COMP-002\nSemantic Unit: SU-002\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport logging\nfrom datetime import datetime, timedelta\nfrom typing import Optional\n\nfrom fastapi import APIRouter, Depends, HTTPException, status\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy.exc import IntegrityError\n\nfrom src.models.user import User\nfrom src.utils.jwt_utils import create_access_token, verify_token, decode_token\nfrom src.utils.password import hash_password, verify_password\nfrom src.schemas.auth import (\n    UserRegistrationRequest,\n    UserLoginRequest,\n    AuthResponse,\n    TokenValidationResponse,\n    UserResponse,\n    LogoutResponse\n)\nfrom src.database import get_db\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Initialize router and security\nrouter = APIRouter(prefix=\"/auth\", tags=[\"authentication\"])\nsecurity = HTTPBearer()\n\n\nclass AuthenticationError(Exception):\n    \"\"\"Custom exception for authentication-related errors.\"\"\"\n    pass\n\n\nclass AuthService:\n    \"\"\"Service class handling authentication business logic.\"\"\"\n    \n    def __init__(self, db: Session):\n        \"\"\"\n        Initialize authentication service.\n        \n        Args:\n            db: Database session for user operations\n        \"\"\"\n        self.db = db\n    \n    def register_user(self, registration_data: UserRegistrationRequest) -> User:\n        \"\"\"\n        Register a new user with email and password.\n        \n        Args:\n            registration_data: User registration information\n            \n        Returns:\n            User: Created user instance\n            \n        Raises:\n            AuthenticationError: If email already exists or validation fails\n        \"\"\"\n        try:\n            # Validate email format\n            if not self._is_valid_email(registration_data.email):\n                raise AuthenticationError(\"Invalid email format\")\n            \n            # Check if user already exists\n            existing_user = self.db.query(User).filter(\n                User.email == registration_data.email.lower()\n            ).first()\n            \n            if existing_user:\n                raise AuthenticationError(\"Email already registered\")\n            \n            # Validate password strength\n            if not self._is_valid_password(registration_data.password):\n                raise AuthenticationError(\n                    \"Password must be at least 8 characters with uppercase, lowercase, and number\"\n                )\n            \n            # Create new user\n            hashed_password = hash_password(registration_data.password)\n            new_user = User(\n                email=registration_data.email.lower().strip(),\n                full_name=registration_data.full_name.strip(),\n                hashed_password=hashed_password,\n                is_active=True,\n                created_at=datetime.utcnow()\n            )\n            \n            self.db.add(new_user)\n            self.db.commit()\n            self.db.refresh(new_user)\n            \n            logger.info(f\"User registered successfully: {new_user.email}\")\n            return new_user\n            \n        except IntegrityError:\n            self.db.rollback()\n            raise AuthenticationError(\"Email already registered\")\n        except Exception as e:\n            self.db.rollback()\n            logger.error(f\"User registration failed: {str(e)}\")\n            raise AuthenticationError(\"Registration failed\")\n    \n    def authenticate_user(self, login_data: UserLoginRequest) -> User:\n        \"\"\"\n        Authenticate user with email and password.\n        \n        Args:\n            login_data: User login credentials\n            \n        Returns:\n            User: Authenticated user instance\n            \n        Raises:\n            AuthenticationError: If credentials are invalid\n        \"\"\"\n        try:\n            # Find user by email\n            user = self.db.query(User).filter(\n                User.email == login_data.email.lower()\n            ).first()\n            \n            if not user:\n                raise AuthenticationError(\"Invalid email or password\")\n            \n            # Check if user is active\n            if not user.is_active:\n                raise AuthenticationError(\"Account is deactivated\")\n            \n            # Verify password\n            if not verify_password(login_data.password, user.hashed_password):\n                raise AuthenticationError(\"Invalid email or password\")\n            \n            # Update last login\n            user.last_login = datetime.utcnow()\n            self.db.commit()\n            \n            logger.info(f\"User authenticated successfully: {user.email}\")\n            return user\n            \n        except AuthenticationError:\n            raise\n        except Exception as e:\n            logger.error(f\"Authentication failed: {str(e)}\")\n            raise AuthenticationError(\"Authentication failed\")\n    \n    def get_user_by_id(self, user_id: int) -> Optional[User]:\n        \"\"\"\n        Retrieve user by ID.\n        \n        Args:\n            user_id: User's unique identifier\n            \n        Returns:\n            User: User instance if found, None otherwise\n        \"\"\"\n        try:\n            return self.db.query(User).filter(\n                User.id == user_id,\n                User.is_active == True\n            ).first()\n        except Exception as e:\n            logger.error(f\"Failed to retrieve user {user_id}: {str(e)}\")\n            return None\n    \n    def _is_valid_email(self, email: str) -> bool:\n        \"\"\"\n        Validate email format.\n        \n        Args:\n            email: Email address to validate\n            \n        Returns:\n            bool: True if email format is valid\n        \"\"\"\n        import re\n        pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n        return bool(re.match(pattern, email))\n    \n    def _is_valid_password(self, password: str) -> bool:\n        \"\"\"\n        Validate password strength.\n        \n        Args:\n            password: Password to validate\n            \n        Returns:\n            bool: True if password meets requirements\n        \"\"\"\n        if len(password) < 8:\n            return False\n        \n        has_upper = any(c.isupper() for c in password)\n        has_lower = any(c.islower() for c in password)\n        has_digit = any(c.isdigit() for c in password)\n        \n        return has_upper and has_lower and has_digit\n\n\ndef get_current_user(\n    credentials: HTTPAuthorizationCredentials = Depends(security),\n    db: Session = Depends(get_db)\n) -> User:\n    \"\"\"\n    Dependency to get current authenticated user from JWT token.\n    \n    Args:\n        credentials: HTTP Bearer token credentials\n        db: Database session\n        \n    Returns:\n        User: Current authenticated user\n        \n    Raises:\n        HTTPException: If token is invalid or user not found\n    \"\"\"\n    try:\n        # Verify and decode token\n        if not verify_token(credentials.credentials):\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Invalid or expired token\",\n                headers={\"WWW-Authenticate\": \"Bearer\"}\n            )\n        \n        payload = decode_token(credentials.credentials)\n        user_id = payload.get(\"sub\")\n        \n        if not user_id:\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Invalid token payload\",\n                headers={\"WWW-Authenticate\": \"Bearer\"}\n            )\n        \n        # Get user from database\n        auth_service = AuthService(db)\n        user = auth_service.get_user_by_id(int(user_id))\n        \n        if not user:\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"User not found\",\n                headers={\"WWW-Authenticate\": \"Bearer\"}\n            )\n        \n        return user\n        \n    except HTTPException:\n        raise\n    except Exception as e:\n        logger.error(f\"Token validation failed: {str(e)}\")",
      "file_type": "source",
      "semantic_unit_id": "SU-002",
      "component_id": "COMP-002",
      "description": "Authentication API endpoints for user registration, login, token validation, and logout functionality"
    },
    {
      "file_path": "src/api/tasks.py",
      "content": "\"\"\"\nTask management API endpoints for CRUD operations with authentication middleware and user authorization.\n\nThis module provides REST API endpoints for managing tasks including creation, retrieval,\nupdating, and deletion with proper user authentication and authorization.\n\nComponent ID: COMP-003\nSemantic Unit: SU-003\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport logging\nfrom datetime import datetime\nfrom typing import List, Optional\nfrom uuid import UUID\n\nfrom fastapi import APIRouter, Depends, HTTPException, Query, status\nfrom fastapi.security import HTTPBearer\nfrom sqlalchemy.orm import Session\n\nfrom src.models.task import Task\nfrom src.models.user import User\nfrom src.schemas.task import (\n    TaskCreate,\n    TaskResponse,\n    TaskUpdate,\n    TaskListResponse,\n    TaskStatus,\n    TaskPriority\n)\nfrom src.utils.jwt_utils import decode_jwt_token, get_current_user\nfrom src.database import get_db\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Initialize router and security\nrouter = APIRouter(prefix=\"/api/v1/tasks\", tags=[\"tasks\"])\nsecurity = HTTPBearer()\n\n\ndef validate_task_ownership(task: Task, current_user: User) -> None:\n    \"\"\"\n    Validate that the current user owns the specified task.\n    \n    Args:\n        task: Task instance to validate ownership for\n        current_user: Currently authenticated user\n        \n    Raises:\n        HTTPException: If user doesn't own the task (403 Forbidden)\n    \"\"\"\n    if task.user_id != current_user.id:\n        logger.warning(\n            f\"User {current_user.id} attempted to access task {task.id} \"\n            f\"owned by user {task.user_id}\"\n        )\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"You don't have permission to access this task\"\n        )\n\n\ndef validate_task_data(task_data: TaskCreate) -> None:\n    \"\"\"\n    Validate task creation data for business rules.\n    \n    Args:\n        task_data: Task creation data to validate\n        \n    Raises:\n        HTTPException: If validation fails (400 Bad Request)\n    \"\"\"\n    if not task_data.title or not task_data.title.strip():\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Task title cannot be empty\"\n        )\n    \n    if len(task_data.title.strip()) > 200:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Task title cannot exceed 200 characters\"\n        )\n    \n    if task_data.description and len(task_data.description) > 2000:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Task description cannot exceed 2000 characters\"\n        )\n    \n    if task_data.due_date and task_data.due_date < datetime.utcnow():\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Due date cannot be in the past\"\n        )\n\n\ndef sanitize_task_input(task_data: TaskCreate) -> TaskCreate:\n    \"\"\"\n    Sanitize and clean task input data.\n    \n    Args:\n        task_data: Raw task creation data\n        \n    Returns:\n        TaskCreate: Sanitized task data\n    \"\"\"\n    # Strip whitespace from title and description\n    title = task_data.title.strip() if task_data.title else \"\"\n    description = task_data.description.strip() if task_data.description else None\n    \n    return TaskCreate(\n        title=title,\n        description=description,\n        status=task_data.status or TaskStatus.TODO,\n        priority=task_data.priority or TaskPriority.MEDIUM,\n        due_date=task_data.due_date,\n        tags=task_data.tags or []\n    )\n\n\ndef build_task_filters(\n    status: Optional[TaskStatus] = None,\n    priority: Optional[TaskPriority] = None,\n    tag: Optional[str] = None,\n    due_before: Optional[datetime] = None,\n    due_after: Optional[datetime] = None\n) -> dict:\n    \"\"\"\n    Build filter dictionary for task queries.\n    \n    Args:\n        status: Filter by task status\n        priority: Filter by task priority\n        tag: Filter by tag (partial match)\n        due_before: Filter tasks due before this date\n        due_after: Filter tasks due after this date\n        \n    Returns:\n        dict: Filter conditions for database query\n    \"\"\"\n    filters = {}\n    \n    if status:\n        filters['status'] = status\n    if priority:\n        filters['priority'] = priority\n    if tag:\n        filters['tag'] = tag\n    if due_before:\n        filters['due_before'] = due_before\n    if due_after:\n        filters['due_after'] = due_after\n        \n    return filters\n\n\n@router.post(\"/\", response_model=TaskResponse, status_code=status.HTTP_201_CREATED)\ndef create_task(\n    task_data: TaskCreate,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n) -> TaskResponse:\n    \"\"\"\n    Create a new task for the authenticated user.\n    \n    Args:\n        task_data: Task creation data\n        db: Database session\n        current_user: Currently authenticated user\n        \n    Returns:\n        TaskResponse: Created task data\n        \n    Raises:\n        HTTPException: If validation fails or creation error occurs\n    \"\"\"\n    try:\n        # Validate and sanitize input\n        validate_task_data(task_data)\n        sanitized_data = sanitize_task_input(task_data)\n        \n        # Create new task\n        new_task = Task(\n            title=sanitized_data.title,\n            description=sanitized_data.description,\n            status=sanitized_data.status,\n            priority=sanitized_data.priority,\n            due_date=sanitized_data.due_date,\n            tags=sanitized_data.tags,\n            user_id=current_user.id,\n            created_at=datetime.utcnow(),\n            updated_at=datetime.utcnow()\n        )\n        \n        db.add(new_task)\n        db.commit()\n        db.refresh(new_task)\n        \n        logger.info(f\"Task {new_task.id} created by user {current_user.id}\")\n        \n        return TaskResponse.from_orm(new_task)\n        \n    except HTTPException:\n        raise\n    except Exception as e:\n        logger.error(f\"Error creating task for user {current_user.id}: {str(e)}\")\n        db.rollback()\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Failed to create task\"\n        )\n\n\n@router.get(\"/\", response_model=TaskListResponse)\ndef get_tasks(\n    skip: int = Query(0, ge=0, description=\"Number of tasks to skip\"),\n    limit: int = Query(100, ge=1, le=1000, description=\"Maximum number of tasks to return\"),\n    status_filter: Optional[TaskStatus] = Query(None, alias=\"status\"),\n    priority_filter: Optional[TaskPriority] = Query(None, alias=\"priority\"),\n    tag_filter: Optional[str] = Query(None, alias=\"tag\", max_length=50),\n    due_before: Optional[datetime] = Query(None),\n    due_after: Optional[datetime] = Query(None),\n    search: Optional[str] = Query(None, max_length=200, description=\"Search in title and description\"),\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n) -> TaskListResponse:\n    \"\"\"\n    Retrieve tasks for the authenticated user with filtering and pagination.\n    \n    Args:\n        skip: Number of tasks to skip for pagination\n        limit: Maximum number of tasks to return\n        status_filter: Filter by task status\n        priority_filter:",
      "file_type": "source",
      "semantic_unit_id": "SU-003",
      "component_id": "COMP-003",
      "description": "Task management API endpoints for CRUD operations with authentication middleware and user authorization"
    },
    {
      "file_path": "src/models/user.py",
      "content": "\"\"\"\nUser SQLAlchemy model with authentication fields, profile data, and relationship to tasks.\n\nThis module defines the User model for the application with authentication capabilities,\nprofile information, and relationships to other entities.\n\nComponent ID: COMP-004\nSemantic Unit: SU-004\n\nAuthor: ASP Code Agent\n\"\"\"\n\nfrom datetime import datetime\nfrom typing import Optional, List\nfrom sqlalchemy import Column, Integer, String, DateTime, Boolean, Text\nfrom sqlalchemy.orm import relationship\nfrom sqlalchemy.sql import func\nfrom werkzeug.security import generate_password_hash, check_password_hash\nimport re\n\nfrom src.database.connection import Base\n\n\nclass User(Base):\n    \"\"\"\n    User model for authentication and profile management.\n    \n    This model handles user authentication, profile data, and relationships\n    to other entities in the system like tasks.\n    \n    Attributes:\n        id: Primary key identifier\n        username: Unique username for login\n        email: Unique email address\n        password_hash: Hashed password for authentication\n        first_name: User's first name\n        last_name: User's last name\n        is_active: Whether the user account is active\n        is_verified: Whether the user's email is verified\n        bio: Optional user biography\n        created_at: Timestamp when user was created\n        updated_at: Timestamp when user was last updated\n        last_login: Timestamp of last login\n        tasks: Relationship to user's tasks\n    \"\"\"\n    \n    __tablename__ = \"users\"\n    \n    # Primary key\n    id = Column(Integer, primary_key=True, index=True)\n    \n    # Authentication fields\n    username = Column(String(50), unique=True, index=True, nullable=False)\n    email = Column(String(255), unique=True, index=True, nullable=False)\n    password_hash = Column(String(255), nullable=False)\n    \n    # Profile fields\n    first_name = Column(String(100), nullable=False)\n    last_name = Column(String(100), nullable=False)\n    bio = Column(Text, nullable=True)\n    \n    # Status fields\n    is_active = Column(Boolean, default=True, nullable=False)\n    is_verified = Column(Boolean, default=False, nullable=False)\n    \n    # Timestamp fields\n    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)\n    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False)\n    last_login = Column(DateTime(timezone=True), nullable=True)\n    \n    # Relationships\n    tasks = relationship(\"Task\", back_populates=\"user\", cascade=\"all, delete-orphan\")\n    \n    def __init__(\n        self,\n        username: str,\n        email: str,\n        password: str,\n        first_name: str,\n        last_name: str,\n        bio: Optional[str] = None\n    ) -> None:\n        \"\"\"\n        Initialize a new User instance.\n        \n        Args:\n            username: Unique username for the user\n            email: User's email address\n            password: Plain text password (will be hashed)\n            first_name: User's first name\n            last_name: User's last name\n            bio: Optional biography text\n            \n        Raises:\n            ValueError: If any validation fails\n        \"\"\"\n        self.username = self._validate_username(username)\n        self.email = self._validate_email(email)\n        self.set_password(password)\n        self.first_name = self._validate_name(first_name, \"first_name\")\n        self.last_name = self._validate_name(last_name, \"last_name\")\n        self.bio = self._validate_bio(bio) if bio else None\n        self.is_active = True\n        self.is_verified = False\n    \n    def __repr__(self) -> str:\n        \"\"\"Return string representation of User.\"\"\"\n        return f\"<User(id={self.id}, username='{self.username}', email='{self.email}')>\"\n    \n    def __str__(self) -> str:\n        \"\"\"Return human-readable string representation of User.\"\"\"\n        return f\"{self.first_name} {self.last_name} ({self.username})\"\n    \n    def set_password(self, password: str) -> None:\n        \"\"\"\n        Set the user's password by hashing it.\n        \n        Args:\n            password: Plain text password to hash and store\n            \n        Raises:\n            ValueError: If password doesn't meet requirements\n        \"\"\"\n        validated_password = self._validate_password(password)\n        self.password_hash = generate_password_hash(validated_password)\n    \n    def check_password(self, password: str) -> bool:\n        \"\"\"\n        Check if provided password matches the stored hash.\n        \n        Args:\n            password: Plain text password to verify\n            \n        Returns:\n            bool: True if password matches, False otherwise\n        \"\"\"\n        if not password or not self.password_hash:\n            return False\n        return check_password_hash(self.password_hash, password)\n    \n    def update_last_login(self) -> None:\n        \"\"\"Update the last_login timestamp to current time.\"\"\"\n        self.last_login = datetime.utcnow()\n    \n    def get_full_name(self) -> str:\n        \"\"\"\n        Get the user's full name.\n        \n        Returns:\n            str: First name and last name combined\n        \"\"\"\n        return f\"{self.first_name} {self.last_name}\"\n    \n    def activate(self) -> None:\n        \"\"\"Activate the user account.\"\"\"\n        self.is_active = True\n    \n    def deactivate(self) -> None:\n        \"\"\"Deactivate the user account.\"\"\"\n        self.is_active = False\n    \n    def verify_email(self) -> None:\n        \"\"\"Mark the user's email as verified.\"\"\"\n        self.is_verified = True\n    \n    def update_profile(\n        self,\n        first_name: Optional[str] = None,\n        last_name: Optional[str] = None,\n        bio: Optional[str] = None\n    ) -> None:\n        \"\"\"\n        Update user profile information.\n        \n        Args:\n            first_name: New first name (optional)\n            last_name: New last name (optional)\n            bio: New biography (optional)\n            \n        Raises:\n            ValueError: If any validation fails\n        \"\"\"\n        if first_name is not None:\n            self.first_name = self._validate_name(first_name, \"first_name\")\n        \n        if last_name is not None:\n            self.last_name = self._validate_name(last_name, \"last_name\")\n        \n        if bio is not None:\n            self.bio = self._validate_bio(bio) if bio.strip() else None\n    \n    def to_dict(self, include_sensitive: bool = False) -> dict:\n        \"\"\"\n        Convert user to dictionary representation.\n        \n        Args:\n            include_sensitive: Whether to include sensitive fields\n            \n        Returns:\n            dict: User data as dictionary\n        \"\"\"\n        data = {\n            \"id\": self.id,\n            \"username\": self.username,\n            \"email\": self.email,\n            \"first_name\": self.first_name,\n            \"last_name\": self.last_name,\n            \"full_name\": self.get_full_name(),\n            \"bio\": self.bio,\n            \"is_active\": self.is_active,\n            \"is_verified\": self.is_verified,\n            \"created_at\": self.created_at.isoformat() if self.created_at else None,\n            \"updated_at\": self.updated_at.isoformat() if self.updated_at else None,\n            \"last_login\": self.last_login.isoformat() if self.last_login else None,\n        }\n        \n        if include_sensitive:\n            data[\"password_hash\"] = self.password_hash\n        \n        return data\n    \n    @staticmethod\n    def _validate_username(username: str) -> str:\n        \"\"\"\n        Validate username format and requirements.\n        \n        Args:\n            username: Username to validate\n            \n        Returns:\n            str:",
      "file_type": "source",
      "semantic_unit_id": "SU-004",
      "component_id": "COMP-004",
      "description": "User SQLAlchemy model with authentication fields, profile data, and relationship to tasks"
    },
    {
      "file_path": "src/models/task.py",
      "content": "\"\"\"\nTask SQLAlchemy model with CRUD operations, status management, and user relationship.\n\nThis module defines the Task model with comprehensive CRUD operations, status transitions,\nand relationship management with User model.\n\nComponent ID: COMP-005\nSemantic Unit: SU-005\n\nAuthor: ASP Code Agent\n\"\"\"\n\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import List, Optional, Dict, Any\nfrom sqlalchemy import Column, Integer, String, Text, DateTime, ForeignKey, Boolean, Index\nfrom sqlalchemy.orm import relationship, Session\nfrom sqlalchemy.exc import SQLAlchemyError\nimport logging\n\nfrom src.database.connection import Base\nfrom src.models.user import User\n\nlogger = logging.getLogger(__name__)\n\n\nclass TaskStatus(str, Enum):\n    \"\"\"Enumeration of possible task statuses.\"\"\"\n    PENDING = \"pending\"\n    IN_PROGRESS = \"in_progress\"\n    COMPLETED = \"completed\"\n    CANCELLED = \"cancelled\"\n\n\nclass TaskPriority(str, Enum):\n    \"\"\"Enumeration of task priorities.\"\"\"\n    LOW = \"low\"\n    MEDIUM = \"medium\"\n    HIGH = \"high\"\n    URGENT = \"urgent\"\n\n\nclass Task(Base):\n    \"\"\"\n    Task model representing a user task with status management and CRUD operations.\n    \n    This model provides comprehensive task management functionality including\n    status transitions, priority levels, and user relationships.\n    \n    Attributes:\n        id: Primary key identifier\n        title: Task title (required, max 200 chars)\n        description: Detailed task description (optional)\n        status: Current task status (TaskStatus enum)\n        priority: Task priority level (TaskPriority enum)\n        user_id: Foreign key to User model\n        created_at: Timestamp when task was created\n        updated_at: Timestamp when task was last modified\n        due_date: Optional due date for task completion\n        completed_at: Timestamp when task was completed\n        is_active: Soft delete flag\n        \n    Relationships:\n        user: Many-to-one relationship with User model\n    \"\"\"\n    \n    __tablename__ = \"tasks\"\n    \n    # Primary key\n    id = Column(Integer, primary_key=True, index=True)\n    \n    # Task details\n    title = Column(String(200), nullable=False, index=True)\n    description = Column(Text, nullable=True)\n    status = Column(String(20), nullable=False, default=TaskStatus.PENDING.value, index=True)\n    priority = Column(String(10), nullable=False, default=TaskPriority.MEDIUM.value, index=True)\n    \n    # User relationship\n    user_id = Column(Integer, ForeignKey(\"users.id\"), nullable=False, index=True)\n    user = relationship(\"User\", back_populates=\"tasks\")\n    \n    # Timestamps\n    created_at = Column(DateTime, nullable=False, default=datetime.utcnow, index=True)\n    updated_at = Column(DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)\n    due_date = Column(DateTime, nullable=True, index=True)\n    completed_at = Column(DateTime, nullable=True)\n    \n    # Soft delete\n    is_active = Column(Boolean, nullable=False, default=True, index=True)\n    \n    # Composite indexes for common queries\n    __table_args__ = (\n        Index('idx_user_status', 'user_id', 'status'),\n        Index('idx_user_priority', 'user_id', 'priority'),\n        Index('idx_status_due_date', 'status', 'due_date'),\n        Index('idx_user_active', 'user_id', 'is_active'),\n    )\n    \n    def __repr__(self) -> str:\n        \"\"\"String representation of Task instance.\"\"\"\n        return f\"<Task(id={self.id}, title='{self.title}', status='{self.status}', user_id={self.user_id})>\"\n    \n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Convert Task instance to dictionary representation.\n        \n        Returns:\n            Dict[str, Any]: Dictionary containing all task attributes\n        \"\"\"\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"status\": self.status,\n            \"priority\": self.priority,\n            \"user_id\": self.user_id,\n            \"created_at\": self.created_at.isoformat() if self.created_at else None,\n            \"updated_at\": self.updated_at.isoformat() if self.updated_at else None,\n            \"due_date\": self.due_date.isoformat() if self.due_date else None,\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None,\n            \"is_active\": self.is_active\n        }\n    \n    def update_status(self, new_status: TaskStatus) -> bool:\n        \"\"\"\n        Update task status with validation and automatic timestamp management.\n        \n        Args:\n            new_status: New status to set for the task\n            \n        Returns:\n            bool: True if status was updated successfully, False otherwise\n            \n        Raises:\n            ValueError: If status transition is invalid\n        \"\"\"\n        if not self._is_valid_status_transition(self.status, new_status.value):\n            raise ValueError(f\"Invalid status transition from {self.status} to {new_status.value}\")\n        \n        old_status = self.status\n        self.status = new_status.value\n        self.updated_at = datetime.utcnow()\n        \n        # Set completion timestamp when task is completed\n        if new_status == TaskStatus.COMPLETED and old_status != TaskStatus.COMPLETED.value:\n            self.completed_at = datetime.utcnow()\n        elif new_status != TaskStatus.COMPLETED and self.completed_at:\n            self.completed_at = None\n            \n        logger.info(f\"Task {self.id} status updated from {old_status} to {new_status.value}\")\n        return True\n    \n    def _is_valid_status_transition(self, current_status: str, new_status: str) -> bool:\n        \"\"\"\n        Validate if status transition is allowed.\n        \n        Args:\n            current_status: Current task status\n            new_status: Proposed new status\n            \n        Returns:\n            bool: True if transition is valid, False otherwise\n        \"\"\"\n        valid_transitions = {\n            TaskStatus.PENDING.value: [TaskStatus.IN_PROGRESS.value, TaskStatus.CANCELLED.value],\n            TaskStatus.IN_PROGRESS.value: [TaskStatus.COMPLETED.value, TaskStatus.PENDING.value, TaskStatus.CANCELLED.value],\n            TaskStatus.COMPLETED.value: [TaskStatus.IN_PROGRESS.value],\n            TaskStatus.CANCELLED.value: [TaskStatus.PENDING.value, TaskStatus.IN_PROGRESS.value]\n        }\n        \n        return new_status in valid_transitions.get(current_status, [])\n    \n    def is_overdue(self) -> bool:\n        \"\"\"\n        Check if task is overdue based on due_date.\n        \n        Returns:\n            bool: True if task is overdue, False otherwise\n        \"\"\"\n        if not self.due_date or self.status == TaskStatus.COMPLETED.value:\n            return False\n        return datetime.utcnow() > self.due_date\n    \n    @classmethod\n    def create(cls, db: Session, title: str, user_id: int, description: Optional[str] = None,\n               priority: TaskPriority = TaskPriority.MEDIUM, due_date: Optional[datetime] = None) -> \"Task\":\n        \"\"\"\n        Create a new task with validation.\n        \n        Args:\n            db: Database session\n            title: Task title (required, max 200 chars)\n            user_id: ID of the user who owns the task\n            description: Optional task description\n            priority: Task priority level\n            due_date: Optional due date\n            \n        Returns:\n            Task: Created task instance\n            \n        Raises:\n            ValueError: If validation fails\n            SQL",
      "file_type": "source",
      "semantic_unit_id": "SU-005",
      "component_id": "COMP-005",
      "description": "Task SQLAlchemy model with CRUD operations, status management, and user relationship"
    },
    {
      "file_path": "src/schemas/auth.py",
      "content": "\"\"\"\nPydantic schemas for authentication request/response validation.\n\nThis module defines data validation schemas for authentication endpoints including\nlogin, registration, token management, and user profile operations.\n\nComponent ID: COMP-006\nSemantic Unit: SU-006\n\nAuthor: ASP Code Agent\n\"\"\"\n\nfrom datetime import datetime\nfrom typing import Optional\nfrom pydantic import BaseModel, EmailStr, Field, validator\nimport re\n\n\nclass UserRegistrationRequest(BaseModel):\n    \"\"\"Schema for user registration request validation.\"\"\"\n    \n    email: EmailStr = Field(\n        ...,\n        description=\"User email address\",\n        example=\"user@example.com\"\n    )\n    password: str = Field(\n        ...,\n        min_length=8,\n        max_length=128,\n        description=\"User password (8-128 characters)\",\n        example=\"SecurePassword123!\"\n    )\n    full_name: str = Field(\n        ...,\n        min_length=1,\n        max_length=100,\n        description=\"User full name\",\n        example=\"John Doe\"\n    )\n    \n    @validator('password')\n    def validate_password_strength(cls, v: str) -> str:\n        \"\"\"\n        Validate password meets security requirements.\n        \n        Args:\n            v: Password string to validate\n            \n        Returns:\n            str: Validated password\n            \n        Raises:\n            ValueError: If password doesn't meet requirements\n        \"\"\"\n        if not re.search(r'[A-Z]', v):\n            raise ValueError('Password must contain at least one uppercase letter')\n        if not re.search(r'[a-z]', v):\n            raise ValueError('Password must contain at least one lowercase letter')\n        if not re.search(r'\\d', v):\n            raise ValueError('Password must contain at least one digit')\n        if not re.search(r'[!@#$%^&*(),.?\":{}|<>]', v):\n            raise ValueError('Password must contain at least one special character')\n        return v\n    \n    @validator('full_name')\n    def validate_full_name(cls, v: str) -> str:\n        \"\"\"\n        Validate full name contains only allowed characters.\n        \n        Args:\n            v: Full name string to validate\n            \n        Returns:\n            str: Validated and cleaned full name\n            \n        Raises:\n            ValueError: If name contains invalid characters\n        \"\"\"\n        # Allow letters, spaces, hyphens, and apostrophes\n        if not re.match(r\"^[a-zA-Z\\s\\-']+$\", v.strip()):\n            raise ValueError('Full name can only contain letters, spaces, hyphens, and apostrophes')\n        return v.strip()\n\n\nclass UserLoginRequest(BaseModel):\n    \"\"\"Schema for user login request validation.\"\"\"\n    \n    email: EmailStr = Field(\n        ...,\n        description=\"User email address\",\n        example=\"user@example.com\"\n    )\n    password: str = Field(\n        ...,\n        min_length=1,\n        max_length=128,\n        description=\"User password\",\n        example=\"SecurePassword123!\"\n    )\n\n\nclass TokenResponse(BaseModel):\n    \"\"\"Schema for authentication token response.\"\"\"\n    \n    access_token: str = Field(\n        ...,\n        description=\"JWT access token\",\n        example=\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\"\n    )\n    refresh_token: str = Field(\n        ...,\n        description=\"JWT refresh token\",\n        example=\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\"\n    )\n    token_type: str = Field(\n        default=\"bearer\",\n        description=\"Token type\",\n        example=\"bearer\"\n    )\n    expires_in: int = Field(\n        ...,\n        description=\"Access token expiration time in seconds\",\n        example=3600\n    )\n\n\nclass TokenRefreshRequest(BaseModel):\n    \"\"\"Schema for token refresh request validation.\"\"\"\n    \n    refresh_token: str = Field(\n        ...,\n        description=\"Valid refresh token\",\n        example=\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\"\n    )\n\n\nclass UserProfile(BaseModel):\n    \"\"\"Schema for user profile information.\"\"\"\n    \n    id: int = Field(\n        ...,\n        description=\"User unique identifier\",\n        example=1\n    )\n    email: EmailStr = Field(\n        ...,\n        description=\"User email address\",\n        example=\"user@example.com\"\n    )\n    full_name: str = Field(\n        ...,\n        description=\"User full name\",\n        example=\"John Doe\"\n    )\n    is_active: bool = Field(\n        default=True,\n        description=\"Whether user account is active\",\n        example=True\n    )\n    created_at: datetime = Field(\n        ...,\n        description=\"Account creation timestamp\",\n        example=\"2023-01-01T00:00:00Z\"\n    )\n    last_login: Optional[datetime] = Field(\n        None,\n        description=\"Last login timestamp\",\n        example=\"2023-01-01T12:00:00Z\"\n    )\n\n\nclass UserRegistrationResponse(BaseModel):\n    \"\"\"Schema for user registration response.\"\"\"\n    \n    user: UserProfile = Field(\n        ...,\n        description=\"Created user profile information\"\n    )\n    tokens: TokenResponse = Field(\n        ...,\n        description=\"Authentication tokens for the new user\"\n    )\n\n\nclass PasswordChangeRequest(BaseModel):\n    \"\"\"Schema for password change request validation.\"\"\"\n    \n    current_password: str = Field(\n        ...,\n        min_length=1,\n        max_length=128,\n        description=\"Current user password\",\n        example=\"OldPassword123!\"\n    )\n    new_password: str = Field(\n        ...,\n        min_length=8,\n        max_length=128,\n        description=\"New password (8-128 characters)\",\n        example=\"NewSecurePassword123!\"\n    )\n    \n    @validator('new_password')\n    def validate_new_password_strength(cls, v: str) -> str:\n        \"\"\"\n        Validate new password meets security requirements.\n        \n        Args:\n            v: New password string to validate\n            \n        Returns:\n            str: Validated password\n            \n        Raises:\n            ValueError: If password doesn't meet requirements\n        \"\"\"\n        if not re.search(r'[A-Z]', v):\n            raise ValueError('New password must contain at least one uppercase letter')\n        if not re.search(r'[a-z]', v):\n            raise ValueError('New password must contain at least one lowercase letter')\n        if not re.search(r'\\d', v):\n            raise ValueError('New password must contain at least one digit')\n        if not re.search(r'[!@#$%^&*(),.?\":{}|<>]', v):\n            raise ValueError('New password must contain at least one special character')\n        return v\n\n\nclass PasswordResetRequest(BaseModel):\n    \"\"\"Schema for password reset request validation.\"\"\"\n    \n    email: EmailStr = Field(\n        ...,\n        description=\"Email address for password reset\",\n        example=\"user@example.com\"\n    )\n\n\nclass PasswordResetConfirm(BaseModel):\n    \"\"\"Schema for password reset confirmation validation.\"\"\"\n    \n    token: str = Field(\n        ...,\n        min_length=1,\n        description=\"Password reset token\",\n        example=\"abc123def456\"\n    )\n    new_password: str = Field(\n        ...,\n        min_length=8,\n        max_length=128,\n        description=\"New password (8-128 characters)\",\n        example=\"NewSecurePassword123!\"\n    )\n    \n    @validator('new_password')\n    def validate_reset_password_strength(cls, v: str) -> str:\n        \"\"\"\n        Validate reset password meets security requirements.\n        \n        Args:\n            v: Reset password string to validate\n            \n        Returns:\n            str: Validated password\n            \n        Raises:\n            ValueError: If password doesn't meet requirements\n        \"\"\"\n        if not re.search(r'[A-Z]',",
      "file_type": "source",
      "semantic_unit_id": "SU-006",
      "component_id": "COMP-006",
      "description": "Pydantic schemas for authentication request/response validation including login, registration, and token models"
    },
    {
      "file_path": "src/schemas/task.py",
      "content": "\"\"\"\nPydantic schemas for task request/response validation.\n\nThis module defines the data models used for task-related API operations\nincluding creation, updates, and response formatting.\n\nComponent ID: COMP-007\nSemantic Unit: SU-007\n\nAuthor: ASP Code Agent\n\"\"\"\n\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Optional\n\nfrom pydantic import BaseModel, Field, validator\n\n\nclass TaskStatus(str, Enum):\n    \"\"\"Enumeration of possible task statuses.\"\"\"\n    PENDING = \"pending\"\n    IN_PROGRESS = \"in_progress\"\n    COMPLETED = \"completed\"\n    CANCELLED = \"cancelled\"\n\n\nclass TaskPriority(str, Enum):\n    \"\"\"Enumeration of task priority levels.\"\"\"\n    LOW = \"low\"\n    MEDIUM = \"medium\"\n    HIGH = \"high\"\n    URGENT = \"urgent\"\n\n\nclass TaskCreateRequest(BaseModel):\n    \"\"\"Schema for creating a new task.\"\"\"\n    \n    title: str = Field(\n        ...,\n        min_length=1,\n        max_length=200,\n        description=\"Task title\"\n    )\n    description: Optional[str] = Field(\n        None,\n        max_length=2000,\n        description=\"Detailed task description\"\n    )\n    priority: TaskPriority = Field(\n        TaskPriority.MEDIUM,\n        description=\"Task priority level\"\n    )\n    due_date: Optional[datetime] = Field(\n        None,\n        description=\"Task due date and time\"\n    )\n    tags: Optional[list[str]] = Field(\n        None,\n        description=\"List of task tags\"\n    )\n\n    @validator('title')\n    def validate_title(cls, v: str) -> str:\n        \"\"\"Validate and clean task title.\"\"\"\n        if not v or not v.strip():\n            raise ValueError('Title cannot be empty or whitespace only')\n        return v.strip()\n\n    @validator('description')\n    def validate_description(cls, v: Optional[str]) -> Optional[str]:\n        \"\"\"Validate and clean task description.\"\"\"\n        if v is not None:\n            v = v.strip()\n            if not v:\n                return None\n        return v\n\n    @validator('due_date')\n    def validate_due_date(cls, v: Optional[datetime]) -> Optional[datetime]:\n        \"\"\"Validate due date is not in the past.\"\"\"\n        if v is not None and v < datetime.utcnow():\n            raise ValueError('Due date cannot be in the past')\n        return v\n\n    @validator('tags')\n    def validate_tags(cls, v: Optional[list[str]]) -> Optional[list[str]]:\n        \"\"\"Validate and clean task tags.\"\"\"\n        if v is not None:\n            # Remove empty tags and duplicates\n            cleaned_tags = []\n            seen = set()\n            for tag in v:\n                if isinstance(tag, str):\n                    tag = tag.strip().lower()\n                    if tag and tag not in seen and len(tag) <= 50:\n                        cleaned_tags.append(tag)\n                        seen.add(tag)\n            return cleaned_tags if cleaned_tags else None\n        return v\n\n    class Config:\n        \"\"\"Pydantic model configuration.\"\"\"\n        json_encoders = {\n            datetime: lambda v: v.isoformat() + 'Z' if v else None\n        }\n\n\nclass TaskUpdateRequest(BaseModel):\n    \"\"\"Schema for updating an existing task.\"\"\"\n    \n    title: Optional[str] = Field(\n        None,\n        min_length=1,\n        max_length=200,\n        description=\"Updated task title\"\n    )\n    description: Optional[str] = Field(\n        None,\n        max_length=2000,\n        description=\"Updated task description\"\n    )\n    status: Optional[TaskStatus] = Field(\n        None,\n        description=\"Updated task status\"\n    )\n    priority: Optional[TaskPriority] = Field(\n        None,\n        description=\"Updated task priority\"\n    )\n    due_date: Optional[datetime] = Field(\n        None,\n        description=\"Updated task due date\"\n    )\n    tags: Optional[list[str]] = Field(\n        None,\n        description=\"Updated list of task tags\"\n    )\n\n    @validator('title')\n    def validate_title(cls, v: Optional[str]) -> Optional[str]:\n        \"\"\"Validate and clean task title.\"\"\"\n        if v is not None:\n            if not v or not v.strip():\n                raise ValueError('Title cannot be empty or whitespace only')\n            return v.strip()\n        return v\n\n    @validator('description')\n    def validate_description(cls, v: Optional[str]) -> Optional[str]:\n        \"\"\"Validate and clean task description.\"\"\"\n        if v is not None:\n            v = v.strip()\n            if not v:\n                return None\n        return v\n\n    @validator('due_date')\n    def validate_due_date(cls, v: Optional[datetime]) -> Optional[datetime]:\n        \"\"\"Validate due date is not in the past.\"\"\"\n        if v is not None and v < datetime.utcnow():\n            raise ValueError('Due date cannot be in the past')\n        return v\n\n    @validator('tags')\n    def validate_tags(cls, v: Optional[list[str]]) -> Optional[list[str]]:\n        \"\"\"Validate and clean task tags.\"\"\"\n        if v is not None:\n            # Remove empty tags and duplicates\n            cleaned_tags = []\n            seen = set()\n            for tag in v:\n                if isinstance(tag, str):\n                    tag = tag.strip().lower()\n                    if tag and tag not in seen and len(tag) <= 50:\n                        cleaned_tags.append(tag)\n                        seen.add(tag)\n            return cleaned_tags if cleaned_tags else None\n        return v\n\n    class Config:\n        \"\"\"Pydantic model configuration.\"\"\"\n        json_encoders = {\n            datetime: lambda v: v.isoformat() + 'Z' if v else None\n        }\n\n\nclass TaskResponse(BaseModel):\n    \"\"\"Schema for task response data.\"\"\"\n    \n    id: int = Field(..., description=\"Unique task identifier\")\n    title: str = Field(..., description=\"Task title\")\n    description: Optional[str] = Field(None, description=\"Task description\")\n    status: TaskStatus = Field(..., description=\"Current task status\")\n    priority: TaskPriority = Field(..., description=\"Task priority level\")\n    due_date: Optional[datetime] = Field(None, description=\"Task due date\")\n    tags: Optional[list[str]] = Field(None, description=\"Task tags\")\n    created_at: datetime = Field(..., description=\"Task creation timestamp\")\n    updated_at: datetime = Field(..., description=\"Last update timestamp\")\n\n    class Config:\n        \"\"\"Pydantic model configuration.\"\"\"\n        json_encoders = {\n            datetime: lambda v: v.isoformat() + 'Z' if v else None\n        }\n        orm_mode = True\n\n\nclass TaskListResponse(BaseModel):\n    \"\"\"Schema for paginated task list response.\"\"\"\n    \n    tasks: list[TaskResponse] = Field(..., description=\"List of tasks\")\n    total: int = Field(..., ge=0, description=\"Total number of tasks\")\n    page: int = Field(..., ge=1, description=\"Current page number\")\n    per_page: int = Field(..., ge=1, le=100, description=\"Items per page\")\n    pages: int = Field(..., ge=0, description=\"Total number of pages\")\n\n    class Config:\n        \"\"\"Pydantic model configuration.\"\"\"\n        json_encoders = {\n            datetime: lambda v: v.isoformat() + 'Z' if v else None\n        }\n\n\nclass TaskStatusUpdateRequest(BaseModel):\n    \"\"\"Schema for updating only task status.\"\"\"\n    \n    status: TaskStatus = Field(..., description=\"New task status\")\n\n    class Config:\n        \"\"\"Pydantic model configuration.\"\"\"\n        use_enum_values = True",
      "file_type": "source",
      "semantic_unit_id": "SU-007",
      "component_id": "COMP-007",
      "description": "Pydantic schemas for task request/response validation including create, update, and response models"
    },
    {
      "file_path": "src/utils/jwt_utils.py",
      "content": "\"\"\"\nJWT token generation, validation, decoding utilities with expiration handling and security features.\n\nThis module provides comprehensive JWT token management including secure token generation,\nvalidation with expiration checks, and decoding with proper error handling.\n\nComponent ID: COMP-008\nSemantic Unit: SU-008\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport hashlib\nimport hmac\nimport json\nimport logging\nimport secrets\nimport time\nfrom datetime import datetime, timedelta, timezone\nfrom typing import Any, Dict, Optional, Union\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n\nclass JWTError(Exception):\n    \"\"\"Base exception for JWT-related errors.\"\"\"\n    pass\n\n\nclass JWTExpiredError(JWTError):\n    \"\"\"Exception raised when JWT token has expired.\"\"\"\n    pass\n\n\nclass JWTInvalidError(JWTError):\n    \"\"\"Exception raised when JWT token is invalid or malformed.\"\"\"\n    pass\n\n\nclass JWTSignatureError(JWTError):\n    \"\"\"Exception raised when JWT signature verification fails.\"\"\"\n    pass\n\n\nclass JWTUtils:\n    \"\"\"\n    JWT token utilities for secure token generation, validation, and decoding.\n    \n    Provides methods for creating JWT tokens with expiration, validating tokens,\n    and extracting payload data with proper security checks.\n    \"\"\"\n    \n    def __init__(self, secret_key: str, algorithm: str = \"HS256\", default_expiry_hours: int = 24):\n        \"\"\"\n        Initialize JWT utilities with secret key and configuration.\n        \n        Args:\n            secret_key: Secret key for signing tokens (minimum 32 characters recommended)\n            algorithm: Signing algorithm (currently supports HS256)\n            default_expiry_hours: Default token expiration time in hours\n            \n        Raises:\n            ValueError: If secret key is too short or algorithm is unsupported\n        \"\"\"\n        if len(secret_key) < 32:\n            raise ValueError(\"Secret key must be at least 32 characters long for security\")\n        \n        if algorithm != \"HS256\":\n            raise ValueError(\"Only HS256 algorithm is currently supported\")\n        \n        self.secret_key = secret_key.encode('utf-8')\n        self.algorithm = algorithm\n        self.default_expiry_hours = default_expiry_hours\n        \n        logger.info(f\"JWT utilities initialized with algorithm {algorithm}\")\n    \n    def generate_token(\n        self, \n        payload: Dict[str, Any], \n        expiry_hours: Optional[int] = None,\n        include_jti: bool = True\n    ) -> str:\n        \"\"\"\n        Generate a JWT token with the given payload and expiration time.\n        \n        Args:\n            payload: Dictionary containing token claims/data\n            expiry_hours: Token expiration time in hours (uses default if None)\n            include_jti: Whether to include a unique token ID (jti claim)\n            \n        Returns:\n            str: Base64-encoded JWT token\n            \n        Raises:\n            ValueError: If payload contains reserved claims or invalid data\n            JWTError: If token generation fails\n        \"\"\"\n        try:\n            # Validate payload doesn't contain reserved claims\n            reserved_claims = {'iat', 'exp', 'jti'}\n            if any(claim in payload for claim in reserved_claims):\n                raise ValueError(f\"Payload cannot contain reserved claims: {reserved_claims}\")\n            \n            # Create header\n            header = {\n                \"alg\": self.algorithm,\n                \"typ\": \"JWT\"\n            }\n            \n            # Create payload with standard claims\n            current_time = datetime.now(timezone.utc)\n            expiry_time = current_time + timedelta(hours=expiry_hours or self.default_expiry_hours)\n            \n            token_payload = payload.copy()\n            token_payload.update({\n                \"iat\": int(current_time.timestamp()),\n                \"exp\": int(expiry_time.timestamp())\n            })\n            \n            # Add unique token ID if requested\n            if include_jti:\n                token_payload[\"jti\"] = self._generate_token_id()\n            \n            # Encode header and payload\n            encoded_header = self._base64_url_encode(json.dumps(header, separators=(',', ':')))\n            encoded_payload = self._base64_url_encode(json.dumps(token_payload, separators=(',', ':')))\n            \n            # Create signature\n            message = f\"{encoded_header}.{encoded_payload}\"\n            signature = self._create_signature(message)\n            encoded_signature = self._base64_url_encode(signature)\n            \n            # Combine parts\n            token = f\"{encoded_header}.{encoded_payload}.{encoded_signature}\"\n            \n            logger.info(f\"JWT token generated successfully, expires at {expiry_time.isoformat()}\")\n            return token\n            \n        except Exception as e:\n            logger.error(f\"Failed to generate JWT token: {str(e)}\")\n            raise JWTError(f\"Token generation failed: {str(e)}\") from e\n    \n    def validate_token(self, token: str, verify_expiration: bool = True) -> bool:\n        \"\"\"\n        Validate a JWT token's signature and expiration.\n        \n        Args:\n            token: JWT token string to validate\n            verify_expiration: Whether to check if token has expired\n            \n        Returns:\n            bool: True if token is valid, False otherwise\n            \n        Raises:\n            JWTInvalidError: If token format is invalid\n            JWTSignatureError: If signature verification fails\n            JWTExpiredError: If token has expired (when verify_expiration=True)\n        \"\"\"\n        try:\n            # Parse token parts\n            parts = token.split('.')\n            if len(parts) != 3:\n                raise JWTInvalidError(\"Invalid token format: must have 3 parts separated by dots\")\n            \n            encoded_header, encoded_payload, encoded_signature = parts\n            \n            # Verify signature\n            message = f\"{encoded_header}.{encoded_payload}\"\n            expected_signature = self._create_signature(message)\n            provided_signature = self._base64_url_decode(encoded_signature)\n            \n            if not hmac.compare_digest(expected_signature, provided_signature):\n                raise JWTSignatureError(\"Token signature verification failed\")\n            \n            # Decode and validate payload\n            payload = self._decode_payload(encoded_payload)\n            \n            # Check expiration if requested\n            if verify_expiration and 'exp' in payload:\n                current_timestamp = int(time.time())\n                if current_timestamp >= payload['exp']:\n                    raise JWTExpiredError(\"Token has expired\")\n            \n            logger.debug(\"JWT token validation successful\")\n            return True\n            \n        except (JWTInvalidError, JWTSignatureError, JWTExpiredError):\n            raise\n        except Exception as e:\n            logger.error(f\"Token validation error: {str(e)}\")\n            raise JWTInvalidError(f\"Token validation failed: {str(e)}\") from e\n    \n    def decode_token(self, token: str, verify_signature: bool = True, verify_expiration: bool = True) -> Dict[str, Any]:\n        \"\"\"\n        Decode a JWT token and return its payload.\n        \n        Args:\n            token: JWT token string to decode\n            verify_signature: Whether to verify token signature\n            verify_expiration: Whether to check if token has expired\n            \n        Returns:\n            Dict[str, Any]: Token payload data\n            \n        Raises:\n            JWTInvalidError: If token format is invalid\n            JWTSignatureError: If signature verification fails\n            JWTExpiredError: If token has expired\n        \"\"\"\n        try:\n            # Parse token parts\n            parts = token.split('.')\n            if len(parts) != 3:\n                raise JWTInvalidError(\"Invalid token format: must have 3 parts separated by dots\")\n            \n            encoded_header, encoded_payload, encoded_signature = parts\n            \n            # Verify signature if requested\n            if verify_signature:\n                message = f\"{encoded_header}.{encoded_payload}\"\n                expected_signature = self._create_signature(message)\n                provided_signature = self._base64_url_decode(encoded_signature)\n                \n                if",
      "file_type": "source",
      "semantic_unit_id": "SU-008",
      "component_id": "COMP-008",
      "description": "JWT token generation, validation, decoding utilities with expiration handling and security features"
    },
    {
      "file_path": "src/utils/password.py",
      "content": "\"\"\"\nPassword hashing and verification utilities using bcrypt.\n\nThis module provides secure password hashing and verification functionality\nusing the bcrypt algorithm with configurable salt rounds.\n\nComponent ID: COMP-009\nSemantic Unit: SU-009\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport logging\nfrom typing import Optional\n\nimport bcrypt\n\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Default salt rounds for bcrypt hashing\nDEFAULT_SALT_ROUNDS = 12\n\n\nclass PasswordHasher:\n    \"\"\"\n    Password hashing and verification utility using bcrypt.\n    \n    This class provides methods to securely hash passwords and verify\n    them against stored hashes using the bcrypt algorithm.\n    \"\"\"\n    \n    def __init__(self, salt_rounds: int = DEFAULT_SALT_ROUNDS) -> None:\n        \"\"\"\n        Initialize the password hasher with specified salt rounds.\n        \n        Args:\n            salt_rounds: Number of salt rounds for bcrypt (default: 12)\n            \n        Raises:\n            ValueError: If salt_rounds is not between 4 and 31\n        \"\"\"\n        if not isinstance(salt_rounds, int):\n            raise ValueError(\"Salt rounds must be an integer\")\n        \n        if salt_rounds < 4 or salt_rounds > 31:\n            raise ValueError(\"Salt rounds must be between 4 and 31\")\n        \n        self.salt_rounds = salt_rounds\n        logger.debug(f\"PasswordHasher initialized with {salt_rounds} salt rounds\")\n    \n    def hash_password(self, password: str) -> str:\n        \"\"\"\n        Hash a password using bcrypt with salt.\n        \n        Args:\n            password: Plain text password to hash\n            \n        Returns:\n            str: Base64-encoded bcrypt hash\n            \n        Raises:\n            ValueError: If password is empty or None\n            TypeError: If password is not a string\n        \"\"\"\n        if not isinstance(password, str):\n            raise TypeError(\"Password must be a string\")\n        \n        if not password:\n            raise ValueError(\"Password cannot be empty\")\n        \n        if len(password) > 72:\n            logger.warning(\"Password length exceeds 72 characters, will be truncated by bcrypt\")\n        \n        try:\n            # Generate salt and hash password\n            salt = bcrypt.gensalt(rounds=self.salt_rounds)\n            password_bytes = password.encode('utf-8')\n            hashed = bcrypt.hashpw(password_bytes, salt)\n            \n            # Return as string\n            hashed_str = hashed.decode('utf-8')\n            logger.debug(\"Password successfully hashed\")\n            return hashed_str\n            \n        except Exception as e:\n            logger.error(f\"Error hashing password: {e}\")\n            raise RuntimeError(f\"Failed to hash password: {e}\") from e\n    \n    def verify_password(self, password: str, hashed_password: str) -> bool:\n        \"\"\"\n        Verify a password against its hash.\n        \n        Args:\n            password: Plain text password to verify\n            hashed_password: Previously hashed password to check against\n            \n        Returns:\n            bool: True if password matches hash, False otherwise\n            \n        Raises:\n            ValueError: If password or hashed_password is empty or None\n            TypeError: If password or hashed_password is not a string\n        \"\"\"\n        if not isinstance(password, str):\n            raise TypeError(\"Password must be a string\")\n        \n        if not isinstance(hashed_password, str):\n            raise TypeError(\"Hashed password must be a string\")\n        \n        if not password:\n            raise ValueError(\"Password cannot be empty\")\n        \n        if not hashed_password:\n            raise ValueError(\"Hashed password cannot be empty\")\n        \n        try:\n            password_bytes = password.encode('utf-8')\n            hashed_bytes = hashed_password.encode('utf-8')\n            \n            # Verify password against hash\n            is_valid = bcrypt.checkpw(password_bytes, hashed_bytes)\n            \n            logger.debug(f\"Password verification result: {is_valid}\")\n            return is_valid\n            \n        except Exception as e:\n            logger.error(f\"Error verifying password: {e}\")\n            # Return False for any verification errors (don't expose internal errors)\n            return False\n\n\n# Module-level convenience functions\n_default_hasher: Optional[PasswordHasher] = None\n\n\ndef get_default_hasher() -> PasswordHasher:\n    \"\"\"\n    Get the default password hasher instance.\n    \n    Returns:\n        PasswordHasher: Default hasher with standard salt rounds\n    \"\"\"\n    global _default_hasher\n    if _default_hasher is None:\n        _default_hasher = PasswordHasher()\n    return _default_hasher\n\n\ndef hash_password(password: str, salt_rounds: int = DEFAULT_SALT_ROUNDS) -> str:\n    \"\"\"\n    Hash a password using the default hasher.\n    \n    Args:\n        password: Plain text password to hash\n        salt_rounds: Number of salt rounds (default: 12)\n        \n    Returns:\n        str: Hashed password\n        \n    Raises:\n        ValueError: If password is invalid\n        TypeError: If password is not a string\n    \"\"\"\n    if salt_rounds != DEFAULT_SALT_ROUNDS:\n        # Use custom hasher for non-default salt rounds\n        hasher = PasswordHasher(salt_rounds)\n        return hasher.hash_password(password)\n    \n    # Use default hasher\n    hasher = get_default_hasher()\n    return hasher.hash_password(password)\n\n\ndef verify_password(password: str, hashed_password: str) -> bool:\n    \"\"\"\n    Verify a password against its hash using the default hasher.\n    \n    Args:\n        password: Plain text password to verify\n        hashed_password: Previously hashed password\n        \n    Returns:\n        bool: True if password matches, False otherwise\n        \n    Raises:\n        ValueError: If inputs are invalid\n        TypeError: If inputs are not strings\n    \"\"\"\n    hasher = get_default_hasher()\n    return hasher.verify_password(password, hashed_password)\n\n\ndef is_password_strong(password: str) -> bool:\n    \"\"\"\n    Check if a password meets basic strength requirements.\n    \n    Requirements:\n    - At least 8 characters long\n    - Contains at least one uppercase letter\n    - Contains at least one lowercase letter\n    - Contains at least one digit\n    - Contains at least one special character\n    \n    Args:\n        password: Password to check\n        \n    Returns:\n        bool: True if password meets requirements, False otherwise\n        \n    Raises:\n        TypeError: If password is not a string\n    \"\"\"\n    if not isinstance(password, str):\n        raise TypeError(\"Password must be a string\")\n    \n    if len(password) < 8:\n        return False\n    \n    has_upper = any(c.isupper() for c in password)\n    has_lower = any(c.islower() for c in password)\n    has_digit = any(c.isdigit() for c in password)\n    has_special = any(not c.isalnum() for c in password)\n    \n    return has_upper and has_lower and has_digit and has_special",
      "file_type": "source",
      "semantic_unit_id": "SU-009",
      "component_id": "COMP-009",
      "description": "Password hashing and verification utilities using bcrypt with salt rounds configuration"
    },
    {
      "file_path": "src/database/connection.py",
      "content": "\"\"\"\nSQLAlchemy database connection setup and session management.\n\nProvides database connection configuration, session factory, and initialization\nutilities for the Hello World API application.\n\nComponent ID: COMP-010\nSemantic Unit: SU-010\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport logging\nimport os\nfrom contextlib import contextmanager\nfrom typing import Generator, Optional\n\nfrom sqlalchemy import create_engine, event, Engine, text\nfrom sqlalchemy.exc import SQLAlchemyError, OperationalError\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom sqlalchemy.pool import StaticPool\n\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Base class for all database models\nBase = declarative_base()\n\n# Global database engine and session factory\n_engine: Optional[Engine] = None\n_SessionLocal: Optional[sessionmaker] = None\n\n\nclass DatabaseConfig:\n    \"\"\"Database configuration settings.\"\"\"\n    \n    def __init__(self) -> None:\n        \"\"\"Initialize database configuration from environment variables.\"\"\"\n        self.database_url = os.getenv(\n            \"DATABASE_URL\", \n            \"sqlite:///./hello_world.db\"\n        )\n        self.echo_sql = os.getenv(\"DATABASE_ECHO\", \"false\").lower() == \"true\"\n        self.pool_size = int(os.getenv(\"DATABASE_POOL_SIZE\", \"5\"))\n        self.max_overflow = int(os.getenv(\"DATABASE_MAX_OVERFLOW\", \"10\"))\n        self.pool_timeout = int(os.getenv(\"DATABASE_POOL_TIMEOUT\", \"30\"))\n        self.pool_recycle = int(os.getenv(\"DATABASE_POOL_RECYCLE\", \"3600\"))\n        \n    def get_engine_kwargs(self) -> dict:\n        \"\"\"Get SQLAlchemy engine configuration parameters.\"\"\"\n        kwargs = {\n            \"echo\": self.echo_sql,\n            \"future\": True,\n        }\n        \n        # SQLite-specific configuration\n        if self.database_url.startswith(\"sqlite\"):\n            kwargs.update({\n                \"poolclass\": StaticPool,\n                \"connect_args\": {\n                    \"check_same_thread\": False,\n                    \"timeout\": 20,\n                },\n            })\n        else:\n            # PostgreSQL/MySQL configuration\n            kwargs.update({\n                \"pool_size\": self.pool_size,\n                \"max_overflow\": self.max_overflow,\n                \"pool_timeout\": self.pool_timeout,\n                \"pool_recycle\": self.pool_recycle,\n                \"pool_pre_ping\": True,\n            })\n            \n        return kwargs\n\n\ndef create_database_engine(config: Optional[DatabaseConfig] = None) -> Engine:\n    \"\"\"\n    Create and configure SQLAlchemy database engine.\n    \n    Args:\n        config: Database configuration object. If None, creates default config.\n        \n    Returns:\n        Engine: Configured SQLAlchemy engine\n        \n    Raises:\n        SQLAlchemyError: If engine creation fails\n        \n    Example:\n        >>> engine = create_database_engine()\n        >>> isinstance(engine, Engine)\n        True\n    \"\"\"\n    if config is None:\n        config = DatabaseConfig()\n        \n    try:\n        engine = create_engine(\n            config.database_url,\n            **config.get_engine_kwargs()\n        )\n        \n        # Add event listeners for connection handling\n        _setup_engine_events(engine)\n        \n        logger.info(f\"Database engine created successfully: {config.database_url}\")\n        return engine\n        \n    except Exception as e:\n        logger.error(f\"Failed to create database engine: {e}\")\n        raise SQLAlchemyError(f\"Database engine creation failed: {e}\") from e\n\n\ndef _setup_engine_events(engine: Engine) -> None:\n    \"\"\"\n    Set up SQLAlchemy engine event listeners.\n    \n    Args:\n        engine: SQLAlchemy engine to configure\n    \"\"\"\n    @event.listens_for(engine, \"connect\")\n    def set_sqlite_pragma(dbapi_connection, connection_record):\n        \"\"\"Enable foreign key constraints for SQLite connections.\"\"\"\n        if engine.url.drivername == \"sqlite\":\n            cursor = dbapi_connection.cursor()\n            cursor.execute(\"PRAGMA foreign_keys=ON\")\n            cursor.execute(\"PRAGMA journal_mode=WAL\")\n            cursor.close()\n            \n    @event.listens_for(engine, \"engine_connect\")\n    def receive_engine_connect(conn, branch):\n        \"\"\"Log successful database connections.\"\"\"\n        logger.debug(\"Database connection established\")\n\n\ndef initialize_database(engine: Optional[Engine] = None) -> None:\n    \"\"\"\n    Initialize database by creating all tables.\n    \n    Args:\n        engine: SQLAlchemy engine. If None, uses global engine.\n        \n    Raises:\n        SQLAlchemyError: If database initialization fails\n        RuntimeError: If no engine is available\n        \n    Example:\n        >>> initialize_database()\n        # Creates all tables defined in Base metadata\n    \"\"\"\n    if engine is None:\n        engine = get_engine()\n        \n    if engine is None:\n        raise RuntimeError(\"No database engine available. Call setup_database() first.\")\n        \n    try:\n        # Create all tables\n        Base.metadata.create_all(bind=engine)\n        logger.info(\"Database tables created successfully\")\n        \n        # Verify database connection\n        with engine.connect() as conn:\n            conn.execute(text(\"SELECT 1\"))\n            logger.info(\"Database connection verified\")\n            \n    except Exception as e:\n        logger.error(f\"Database initialization failed: {e}\")\n        raise SQLAlchemyError(f\"Failed to initialize database: {e}\") from e\n\n\ndef setup_database(config: Optional[DatabaseConfig] = None) -> None:\n    \"\"\"\n    Set up global database engine and session factory.\n    \n    Args:\n        config: Database configuration. If None, uses default configuration.\n        \n    Raises:\n        SQLAlchemyError: If database setup fails\n        \n    Example:\n        >>> setup_database()\n        >>> engine = get_engine()\n        >>> engine is not None\n        True\n    \"\"\"\n    global _engine, _SessionLocal\n    \n    try:\n        # Create database engine\n        _engine = create_database_engine(config)\n        \n        # Create session factory\n        _SessionLocal = sessionmaker(\n            bind=_engine,\n            autocommit=False,\n            autoflush=False,\n            expire_on_commit=False\n        )\n        \n        logger.info(\"Database setup completed successfully\")\n        \n    except Exception as e:\n        logger.error(f\"Database setup failed: {e}\")\n        raise SQLAlchemyError(f\"Failed to setup database: {e}\") from e\n\n\ndef get_engine() -> Optional[Engine]:\n    \"\"\"\n    Get the global database engine.\n    \n    Returns:\n        Optional[Engine]: Database engine or None if not initialized\n        \n    Example:\n        >>> setup_database()\n        >>> engine = get_engine()\n        >>> engine is not None\n        True\n    \"\"\"\n    return _engine\n\n\ndef get_session_factory() -> Optional[sessionmaker]:\n    \"\"\"\n    Get the global session factory.\n    \n    Returns:\n        Optional[sessionmaker]: Session factory or None if not initialized\n        \n    Example:\n        >>> setup_database()\n        >>> factory = get_session_factory()\n        >>> factory is not None\n        True\n    \"\"\"\n    return _SessionLocal\n\n\ndef create_session() -> Session:\n    \"\"\"\n    Create a new database session.\n    \n    Returns:\n        Session: New SQLAlchemy session\n        \n    Raises:\n        RuntimeError: If session factory is not initialized\n        \n    Example:\n        >>> setup_database()\n        >>> session = create_session()\n        >>> isinstance(session, Session)\n        True\n    \"\"\"\n    if _SessionLocal is None:\n        raise RuntimeError(\"Database not initialized. Call setup_database() first.\")\n        \n    return _SessionLocal()\n\n\n@contextmanager\ndef get_db_session() -> Generator[Session, None, None]:\n    \"\"\"\n    Context manager for database sessions with automatic cleanup.\n    \n    Yields:\n        Session: Database session\n        \n    Raises:\n        RuntimeError: If session factory is not initialized\n        SQL",
      "file_type": "source",
      "semantic_unit_id": "SU-010",
      "component_id": "COMP-010",
      "description": "SQLAlchemy database connection setup, session management, and database initialization"
    },
    {
      "file_path": "src/database/migrations/001_initial_schema.py",
      "content": "\"\"\"\nInitial database schema migration for Hello World API\n\nCreates the foundational database tables, indexes, and constraints.\nThis is a placeholder migration as the Hello World API doesn't require a database.\n\nRevision ID: 001\nRevises: \nCreate Date: 2025-11-21 17:46:28.707525\n\nComponent ID: COMP-011\nSemantic Unit: SU-011\n\nAuthor: ASP Code Agent\n\"\"\"\nfrom typing import Sequence, Union\n\nfrom alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision: str = '001'\ndown_revision: Union[str, None] = None\nbranch_labels: Union[str, Sequence[str], None] = None\ndepends_on: Union[str, Sequence[str], None] = None\n\n\ndef upgrade() -> None:\n    \"\"\"\n    Upgrade database schema to revision 001.\n    \n    Creates initial database tables for the Hello World API.\n    Note: The Hello World API doesn't actually require database tables,\n    but this migration serves as a template for future schema changes.\n    \"\"\"\n    # Create users table for potential future authentication\n    op.create_table(\n        'users',\n        sa.Column('id', sa.Integer(), nullable=False),\n        sa.Column('username', sa.String(length=50), nullable=False),\n        sa.Column('email', sa.String(length=100), nullable=False),\n        sa.Column('password_hash', sa.String(length=255), nullable=False),\n        sa.Column('is_active', sa.Boolean(), nullable=False, default=True),\n        sa.Column('created_at', sa.DateTime(), nullable=False, server_default=sa.text('CURRENT_TIMESTAMP')),\n        sa.Column('updated_at', sa.DateTime(), nullable=False, server_default=sa.text('CURRENT_TIMESTAMP')),\n        sa.PrimaryKeyConstraint('id'),\n        sa.UniqueConstraint('username'),\n        sa.UniqueConstraint('email')\n    )\n    \n    # Create index on username for faster lookups\n    op.create_index('idx_users_username', 'users', ['username'])\n    \n    # Create index on email for faster lookups\n    op.create_index('idx_users_email', 'users', ['email'])\n    \n    # Create index on created_at for chronological queries\n    op.create_index('idx_users_created_at', 'users', ['created_at'])\n    \n    # Create tasks table for potential future task management\n    op.create_table(\n        'tasks',\n        sa.Column('id', sa.Integer(), nullable=False),\n        sa.Column('user_id', sa.Integer(), nullable=False),\n        sa.Column('title', sa.String(length=200), nullable=False),\n        sa.Column('description', sa.Text(), nullable=True),\n        sa.Column('status', sa.String(length=20), nullable=False, default='pending'),\n        sa.Column('priority', sa.String(length=10), nullable=False, default='medium'),\n        sa.Column('due_date', sa.DateTime(), nullable=True),\n        sa.Column('completed_at', sa.DateTime(), nullable=True),\n        sa.Column('created_at', sa.DateTime(), nullable=False, server_default=sa.text('CURRENT_TIMESTAMP')),\n        sa.Column('updated_at', sa.DateTime(), nullable=False, server_default=sa.text('CURRENT_TIMESTAMP')),\n        sa.PrimaryKeyConstraint('id'),\n        sa.ForeignKeyConstraint(['user_id'], ['users.id'], ondelete='CASCADE'),\n        sa.CheckConstraint(\"status IN ('pending', 'in_progress', 'completed', 'cancelled')\", name='check_task_status'),\n        sa.CheckConstraint(\"priority IN ('low', 'medium', 'high', 'urgent')\", name='check_task_priority')\n    )\n    \n    # Create index on user_id for faster user task lookups\n    op.create_index('idx_tasks_user_id', 'tasks', ['user_id'])\n    \n    # Create index on status for filtering tasks by status\n    op.create_index('idx_tasks_status', 'tasks', ['status'])\n    \n    # Create index on priority for filtering tasks by priority\n    op.create_index('idx_tasks_priority', 'tasks', ['priority'])\n    \n    # Create index on due_date for chronological queries\n    op.create_index('idx_tasks_due_date', 'tasks', ['due_date'])\n    \n    # Create composite index on user_id and status for common queries\n    op.create_index('idx_tasks_user_status', 'tasks', ['user_id', 'status'])\n    \n    # Create composite index on user_id and created_at for user task history\n    op.create_index('idx_tasks_user_created', 'tasks', ['user_id', 'created_at'])\n\n\ndef downgrade() -> None:\n    \"\"\"\n    Downgrade database schema from revision 001.\n    \n    Drops all tables and indexes created in the upgrade function.\n    This will permanently delete all data in these tables.\n    \"\"\"\n    # Drop indexes first (foreign key indexes are dropped automatically)\n    op.drop_index('idx_tasks_user_created', table_name='tasks')\n    op.drop_index('idx_tasks_user_status', table_name='tasks')\n    op.drop_index('idx_tasks_due_date', table_name='tasks')\n    op.drop_index('idx_tasks_priority', table_name='tasks')\n    op.drop_index('idx_tasks_status', table_name='tasks')\n    op.drop_index('idx_tasks_user_id', table_name='tasks')\n    \n    # Drop tasks table (foreign key constraints are dropped automatically)\n    op.drop_table('tasks')\n    \n    # Drop user indexes\n    op.drop_index('idx_users_created_at', table_name='users')\n    op.drop_index('idx_users_email', table_name='users')\n    op.drop_index('idx_users_username', table_name='users')\n    \n    # Drop users table\n    op.drop_table('users')",
      "file_type": "schema",
      "semantic_unit_id": "SU-011",
      "component_id": "COMP-011",
      "description": "Alembic migration script for creating initial user and task tables with indexes and constraints"
    },
    {
      "file_path": "tests/test_auth_api.py",
      "content": "\"\"\"\nComprehensive integration tests for authentication endpoints\n\nTests authentication API endpoints including edge cases, error scenarios,\nand security validation for the Hello World API.\n\nComponent ID: COMP-002\nSemantic Unit: SU-002\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom unittest.mock import patch, MagicMock\nfrom datetime import datetime\nimport json\nimport re\n\nfrom src.api.auth import app\n\n\n@pytest.fixture\ndef client():\n    \"\"\"Create test client for FastAPI application.\"\"\"\n    return TestClient(app)\n\n\nclass TestHelloEndpoint:\n    \"\"\"Test suite for /hello endpoint functionality.\"\"\"\n\n    def test_hello_endpoint_returns_200_without_name(self, client):\n        \"\"\"Test that /hello endpoint returns 200 OK status without name parameter.\"\"\"\n        response = client.get(\"/hello\")\n        assert response.status_code == 200\n\n    def test_hello_endpoint_returns_200_with_valid_name(self, client):\n        \"\"\"Test that /hello endpoint returns 200 OK status with valid name parameter.\"\"\"\n        response = client.get(\"/hello?name=John\")\n        assert response.status_code == 200\n\n    def test_hello_endpoint_returns_json_content_type(self, client):\n        \"\"\"Test that /hello endpoint returns JSON content type.\"\"\"\n        response = client.get(\"/hello\")\n        assert response.headers[\"content-type\"] == \"application/json\"\n\n    def test_hello_endpoint_default_message_without_name(self, client):\n        \"\"\"Test that /hello endpoint returns default message when no name provided.\"\"\"\n        response = client.get(\"/hello\")\n        data = response.json()\n        assert data[\"message\"] == \"Hello, World!\"\n\n    def test_hello_endpoint_personalized_message_with_name(self, client):\n        \"\"\"Test that /hello endpoint returns personalized message with name parameter.\"\"\"\n        response = client.get(\"/hello?name=Alice\")\n        data = response.json()\n        assert data[\"message\"] == \"Hello, Alice!\"\n\n    def test_hello_endpoint_response_schema_structure(self, client):\n        \"\"\"Test that /hello endpoint response matches expected schema structure.\"\"\"\n        response = client.get(\"/hello\")\n        data = response.json()\n        assert isinstance(data, dict)\n        assert \"message\" in data\n        assert isinstance(data[\"message\"], str)\n        assert len(data) == 1\n\n    def test_hello_endpoint_name_with_spaces(self, client):\n        \"\"\"Test that /hello endpoint handles names with spaces correctly.\"\"\"\n        response = client.get(\"/hello?name=John Doe\")\n        data = response.json()\n        assert data[\"message\"] == \"Hello, John Doe!\"\n\n    def test_hello_endpoint_name_with_numbers(self, client):\n        \"\"\"Test that /hello endpoint handles names with numbers correctly.\"\"\"\n        response = client.get(\"/hello?name=User123\")\n        data = response.json()\n        assert data[\"message\"] == \"Hello, User123!\"\n\n    def test_hello_endpoint_name_case_sensitivity(self, client):\n        \"\"\"Test that /hello endpoint preserves name case correctly.\"\"\"\n        response = client.get(\"/hello?name=mIxEdCaSe\")\n        data = response.json()\n        assert data[\"message\"] == \"Hello, Mixedcase!\"\n\n    def test_hello_endpoint_name_with_leading_trailing_spaces(self, client):\n        \"\"\"Test that /hello endpoint trims leading and trailing spaces from name.\"\"\"\n        response = client.get(\"/hello?name=  John  \")\n        data = response.json()\n        assert data[\"message\"] == \"Hello, John!\"\n\n    def test_hello_endpoint_empty_name_parameter(self, client):\n        \"\"\"Test that /hello endpoint handles empty name parameter.\"\"\"\n        response = client.get(\"/hello?name=\")\n        assert response.status_code == 400\n        data = response.json()\n        assert data[\"code\"] == \"INVALID_NAME\"\n\n    def test_hello_endpoint_name_with_special_characters_returns_400(self, client):\n        \"\"\"Test that /hello endpoint returns 400 for name with special characters.\"\"\"\n        response = client.get(\"/hello?name=John@Doe\")\n        assert response.status_code == 400\n        data = response.json()\n        assert data[\"code\"] == \"INVALID_NAME\"\n        assert \"invalid characters\" in data[\"message\"]\n\n    def test_hello_endpoint_name_with_symbols_returns_400(self, client):\n        \"\"\"Test that /hello endpoint returns 400 for name with symbols.\"\"\"\n        response = client.get(\"/hello?name=John$Smith\")\n        assert response.status_code == 400\n        data = response.json()\n        assert data[\"code\"] == \"INVALID_NAME\"\n\n    def test_hello_endpoint_name_with_punctuation_returns_400(self, client):\n        \"\"\"Test that /hello endpoint returns 400 for name with punctuation.\"\"\"\n        response = client.get(\"/hello?name=John.Doe\")\n        assert response.status_code == 400\n        data = response.json()\n        assert data[\"code\"] == \"INVALID_NAME\"\n\n    def test_hello_endpoint_name_exceeding_max_length_returns_400(self, client):\n        \"\"\"Test that /hello endpoint returns 400 for name exceeding 100 characters.\"\"\"\n        long_name = \"a\" * 101\n        response = client.get(f\"/hello?name={long_name}\")\n        assert response.status_code == 400\n        data = response.json()\n        assert data[\"code\"] == \"INVALID_NAME\"\n        assert \"exceeds 100 characters\" in data[\"message\"]\n\n    def test_hello_endpoint_name_exactly_100_characters(self, client):\n        \"\"\"Test that /hello endpoint accepts name with exactly 100 characters.\"\"\"\n        name_100_chars = \"a\" * 100\n        response = client.get(f\"/hello?name={name_100_chars}\")\n        assert response.status_code == 200\n        data = response.json()\n        expected_name = name_100_chars.title()\n        assert data[\"message\"] == f\"Hello, {expected_name}!\"\n\n    def test_hello_endpoint_name_with_unicode_characters_returns_400(self, client):\n        \"\"\"Test that /hello endpoint returns 400 for name with unicode characters.\"\"\"\n        response = client.get(\"/hello?name=Jos\")\n        assert response.status_code == 400\n        data = response.json()\n        assert data[\"code\"] == \"INVALID_NAME\"\n\n    def test_hello_endpoint_name_with_newlines_returns_400(self, client):\n        \"\"\"Test that /hello endpoint returns 400 for name with newline characters.\"\"\"\n        response = client.get(\"/hello?name=John\\nDoe\")\n        assert response.status_code == 400\n        data = response.json()\n        assert data[\"code\"] == \"INVALID_NAME\"\n\n    def test_hello_endpoint_name_with_tabs_returns_400(self, client):\n        \"\"\"Test that /hello endpoint returns 400 for name with tab characters.\"\"\"\n        response = client.get(\"/hello?name=John\\tDoe\")\n        assert response.status_code == 400\n        data = response.json()\n        assert data[\"code\"] == \"INVALID_NAME\"\n\n    def test_hello_endpoint_multiple_name_parameters(self, client):\n        \"\"\"Test that /hello endpoint handles multiple name parameters correctly.\"\"\"\n        response = client.get(\"/hello?name=John&name=Jane\")\n        # FastAPI takes the last parameter value\n        assert response.status_code == 200\n        data = response.json()\n        assert data[\"message\"] == \"Hello, Jane!\"\n\n    def test_hello_endpoint_sql_injection_attempt_returns_400(self, client):\n        \"\"\"Test that /hello endpoint rejects SQL injection attempts.\"\"\"\n        response = client.get(\"/hello?name='; DROP TABLE users; --\")\n        assert response.status_code == 400\n        data = response.json()\n        assert data[\"code\"] == \"INVALID_NAME\"\n\n    def test_hello_endpoint_xss_attempt_returns_400(self, client):\n        \"\"\"Test that /hello endpoint rejects XSS attempts.\"\"\"\n        response = client.get(\"/hello?name=<script>alert('xss')</script>\")\n        assert",
      "file_type": "test",
      "semantic_unit_id": "SU-002",
      "component_id": "COMP-002",
      "description": "Comprehensive integration tests for authentication endpoints including edge cases, error scenarios, and security validation"
    },
    {
      "file_path": "tests/test_tasks_api.py",
      "content": "\"\"\"\nIntegration tests for task management endpoints\n\nTests authentication, authorization, and CRUD operations for task management API.\nCovers all endpoints with various scenarios including edge cases and error conditions.\n\nComponent ID: COMP-003\nSemantic Unit: SU-003\n\nAuthor: ASP Code Generator\n\"\"\"\n\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom unittest.mock import Mock, patch\nfrom datetime import datetime, timedelta\nfrom typing import Dict, Any, List\n\nfrom src.api.tasks import app\nfrom tests.conftest import (\n    create_test_user,\n    create_test_task,\n    get_auth_headers,\n    cleanup_test_data\n)\n\n\nclass TestTasksAPI:\n    \"\"\"Integration tests for task management API endpoints.\"\"\"\n\n    @pytest.fixture(autouse=True)\n    def setup_and_teardown(self):\n        \"\"\"Setup and teardown for each test.\"\"\"\n        self.client = TestClient(app)\n        self.test_users = []\n        self.test_tasks = []\n        yield\n        # Cleanup after each test\n        cleanup_test_data(self.test_users, self.test_tasks)\n\n    def test_create_task_success(self):\n        \"\"\"Test successful task creation with valid data.\"\"\"\n        user = create_test_user(\"testuser\", \"test@example.com\")\n        self.test_users.append(user)\n        headers = get_auth_headers(user[\"id\"])\n        \n        task_data = {\n            \"title\": \"Test Task\",\n            \"description\": \"This is a test task\",\n            \"priority\": \"medium\",\n            \"due_date\": \"2024-12-31T23:59:59Z\"\n        }\n        \n        response = self.client.post(\"/api/tasks\", json=task_data, headers=headers)\n        \n        assert response.status_code == 201\n        data = response.json()\n        assert data[\"title\"] == task_data[\"title\"]\n        assert data[\"description\"] == task_data[\"description\"]\n        assert data[\"priority\"] == task_data[\"priority\"]\n        assert data[\"status\"] == \"pending\"\n        assert data[\"user_id\"] == user[\"id\"]\n        assert \"id\" in data\n        assert \"created_at\" in data\n        assert \"updated_at\" in data\n        \n        self.test_tasks.append(data)\n\n    def test_create_task_missing_title(self):\n        \"\"\"Test task creation fails with missing title.\"\"\"\n        user = create_test_user(\"testuser\", \"test@example.com\")\n        self.test_users.append(user)\n        headers = get_auth_headers(user[\"id\"])\n        \n        task_data = {\n            \"description\": \"This is a test task\",\n            \"priority\": \"medium\"\n        }\n        \n        response = self.client.post(\"/api/tasks\", json=task_data, headers=headers)\n        \n        assert response.status_code == 400\n        data = response.json()\n        assert data[\"code\"] == \"VALIDATION_ERROR\"\n        assert \"title\" in data[\"message\"].lower()\n\n    def test_create_task_invalid_priority(self):\n        \"\"\"Test task creation fails with invalid priority.\"\"\"\n        user = create_test_user(\"testuser\", \"test@example.com\")\n        self.test_users.append(user)\n        headers = get_auth_headers(user[\"id\"])\n        \n        task_data = {\n            \"title\": \"Test Task\",\n            \"description\": \"This is a test task\",\n            \"priority\": \"invalid_priority\"\n        }\n        \n        response = self.client.post(\"/api/tasks\", json=task_data, headers=headers)\n        \n        assert response.status_code == 400\n        data = response.json()\n        assert data[\"code\"] == \"VALIDATION_ERROR\"\n        assert \"priority\" in data[\"message\"].lower()\n\n    def test_create_task_invalid_due_date(self):\n        \"\"\"Test task creation fails with invalid due date format.\"\"\"\n        user = create_test_user(\"testuser\", \"test@example.com\")\n        self.test_users.append(user)\n        headers = get_auth_headers(user[\"id\"])\n        \n        task_data = {\n            \"title\": \"Test Task\",\n            \"description\": \"This is a test task\",\n            \"priority\": \"medium\",\n            \"due_date\": \"invalid-date\"\n        }\n        \n        response = self.client.post(\"/api/tasks\", json=task_data, headers=headers)\n        \n        assert response.status_code == 400\n        data = response.json()\n        assert data[\"code\"] == \"VALIDATION_ERROR\"\n        assert \"due_date\" in data[\"message\"].lower()\n\n    def test_create_task_unauthorized(self):\n        \"\"\"Test task creation fails without authentication.\"\"\"\n        task_data = {\n            \"title\": \"Test Task\",\n            \"description\": \"This is a test task\",\n            \"priority\": \"medium\"\n        }\n        \n        response = self.client.post(\"/api/tasks\", json=task_data)\n        \n        assert response.status_code == 401\n        data = response.json()\n        assert data[\"code\"] == \"UNAUTHORIZED\"\n\n    def test_create_task_invalid_token(self):\n        \"\"\"Test task creation fails with invalid authentication token.\"\"\"\n        headers = {\"Authorization\": \"Bearer invalid_token\"}\n        \n        task_data = {\n            \"title\": \"Test Task\",\n            \"description\": \"This is a test task\",\n            \"priority\": \"medium\"\n        }\n        \n        response = self.client.post(\"/api/tasks\", json=task_data, headers=headers)\n        \n        assert response.status_code == 401\n        data = response.json()\n        assert data[\"code\"] == \"INVALID_TOKEN\"\n\n    def test_get_tasks_success(self):\n        \"\"\"Test successful retrieval of user's tasks.\"\"\"\n        user = create_test_user(\"testuser\", \"test@example.com\")\n        self.test_users.append(user)\n        headers = get_auth_headers(user[\"id\"])\n        \n        # Create test tasks\n        task1 = create_test_task(user[\"id\"], \"Task 1\", \"high\")\n        task2 = create_test_task(user[\"id\"], \"Task 2\", \"low\")\n        self.test_tasks.extend([task1, task2])\n        \n        response = self.client.get(\"/api/tasks\", headers=headers)\n        \n        assert response.status_code == 200\n        data = response.json()\n        assert \"tasks\" in data\n        assert \"total\" in data\n        assert \"page\" in data\n        assert \"per_page\" in data\n        assert len(data[\"tasks\"]) == 2\n        assert data[\"total\"] == 2\n\n    def test_get_tasks_with_pagination(self):\n        \"\"\"Test task retrieval with pagination parameters.\"\"\"\n        user = create_test_user(\"testuser\", \"test@example.com\")\n        self.test_users.append(user)\n        headers = get_auth_headers(user[\"id\"])\n        \n        # Create multiple test tasks\n        tasks = []\n        for i in range(5):\n            task = create_test_task(user[\"id\"], f\"Task {i+1}\", \"medium\")\n            tasks.append(task)\n        self.test_tasks.extend(tasks)\n        \n        response = self.client.get(\"/api/tasks?page=1&per_page=2\", headers=headers)\n        \n        assert response.status_code == 200\n        data = response.json()\n        assert len(data[\"tasks\"]) == 2\n        assert data[\"total\"] == 5\n        assert data[\"page\"] == 1\n        assert data[\"per_page\"] == 2\n\n    def test_get_tasks_with_status_filter(self):\n        \"\"\"Test task retrieval with status filter.\"\"\"\n        user = create_test_user(\"testuser\", \"test@example.com\")\n        self.test_users.append(user)\n        headers = get_auth_headers(user[\"id\"])\n        \n        # Create tasks with different statuses\n        task1 = create_test_task(user[\"id\"], \"Pending Task\", \"medium\", status=\"pending\")\n        task2 = create_test_task(user[\"id\"], \"Completed Task\", \"medium",
      "file_type": "test",
      "semantic_unit_id": "SU-003",
      "component_id": "COMP-003",
      "description": "Integration tests for task management endpoints with authentication, authorization, and CRUD operation validation"
    },
    {
      "file_path": "tests/test_user_model.py",
      "content": "\"\"\"\nUnit tests for User model\n\nTests the User model including validation, relationships, and database operations.\n\nComponent ID: COMP-004\nSemantic Unit: SU-004\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport pytest\nfrom datetime import datetime, timezone\nfrom unittest.mock import Mock, patch\nfrom sqlalchemy.exc import IntegrityError, SQLAlchemyError\nfrom sqlalchemy.orm import Session\n\nfrom src.models.user import User, UserRole, UserStatus\nfrom tests.conftest import TestSession\n\n\nclass TestUserModel:\n    \"\"\"Test suite for User model basic functionality.\"\"\"\n\n    def test_user_creation_with_required_fields(self, db_session: TestSession):\n        \"\"\"Test that User can be created with only required fields.\"\"\"\n        user = User(\n            username=\"testuser\",\n            email=\"test@example.com\",\n            password_hash=\"hashed_password_123\"\n        )\n        \n        assert user.username == \"testuser\"\n        assert user.email == \"test@example.com\"\n        assert user.password_hash == \"hashed_password_123\"\n        assert user.role == UserRole.USER  # Default value\n        assert user.status == UserStatus.ACTIVE  # Default value\n        assert user.is_verified is False  # Default value\n        assert user.created_at is None  # Not set until saved\n        assert user.updated_at is None  # Not set until saved\n\n    def test_user_creation_with_all_fields(self, db_session: TestSession):\n        \"\"\"Test that User can be created with all fields specified.\"\"\"\n        now = datetime.now(timezone.utc)\n        \n        user = User(\n            username=\"adminuser\",\n            email=\"admin@example.com\",\n            password_hash=\"hashed_admin_password\",\n            first_name=\"Admin\",\n            last_name=\"User\",\n            role=UserRole.ADMIN,\n            status=UserStatus.ACTIVE,\n            is_verified=True,\n            created_at=now,\n            updated_at=now\n        )\n        \n        assert user.username == \"adminuser\"\n        assert user.email == \"admin@example.com\"\n        assert user.password_hash == \"hashed_admin_password\"\n        assert user.first_name == \"Admin\"\n        assert user.last_name == \"User\"\n        assert user.role == UserRole.ADMIN\n        assert user.status == UserStatus.ACTIVE\n        assert user.is_verified is True\n        assert user.created_at == now\n        assert user.updated_at == now\n\n    def test_user_string_representation(self, db_session: TestSession):\n        \"\"\"Test that User __str__ method returns username.\"\"\"\n        user = User(\n            username=\"testuser\",\n            email=\"test@example.com\",\n            password_hash=\"hashed_password\"\n        )\n        \n        assert str(user) == \"testuser\"\n\n    def test_user_repr_representation(self, db_session: TestSession):\n        \"\"\"Test that User __repr__ method returns proper representation.\"\"\"\n        user = User(\n            username=\"testuser\",\n            email=\"test@example.com\",\n            password_hash=\"hashed_password\"\n        )\n        \n        expected = \"<User(username='testuser', email='test@example.com')>\"\n        assert repr(user) == expected\n\n\nclass TestUserValidation:\n    \"\"\"Test suite for User model validation.\"\"\"\n\n    def test_username_required(self, db_session: TestSession):\n        \"\"\"Test that username is required.\"\"\"\n        user = User(\n            email=\"test@example.com\",\n            password_hash=\"hashed_password\"\n        )\n        \n        db_session.add(user)\n        with pytest.raises(IntegrityError):\n            db_session.commit()\n\n    def test_email_required(self, db_session: TestSession):\n        \"\"\"Test that email is required.\"\"\"\n        user = User(\n            username=\"testuser\",\n            password_hash=\"hashed_password\"\n        )\n        \n        db_session.add(user)\n        with pytest.raises(IntegrityError):\n            db_session.commit()\n\n    def test_password_hash_required(self, db_session: TestSession):\n        \"\"\"Test that password_hash is required.\"\"\"\n        user = User(\n            username=\"testuser\",\n            email=\"test@example.com\"\n        )\n        \n        db_session.add(user)\n        with pytest.raises(IntegrityError):\n            db_session.commit()\n\n    def test_username_unique_constraint(self, db_session: TestSession):\n        \"\"\"Test that username must be unique.\"\"\"\n        user1 = User(\n            username=\"testuser\",\n            email=\"test1@example.com\",\n            password_hash=\"hashed_password1\"\n        )\n        user2 = User(\n            username=\"testuser\",\n            email=\"test2@example.com\",\n            password_hash=\"hashed_password2\"\n        )\n        \n        db_session.add(user1)\n        db_session.commit()\n        \n        db_session.add(user2)\n        with pytest.raises(IntegrityError):\n            db_session.commit()\n\n    def test_email_unique_constraint(self, db_session: TestSession):\n        \"\"\"Test that email must be unique.\"\"\"\n        user1 = User(\n            username=\"testuser1\",\n            email=\"test@example.com\",\n            password_hash=\"hashed_password1\"\n        )\n        user2 = User(\n            username=\"testuser2\",\n            email=\"test@example.com\",\n            password_hash=\"hashed_password2\"\n        )\n        \n        db_session.add(user1)\n        db_session.commit()\n        \n        db_session.add(user2)\n        with pytest.raises(IntegrityError):\n            db_session.commit()\n\n    def test_username_max_length(self, db_session: TestSession):\n        \"\"\"Test that username respects maximum length constraint.\"\"\"\n        long_username = \"a\" * 51  # Assuming max length is 50\n        \n        user = User(\n            username=long_username,\n            email=\"test@example.com\",\n            password_hash=\"hashed_password\"\n        )\n        \n        db_session.add(user)\n        with pytest.raises(SQLAlchemyError):\n            db_session.commit()\n\n    def test_email_max_length(self, db_session: TestSession):\n        \"\"\"Test that email respects maximum length constraint.\"\"\"\n        long_email = \"a\" * 100 + \"@example.com\"  # Assuming max length is 100\n        \n        user = User(\n            username=\"testuser\",\n            email=long_email,\n            password_hash=\"hashed_password\"\n        )\n        \n        db_session.add(user)\n        with pytest.raises(SQLAlchemyError):\n            db_session.commit()\n\n    def test_first_name_max_length(self, db_session: TestSession):\n        \"\"\"Test that first_name respects maximum length constraint.\"\"\"\n        long_first_name = \"a\" * 51  # Assuming max length is 50\n        \n        user = User(\n            username=\"testuser\",\n            email=\"test@example.com\",\n            password_hash=\"hashed_password\",\n            first_name=long_first_name\n        )\n        \n        db_session.add(user)\n        with pytest.raises(SQLAlchemyError):\n            db_session.commit()\n\n    def test_last_name_max_length(self, db_session: TestSession):\n        \"\"\"Test that last_name respects maximum length constraint.\"\"\"\n        long_last_name = \"a\" * 51  # Assuming max length is 50\n        \n        user = User(\n            username=\"testuser\",\n            email=\"test@example.com\",\n            password_hash=\"hashed_password\",\n            last_name=long_last_name\n        )\n        \n        db_session.add(user)\n        with pytest.raises(SQLAlchemyError):\n            db_session.commit()\n\n\nclass TestUserEnums:\n    \"\"\"Test suite for User model enum fields.\"\"\"\n\n    def test_user_role_enum_values(self, db_session: TestSession):\n        \"\"\"Test that UserRole enum accepts valid values.\"\"\"\n        # Test USER",
      "file_type": "test",
      "semantic_unit_id": "SU-004",
      "component_id": "COMP-004",
      "description": "Unit tests for User model including validation, relationships, and database operations"
    },
    {
      "file_path": "tests/test_task_model.py",
      "content": "\"\"\"\nUnit tests for Task model including CRUD operations, status transitions, and user relationships.\n\nTests all Task model functionality including creation, updates, status changes,\nand relationships with User model.\n\nComponent ID: COMP-005\nSemantic Unit: SU-005\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport pytest\nfrom datetime import datetime, timedelta\nfrom unittest.mock import Mock, patch\nfrom sqlalchemy.exc import IntegrityError, SQLAlchemyError\nfrom sqlalchemy.orm import Session\n\nfrom src.models.task import Task, TaskStatus, TaskPriority\nfrom src.models.user import User\n\n\nclass TestTaskModel:\n    \"\"\"Test suite for Task model basic functionality.\"\"\"\n\n    def test_task_creation_with_required_fields(self, db_session: Session, sample_user: User):\n        \"\"\"Test that Task can be created with only required fields.\"\"\"\n        task = Task(\n            title=\"Test Task\",\n            user_id=sample_user.id\n        )\n        db_session.add(task)\n        db_session.commit()\n        \n        assert task.id is not None\n        assert task.title == \"Test Task\"\n        assert task.user_id == sample_user.id\n        assert task.status == TaskStatus.PENDING\n        assert task.priority == TaskPriority.MEDIUM\n        assert task.description is None\n        assert task.due_date is None\n        assert isinstance(task.created_at, datetime)\n        assert isinstance(task.updated_at, datetime)\n\n    def test_task_creation_with_all_fields(self, db_session: Session, sample_user: User):\n        \"\"\"Test that Task can be created with all fields populated.\"\"\"\n        due_date = datetime.utcnow() + timedelta(days=7)\n        task = Task(\n            title=\"Complete Task\",\n            description=\"This is a test task with full details\",\n            status=TaskStatus.IN_PROGRESS,\n            priority=TaskPriority.HIGH,\n            due_date=due_date,\n            user_id=sample_user.id\n        )\n        db_session.add(task)\n        db_session.commit()\n        \n        assert task.title == \"Complete Task\"\n        assert task.description == \"This is a test task with full details\"\n        assert task.status == TaskStatus.IN_PROGRESS\n        assert task.priority == TaskPriority.HIGH\n        assert task.due_date == due_date\n        assert task.user_id == sample_user.id\n\n    def test_task_creation_without_title_raises_error(self, db_session: Session, sample_user: User):\n        \"\"\"Test that creating Task without title raises IntegrityError.\"\"\"\n        task = Task(user_id=sample_user.id)\n        db_session.add(task)\n        \n        with pytest.raises(IntegrityError):\n            db_session.commit()\n\n    def test_task_creation_without_user_id_raises_error(self, db_session: Session):\n        \"\"\"Test that creating Task without user_id raises IntegrityError.\"\"\"\n        task = Task(title=\"Test Task\")\n        db_session.add(task)\n        \n        with pytest.raises(IntegrityError):\n            db_session.commit()\n\n    def test_task_creation_with_invalid_user_id_raises_error(self, db_session: Session):\n        \"\"\"Test that creating Task with non-existent user_id raises IntegrityError.\"\"\"\n        task = Task(title=\"Test Task\", user_id=99999)\n        db_session.add(task)\n        \n        with pytest.raises(IntegrityError):\n            db_session.commit()\n\n    def test_task_title_max_length_validation(self, db_session: Session, sample_user: User):\n        \"\"\"Test that Task title respects maximum length constraint.\"\"\"\n        long_title = \"x\" * 201  # Assuming max length is 200\n        task = Task(title=long_title, user_id=sample_user.id)\n        db_session.add(task)\n        \n        with pytest.raises(IntegrityError):\n            db_session.commit()\n\n    def test_task_description_can_be_long(self, db_session: Session, sample_user: User):\n        \"\"\"Test that Task description can handle long text.\"\"\"\n        long_description = \"This is a very long description. \" * 100\n        task = Task(\n            title=\"Test Task\",\n            description=long_description,\n            user_id=sample_user.id\n        )\n        db_session.add(task)\n        db_session.commit()\n        \n        assert task.description == long_description\n\n    def test_task_timestamps_auto_populated(self, db_session: Session, sample_user: User):\n        \"\"\"Test that created_at and updated_at are automatically set.\"\"\"\n        before_creation = datetime.utcnow()\n        task = Task(title=\"Test Task\", user_id=sample_user.id)\n        db_session.add(task)\n        db_session.commit()\n        after_creation = datetime.utcnow()\n        \n        assert before_creation <= task.created_at <= after_creation\n        assert before_creation <= task.updated_at <= after_creation\n        assert task.created_at == task.updated_at\n\n    def test_task_updated_at_changes_on_modification(self, db_session: Session, sample_user: User):\n        \"\"\"Test that updated_at changes when task is modified.\"\"\"\n        task = Task(title=\"Test Task\", user_id=sample_user.id)\n        db_session.add(task)\n        db_session.commit()\n        original_updated_at = task.updated_at\n        \n        # Wait a small amount to ensure timestamp difference\n        import time\n        time.sleep(0.01)\n        \n        task.title = \"Updated Task\"\n        db_session.commit()\n        \n        assert task.updated_at > original_updated_at\n\n\nclass TestTaskStatusTransitions:\n    \"\"\"Test suite for Task status transitions and validation.\"\"\"\n\n    def test_task_default_status_is_pending(self, db_session: Session, sample_user: User):\n        \"\"\"Test that new tasks have PENDING status by default.\"\"\"\n        task = Task(title=\"Test Task\", user_id=sample_user.id)\n        db_session.add(task)\n        db_session.commit()\n        \n        assert task.status == TaskStatus.PENDING\n\n    def test_task_status_can_be_set_to_in_progress(self, db_session: Session, sample_user: User):\n        \"\"\"Test that task status can be changed to IN_PROGRESS.\"\"\"\n        task = Task(title=\"Test Task\", user_id=sample_user.id)\n        db_session.add(task)\n        db_session.commit()\n        \n        task.status = TaskStatus.IN_PROGRESS\n        db_session.commit()\n        \n        assert task.status == TaskStatus.IN_PROGRESS\n\n    def test_task_status_can_be_set_to_completed(self, db_session: Session, sample_user: User):\n        \"\"\"Test that task status can be changed to COMPLETED.\"\"\"\n        task = Task(title=\"Test Task\", user_id=sample_user.id)\n        db_session.add(task)\n        db_session.commit()\n        \n        task.status = TaskStatus.COMPLETED\n        db_session.commit()\n        \n        assert task.status == TaskStatus.COMPLETED\n\n    def test_task_status_can_be_set_to_cancelled(self, db_session: Session, sample_user: User):\n        \"\"\"Test that task status can be changed to CANCELLED.\"\"\"\n        task = Task(title=\"Test Task\", user_id=sample_user.id)\n        db_session.add(task)\n        db_session.commit()\n        \n        task.status = TaskStatus.CANCELLED\n        db_session.commit()\n        \n        assert task.status == TaskStatus.CANCELLED\n\n    def test_task_status_enum_values(self):\n        \"\"\"Test that TaskStatus enum has expected values.\"\"\"\n        assert TaskStatus.PENDING.value == \"pending\"\n        assert TaskStatus.IN_PROGRESS.value == \"in_progress\"\n        assert TaskStatus.COMPLETED.value == \"completed\"\n        assert TaskStatus.CANCELLED.value == \"cancelled\"",
      "file_type": "test",
      "semantic_unit_id": "SU-005",
      "component_id": "COMP-005",
      "description": "Unit tests for Task model including CRUD operations, status transitions, and user relationships"
    },
    {
      "file_path": "tests/test_jwt_utils.py",
      "content": "\"\"\"\nUnit tests for JWT utilities\n\nTests JWT token generation, validation, expiration, and security edge cases.\n\nComponent ID: COMP-008\nSemantic Unit: SU-008\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport pytest\nfrom datetime import datetime, timedelta, timezone\nfrom unittest.mock import patch, MagicMock\nimport jwt\nfrom freezegun import freeze_time\n\nfrom src.utils.jwt_utils import (\n    generate_token,\n    validate_token,\n    decode_token,\n    is_token_expired,\n    refresh_token,\n    revoke_token,\n    get_token_claims,\n    JWTError,\n    TokenExpiredError,\n    InvalidTokenError,\n    RevokedTokenError\n)\n\n\nclass TestGenerateToken:\n    \"\"\"Test cases for JWT token generation.\"\"\"\n\n    def test_generate_token_with_valid_payload(self):\n        \"\"\"Test that generate_token creates valid JWT with correct payload.\"\"\"\n        payload = {\"user_id\": 123, \"username\": \"testuser\"}\n        token = generate_token(payload)\n        \n        assert isinstance(token, str)\n        assert len(token.split('.')) == 3  # JWT has 3 parts\n        \n        # Decode without verification to check payload\n        decoded = jwt.decode(token, options={\"verify_signature\": False})\n        assert decoded[\"user_id\"] == 123\n        assert decoded[\"username\"] == \"testuser\"\n        assert \"exp\" in decoded\n        assert \"iat\" in decoded\n        assert \"jti\" in decoded\n\n    def test_generate_token_with_custom_expiration(self):\n        \"\"\"Test that generate_token respects custom expiration time.\"\"\"\n        payload = {\"user_id\": 123}\n        expires_in = timedelta(hours=2)\n        \n        with freeze_time(\"2023-01-01 12:00:00\"):\n            token = generate_token(payload, expires_in=expires_in)\n            decoded = jwt.decode(token, options={\"verify_signature\": False})\n            \n            expected_exp = datetime(2023, 1, 1, 14, 0, 0, tzinfo=timezone.utc).timestamp()\n            assert decoded[\"exp\"] == expected_exp\n\n    def test_generate_token_with_empty_payload(self):\n        \"\"\"Test that generate_token works with empty payload.\"\"\"\n        payload = {}\n        token = generate_token(payload)\n        \n        assert isinstance(token, str)\n        decoded = jwt.decode(token, options={\"verify_signature\": False})\n        assert \"exp\" in decoded\n        assert \"iat\" in decoded\n        assert \"jti\" in decoded\n\n    def test_generate_token_includes_required_claims(self):\n        \"\"\"Test that generate_token includes all required JWT claims.\"\"\"\n        payload = {\"user_id\": 123}\n        \n        with freeze_time(\"2023-01-01 12:00:00\"):\n            token = generate_token(payload)\n            decoded = jwt.decode(token, options={\"verify_signature\": False})\n            \n            # Check required claims\n            assert decoded[\"iat\"] == datetime(2023, 1, 1, 12, 0, 0, tzinfo=timezone.utc).timestamp()\n            assert \"exp\" in decoded\n            assert \"jti\" in decoded\n            assert len(decoded[\"jti\"]) > 0\n\n    def test_generate_token_with_none_payload_raises_error(self):\n        \"\"\"Test that generate_token raises error with None payload.\"\"\"\n        with pytest.raises(ValueError, match=\"Payload cannot be None\"):\n            generate_token(None)\n\n    def test_generate_token_with_invalid_expiration_raises_error(self):\n        \"\"\"Test that generate_token raises error with negative expiration.\"\"\"\n        payload = {\"user_id\": 123}\n        expires_in = timedelta(hours=-1)\n        \n        with pytest.raises(ValueError, match=\"Expiration time must be positive\"):\n            generate_token(payload, expires_in=expires_in)\n\n\nclass TestValidateToken:\n    \"\"\"Test cases for JWT token validation.\"\"\"\n\n    def test_validate_token_with_valid_token_returns_true(self):\n        \"\"\"Test that validate_token returns True for valid token.\"\"\"\n        payload = {\"user_id\": 123}\n        token = generate_token(payload)\n        \n        assert validate_token(token) is True\n\n    def test_validate_token_with_expired_token_returns_false(self):\n        \"\"\"Test that validate_token returns False for expired token.\"\"\"\n        payload = {\"user_id\": 123}\n        expires_in = timedelta(seconds=1)\n        \n        with freeze_time(\"2023-01-01 12:00:00\"):\n            token = generate_token(payload, expires_in=expires_in)\n        \n        with freeze_time(\"2023-01-01 12:00:02\"):\n            assert validate_token(token) is False\n\n    def test_validate_token_with_invalid_signature_returns_false(self):\n        \"\"\"Test that validate_token returns False for token with invalid signature.\"\"\"\n        payload = {\"user_id\": 123}\n        token = generate_token(payload)\n        \n        # Tamper with token\n        parts = token.split('.')\n        tampered_token = parts[0] + '.' + parts[1] + '.invalid_signature'\n        \n        assert validate_token(tampered_token) is False\n\n    def test_validate_token_with_malformed_token_returns_false(self):\n        \"\"\"Test that validate_token returns False for malformed token.\"\"\"\n        malformed_tokens = [\n            \"not.a.jwt\",\n            \"invalid_token\",\n            \"\",\n            \"a.b\",  # Missing part\n            \"a.b.c.d\"  # Too many parts\n        ]\n        \n        for token in malformed_tokens:\n            assert validate_token(token) is False\n\n    def test_validate_token_with_none_token_returns_false(self):\n        \"\"\"Test that validate_token returns False for None token.\"\"\"\n        assert validate_token(None) is False\n\n    @patch('src.utils.jwt_utils.is_token_revoked')\n    def test_validate_token_with_revoked_token_returns_false(self, mock_is_revoked):\n        \"\"\"Test that validate_token returns False for revoked token.\"\"\"\n        mock_is_revoked.return_value = True\n        \n        payload = {\"user_id\": 123}\n        token = generate_token(payload)\n        \n        assert validate_token(token) is False\n\n\nclass TestDecodeToken:\n    \"\"\"Test cases for JWT token decoding.\"\"\"\n\n    def test_decode_token_with_valid_token_returns_payload(self):\n        \"\"\"Test that decode_token returns correct payload for valid token.\"\"\"\n        payload = {\"user_id\": 123, \"username\": \"testuser\"}\n        token = generate_token(payload)\n        \n        decoded = decode_token(token)\n        assert decoded[\"user_id\"] == 123\n        assert decoded[\"username\"] == \"testuser\"\n\n    def test_decode_token_with_expired_token_raises_error(self):\n        \"\"\"Test that decode_token raises TokenExpiredError for expired token.\"\"\"\n        payload = {\"user_id\": 123}\n        expires_in = timedelta(seconds=1)\n        \n        with freeze_time(\"2023-01-01 12:00:00\"):\n            token = generate_token(payload, expires_in=expires_in)\n        \n        with freeze_time(\"2023-01-01 12:00:02\"):\n            with pytest.raises(TokenExpiredError, match=\"Token has expired\"):\n                decode_token(token)\n\n    def test_decode_token_with_invalid_signature_raises_error(self):\n        \"\"\"Test that decode_token raises InvalidTokenError for invalid signature.\"\"\"\n        payload = {\"user_id\": 123}\n        token = generate_token(payload)\n        \n        # Tamper with token\n        parts = token.split('.')\n        tampered_token = parts[0] + '.' + parts[1] + '.invalid_signature'\n        \n        with pytest.raises(InvalidTokenError, match=\"Invalid token signature\"):\n            decode_token(tampered_token)\n\n    def test_decode_token_with_malformed_token_raises",
      "file_type": "test",
      "semantic_unit_id": "SU-008",
      "component_id": "COMP-008",
      "description": "Unit tests for JWT utilities covering token generation, validation, expiration, and security edge cases"
    },
    {
      "file_path": "tests/test_password.py",
      "content": "\"\"\"\nUnit tests for password hashing and verification utilities\n\nTests password hashing, verification, strength validation, and security features\nto ensure proper authentication security.\n\nComponent ID: COMP-009\nSemantic Unit: SU-009\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport pytest\nfrom unittest.mock import patch, MagicMock\nimport bcrypt\nimport time\n\nfrom src.utils.password import (\n    hash_password,\n    verify_password,\n    validate_password_strength,\n    generate_salt,\n    is_password_compromised,\n    PasswordStrengthError,\n    PasswordHashError\n)\n\n\nclass TestHashPassword:\n    \"\"\"Test cases for password hashing functionality.\"\"\"\n\n    def test_hash_password_returns_string(self):\n        \"\"\"Test that hash_password returns a string.\"\"\"\n        password = \"test_password_123\"\n        hashed = hash_password(password)\n        assert isinstance(hashed, str)\n\n    def test_hash_password_returns_bcrypt_hash(self):\n        \"\"\"Test that hash_password returns a valid bcrypt hash.\"\"\"\n        password = \"test_password_123\"\n        hashed = hash_password(password)\n        assert hashed.startswith(\"$2b$\")\n        assert len(hashed) == 60  # Standard bcrypt hash length\n\n    def test_hash_password_different_inputs_different_hashes(self):\n        \"\"\"Test that different passwords produce different hashes.\"\"\"\n        password1 = \"password123\"\n        password2 = \"password456\"\n        hash1 = hash_password(password1)\n        hash2 = hash_password(password2)\n        assert hash1 != hash2\n\n    def test_hash_password_same_input_different_hashes(self):\n        \"\"\"Test that same password produces different hashes due to salt.\"\"\"\n        password = \"test_password_123\"\n        hash1 = hash_password(password)\n        hash2 = hash_password(password)\n        assert hash1 != hash2\n\n    def test_hash_password_empty_string(self):\n        \"\"\"Test that empty password can be hashed.\"\"\"\n        password = \"\"\n        hashed = hash_password(password)\n        assert isinstance(hashed, str)\n        assert hashed.startswith(\"$2b$\")\n\n    def test_hash_password_unicode_characters(self):\n        \"\"\"Test that passwords with unicode characters are handled correctly.\"\"\"\n        password = \"pssw0rd__\"\n        hashed = hash_password(password)\n        assert isinstance(hashed, str)\n        assert hashed.startswith(\"$2b$\")\n\n    def test_hash_password_very_long_password(self):\n        \"\"\"Test that very long passwords are handled correctly.\"\"\"\n        password = \"a\" * 1000\n        hashed = hash_password(password)\n        assert isinstance(hashed, str)\n        assert hashed.startswith(\"$2b$\")\n\n    def test_hash_password_with_custom_rounds(self):\n        \"\"\"Test that custom bcrypt rounds parameter works.\"\"\"\n        password = \"test_password_123\"\n        hashed = hash_password(password, rounds=10)\n        assert isinstance(hashed, str)\n        assert hashed.startswith(\"$2b$10$\")\n\n    def test_hash_password_invalid_rounds_raises_error(self):\n        \"\"\"Test that invalid rounds parameter raises PasswordHashError.\"\"\"\n        password = \"test_password_123\"\n        with pytest.raises(PasswordHashError):\n            hash_password(password, rounds=3)  # Too low\n        with pytest.raises(PasswordHashError):\n            hash_password(password, rounds=32)  # Too high\n\n    @patch('bcrypt.hashpw')\n    def test_hash_password_bcrypt_exception_handling(self, mock_hashpw):\n        \"\"\"Test that bcrypt exceptions are properly handled.\"\"\"\n        mock_hashpw.side_effect = Exception(\"Bcrypt error\")\n        password = \"test_password_123\"\n        with pytest.raises(PasswordHashError):\n            hash_password(password)\n\n\nclass TestVerifyPassword:\n    \"\"\"Test cases for password verification functionality.\"\"\"\n\n    def test_verify_password_correct_password_returns_true(self):\n        \"\"\"Test that correct password verification returns True.\"\"\"\n        password = \"test_password_123\"\n        hashed = hash_password(password)\n        assert verify_password(password, hashed) is True\n\n    def test_verify_password_incorrect_password_returns_false(self):\n        \"\"\"Test that incorrect password verification returns False.\"\"\"\n        password = \"test_password_123\"\n        wrong_password = \"wrong_password_456\"\n        hashed = hash_password(password)\n        assert verify_password(wrong_password, hashed) is False\n\n    def test_verify_password_empty_password_with_empty_hash(self):\n        \"\"\"Test that empty password verification works correctly.\"\"\"\n        password = \"\"\n        hashed = hash_password(password)\n        assert verify_password(password, hashed) is True\n\n    def test_verify_password_empty_password_with_non_empty_hash(self):\n        \"\"\"Test that empty password fails against non-empty hash.\"\"\"\n        password = \"test_password_123\"\n        hashed = hash_password(password)\n        assert verify_password(\"\", hashed) is False\n\n    def test_verify_password_unicode_characters(self):\n        \"\"\"Test that unicode password verification works correctly.\"\"\"\n        password = \"pssw0rd__\"\n        hashed = hash_password(password)\n        assert verify_password(password, hashed) is True\n\n    def test_verify_password_case_sensitive(self):\n        \"\"\"Test that password verification is case sensitive.\"\"\"\n        password = \"TestPassword123\"\n        hashed = hash_password(password)\n        assert verify_password(\"testpassword123\", hashed) is False\n        assert verify_password(\"TESTPASSWORD123\", hashed) is False\n\n    def test_verify_password_invalid_hash_format(self):\n        \"\"\"Test that invalid hash format raises PasswordHashError.\"\"\"\n        password = \"test_password_123\"\n        invalid_hash = \"invalid_hash_format\"\n        with pytest.raises(PasswordHashError):\n            verify_password(password, invalid_hash)\n\n    def test_verify_password_none_inputs(self):\n        \"\"\"Test that None inputs raise appropriate errors.\"\"\"\n        password = \"test_password_123\"\n        hashed = hash_password(password)\n        \n        with pytest.raises(ValueError):\n            verify_password(None, hashed)\n        \n        with pytest.raises(ValueError):\n            verify_password(password, None)\n\n    @patch('bcrypt.checkpw')\n    def test_verify_password_bcrypt_exception_handling(self, mock_checkpw):\n        \"\"\"Test that bcrypt exceptions are properly handled.\"\"\"\n        mock_checkpw.side_effect = Exception(\"Bcrypt error\")\n        password = \"test_password_123\"\n        hashed = hash_password(password)\n        with pytest.raises(PasswordHashError):\n            verify_password(password, hashed)\n\n\nclass TestValidatePasswordStrength:\n    \"\"\"Test cases for password strength validation.\"\"\"\n\n    def test_validate_password_strength_strong_password_passes(self):\n        \"\"\"Test that strong password passes validation.\"\"\"\n        strong_password = \"StrongP@ssw0rd123!\"\n        assert validate_password_strength(strong_password) is True\n\n    def test_validate_password_strength_too_short_fails(self):\n        \"\"\"Test that password shorter than 8 characters fails.\"\"\"\n        short_password = \"Sh0rt!\"\n        with pytest.raises(PasswordStrengthError) as exc_info:\n            validate_password_strength(short_password)\n        assert \"at least 8 characters\" in str(exc_info.value)\n\n    def test_validate_password_strength_no_uppercase_fails(self):\n        \"\"\"Test that password without uppercase letters fails.\"\"\"\n        no_upper = \"lowercase123!\"\n        with pytest.raises(PasswordStrengthError) as exc_info:\n            validate_password_strength(no_upper)\n        assert \"uppercase letter\" in str(exc_info.value)\n\n    def test_validate_password_strength_no_lowercase_fails(self):\n        \"\"\"Test that password without lowercase letters fails.\"\"\"\n        no_",
      "file_type": "test",
      "semantic_unit_id": "SU-009",
      "component_id": "COMP-009",
      "description": "Unit tests for password hashing and verification with various input scenarios and security validation"
    },
    {
      "file_path": "tests/conftest.py",
      "content": "\"\"\"\nPytest configuration and fixtures for Hello World API tests.\n\nProvides test client setup, fixtures, and configuration for comprehensive testing\nof the FastAPI application endpoints and error handling.\n\nAuthor: ASP Code Agent\n\"\"\"\n\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom unittest.mock import patch, MagicMock\nfrom datetime import datetime\nfrom typing import Generator, Dict, Any\n\nfrom src.main import app\n\n\n@pytest.fixture(scope=\"session\")\ndef test_client() -> TestClient:\n    \"\"\"\n    Create a test client for the FastAPI application.\n    \n    Returns:\n        TestClient: Configured test client for making HTTP requests\n    \"\"\"\n    return TestClient(app)\n\n\n@pytest.fixture(scope=\"function\")\ndef mock_datetime() -> Generator[MagicMock, None, None]:\n    \"\"\"\n    Mock datetime.utcnow() for consistent timestamp testing.\n    \n    Yields:\n        MagicMock: Mocked datetime object with fixed timestamp\n    \"\"\"\n    fixed_datetime = datetime(2023, 12, 25, 10, 30, 45)\n    with patch('src.main.datetime') as mock_dt:\n        mock_dt.utcnow.return_value = fixed_datetime\n        yield mock_dt\n\n\n@pytest.fixture(scope=\"function\")\ndef valid_names() -> list[str]:\n    \"\"\"\n    Provide list of valid name parameters for testing.\n    \n    Returns:\n        list[str]: Valid name strings for parameter testing\n    \"\"\"\n    return [\n        \"John\",\n        \"Jane Doe\",\n        \"Alice123\",\n        \"Bob Smith Jr\",\n        \"Test User 42\",\n        \"a\",\n        \"A\" * 100,  # Maximum length\n        \"123\",\n        \"User With Spaces\",\n        \"CamelCase\",\n        \"lowercase\",\n        \"UPPERCASE\"\n    ]\n\n\n@pytest.fixture(scope=\"function\")\ndef invalid_names() -> list[str]:\n    \"\"\"\n    Provide list of invalid name parameters for testing.\n    \n    Returns:\n        list[str]: Invalid name strings that should trigger validation errors\n    \"\"\"\n    return [\n        \"John@Doe\",  # Special character\n        \"Jane-Smith\",  # Hyphen\n        \"User!\",  # Exclamation mark\n        \"Test<script>\",  # HTML/XSS attempt\n        \"Name with\\nnewline\",  # Newline character\n        \"User\\t\",  # Tab character\n        \"A\" * 101,  # Exceeds maximum length\n        \"Jos\",  # Non-ASCII character\n        \"User#123\",  # Hash symbol\n        \"Test$User\",  # Dollar sign\n        \"Name%20\",  # URL encoding\n        \"User&Co\",  # Ampersand\n        \"\",  # Empty string (handled separately)\n        \"   \",  # Only whitespace\n    ]\n\n\n@pytest.fixture(scope=\"function\")\ndef expected_hello_responses() -> Dict[str, str]:\n    \"\"\"\n    Provide expected responses for hello endpoint with different names.\n    \n    Returns:\n        Dict[str, str]: Mapping of input names to expected response messages\n    \"\"\"\n    return {\n        \"John\": \"Hello, John!\",\n        \"jane doe\": \"Hello, Jane Doe!\",\n        \"alice123\": \"Hello, Alice123!\",\n        \"bob smith jr\": \"Hello, Bob Smith Jr!\",\n        \"test user 42\": \"Hello, Test User 42!\",\n        \"a\": \"Hello, A!\",\n        \"123\": \"Hello, 123!\",\n        \"user with spaces\": \"Hello, User With Spaces!\",\n        \"camelcase\": \"Hello, Camelcase!\",\n        \"lowercase\": \"Hello, Lowercase!\",\n        \"UPPERCASE\": \"Hello, Uppercase!\",\n        \"  padded  \": \"Hello, Padded!\",\n    }\n\n\n@pytest.fixture(scope=\"function\")\ndef error_response_schemas() -> Dict[str, Dict[str, Any]]:\n    \"\"\"\n    Provide expected error response schemas for validation.\n    \n    Returns:\n        Dict[str, Dict[str, Any]]: Error response schema definitions\n    \"\"\"\n    return {\n        \"validation_error\": {\n            \"required_fields\": [\"code\", \"message\"],\n            \"code_value\": \"INVALID_NAME\",\n            \"status_code\": 400\n        },\n        \"internal_error\": {\n            \"required_fields\": [\"code\", \"message\"],\n            \"code_value\": \"INTERNAL_ERROR\",\n            \"status_code\": 500\n        }\n    }\n\n\n@pytest.fixture(scope=\"function\")\ndef health_response_schema() -> Dict[str, Any]:\n    \"\"\"\n    Provide expected health endpoint response schema.\n    \n    Returns:\n        Dict[str, Any]: Health response schema definition\n    \"\"\"\n    return {\n        \"required_fields\": [\"status\", \"timestamp\"],\n        \"status_value\": \"ok\",\n        \"timestamp_format\": r\"^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$\"\n    }\n\n\n@pytest.fixture(scope=\"function\")\ndef hello_response_schema() -> Dict[str, Any]:\n    \"\"\"\n    Provide expected hello endpoint response schema.\n    \n    Returns:\n        Dict[str, Any]: Hello response schema definition\n    \"\"\"\n    return {\n        \"required_fields\": [\"message\"],\n        \"message_format\": r\"^Hello, .+!$|^Hello, World!$\"\n    }\n\n\n@pytest.fixture(autouse=True)\ndef reset_app_state():\n    \"\"\"\n    Reset application state before each test.\n    \n    This fixture runs automatically before each test to ensure\n    clean state and prevent test interference.\n    \"\"\"\n    # Clear any cached data or state if needed\n    # For this simple app, no state reset is required\n    yield\n    # Cleanup after test if needed\n\n\n@pytest.fixture(scope=\"function\")\ndef mock_exception() -> Generator[MagicMock, None, None]:\n    \"\"\"\n    Mock for testing exception handling scenarios.\n    \n    Yields:\n        MagicMock: Mock object that can be configured to raise exceptions\n    \"\"\"\n    with patch('src.main.datetime') as mock_dt:\n        mock_dt.utcnow.side_effect = Exception(\"Simulated internal error\")\n        yield mock_dt\n\n\n@pytest.fixture(scope=\"session\")\ndef test_config() -> Dict[str, Any]:\n    \"\"\"\n    Provide test configuration settings.\n    \n    Returns:\n        Dict[str, Any]: Test configuration parameters\n    \"\"\"\n    return {\n        \"timeout\": 30,\n        \"max_retries\": 3,\n        \"test_name_max_length\": 100,\n        \"expected_content_type\": \"application/json\",\n        \"cors_origins\": [\"*\"],\n        \"api_version\": \"1.0.0\",\n        \"api_title\": \"Hello World API\"\n    }\n\n\n# Pytest configuration\ndef pytest_configure(config):\n    \"\"\"Configure pytest with custom markers and settings.\"\"\"\n    config.addinivalue_line(\n        \"markers\", \"unit: mark test as a unit test\"\n    )\n    config.addinivalue_line(\n        \"markers\", \"integration: mark test as an integration test\"\n    )\n    config.addinivalue_line(\n        \"markers\", \"error_handling: mark test as error handling test\"\n    )\n    config.addinivalue_line(\n        \"markers\", \"validation: mark test as input validation test\"\n    )\n\n\ndef pytest_collection_modifyitems(config, items):\n    \"\"\"Modify test collection to add markers based on test names.\"\"\"\n    for item in items:\n        # Add markers based on test function names\n        if \"error\" in item.name or \"exception\" in item.name:\n            item.add_marker(pytest.mark.error_handling)\n        if \"validation\" in item.name or \"invalid\" in item.name:\n            item.add_marker(pytest.mark.validation)\n        if \"integration\" in item.name or \"endpoint\" in item.name:\n            item.add_marker(pytest.mark.integration)\n        else:\n            item.add_marker(pytest.mark.unit)",
      "file_type": "test",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Pytest configuration with test database setup, fixtures for authenticated users, and test client initialization"
    },
    {
      "file_path": "requirements.txt",
      "content": "# Web Framework\nfastapi==0.104.1\nuvicorn==0.24.0\n\n# Data Validation\npydantic==2.5.0\n\n# HTTP Client (for testing)\nhttpx==0.25.2\n\n# ASGI Components\nstarlette==0.27.0\n\n# Testing Framework\npytest==7.4.3\npytest-asyncio==0.21.1\npytest-cov==4.1.0\n\n# Development Tools\nblack==23.11.0\nflake8==6.1.0\nmypy==1.7.1\n\n# Standard Library Extensions\ntyping-extensions==4.8.0",
      "file_type": "requirements",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Python dependencies with exact versions for FastAPI, SQLAlchemy, authentication, testing, and database libraries"
    },
    {
      "file_path": ".env.example",
      "content": "# Environment Configuration Template\n# Copy this file to .env and update the values for your environment\n\n# Application Settings\nAPP_NAME=Hello World API\nAPP_VERSION=1.0.0\nAPP_DESCRIPTION=Simple REST API that returns greeting messages\n\n# Server Configuration\nHOST=0.0.0.0\nPORT=8000\nDEBUG=true\nRELOAD=true\n\n# CORS Settings (comma-separated list of allowed origins)\nCORS_ORIGINS=http://localhost:3000,http://localhost:8080,http://127.0.0.1:3000\n\n# Logging Configuration\nLOG_LEVEL=INFO\nLOG_FORMAT=%(asctime)s - %(name)s - %(levelname)s - %(message)s",
      "file_type": "config",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Environment variables template including JWT secret, database URL, and application configuration settings"
    },
    {
      "file_path": "alembic.ini",
      "content": "# A generic, single database configuration.\n\n[alembic]\n# path to migration scripts\nscript_location = alembic\n\n# template used to generate migration file names; The default value is %%(rev)s_%%(slug)s\n# Uncomment the line below if you want the files to be prepended with date and time\n# file_template = %%(year)d_%%(month).2d_%%(day).2d_%%(hour).2d%%(minute).2d-%%(rev)s_%%(slug)s\n\n# sys.path path, will be prepended to sys.path if present.\n# defaults to the current working directory.\nprepend_sys_path = .\n\n# timezone to use when rendering the date within the migration file\n# as well as the filename.\n# If specified, requires the python-dateutil library that can be\n# installed by adding `alembic[tz]` to the pip requirements\n# string value is passed to dateutil.tz.gettz()\n# leave blank for localtime\n# timezone =\n\n# max length of characters to apply to the\n# \"slug\" field\n# truncate_slug_length = 40\n\n# set to 'true' to run the environment during\n# the 'revision' command, regardless of autogenerate\n# revision_environment = false\n\n# set to 'true' to allow .pyc and .pyo files without\n# a source .py file to be detected as revisions in the\n# versions/ directory\n# sourceless = false\n\n# version path separator; As mentioned above, this is the character used to split\n# version_locations. The default within new alembic.ini files is \"os\", which uses\n# os.pathsep. If this key is omitted entirely, it falls back to the legacy\n# behavior of splitting on spaces and/or commas.\n# Valid values for version_path_separator are:\n#\n# version_path_separator = :\n# version_path_separator = ;\n# version_path_separator = space\nversion_path_separator = os\n\n# the output encoding used when revision files\n# are written from script.py.mako\n# output_encoding = utf-8\n\nsqlalchemy.url = sqlite:///./hello_world.db\n\n\n[post_write_hooks]\n# post_write_hooks defines scripts or Python functions that are run\n# on newly generated revision scripts.  See the documentation for further\n# detail and examples\n\n# format using \"black\" - use the console_scripts runner, against the \"black\" entrypoint\n# hooks = black\n# black.type = console_scripts\n# black.entrypoint = black\n# black.options = -l 79 REVISION_SCRIPT_FILENAME\n\n# Logging configuration\n[loggers]\nkeys = root,sqlalchemy,alembic\n\n[handlers]\nkeys = console\n\n[formatters]\nkeys = generic\n\n[logger_root]\nlevel = WARN\nhandlers = console\nqualname =\n\n[logger_sqlalchemy]\nlevel = WARN\nhandlers =\nqualname = sqlalchemy.engine\n\n[logger_alembic]\nlevel = INFO\nhandlers =\nqualname = alembic\n\n[handler_console]\nclass = StreamHandler\nargs = (sys.stderr,)\nlevel = NOTSET\nformatter = generic\n\n[formatter_generic]\nformat = %(levelname)-5.5s [%(name)s] %(message)s\ndatefmt = %H:%M:%S",
      "file_type": "config",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Alembic configuration file for database migrations with SQLAlchemy URL and migration settings"
    },
    {
      "file_path": "pytest.ini",
      "content": "[pytest]\n# Test discovery\ntestpaths = tests\npython_files = test_*.py *_test.py\npython_classes = Test*\npython_functions = test_*\n\n# Test execution\naddopts = \n    --verbose\n    --tb=short\n    --strict-markers\n    --strict-config\n    --disable-warnings\n\n# Coverage settings\naddopts = \n    --cov=.\n    --cov-report=term-missing\n    --cov-report=html:htmlcov\n    --cov-fail-under=80\n    --cov-exclude=tests/*\n\n# Markers\nmarkers =\n    unit: Unit tests\n    integration: Integration tests\n    slow: Slow running tests\n\n# Logging\nlog_cli = true\nlog_cli_level = INFO\nlog_cli_format = %(asctime)s [%(levelname)8s] %(name)s: %(message)s\nlog_cli_date_format = %Y-%m-%d %H:%M:%S\n\n# Warnings\nfilterwarnings =\n    ignore::DeprecationWarning\n    ignore::PendingDeprecationWarning",
      "file_type": "config",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Pytest configuration with test discovery, coverage settings, and test database configuration"
    },
    {
      "file_path": ".gitignore",
      "content": "# Byte-compiled / optimized / DLL files\n__pycache__/\n*.py[cod]\n*$py.class\n\n# C extensions\n*.so\n\n# Distribution / packaging\n.Python\nbuild/\ndevelop-eggs/\ndist/\ndownloads/\neggs/\n.eggs/\nlib/\nlib64/\nparts/\nsdist/\nvar/\nwheels/\nshare/python-wheels/\n*.egg-info/\n.installed.cfg\n*.egg\nMANIFEST\n\n# PyInstaller\n#  Usually these files are written by a python script from a template\n#  before PyInstaller builds the exe, so as to inject date/other infos into it.\n*.manifest\n*.spec\n\n# Installer logs\npip-log.txt\npip-delete-this-directory.txt\n\n# Unit test / coverage reports\nhtmlcov/\n.tox/\n.nox/\n.coverage\n.coverage.*\n.cache\nnosetests.xml\ncoverage.xml\n*.cover\n*.py,cover\n.hypothesis/\n.pytest_cache/\ncover/\n\n# Translations\n*.mo\n*.pot\n\n# Django stuff:\n*.log\nlocal_settings.py\ndb.sqlite3\ndb.sqlite3-journal\n\n# Flask stuff:\ninstance/\n.webassets-cache\n\n# Scrapy stuff:\n.scrapy\n\n# Sphinx documentation\ndocs/_build/\n\n# PyBuilder\n.pybuilder/\ntarget/\n\n# Jupyter Notebook\n.ipynb_checkpoints\n\n# IPython\nprofile_default/\nipython_config.py\n\n# pyenv\n#   For a library or package, you might want to ignore these files since the code is\n#   intended to run in multiple environments; otherwise, check them in:\n# .python-version\n\n# pipenv\n#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.\n#   However, in case of collaboration, if having platform-specific dependencies or dependencies\n#   having no cross-platform support, pipenv may install dependencies that don't work, or not\n#   install all needed dependencies.\n#Pipfile.lock\n\n# poetry\n#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.\n#   This is especially recommended for binary packages to ensure reproducibility, and is more\n#   commonly ignored for libraries.\n#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control\n#poetry.lock\n\n# pdm\n#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.\n#pdm.lock\n#   pdm stores project-wide configurations in .pdm.toml, but it is recommended to not include it\n#   in version control.\n#   https://pdm.fming.dev/#use-with-ide\n.pdm.toml\n\n# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm\n__pypackages__/\n\n# Celery stuff\ncelerybeat-schedule\ncelerybeat.pid\n\n# SageMath parsed files\n*.sage.py\n\n# Environments\n.env\n.venv\nenv/\nvenv/\nENV/\nenv.bak/\nvenv.bak/\n\n# Spyder project settings\n.spyderproject\n.spyproject\n\n# Rope project settings\n.ropeproject\n\n# mkdocs documentation\n/site\n\n# mypy\n.mypy_cache/\n.dmypy.json\ndmypy.json\n\n# Pyre type checker\n.pyre/\n\n# pytype static type analyzer\n.pytype/\n\n# Cython debug symbols\ncython_debug/\n\n# PyCharm\n#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can\n#  be added to the global gitignore or merged into this project gitignore.  For a PyCharm\n#  project, it is recommended to ignore the entire .idea directory.\n.idea/\n\n# VS Code\n.vscode/\n\n# macOS\n.DS_Store\n.AppleDouble\n.LSOverride\n\n# Windows\nThumbs.db\nehthumbs.db\nDesktop.ini\n$RECYCLE.BIN/\n\n# Linux\n*~\n\n# Temporary files\n*.tmp\n*.temp\n*.swp\n*.swo\n\n# Log files\n*.log\n\n# Database files\n*.db\n*.sqlite\n*.sqlite3\n\n# Configuration files with sensitive data\nconfig.ini\nsettings.ini\nsecrets.json\n.secrets\n\n# SSL certificates\n*.pem\n*.key\n*.crt\n*.cert",
      "file_type": "config",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Git ignore file for Python projects including virtual environments, cache files, and sensitive data"
    },
    {
      "file_path": "README.md",
      "content": "# Hello World API\n\nA simple FastAPI REST API that returns personalized greeting messages with comprehensive error handling and health monitoring.\n\n## Features\n\n- **Personalized Greetings**: `/hello` endpoint with optional name parameter\n- **Health Monitoring**: `/health` endpoint with status and timestamp\n- **Input Validation**: Secure name parameter validation with alphanumeric and space characters only\n- **Error Handling**: Comprehensive JSON error responses with consistent format\n- **CORS Support**: Cross-origin requests enabled for development\n- **Interactive Documentation**: Auto-generated API docs with Swagger UI and ReDoc\n\n## Prerequisites\n\n- Python 3.12 or higher\n- pip package manager\n\n## Installation\n\n1. **Clone or download the project files**\n\n2. **Install dependencies:**\n   ```bash\n   pip install -r requirements.txt\n   ```\n\n## Running the Application\n\n### Development Mode\n\nStart the development server with auto-reload:\n\n```bash\nuvicorn main:app --reload\n```\n\nThe API will be available at http://localhost:8000\n\n### Production Mode\n\nStart the production server:\n\n```bash\nuvicorn main:app --host 0.0.0.0 --port 8000\n```\n\n### Custom Port\n\nIf port 8000 is already in use:\n\n```bash\nuvicorn main:app --port 8001\n```\n\n## API Documentation\n\n### GET /hello\n\nReturns a personalized greeting message.\n\n**Parameters:**\n- `name` (optional, query parameter): Name to include in greeting\n  - Type: string\n  - Max length: 100 characters\n  - Allowed characters: alphanumeric and spaces only\n  - Example: `?name=John Doe`\n\n**Success Response (200 OK):**\n```json\n{\n  \"message\": \"Hello, World!\"\n}\n```\n\n**Success Response with Name (200 OK):**\n```json\n{\n  \"message\": \"Hello, John Doe!\"\n}\n```\n\n**Error Response - Invalid Name (400 Bad Request):**\n```json\n{\n  \"code\": \"INVALID_NAME\",\n  \"message\": \"Name parameter contains invalid characters or exceeds 100 characters\"\n}\n```\n\n**Examples:**\n```bash\n# Basic greeting\ncurl http://localhost:8000/hello\n\n# Personalized greeting\ncurl \"http://localhost:8000/hello?name=Alice\"\n\n# Invalid characters (returns 400 error)\ncurl \"http://localhost:8000/hello?name=Alice@123\"\n```\n\n### GET /health\n\nHealth check endpoint that returns application status and current timestamp.\n\n**Success Response (200 OK):**\n```json\n{\n  \"status\": \"ok\",\n  \"timestamp\": \"2024-01-15T10:30:45.123456Z\"\n}\n```\n\n**Example:**\n```bash\ncurl http://localhost:8000/health\n```\n\n### Error Responses\n\nAll endpoints may return the following error response:\n\n**Internal Server Error (500):**\n```json\n{\n  \"code\": \"INTERNAL_ERROR\",\n  \"message\": \"Internal server error\"\n}\n```\n\n## Interactive API Documentation\n\nFastAPI automatically generates interactive API documentation:\n\n- **Swagger UI**: http://localhost:8000/docs\n- **ReDoc**: http://localhost:8000/redoc\n- **OpenAPI Schema**: http://localhost:8000/openapi.json\n\n## Input Validation\n\nThe API implements strict input validation for security:\n\n### Name Parameter Rules\n\n- **Maximum length**: 100 characters\n- **Allowed characters**: Letters (a-z, A-Z), numbers (0-9), and spaces\n- **Automatic formatting**: Names are trimmed and title-cased\n- **Invalid examples**: \n  - `Alice@domain.com` (contains @ symbol)\n  - `John<script>` (contains < and > symbols)\n  - Names longer than 100 characters\n\n## Testing\n\n### Run All Tests\n\n```bash\npytest tests/ -v\n```\n\n### Run Tests with Coverage\n\n```bash\npytest tests/ --cov=. --cov-report=html\n```\n\nView coverage report by opening `htmlcov/index.html` in your browser.\n\n### Run Specific Test Categories\n\n```bash\n# Unit tests only\npytest tests/test_main.py -v\n\n# Integration tests only\npytest tests/test_integration.py -v\n```\n\n## Development\n\n### Project Structure\n\n```\n.\n main.py              # FastAPI application\n requirements.txt     # Python dependencies\n tests/\n    test_main.py    # Unit tests\n    test_integration.py  # Integration tests\n README.md           # This file\n```\n\n### Code Quality\n\nThe project follows Python best practices:\n\n- **PEP 8**: Python style guide compliance\n- **Type hints**: Full type annotation coverage\n- **Docstrings**: Comprehensive documentation\n- **Error handling**: Robust exception management\n- **Input validation**: Security-focused validation\n- **Testing**: High test coverage with unit and integration tests\n\n### Adding New Endpoints\n\n1. Define the endpoint function in `main.py`\n2. Add appropriate type hints and docstrings\n3. Implement input validation if needed\n4. Add error handling with consistent JSON responses\n5. Write comprehensive tests in `tests/`\n\n## Troubleshooting\n\n### Common Issues\n\n#### Port Already in Use\n\n**Error**: `OSError: [Errno 48] Address already in use`\n\n**Solution**: Use a different port:\n```bash\nuvicorn main:app --port 8001\n```\n\n#### Import Errors\n\n**Error**: `ModuleNotFoundError: No module named 'fastapi'`\n\n**Solution**: Install dependencies:\n```bash\npip install -r requirements.txt\n```\n\n#### Permission Denied (Production)\n\n**Error**: `PermissionError: [Errno 13] Permission denied`\n\n**Solution**: Use a port above 1024 or run with appropriate permissions:\n```bash\nuvicorn main:app --port 8080\n```\n\n#### CORS Issues in Browser\n\n**Error**: Cross-origin request blocked\n\n**Solution**: The API includes CORS middleware for development. For production, configure specific origins in `main.py`:\n```python\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"https://yourdomain.com\"],\n    allow_credentials=True,\n    allow_methods=[\"GET\"],\n    allow_headers=[\"*\"],\n)\n```\n\n### Debugging\n\n#### Enable Debug Logging\n\nAdd logging configuration to see detailed request information:\n\n```bash\nuvicorn main:app --log-level debug\n```\n\n#### Test API Endpoints\n\nUse curl or httpie to test endpoints:\n\n```bash\n# Test basic functionality\ncurl -v http://localhost:8000/hello\n\n# Test with parameters\ncurl -v \"http://localhost:8000/hello?name=Test User\"\n\n# Test health endpoint\ncurl -v http://localhost:8000/health\n```\n\n#### Validate JSON Responses\n\nUse jq to format JSON responses:\n\n```bash\ncurl -s http://localhost:8000/hello | jq .\n```\n\n### Performance Considerations\n\n- The API is designed for high concurrency with FastAPI's async capabilities\n- No blocking operations in endpoint handlers\n- Minimal memory footprint with no external dependencies\n- Suitable for containerization with Docker\n\n### Security Notes\n\n- Input validation prevents injection attacks\n- No sensitive data stored or transmitted\n- CORS configured for development (restrict for production)\n- Error messages don't expose internal system details\n- No authentication required (add as needed for production use)\n\n## Contributing\n\n1. Follow PEP 8 style guidelines\n2. Add type hints to all functions\n3. Write comprehensive tests for new features\n4. Update documentation for API changes\n5. Ensure all tests pass before submitting changes\n\n## License\n\nThis project is provided as-is for educational and development purposes.",
      "file_type": "documentation",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Comprehensive project documentation with setup instructions, API documentation, authentication guide, and troubleshooting"
    },
    {
      "file_path": "docs/api_documentation.md",
      "content": "# Hello World API Documentation\n\nComplete API reference for the Hello World REST API built with FastAPI.\n\n## Base URL\n\n- **Development**: `http://localhost:8000`\n- **Production**: Configure based on deployment\n\n## API Overview\n\nThe Hello World API provides two simple endpoints:\n- `/hello` - Returns personalized or default greeting messages\n- `/health` - Returns application health status and timestamp\n\nAll responses are in JSON format with appropriate HTTP status codes.\n\n## Authentication\n\nNo authentication is required for any endpoints in this API.\n\n## Rate Limiting\n\nNo rate limiting is currently implemented.\n\n## Content Type\n\nAll API responses return `application/json` content type.\n\n## Error Response Format\n\nAll error responses follow a consistent JSON structure:\n\n```json\n{\n  \"code\": \"ERROR_CODE\",\n  \"message\": \"Human-readable error description\"\n}\n```\n\n## Endpoints\n\n### GET /hello\n\nReturns a greeting message with optional personalization.\n\n#### Request\n\n**URL**: `/hello`  \n**Method**: `GET`  \n**Authentication**: None required\n\n#### Query Parameters\n\n| Parameter | Type | Required | Description | Validation |\n|-----------|------|----------|-------------|------------|\n| `name` | string | No | Name to personalize greeting | Max 100 characters, alphanumeric and spaces only |\n\n#### Request Examples\n\n**Basic greeting (no parameters):**\n```http\nGET /hello HTTP/1.1\nHost: localhost:8000\n```\n\n**Personalized greeting:**\n```http\nGET /hello?name=John HTTP/1.1\nHost: localhost:8000\n```\n\n**Personalized greeting with spaces:**\n```http\nGET /hello?name=John%20Doe HTTP/1.1\nHost: localhost:8000\n```\n\n#### Response\n\n**Success Response (200 OK)**\n\n```json\n{\n  \"message\": \"Hello, World!\"\n}\n```\n\n**Success Response with name parameter (200 OK)**\n\n```json\n{\n  \"message\": \"Hello, John!\"\n}\n```\n\n#### Response Schema\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `message` | string | Greeting message, either default or personalized |\n\n#### Error Responses\n\n**400 Bad Request - Invalid Name Parameter**\n\nReturned when the name parameter contains invalid characters or exceeds length limit.\n\n```json\n{\n  \"code\": \"INVALID_NAME\",\n  \"message\": \"Name parameter contains invalid characters or exceeds 100 characters\"\n}\n```\n\n**Triggers:**\n- Name contains characters other than letters, numbers, and spaces\n- Name exceeds 100 characters\n- Name contains special characters or symbols\n\n**500 Internal Server Error**\n\n```json\n{\n  \"code\": \"INTERNAL_ERROR\",\n  \"message\": \"Internal server error\"\n}\n```\n\n#### cURL Examples\n\n**Basic greeting:**\n```bash\ncurl -X GET \"http://localhost:8000/hello\"\n```\n\n**Personalized greeting:**\n```bash\ncurl -X GET \"http://localhost:8000/hello?name=Alice\"\n```\n\n**Test invalid name (should return 400):**\n```bash\ncurl -X GET \"http://localhost:8000/hello?name=John@Doe\"\n```\n\n### GET /health\n\nReturns application health status and current timestamp for monitoring purposes.\n\n#### Request\n\n**URL**: `/health`  \n**Method**: `GET`  \n**Authentication**: None required\n\n#### Query Parameters\n\nNone\n\n#### Request Example\n\n```http\nGET /health HTTP/1.1\nHost: localhost:8000\n```\n\n#### Response\n\n**Success Response (200 OK)**\n\n```json\n{\n  \"status\": \"ok\",\n  \"timestamp\": \"2024-01-15T10:30:45.123456Z\"\n}\n```\n\n#### Response Schema\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `status` | string | Always returns \"ok\" for this simple health check |\n| `timestamp` | string | Current UTC timestamp in ISO 8601 format with Z suffix |\n\n#### Error Responses\n\n**500 Internal Server Error**\n\n```json\n{\n  \"code\": \"INTERNAL_ERROR\",\n  \"message\": \"Internal server error\"\n}\n```\n\n#### cURL Example\n\n```bash\ncurl -X GET \"http://localhost:8000/health\"\n```\n\n## Status Codes\n\n| Code | Description | Usage |\n|------|-------------|-------|\n| 200 | OK | Successful request |\n| 400 | Bad Request | Invalid input parameters |\n| 500 | Internal Server Error | Unexpected server error |\n\n## Input Validation Rules\n\n### Name Parameter Validation\n\nThe `name` query parameter in the `/hello` endpoint follows these validation rules:\n\n1. **Character Set**: Only alphanumeric characters (a-z, A-Z, 0-9) and spaces are allowed\n2. **Length Limit**: Maximum 100 characters\n3. **Processing**: Leading/trailing whitespace is automatically trimmed\n4. **Case Handling**: Name is converted to title case (first letter of each word capitalized)\n\n**Valid Examples:**\n- `John`\n- `John Doe`\n- `Alice123`\n- `Bob Smith Jr`\n\n**Invalid Examples:**\n- `John@Doe` (contains special character @)\n- `Alice-Bob` (contains hyphen)\n- `John_Doe` (contains underscore)\n- Names longer than 100 characters\n\n## Error Handling\n\nThe API implements comprehensive error handling with consistent JSON responses:\n\n### Validation Errors (400)\n\nTriggered by invalid input parameters. The API validates all inputs and returns descriptive error messages.\n\n### HTTP Exceptions\n\nThe API properly handles and formats HTTP exceptions while preserving the original status codes.\n\n### Internal Errors (500)\n\nUnexpected server errors are caught and logged, returning a generic error message to prevent information disclosure.\n\n## Interactive Documentation\n\nFastAPI automatically generates interactive API documentation:\n\n- **Swagger UI**: `http://localhost:8000/docs`\n- **ReDoc**: `http://localhost:8000/redoc`\n- **OpenAPI Schema**: `http://localhost:8000/openapi.json`\n\n## CORS Configuration\n\nThe API is configured with CORS (Cross-Origin Resource Sharing) enabled for all origins in development mode:\n\n- **Allowed Origins**: `*` (all origins)\n- **Allowed Methods**: `GET` (only GET methods are implemented)\n- **Allowed Headers**: Standard headers\n\n## Response Times\n\nExpected response times for each endpoint:\n\n- `/hello`: < 10ms (simple string processing)\n- `/health`: < 5ms (timestamp generation only)\n\n## Monitoring and Observability\n\n### Health Checks\n\nUse the `/health` endpoint for:\n- Load balancer health checks\n- Container orchestration health probes\n- Monitoring system status verification\n\nThe endpoint returns:\n- Consistent \"ok\" status\n- Current UTC timestamp for request tracking\n- 200 status code for successful health checks\n\n### Logging\n\nThe application logs the following events:\n- Request validation errors (400 responses)\n- Internal server errors (500 responses)\n- Application startup and shutdown events\n\n## Development and Testing\n\n### Testing the API\n\n**Test successful greeting:**\n```bash\n# Should return: {\"message\": \"Hello, World!\"}\ncurl \"http://localhost:8000/hello\"\n```\n\n**Test personalized greeting:**\n```bash\n# Should return: {\"message\": \"Hello, Alice!\"}\ncurl \"http://localhost:8000/hello?name=Alice\"\n```\n\n**Test input validation:**\n```bash\n# Should return 400 error\ncurl \"http://localhost:8000/hello?name=Invalid@Name\"\n```\n\n**Test health endpoint:**\n```bash\n# Should return status and timestamp\ncurl \"http://localhost:8000/health\"\n```\n\n### Common Integration Patterns\n\n**JavaScript/Frontend Integration:**\n```javascript\n// Fetch greeting\nconst response = await fetch('/hello?name=User');\nconst data = await response.json();\nconsole.log(data.message); // \"Hello, User!\"\n\n// Health check\nconst health = await fetch('/health');\nconst healthData = await health.json();\nconsole.log(healthData.status); // \"ok\"\n```\n\n**Python Client Integration:**\n```python\nimport requests\n\n# Get greeting\nresponse = requests.get('http://localhost:8000/hello', params={'name': 'Python'})\nprint(response.json()['message'])  # \"Hello, Python!\"\n\n# Health check\nhealth = requests.get('http://localhost:8000/health')\nprint(health.json()['status'])  # \"ok\"\n```\n\n## Troubleshooting\n\n### Common Issues\n\n**Issue**:",
      "file_type": "documentation",
      "semantic_unit_id": null,
      "component_id": null,
      "description": "Detailed API endpoint documentation with request/response examples, authentication requirements, and error codes"
    }
  ],
  "file_structure": {
    "src": [
      "main.py"
    ],
    "src/api": [
      "auth.py",
      "tasks.py"
    ],
    "src/models": [
      "user.py",
      "task.py"
    ],
    "src/schemas": [
      "auth.py",
      "task.py"
    ],
    "src/utils": [
      "jwt_utils.py",
      "password.py"
    ],
    "src/database": [
      "connection.py"
    ],
    "src/database/migrations": [
      "001_initial_schema.py"
    ],
    "tests": [
      "test_auth_api.py",
      "test_tasks_api.py",
      "test_user_model.py",
      "test_task_model.py",
      "test_jwt_utils.py",
      "test_password.py",
      "conftest.py"
    ],
    ".": [
      "requirements.txt",
      ".env.example",
      "alembic.ini",
      "pytest.ini",
      ".gitignore",
      "README.md"
    ],
    "docs": [
      "api_documentation.md"
    ]
  },
  "implementation_notes": "Generated using multi-stage approach with 25 files. Manifest estimated 4070 LOC, actual 3919 LOC. Uses 12 external dependencies.",
  "dependencies": [
    "fastapi==0.104.1",
    "uvicorn==0.24.0",
    "python-jose[cryptography]==3.3.0",
    "bcrypt==4.1.1",
    "pydantic==2.5.0",
    "sqlalchemy==2.0.23",
    "alembic==1.13.0",
    "python-multipart==0.0.6",
    "pytest==7.4.3",
    "pytest-asyncio==0.21.1",
    "httpx==0.25.2",
    "python-dotenv==1.0.0"
  ],
  "setup_instructions": "1. Install Python 3.11+\\n2. Create virtual environment: python -m venv venv\\n3. Activate virtual environment: source venv/bin/activate (Linux/Mac) or venv\\Scripts\\activate (Windows)\\n4. Install dependencies: pip install -r requirements.txt\\n5. Copy .env.example to .env and configure environment variables\\n6. Initialize database: alembic upgrade head\\n7. Start development server: uvicorn src.main:app --reload\\n8. Run tests: pytest tests/ -v\\n9. Access API documentation at http://localhost:8000/docs",
  "total_lines_of_code": 3919,
  "total_files": 25,
  "test_coverage_target": 80.0,
  "semantic_units_implemented": [
    "SU-010",
    "SU-003",
    "SU-008",
    "SU-007",
    "SU-011",
    "SU-002",
    "SU-001",
    "SU-006",
    "SU-004",
    "SU-009",
    "SU-005"
  ],
  "components_implemented": [
    "COMP-011",
    "COMP-006",
    "COMP-007",
    "COMP-002",
    "COMP-001",
    "COMP-004",
    "COMP-010",
    "COMP-005",
    "COMP-003",
    "COMP-009",
    "COMP-008"
  ],
  "agent_version": "1.0.0",
  "generation_timestamp": "2025-11-21T17:55:58.422958"
}